<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 //
   2 // Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 // AMD64 Architecture Description File
  26 
  27 //----------REGISTER DEFINITION BLOCK------------------------------------------
  28 // This information is used by the matcher and the register allocator to
  29 // describe individual registers and classes of registers within the target
  30 // archtecture.
  31 
  32 register %{
  33 //----------Architecture Description Register Definitions----------------------
  34 // General Registers
  35 // "reg_def"  name ( register save type, C convention save type,
  36 //                   ideal register type, encoding );
  37 // Register Save Types:
  38 //
  39 // NS  = No-Save:       The register allocator assumes that these registers
  40 //                      can be used without saving upon entry to the method, &amp;
  41 //                      that they do not need to be saved at call sites.
  42 //
  43 // SOC = Save-On-Call:  The register allocator assumes that these registers
  44 //                      can be used without saving upon entry to the method,
  45 //                      but that they must be saved at call sites.
  46 //
  47 // SOE = Save-On-Entry: The register allocator assumes that these registers
  48 //                      must be saved before using them upon entry to the
  49 //                      method, but they do not need to be saved at call
  50 //                      sites.
  51 //
  52 // AS  = Always-Save:   The register allocator assumes that these registers
  53 //                      must be saved before using them upon entry to the
  54 //                      method, &amp; that they must be saved at call sites.
  55 //
  56 // Ideal Register Type is used to determine how to save &amp; restore a
  57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
  59 //
  60 // The encoding number is the actual bit-pattern placed into the opcodes.
  61 
  62 // General Registers
  63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
  64 // used as byte registers)
  65 
  66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
  67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
  68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
  69 
  70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
  71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
  72 
  73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
  74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
  75 
  76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
  77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
  78 
  79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
  80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
  81 
  82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
  83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
  84 
  85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
  86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
  87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
  88 
  89 #ifdef _WIN64
  90 
  91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
  92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  93 
  94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
  95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  96 
  97 #else
  98 
  99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
 100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
 101 
 102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
 103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
 104 
 105 #endif
 106 
 107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
 108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
 109 
 110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
 111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
 112 
 113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
 114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
 115 
 116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
 117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
 118 
 119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
 120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
 121 
 122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
 123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
 124 
 125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
 126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
 127 
 128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
 129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
 130 
 131 
 132 // Floating Point Registers
 133 
 134 // Specify priority of register selection within phases of register
 135 // allocation.  Highest priority is first.  A useful heuristic is to
 136 // give registers a low priority when they are required by machine
 137 // instructions, like EAX and EDX on I486, and choose no-save registers
 138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
 139 // which participate in fixed calling sequences should come last.
 140 // Registers which are used as pairs must fall on an even boundary.
 141 
 142 alloc_class chunk0(R10,         R10_H,
 143                    R11,         R11_H,
 144                    R8,          R8_H,
 145                    R9,          R9_H,
 146                    R12,         R12_H,
 147                    RCX,         RCX_H,
 148                    RBX,         RBX_H,
 149                    RDI,         RDI_H,
 150                    RDX,         RDX_H,
 151                    RSI,         RSI_H,
 152                    RAX,         RAX_H,
 153                    RBP,         RBP_H,
 154                    R13,         R13_H,
 155                    R14,         R14_H,
 156                    R15,         R15_H,
 157                    RSP,         RSP_H);
 158 
 159 
 160 //----------Architecture Description Register Classes--------------------------
 161 // Several register classes are automatically defined based upon information in
 162 // this architecture description.
 163 // 1) reg_class inline_cache_reg           ( /* as def'd in frame section */ )
 164 // 2) reg_class compiler_method_oop_reg    ( /* as def'd in frame section */ )
 165 // 2) reg_class interpreter_method_oop_reg ( /* as def'd in frame section */ )
 166 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 167 //
 168 
 169 // Empty register class.
 170 reg_class no_reg();
 171 
 172 // Class for all pointer registers (including RSP and RBP)
 173 reg_class any_reg_with_rbp(RAX, RAX_H,
 174                            RDX, RDX_H,
 175                            RBP, RBP_H,
 176                            RDI, RDI_H,
 177                            RSI, RSI_H,
 178                            RCX, RCX_H,
 179                            RBX, RBX_H,
 180                            RSP, RSP_H,
 181                            R8,  R8_H,
 182                            R9,  R9_H,
 183                            R10, R10_H,
 184                            R11, R11_H,
 185                            R12, R12_H,
 186                            R13, R13_H,
 187                            R14, R14_H,
 188                            R15, R15_H);
 189 
 190 // Class for all pointer registers (including RSP, but excluding RBP)
 191 reg_class any_reg_no_rbp(RAX, RAX_H,
 192                          RDX, RDX_H,
 193                          RDI, RDI_H,
 194                          RSI, RSI_H,
 195                          RCX, RCX_H,
 196                          RBX, RBX_H,
 197                          RSP, RSP_H,
 198                          R8,  R8_H,
 199                          R9,  R9_H,
 200                          R10, R10_H,
 201                          R11, R11_H,
 202                          R12, R12_H,
 203                          R13, R13_H,
 204                          R14, R14_H,
 205                          R15, R15_H);
 206 
 207 // Dynamic register class that selects at runtime between register classes
 208 // any_reg_no_rbp and any_reg_with_rbp (depending on the value of the flag PreserveFramePointer).
 209 // Equivalent to: return PreserveFramePointer ? any_reg_no_rbp : any_reg_with_rbp;
 210 reg_class_dynamic any_reg(any_reg_no_rbp, any_reg_with_rbp, %{ PreserveFramePointer %});
 211 
 212 // Class for all pointer registers (excluding RSP)
 213 reg_class ptr_reg_with_rbp(RAX, RAX_H,
 214                            RDX, RDX_H,
 215                            RBP, RBP_H,
 216                            RDI, RDI_H,
 217                            RSI, RSI_H,
 218                            RCX, RCX_H,
 219                            RBX, RBX_H,
 220                            R8,  R8_H,
 221                            R9,  R9_H,
 222                            R10, R10_H,
 223                            R11, R11_H,
 224                            R13, R13_H,
 225                            R14, R14_H);
 226 
 227 // Class for all pointer registers (excluding RSP and RBP)
 228 reg_class ptr_reg_no_rbp(RAX, RAX_H,
 229                          RDX, RDX_H,
 230                          RDI, RDI_H,
 231                          RSI, RSI_H,
 232                          RCX, RCX_H,
 233                          RBX, RBX_H,
 234                          R8,  R8_H,
 235                          R9,  R9_H,
 236                          R10, R10_H,
 237                          R11, R11_H,
 238                          R13, R13_H,
 239                          R14, R14_H);
 240 
 241 // Dynamic register class that selects between ptr_reg_no_rbp and ptr_reg_with_rbp.
 242 reg_class_dynamic ptr_reg(ptr_reg_no_rbp, ptr_reg_with_rbp, %{ PreserveFramePointer %});
 243 
 244 // Class for all pointer registers (excluding RAX and RSP)
 245 reg_class ptr_no_rax_reg_with_rbp(RDX, RDX_H,
 246                                   RBP, RBP_H,
 247                                   RDI, RDI_H,
 248                                   RSI, RSI_H,
 249                                   RCX, RCX_H,
 250                                   RBX, RBX_H,
 251                                   R8,  R8_H,
 252                                   R9,  R9_H,
 253                                   R10, R10_H,
 254                                   R11, R11_H,
 255                                   R13, R13_H,
 256                                   R14, R14_H);
 257 
 258 // Class for all pointer registers (excluding RAX, RSP, and RBP)
 259 reg_class ptr_no_rax_reg_no_rbp(RDX, RDX_H,
 260                                 RDI, RDI_H,
 261                                 RSI, RSI_H,
 262                                 RCX, RCX_H,
 263                                 RBX, RBX_H,
 264                                 R8,  R8_H,
 265                                 R9,  R9_H,
 266                                 R10, R10_H,
 267                                 R11, R11_H,
 268                                 R13, R13_H,
 269                                 R14, R14_H);
 270 
 271 // Dynamic register class that selects between ptr_no_rax_reg_no_rbp and ptr_no_rax_reg_with_rbp.
 272 reg_class_dynamic ptr_no_rax_reg(ptr_no_rax_reg_no_rbp, ptr_no_rax_reg_with_rbp, %{ PreserveFramePointer %});
 273 
 274 // Class for all pointer registers (excluding RAX, RBX, and RSP)
 275 reg_class ptr_no_rax_rbx_reg_with_rbp(RDX, RDX_H,
 276                                       RBP, RBP_H,
 277                                       RDI, RDI_H,
 278                                       RSI, RSI_H,
 279                                       RCX, RCX_H,
 280                                       R8,  R8_H,
 281                                       R9,  R9_H,
 282                                       R10, R10_H,
 283                                       R11, R11_H,
 284                                       R13, R13_H,
 285                                       R14, R14_H);
 286 
 287 // Class for all pointer registers (excluding RAX, RBX, RSP, and RBP)
 288 reg_class ptr_no_rax_rbx_reg_no_rbp(RDX, RDX_H,
 289                                     RDI, RDI_H,
 290                                     RSI, RSI_H,
 291                                     RCX, RCX_H,
 292                                     R8,  R8_H,
 293                                     R9,  R9_H,
 294                                     R10, R10_H,
 295                                     R11, R11_H,
 296                                     R13, R13_H,
 297                                     R14, R14_H);
 298 
 299 // Dynamic register class that selects between ptr_no_rax_rbx_reg_no_rbp and ptr_no_rax_rbx_reg_with_rbp.
 300 reg_class_dynamic ptr_no_rax_rbx_reg(ptr_no_rax_rbx_reg_no_rbp, ptr_no_rax_rbx_reg_with_rbp, %{ PreserveFramePointer %});
 301 
 302 // Singleton class for RAX pointer register
 303 reg_class ptr_rax_reg(RAX, RAX_H);
 304 
 305 // Singleton class for RBX pointer register
 306 reg_class ptr_rbx_reg(RBX, RBX_H);
 307 
 308 // Singleton class for RSI pointer register
 309 reg_class ptr_rsi_reg(RSI, RSI_H);
 310 
 311 // Singleton class for RDI pointer register
 312 reg_class ptr_rdi_reg(RDI, RDI_H);
 313 
 314 // Singleton class for stack pointer
 315 reg_class ptr_rsp_reg(RSP, RSP_H);
 316 
 317 // Singleton class for TLS pointer
 318 reg_class ptr_r15_reg(R15, R15_H);
 319 
 320 // Class for all long registers (excluding RSP)
 321 reg_class long_reg_with_rbp(RAX, RAX_H,
 322                             RDX, RDX_H,
 323                             RBP, RBP_H,
 324                             RDI, RDI_H,
 325                             RSI, RSI_H,
 326                             RCX, RCX_H,
 327                             RBX, RBX_H,
 328                             R8,  R8_H,
 329                             R9,  R9_H,
 330                             R10, R10_H,
 331                             R11, R11_H,
 332                             R13, R13_H,
 333                             R14, R14_H);
 334 
 335 // Class for all long registers (excluding RSP and RBP)
 336 reg_class long_reg_no_rbp(RAX, RAX_H,
 337                           RDX, RDX_H,
 338                           RDI, RDI_H,
 339                           RSI, RSI_H,
 340                           RCX, RCX_H,
 341                           RBX, RBX_H,
 342                           R8,  R8_H,
 343                           R9,  R9_H,
 344                           R10, R10_H,
 345                           R11, R11_H,
 346                           R13, R13_H,
 347                           R14, R14_H);
 348 
 349 // Dynamic register class that selects between long_reg_no_rbp and long_reg_with_rbp.
 350 reg_class_dynamic long_reg(long_reg_no_rbp, long_reg_with_rbp, %{ PreserveFramePointer %});
 351 
 352 // Class for all long registers (excluding RAX, RDX and RSP)
 353 reg_class long_no_rax_rdx_reg_with_rbp(RBP, RBP_H,
 354                                        RDI, RDI_H,
 355                                        RSI, RSI_H,
 356                                        RCX, RCX_H,
 357                                        RBX, RBX_H,
 358                                        R8,  R8_H,
 359                                        R9,  R9_H,
 360                                        R10, R10_H,
 361                                        R11, R11_H,
 362                                        R13, R13_H,
 363                                        R14, R14_H);
 364 
 365 // Class for all long registers (excluding RAX, RDX, RSP, and RBP)
 366 reg_class long_no_rax_rdx_reg_no_rbp(RDI, RDI_H,
 367                                      RSI, RSI_H,
 368                                      RCX, RCX_H,
 369                                      RBX, RBX_H,
 370                                      R8,  R8_H,
 371                                      R9,  R9_H,
 372                                      R10, R10_H,
 373                                      R11, R11_H,
 374                                      R13, R13_H,
 375                                      R14, R14_H);
 376 
 377 // Dynamic register class that selects between long_no_rax_rdx_reg_no_rbp and long_no_rax_rdx_reg_with_rbp.
 378 reg_class_dynamic long_no_rax_rdx_reg(long_no_rax_rdx_reg_no_rbp, long_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 379 
 380 // Class for all long registers (excluding RCX and RSP)
 381 reg_class long_no_rcx_reg_with_rbp(RBP, RBP_H,
 382                                    RDI, RDI_H,
 383                                    RSI, RSI_H,
 384                                    RAX, RAX_H,
 385                                    RDX, RDX_H,
 386                                    RBX, RBX_H,
 387                                    R8,  R8_H,
 388                                    R9,  R9_H,
 389                                    R10, R10_H,
 390                                    R11, R11_H,
 391                                    R13, R13_H,
 392                                    R14, R14_H);
 393 
 394 // Class for all long registers (excluding RCX, RSP, and RBP)
 395 reg_class long_no_rcx_reg_no_rbp(RDI, RDI_H,
 396                                  RSI, RSI_H,
 397                                  RAX, RAX_H,
 398                                  RDX, RDX_H,
 399                                  RBX, RBX_H,
 400                                  R8,  R8_H,
 401                                  R9,  R9_H,
 402                                  R10, R10_H,
 403                                  R11, R11_H,
 404                                  R13, R13_H,
 405                                  R14, R14_H);
 406 
 407 // Dynamic register class that selects between long_no_rcx_reg_no_rbp and long_no_rcx_reg_with_rbp.
 408 reg_class_dynamic long_no_rcx_reg(long_no_rcx_reg_no_rbp, long_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 409 
 410 // Singleton class for RAX long register
 411 reg_class long_rax_reg(RAX, RAX_H);
 412 
 413 // Singleton class for RCX long register
 414 reg_class long_rcx_reg(RCX, RCX_H);
 415 
 416 // Singleton class for RDX long register
 417 reg_class long_rdx_reg(RDX, RDX_H);
 418 
 419 // Class for all int registers (excluding RSP)
 420 reg_class int_reg_with_rbp(RAX,
 421                            RDX,
 422                            RBP,
 423                            RDI,
 424                            RSI,
 425                            RCX,
 426                            RBX,
 427                            R8,
 428                            R9,
 429                            R10,
 430                            R11,
 431                            R13,
 432                            R14);
 433 
 434 // Class for all int registers (excluding RSP and RBP)
 435 reg_class int_reg_no_rbp(RAX,
 436                          RDX,
 437                          RDI,
 438                          RSI,
 439                          RCX,
 440                          RBX,
 441                          R8,
 442                          R9,
 443                          R10,
 444                          R11,
 445                          R13,
 446                          R14);
 447 
 448 // Dynamic register class that selects between int_reg_no_rbp and int_reg_with_rbp.
 449 reg_class_dynamic int_reg(int_reg_no_rbp, int_reg_with_rbp, %{ PreserveFramePointer %});
 450 
 451 // Class for all int registers (excluding RCX and RSP)
 452 reg_class int_no_rcx_reg_with_rbp(RAX,
 453                                   RDX,
 454                                   RBP,
 455                                   RDI,
 456                                   RSI,
 457                                   RBX,
 458                                   R8,
 459                                   R9,
 460                                   R10,
 461                                   R11,
 462                                   R13,
 463                                   R14);
 464 
 465 // Class for all int registers (excluding RCX, RSP, and RBP)
 466 reg_class int_no_rcx_reg_no_rbp(RAX,
 467                                 RDX,
 468                                 RDI,
 469                                 RSI,
 470                                 RBX,
 471                                 R8,
 472                                 R9,
 473                                 R10,
 474                                 R11,
 475                                 R13,
 476                                 R14);
 477 
 478 // Dynamic register class that selects between int_no_rcx_reg_no_rbp and int_no_rcx_reg_with_rbp.
 479 reg_class_dynamic int_no_rcx_reg(int_no_rcx_reg_no_rbp, int_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 480 
 481 // Class for all int registers (excluding RAX, RDX, and RSP)
 482 reg_class int_no_rax_rdx_reg_with_rbp(RBP,
 483                                       RDI,
 484                                       RSI,
 485                                       RCX,
 486                                       RBX,
 487                                       R8,
 488                                       R9,
 489                                       R10,
 490                                       R11,
 491                                       R13,
 492                                       R14);
 493 
 494 // Class for all int registers (excluding RAX, RDX, RSP, and RBP)
 495 reg_class int_no_rax_rdx_reg_no_rbp(RDI,
 496                                     RSI,
 497                                     RCX,
 498                                     RBX,
 499                                     R8,
 500                                     R9,
 501                                     R10,
 502                                     R11,
 503                                     R13,
 504                                     R14);
 505 
 506 // Dynamic register class that selects between int_no_rax_rdx_reg_no_rbp and int_no_rax_rdx_reg_with_rbp.
 507 reg_class_dynamic int_no_rax_rdx_reg(int_no_rax_rdx_reg_no_rbp, int_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 508 
 509 // Singleton class for RAX int register
 510 reg_class int_rax_reg(RAX);
 511 
 512 // Singleton class for RBX int register
 513 reg_class int_rbx_reg(RBX);
 514 
 515 // Singleton class for RCX int register
 516 reg_class int_rcx_reg(RCX);
 517 
 518 // Singleton class for RCX int register
 519 reg_class int_rdx_reg(RDX);
 520 
 521 // Singleton class for RCX int register
 522 reg_class int_rdi_reg(RDI);
 523 
 524 // Singleton class for instruction pointer
 525 // reg_class ip_reg(RIP);
 526 
 527 %}
 528 
 529 //----------SOURCE BLOCK-------------------------------------------------------
 530 // This is a block of C++ code which provides values, functions, and
 531 // definitions necessary in the rest of the architecture description
 532 source %{
 533 #define   RELOC_IMM64    Assembler::imm_operand
 534 #define   RELOC_DISP32   Assembler::disp32_operand
 535 
 536 #define __ _masm.
 537 
 538 static int clear_avx_size() {
 539   if(UseAVX &gt; 2) {
 540     return 0; // vzeroupper is ignored
 541   } else {
 542     return (Compile::current()-&gt;max_vector_size() &gt; 16) ? 3 : 0;  // vzeroupper
 543   }
 544 }
 545 
 546 // !!!!! Special hack to get all types of calls to specify the byte offset
 547 //       from the start of the call to the point where the return address
 548 //       will point.
 549 int MachCallStaticJavaNode::ret_addr_offset()
 550 {
 551   int offset = 5; // 5 bytes from start of call to where return address points
 552   offset += clear_avx_size();
 553   return offset;
 554 }
 555 
 556 int MachCallDynamicJavaNode::ret_addr_offset()
 557 {
 558   int offset = 15; // 15 bytes from start of call to where return address points
 559   offset += clear_avx_size();
 560   return offset;
 561 }
 562 
 563 int MachCallRuntimeNode::ret_addr_offset() {
 564   int offset = 13; // movq r10,#addr; callq (r10)
 565   offset += clear_avx_size();
 566   return offset;
 567 }
 568 
 569 // Indicate if the safepoint node needs the polling page as an input,
 570 // it does if the polling page is more than disp32 away.
 571 bool SafePointNode::needs_polling_address_input()
 572 {
 573   return Assembler::is_polling_page_far();
 574 }
 575 
 576 //
 577 // Compute padding required for nodes which need alignment
 578 //
 579 
 580 // The address of the call instruction needs to be 4-byte aligned to
 581 // ensure that it does not span a cache line so that it can be patched.
 582 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
 583 {
 584   current_offset += clear_avx_size(); // skip vzeroupper
 585   current_offset += 1; // skip call opcode byte
 586   return round_to(current_offset, alignment_required()) - current_offset;
 587 }
 588 
 589 // The address of the call instruction needs to be 4-byte aligned to
 590 // ensure that it does not span a cache line so that it can be patched.
 591 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
 592 {
 593   current_offset += clear_avx_size(); // skip vzeroupper
 594   current_offset += 11; // skip movq instruction + call opcode byte
 595   return round_to(current_offset, alignment_required()) - current_offset;
 596 }
 597 
 598 // EMIT_RM()
 599 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
 600   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
 601   cbuf.insts()-&gt;emit_int8(c);
 602 }
 603 
 604 // EMIT_CC()
 605 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
 606   unsigned char c = (unsigned char) (f1 | f2);
 607   cbuf.insts()-&gt;emit_int8(c);
 608 }
 609 
 610 // EMIT_OPCODE()
 611 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
 612   cbuf.insts()-&gt;emit_int8((unsigned char) code);
 613 }
 614 
 615 // EMIT_OPCODE() w/ relocation information
 616 void emit_opcode(CodeBuffer &amp;cbuf,
 617                  int code, relocInfo::relocType reloc, int offset, int format)
 618 {
 619   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
 620   emit_opcode(cbuf, code);
 621 }
 622 
 623 // EMIT_D8()
 624 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
 625   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
 626 }
 627 
 628 // EMIT_D16()
 629 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
 630   cbuf.insts()-&gt;emit_int16(d16);
 631 }
 632 
 633 // EMIT_D32()
 634 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
 635   cbuf.insts()-&gt;emit_int32(d32);
 636 }
 637 
 638 // EMIT_D64()
 639 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
 640   cbuf.insts()-&gt;emit_int64(d64);
 641 }
 642 
 643 // emit 32 bit value and construct relocation entry from relocInfo::relocType
 644 void emit_d32_reloc(CodeBuffer&amp; cbuf,
 645                     int d32,
 646                     relocInfo::relocType reloc,
 647                     int format)
 648 {
 649   assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
 650   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 651   cbuf.insts()-&gt;emit_int32(d32);
 652 }
 653 
 654 // emit 32 bit value and construct relocation entry from RelocationHolder
 655 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
 656 #ifdef ASSERT
 657   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 658       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
 659     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), "should be real oop");
 660     assert(cast_to_oop((intptr_t)d32)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop((intptr_t)d32)-&gt;is_scavengable()), "cannot embed scavengable oops in code");
 661   }
 662 #endif
 663   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 664   cbuf.insts()-&gt;emit_int32(d32);
 665 }
 666 
 667 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
 668   address next_ip = cbuf.insts_end() + 4;
 669   emit_d32_reloc(cbuf, (int) (addr - next_ip),
 670                  external_word_Relocation::spec(addr),
 671                  RELOC_DISP32);
 672 }
 673 
 674 
 675 // emit 64 bit value and construct relocation entry from relocInfo::relocType
 676 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
 677   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 678   cbuf.insts()-&gt;emit_int64(d64);
 679 }
 680 
 681 // emit 64 bit value and construct relocation entry from RelocationHolder
 682 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
 683 #ifdef ASSERT
 684   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 685       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
 686     assert(Universe::heap()-&gt;is_in_reserved((address)d64), "should be real oop");
 687     assert(cast_to_oop(d64)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop(d64)-&gt;is_scavengable()),
 688            "cannot embed scavengable oops in code");
 689   }
 690 #endif
 691   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 692   cbuf.insts()-&gt;emit_int64(d64);
 693 }
 694 
 695 // Access stack slot for load or store
 696 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
 697 {
 698   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
 699   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
 700     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
 701     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 702     emit_d8(cbuf, disp);     // Displacement  // R/M byte
 703   } else {
 704     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
 705     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 706     emit_d32(cbuf, disp);     // Displacement // R/M byte
 707   }
 708 }
 709 
 710    // rRegI ereg, memory mem) %{    // emit_reg_mem
 711 void encode_RegMem(CodeBuffer &amp;cbuf,
 712                    int reg,
 713                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
 714 {
 715   assert(disp_reloc == relocInfo::none, "cannot have disp");
 716   int regenc = reg &amp; 7;
 717   int baseenc = base &amp; 7;
 718   int indexenc = index &amp; 7;
 719 
 720   // There is no index &amp; no scale, use form without SIB byte
 721   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
 722     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 723     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 724       emit_rm(cbuf, 0x0, regenc, baseenc); // *
 725     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 726       // If 8-bit displacement, mode 0x1
 727       emit_rm(cbuf, 0x1, regenc, baseenc); // *
 728       emit_d8(cbuf, disp);
 729     } else {
 730       // If 32-bit displacement
 731       if (base == -1) { // Special flag for absolute address
 732         emit_rm(cbuf, 0x0, regenc, 0x5); // *
 733         if (disp_reloc != relocInfo::none) {
 734           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 735         } else {
 736           emit_d32(cbuf, disp);
 737         }
 738       } else {
 739         // Normal base + offset
 740         emit_rm(cbuf, 0x2, regenc, baseenc); // *
 741         if (disp_reloc != relocInfo::none) {
 742           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 743         } else {
 744           emit_d32(cbuf, disp);
 745         }
 746       }
 747     }
 748   } else {
 749     // Else, encode with the SIB byte
 750     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 751     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 752       // If no displacement
 753       emit_rm(cbuf, 0x0, regenc, 0x4); // *
 754       emit_rm(cbuf, scale, indexenc, baseenc);
 755     } else {
 756       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 757         // If 8-bit displacement, mode 0x1
 758         emit_rm(cbuf, 0x1, regenc, 0x4); // *
 759         emit_rm(cbuf, scale, indexenc, baseenc);
 760         emit_d8(cbuf, disp);
 761       } else {
 762         // If 32-bit displacement
 763         if (base == 0x04 ) {
 764           emit_rm(cbuf, 0x2, regenc, 0x4);
 765           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
 766         } else {
 767           emit_rm(cbuf, 0x2, regenc, 0x4);
 768           emit_rm(cbuf, scale, indexenc, baseenc); // *
 769         }
 770         if (disp_reloc != relocInfo::none) {
 771           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 772         } else {
 773           emit_d32(cbuf, disp);
 774         }
 775       }
 776     }
 777   }
 778 }
 779 
 780 // This could be in MacroAssembler but it's fairly C2 specific
 781 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
 782   Label exit;
 783   __ jccb(Assembler::noParity, exit);
 784   __ pushf();
 785   //
 786   // comiss/ucomiss instructions set ZF,PF,CF flags and
 787   // zero OF,AF,SF for NaN values.
 788   // Fixup flags by zeroing ZF,PF so that compare of NaN
 789   // values returns 'less than' result (CF is set).
 790   // Leave the rest of flags unchanged.
 791   //
 792   //    7 6 5 4 3 2 1 0
 793   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
 794   //    0 0 1 0 1 0 1 1   (0x2B)
 795   //
 796   __ andq(Address(rsp, 0), 0xffffff2b);
 797   __ popf();
 798   __ bind(exit);
 799 }
 800 
 801 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
 802   Label done;
 803   __ movl(dst, -1);
 804   __ jcc(Assembler::parity, done);
 805   __ jcc(Assembler::below, done);
 806   __ setb(Assembler::notEqual, dst);
 807   __ movzbl(dst, dst);
 808   __ bind(done);
 809 }
 810 
 811 
 812 //=============================================================================
 813 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 814 
 815 int Compile::ConstantTable::calculate_table_base_offset() const {
 816   return 0;  // absolute addressing, no offset
 817 }
 818 
 819 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 820 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 821   ShouldNotReachHere();
 822 }
 823 
 824 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 825   // Empty encoding
 826 }
 827 
 828 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 829   return 0;
 830 }
 831 
 832 #ifndef PRODUCT
 833 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 834   st-&gt;print("# MachConstantBaseNode (empty encoding)");
 835 }
 836 #endif
 837 
 838 
 839 //=============================================================================
 840 #ifndef PRODUCT
 841 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 842   Compile* C = ra_-&gt;C;
 843 
 844   int framesize = C-&gt;frame_size_in_bytes();
 845   int bangsize = C-&gt;bang_size_in_bytes();
 846   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 847   // Remove wordSize for return addr which is already pushed.
 848   framesize -= wordSize;
 849 
 850   if (C-&gt;need_stack_bang(bangsize)) {
 851     framesize -= wordSize;
 852     st-&gt;print("# stack bang (%d bytes)", bangsize);
 853     st-&gt;print("\n\t");
 854     st-&gt;print("pushq   rbp\t# Save rbp");
 855     if (PreserveFramePointer) {
 856         st-&gt;print("\n\t");
 857         st-&gt;print("movq    rbp, rsp\t# Save the caller's SP into rbp");
 858     }
 859     if (framesize) {
 860       st-&gt;print("\n\t");
 861       st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 862     }
 863   } else {
 864     st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 865     st-&gt;print("\n\t");
 866     framesize -= wordSize;
 867     st-&gt;print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
 868     if (PreserveFramePointer) {
 869       st-&gt;print("\n\t");
 870       st-&gt;print("movq    rbp, rsp\t# Save the caller's SP into rbp");
 871       if (framesize &gt; 0) {
 872         st-&gt;print("\n\t");
 873         st-&gt;print("addq    rbp, #%d", framesize);
 874       }      
 875     }
 876   }
 877 
 878   if (VerifyStackAtCalls) {
 879     st-&gt;print("\n\t");
 880     framesize -= wordSize;
 881     st-&gt;print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
 882 #ifdef ASSERT
 883     st-&gt;print("\n\t");
 884     st-&gt;print("# stack alignment check");
 885 #endif
 886   }
 887   st-&gt;cr();
 888 }
 889 #endif
 890 
 891 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 892   Compile* C = ra_-&gt;C;
 893   MacroAssembler _masm(&amp;cbuf);
 894 
 895   int framesize = C-&gt;frame_size_in_bytes();
 896   int bangsize = C-&gt;bang_size_in_bytes();
 897 
 898   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false);
 899 
 900   C-&gt;set_frame_complete(cbuf.insts_size());
 901 
 902   if (C-&gt;has_mach_constant_base_node()) {
 903     // NOTE: We set the table base offset here because users might be
 904     // emitted before MachConstantBaseNode.
 905     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 906     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 907   }
 908 }
 909 
 910 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 911 {
 912   return MachNode::size(ra_); // too many variables; just compute it
 913                               // the hard way
 914 }
 915 
 916 int MachPrologNode::reloc() const
 917 {
 918   return 0; // a large enough number
 919 }
 920 
 921 //=============================================================================
 922 #ifndef PRODUCT
 923 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 924 {
 925   Compile* C = ra_-&gt;C;
 926   if (C-&gt;max_vector_size() &gt; 16) {
 927     st-&gt;print("vzeroupper");
 928     st-&gt;cr(); st-&gt;print("\t");
 929   }
 930 
 931   int framesize = C-&gt;frame_size_in_bytes();
 932   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 933   // Remove word for return adr already pushed
 934   // and RBP
 935   framesize -= 2*wordSize;
 936 
 937   if (framesize) {
 938     st-&gt;print_cr("addq    rsp, %d\t# Destroy frame", framesize);
 939     st-&gt;print("\t");
 940   }
 941 
 942   st-&gt;print_cr("popq   rbp");
 943   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 944     st-&gt;print("\t");
 945     if (Assembler::is_polling_page_far()) {
 946       st-&gt;print_cr("movq   rscratch1, #polling_page_address\n\t"
 947                    "testl  rax, [rscratch1]\t"
 948                    "# Safepoint: poll for GC");
 949     } else {
 950       st-&gt;print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
 951                    "# Safepoint: poll for GC");
 952     }
 953   }
 954 }
 955 #endif
 956 
 957 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 958 {
 959   Compile* C = ra_-&gt;C;
 960   if (C-&gt;max_vector_size() &gt; 16) {
 961     // Clear upper bits of YMM registers when current compiled code uses
 962     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 963     MacroAssembler _masm(&amp;cbuf);
 964     __ vzeroupper();
 965   }
 966 
 967   int framesize = C-&gt;frame_size_in_bytes();
 968   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 969   // Remove word for return adr already pushed
 970   // and RBP
 971   framesize -= 2*wordSize;
 972 
 973   // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here
 974 
 975   if (framesize) {
 976     emit_opcode(cbuf, Assembler::REX_W);
 977     if (framesize &lt; 0x80) {
 978       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
 979       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 980       emit_d8(cbuf, framesize);
 981     } else {
 982       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
 983       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 984       emit_d32(cbuf, framesize);
 985     }
 986   }
 987 
 988   // popq rbp
 989   emit_opcode(cbuf, 0x58 | RBP_enc);
 990 
 991   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 992     MacroAssembler _masm(&amp;cbuf);
 993     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 994     if (Assembler::is_polling_page_far()) {
 995       __ lea(rscratch1, polling_page);
 996       __ relocate(relocInfo::poll_return_type);
 997       __ testl(rax, Address(rscratch1, 0));
 998     } else {
 999       __ testl(rax, polling_page);
1000     }
1001   }
1002 }
1003 
1004 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
1005 {
1006   return MachNode::size(ra_); // too many variables; just compute it
1007                               // the hard way
1008 }
1009 
1010 int MachEpilogNode::reloc() const
1011 {
1012   return 2; // a large enough number
1013 }
1014 
1015 const Pipeline* MachEpilogNode::pipeline() const
1016 {
1017   return MachNode::pipeline_class();
1018 }
1019 
1020 int MachEpilogNode::safepoint_offset() const
1021 {
1022   return 0;
1023 }
1024 
1025 //=============================================================================
1026 
1027 enum RC {
1028   rc_bad,
1029   rc_int,
1030   rc_float,
1031   rc_stack
1032 };
1033 
1034 static enum RC rc_class(OptoReg::Name reg)
1035 {
1036   if( !OptoReg::is_valid(reg)  ) return rc_bad;
1037 
1038   if (OptoReg::is_stack(reg)) return rc_stack;
1039 
1040   VMReg r = OptoReg::as_VMReg(reg);
1041 
1042   if (r-&gt;is_Register()) return rc_int;
1043 
1044   assert(r-&gt;is_XMMRegister(), "must be");
1045   return rc_float;
1046 }
1047 
1048 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
1049 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
1050                           int src_hi, int dst_hi, uint ireg, outputStream* st);
1051 
1052 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
1053                             int stack_offset, int reg, uint ireg, outputStream* st);
1054 
1055 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
1056                                       int dst_offset, uint ireg, outputStream* st) {
1057   if (cbuf) {
1058     MacroAssembler _masm(cbuf);
1059     switch (ireg) {
1060     case Op_VecS:
1061       __ movq(Address(rsp, -8), rax);
1062       __ movl(rax, Address(rsp, src_offset));
1063       __ movl(Address(rsp, dst_offset), rax);
1064       __ movq(rax, Address(rsp, -8));
1065       break;
1066     case Op_VecD:
1067       __ pushq(Address(rsp, src_offset));
1068       __ popq (Address(rsp, dst_offset));
1069       break;
1070     case Op_VecX:
1071       __ pushq(Address(rsp, src_offset));
1072       __ popq (Address(rsp, dst_offset));
1073       __ pushq(Address(rsp, src_offset+8));
1074       __ popq (Address(rsp, dst_offset+8));
1075       break;
1076     case Op_VecY:
1077       __ vmovdqu(Address(rsp, -32), xmm0);
1078       __ vmovdqu(xmm0, Address(rsp, src_offset));
1079       __ vmovdqu(Address(rsp, dst_offset), xmm0);
1080       __ vmovdqu(xmm0, Address(rsp, -32));
1081     case Op_VecZ:
1082       __ evmovdqul(Address(rsp, -64), xmm0, 2);
1083       __ evmovdqul(xmm0, Address(rsp, src_offset), 2);
1084       __ evmovdqul(Address(rsp, dst_offset), xmm0, 2);
1085       __ evmovdqul(xmm0, Address(rsp, -64), 2);
1086       break;
1087     default:
1088       ShouldNotReachHere();
1089     }
1090 #ifndef PRODUCT
1091   } else {
1092     switch (ireg) {
1093     case Op_VecS:
1094       st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1095                 "movl    rax, [rsp + #%d]\n\t"
1096                 "movl    [rsp + #%d], rax\n\t"
1097                 "movq    rax, [rsp - #8]",
1098                 src_offset, dst_offset);
1099       break;
1100     case Op_VecD:
1101       st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1102                 "popq    [rsp + #%d]",
1103                 src_offset, dst_offset);
1104       break;
1105      case Op_VecX:
1106       st-&gt;print("pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t"
1107                 "popq    [rsp + #%d]\n\t"
1108                 "pushq   [rsp + #%d]\n\t"
1109                 "popq    [rsp + #%d]",
1110                 src_offset, dst_offset, src_offset+8, dst_offset+8);
1111       break;
1112     case Op_VecY:
1113       st-&gt;print("vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t"
1114                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1115                 "vmovdqu [rsp + #%d], xmm0\n\t"
1116                 "vmovdqu xmm0, [rsp - #32]",
1117                 src_offset, dst_offset);
1118       break;
1119     case Op_VecZ:
1120       st-&gt;print("vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t"
1121                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1122                 "vmovdqu [rsp + #%d], xmm0\n\t"
1123                 "vmovdqu xmm0, [rsp - #64]",
1124                 src_offset, dst_offset);
1125       break;
1126     default:
1127       ShouldNotReachHere();
1128     }
1129 #endif
1130   }
1131 }
1132 
1133 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
1134                                        PhaseRegAlloc* ra_,
1135                                        bool do_size,
1136                                        outputStream* st) const {
1137   assert(cbuf != NULL || st  != NULL, "sanity");
1138   // Get registers to move
1139   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
1140   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
1141   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
1142   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
1143 
1144   enum RC src_second_rc = rc_class(src_second);
1145   enum RC src_first_rc = rc_class(src_first);
1146   enum RC dst_second_rc = rc_class(dst_second);
1147   enum RC dst_first_rc = rc_class(dst_first);
1148 
1149   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
1150          "must move at least 1 register" );
1151 
1152   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
1153     // Self copy, no move
1154     return 0;
1155   }
1156   if (bottom_type()-&gt;isa_vect() != NULL) {
1157     uint ireg = ideal_reg();
1158     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), "sanity");
1159     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), "sanity");
1160     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
1161       // mem -&gt; mem
1162       int src_offset = ra_-&gt;reg2offset(src_first);
1163       int dst_offset = ra_-&gt;reg2offset(dst_first);
1164       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
1165     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
1166       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
1167     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
1168       int stack_offset = ra_-&gt;reg2offset(dst_first);
1169       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
1170     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
1171       int stack_offset = ra_-&gt;reg2offset(src_first);
1172       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
1173     } else {
1174       ShouldNotReachHere();
1175     }
1176     return 0;
1177   }
1178   if (src_first_rc == rc_stack) {
1179     // mem -&gt;
1180     if (dst_first_rc == rc_stack) {
1181       // mem -&gt; mem
1182       assert(src_second != dst_first, "overlap");
1183       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1184           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1185         // 64-bit
1186         int src_offset = ra_-&gt;reg2offset(src_first);
1187         int dst_offset = ra_-&gt;reg2offset(dst_first);
1188         if (cbuf) {
1189           MacroAssembler _masm(cbuf);
1190           __ pushq(Address(rsp, src_offset));
1191           __ popq (Address(rsp, dst_offset));
1192 #ifndef PRODUCT
1193         } else {
1194           st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1195                     "popq    [rsp + #%d]",
1196                      src_offset, dst_offset);
1197 #endif
1198         }
1199       } else {
1200         // 32-bit
1201         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1202         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1203         // No pushl/popl, so:
1204         int src_offset = ra_-&gt;reg2offset(src_first);
1205         int dst_offset = ra_-&gt;reg2offset(dst_first);
1206         if (cbuf) {
1207           MacroAssembler _masm(cbuf);
1208           __ movq(Address(rsp, -8), rax);
1209           __ movl(rax, Address(rsp, src_offset));
1210           __ movl(Address(rsp, dst_offset), rax);
1211           __ movq(rax, Address(rsp, -8));
1212 #ifndef PRODUCT
1213         } else {
1214           st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1215                     "movl    rax, [rsp + #%d]\n\t"
1216                     "movl    [rsp + #%d], rax\n\t"
1217                     "movq    rax, [rsp - #8]",
1218                      src_offset, dst_offset);
1219 #endif
1220         }
1221       }
1222       return 0;
1223     } else if (dst_first_rc == rc_int) {
1224       // mem -&gt; gpr
1225       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1226           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1227         // 64-bit
1228         int offset = ra_-&gt;reg2offset(src_first);
1229         if (cbuf) {
1230           MacroAssembler _masm(cbuf);
1231           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1232 #ifndef PRODUCT
1233         } else {
1234           st-&gt;print("movq    %s, [rsp + #%d]\t# spill",
1235                      Matcher::regName[dst_first],
1236                      offset);
1237 #endif
1238         }
1239       } else {
1240         // 32-bit
1241         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1242         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1243         int offset = ra_-&gt;reg2offset(src_first);
1244         if (cbuf) {
1245           MacroAssembler _masm(cbuf);
1246           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1247 #ifndef PRODUCT
1248         } else {
1249           st-&gt;print("movl    %s, [rsp + #%d]\t# spill",
1250                      Matcher::regName[dst_first],
1251                      offset);
1252 #endif
1253         }
1254       }
1255       return 0;
1256     } else if (dst_first_rc == rc_float) {
1257       // mem-&gt; xmm
1258       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1259           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1260         // 64-bit
1261         int offset = ra_-&gt;reg2offset(src_first);
1262         if (cbuf) {
1263           MacroAssembler _masm(cbuf);
1264           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1265 #ifndef PRODUCT
1266         } else {
1267           st-&gt;print("%s  %s, [rsp + #%d]\t# spill",
1268                      UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
1269                      Matcher::regName[dst_first],
1270                      offset);
1271 #endif
1272         }
1273       } else {
1274         // 32-bit
1275         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1276         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1277         int offset = ra_-&gt;reg2offset(src_first);
1278         if (cbuf) {
1279           MacroAssembler _masm(cbuf);
1280           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1281 #ifndef PRODUCT
1282         } else {
1283           st-&gt;print("movss   %s, [rsp + #%d]\t# spill",
1284                      Matcher::regName[dst_first],
1285                      offset);
1286 #endif
1287         }
1288       }
1289       return 0;
1290     }
1291   } else if (src_first_rc == rc_int) {
1292     // gpr -&gt;
1293     if (dst_first_rc == rc_stack) {
1294       // gpr -&gt; mem
1295       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1296           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1297         // 64-bit
1298         int offset = ra_-&gt;reg2offset(dst_first);
1299         if (cbuf) {
1300           MacroAssembler _masm(cbuf);
1301           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1302 #ifndef PRODUCT
1303         } else {
1304           st-&gt;print("movq    [rsp + #%d], %s\t# spill",
1305                      offset,
1306                      Matcher::regName[src_first]);
1307 #endif
1308         }
1309       } else {
1310         // 32-bit
1311         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1312         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1313         int offset = ra_-&gt;reg2offset(dst_first);
1314         if (cbuf) {
1315           MacroAssembler _masm(cbuf);
1316           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1317 #ifndef PRODUCT
1318         } else {
1319           st-&gt;print("movl    [rsp + #%d], %s\t# spill",
1320                      offset,
1321                      Matcher::regName[src_first]);
1322 #endif
1323         }
1324       }
1325       return 0;
1326     } else if (dst_first_rc == rc_int) {
1327       // gpr -&gt; gpr
1328       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1329           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1330         // 64-bit
1331         if (cbuf) {
1332           MacroAssembler _masm(cbuf);
1333           __ movq(as_Register(Matcher::_regEncode[dst_first]),
1334                   as_Register(Matcher::_regEncode[src_first]));
1335 #ifndef PRODUCT
1336         } else {
1337           st-&gt;print("movq    %s, %s\t# spill",
1338                      Matcher::regName[dst_first],
1339                      Matcher::regName[src_first]);
1340 #endif
1341         }
1342         return 0;
1343       } else {
1344         // 32-bit
1345         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1346         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1347         if (cbuf) {
1348           MacroAssembler _masm(cbuf);
1349           __ movl(as_Register(Matcher::_regEncode[dst_first]),
1350                   as_Register(Matcher::_regEncode[src_first]));
1351 #ifndef PRODUCT
1352         } else {
1353           st-&gt;print("movl    %s, %s\t# spill",
1354                      Matcher::regName[dst_first],
1355                      Matcher::regName[src_first]);
1356 #endif
1357         }
1358         return 0;
1359       }
1360     } else if (dst_first_rc == rc_float) {
1361       // gpr -&gt; xmm
1362       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1363           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1364         // 64-bit
1365         if (cbuf) {
1366           MacroAssembler _masm(cbuf);
1367           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1368 #ifndef PRODUCT
1369         } else {
1370           st-&gt;print("movdq   %s, %s\t# spill",
1371                      Matcher::regName[dst_first],
1372                      Matcher::regName[src_first]);
1373 #endif
1374         }
1375       } else {
1376         // 32-bit
1377         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1378         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1379         if (cbuf) {
1380           MacroAssembler _masm(cbuf);
1381           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1382 #ifndef PRODUCT
1383         } else {
1384           st-&gt;print("movdl   %s, %s\t# spill",
1385                      Matcher::regName[dst_first],
1386                      Matcher::regName[src_first]);
1387 #endif
1388         }
1389       }
1390       return 0;
1391     }
1392   } else if (src_first_rc == rc_float) {
1393     // xmm -&gt;
1394     if (dst_first_rc == rc_stack) {
1395       // xmm -&gt; mem
1396       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1397           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1398         // 64-bit
1399         int offset = ra_-&gt;reg2offset(dst_first);
1400         if (cbuf) {
1401           MacroAssembler _masm(cbuf);
1402           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1403 #ifndef PRODUCT
1404         } else {
1405           st-&gt;print("movsd   [rsp + #%d], %s\t# spill",
1406                      offset,
1407                      Matcher::regName[src_first]);
1408 #endif
1409         }
1410       } else {
1411         // 32-bit
1412         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1413         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1414         int offset = ra_-&gt;reg2offset(dst_first);
1415         if (cbuf) {
1416           MacroAssembler _masm(cbuf);
1417           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1418 #ifndef PRODUCT
1419         } else {
1420           st-&gt;print("movss   [rsp + #%d], %s\t# spill",
1421                      offset,
1422                      Matcher::regName[src_first]);
1423 #endif
1424         }
1425       }
1426       return 0;
1427     } else if (dst_first_rc == rc_int) {
1428       // xmm -&gt; gpr
1429       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1430           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1431         // 64-bit
1432         if (cbuf) {
1433           MacroAssembler _masm(cbuf);
1434           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1435 #ifndef PRODUCT
1436         } else {
1437           st-&gt;print("movdq   %s, %s\t# spill",
1438                      Matcher::regName[dst_first],
1439                      Matcher::regName[src_first]);
1440 #endif
1441         }
1442       } else {
1443         // 32-bit
1444         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1445         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1446         if (cbuf) {
1447           MacroAssembler _masm(cbuf);
1448           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1449 #ifndef PRODUCT
1450         } else {
1451           st-&gt;print("movdl   %s, %s\t# spill",
1452                      Matcher::regName[dst_first],
1453                      Matcher::regName[src_first]);
1454 #endif
1455         }
1456       }
1457       return 0;
1458     } else if (dst_first_rc == rc_float) {
1459       // xmm -&gt; xmm
1460       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1461           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1462         // 64-bit
1463         if (cbuf) {
1464           MacroAssembler _masm(cbuf);
1465           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1466 #ifndef PRODUCT
1467         } else {
1468           st-&gt;print("%s  %s, %s\t# spill",
1469                      UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
1470                      Matcher::regName[dst_first],
1471                      Matcher::regName[src_first]);
1472 #endif
1473         }
1474       } else {
1475         // 32-bit
1476         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1477         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1478         if (cbuf) {
1479           MacroAssembler _masm(cbuf);
1480           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1481 #ifndef PRODUCT
1482         } else {
1483           st-&gt;print("%s  %s, %s\t# spill",
1484                      UseXmmRegToRegMoveAll ? "movaps" : "movss ",
1485                      Matcher::regName[dst_first],
1486                      Matcher::regName[src_first]);
1487 #endif
1488         }
1489       }
1490       return 0;
1491     }
1492   }
1493 
1494   assert(0," foo ");
1495   Unimplemented();
1496   return 0;
1497 }
1498 
1499 #ifndef PRODUCT
1500 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
1501   implementation(NULL, ra_, false, st);
1502 }
1503 #endif
1504 
1505 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1506   implementation(&amp;cbuf, ra_, false, NULL);
1507 }
1508 
1509 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1510   return MachNode::size(ra_);
1511 }
1512 
1513 //=============================================================================
1514 #ifndef PRODUCT
1515 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1516 {
1517   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1518   int reg = ra_-&gt;get_reg_first(this);
1519   st-&gt;print("leaq    %s, [rsp + #%d]\t# box lock",
1520             Matcher::regName[reg], offset);
1521 }
1522 #endif
1523 
1524 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1525 {
1526   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1527   int reg = ra_-&gt;get_encode(this);
1528   if (offset &gt;= 0x80) {
1529     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1530     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1531     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
1532     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1533     emit_d32(cbuf, offset);
1534   } else {
1535     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1536     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1537     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
1538     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1539     emit_d8(cbuf, offset);
1540   }
1541 }
1542 
1543 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
1544 {
1545   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1546   return (offset &lt; 0x80) ? 5 : 8; // REX
1547 }
1548 
1549 //=============================================================================
1550 #ifndef PRODUCT
1551 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1552 {
1553   if (UseCompressedClassPointers) {
1554     st-&gt;print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
1555     st-&gt;print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
1556     st-&gt;print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
1557   } else {
1558     st-&gt;print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
1559                  "# Inline cache check");
1560   }
1561   st-&gt;print_cr("\tjne     SharedRuntime::_ic_miss_stub");
1562   st-&gt;print_cr("\tnop\t# nops to align entry point");
1563 }
1564 #endif
1565 
1566 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1567 {
1568   MacroAssembler masm(&amp;cbuf);
1569   uint insts_size = cbuf.insts_size();
1570   if (UseCompressedClassPointers) {
1571     masm.load_klass(rscratch1, j_rarg0);
1572     masm.cmpptr(rax, rscratch1);
1573   } else {
1574     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
1575   }
1576 
1577   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1578 
1579   /* WARNING these NOPs are critical so that verified entry point is properly
1580      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
1581   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
1582   if (OptoBreakpoint) {
1583     // Leave space for int3
1584     nops_cnt -= 1;
1585   }
1586   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
1587   if (nops_cnt &gt; 0)
1588     masm.nop(nops_cnt);
1589 }
1590 
1591 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
1592 {
1593   return MachNode::size(ra_); // too many variables; just compute it
1594                               // the hard way
1595 }
1596 
1597 
1598 //=============================================================================
1599 
1600 int Matcher::regnum_to_fpu_offset(int regnum)
1601 {
1602   return regnum - 32; // The FP registers are in the second chunk
1603 }
1604 
1605 // This is UltraSparc specific, true just means we have fast l2f conversion
1606 const bool Matcher::convL2FSupported(void) {
1607   return true;
1608 }
1609 
1610 // Is this branch offset short enough that a short branch can be used?
1611 //
1612 // NOTE: If the platform does not provide any short branch variants, then
1613 //       this method should return false for offset 0.
1614 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
1615   // The passed offset is relative to address of the branch.
1616   // On 86 a branch displacement is calculated relative to address
1617   // of a next instruction.
1618   offset -= br_size;
1619 
1620   // the short version of jmpConUCF2 contains multiple branches,
1621   // making the reach slightly less
1622   if (rule == jmpConUCF2_rule)
1623     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
1624   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
1625 }
1626 
1627 const bool Matcher::isSimpleConstant64(jlong value) {
1628   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
1629   //return value == (int) value;  // Cf. storeImmL and immL32.
1630 
1631   // Probably always true, even if a temp register is required.
1632   return true;
1633 }
1634 
1635 // The ecx parameter to rep stosq for the ClearArray node is in words.
1636 const bool Matcher::init_array_count_is_in_bytes = false;
1637 
1638 // Threshold size for cleararray.
1639 const int Matcher::init_array_short_size = 8 * BytesPerLong;
1640 
1641 // No additional cost for CMOVL.
1642 const int Matcher::long_cmove_cost() { return 0; }
1643 
1644 // No CMOVF/CMOVD with SSE2
1645 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
1646 
1647 // Does the CPU require late expand (see block.cpp for description of late expand)?
1648 const bool Matcher::require_postalloc_expand = false;
1649 
1650 // Should the Matcher clone shifts on addressing modes, expecting them
1651 // to be subsumed into complex addressing expressions or compute them
1652 // into registers?  True for Intel but false for most RISCs
1653 const bool Matcher::clone_shift_expressions = true;
1654 
1655 // Do we need to mask the count passed to shift instructions or does
1656 // the cpu only look at the lower 5/6 bits anyway?
1657 const bool Matcher::need_masked_shift_count = false;
1658 
1659 bool Matcher::narrow_oop_use_complex_address() {
1660   assert(UseCompressedOops, "only for compressed oops code");
1661   return (LogMinObjAlignmentInBytes &lt;= 3);
1662 }
1663 
1664 bool Matcher::narrow_klass_use_complex_address() {
1665   assert(UseCompressedClassPointers, "only for compressed klass code");
1666   return (LogKlassAlignmentInBytes &lt;= 3);
1667 }
1668 
1669 // Is it better to copy float constants, or load them directly from
1670 // memory?  Intel can load a float constant from a direct address,
1671 // requiring no extra registers.  Most RISCs will have to materialize
1672 // an address into a register first, so they would do better to copy
1673 // the constant from stack.
1674 const bool Matcher::rematerialize_float_constants = true; // XXX
1675 
1676 // If CPU can load and store mis-aligned doubles directly then no
1677 // fixup is needed.  Else we split the double into 2 integer pieces
1678 // and move it piece-by-piece.  Only happens when passing doubles into
1679 // C code as the Java calling convention forces doubles to be aligned.
1680 const bool Matcher::misaligned_doubles_ok = true;
1681 
1682 // No-op on amd64
1683 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
1684 
1685 // Advertise here if the CPU requires explicit rounding operations to
1686 // implement the UseStrictFP mode.
1687 const bool Matcher::strict_fp_requires_explicit_rounding = true;
1688 
1689 // Are floats conerted to double when stored to stack during deoptimization?
1690 // On x64 it is stored without convertion so we can use normal access.
1691 bool Matcher::float_in_double() { return false; }
1692 
1693 // Do ints take an entire long register or just half?
1694 const bool Matcher::int_in_long = true;
1695 
1696 // Return whether or not this register is ever used as an argument.
1697 // This function is used on startup to build the trampoline stubs in
1698 // generateOptoStub.  Registers not mentioned will be killed by the VM
1699 // call in the trampoline, and arguments in those registers not be
1700 // available to the callee.
1701 bool Matcher::can_be_java_arg(int reg)
1702 {
1703   return
1704     reg ==  RDI_num || reg == RDI_H_num ||
1705     reg ==  RSI_num || reg == RSI_H_num ||
1706     reg ==  RDX_num || reg == RDX_H_num ||
1707     reg ==  RCX_num || reg == RCX_H_num ||
1708     reg ==   R8_num || reg ==  R8_H_num ||
1709     reg ==   R9_num || reg ==  R9_H_num ||
1710     reg ==  R12_num || reg == R12_H_num ||
1711     reg == XMM0_num || reg == XMM0b_num ||
1712     reg == XMM1_num || reg == XMM1b_num ||
1713     reg == XMM2_num || reg == XMM2b_num ||
1714     reg == XMM3_num || reg == XMM3b_num ||
1715     reg == XMM4_num || reg == XMM4b_num ||
1716     reg == XMM5_num || reg == XMM5b_num ||
1717     reg == XMM6_num || reg == XMM6b_num ||
1718     reg == XMM7_num || reg == XMM7b_num;
1719 }
1720 
1721 bool Matcher::is_spillable_arg(int reg)
1722 {
1723   return can_be_java_arg(reg);
1724 }
1725 
1726 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
1727   // In 64 bit mode a code which use multiply when
1728   // devisor is constant is faster than hardware
1729   // DIV instruction (it uses MulHiL).
1730   return false;
1731 }
1732 
1733 // Register for DIVI projection of divmodI
1734 RegMask Matcher::divI_proj_mask() {
1735   return INT_RAX_REG_mask();
1736 }
1737 
1738 // Register for MODI projection of divmodI
1739 RegMask Matcher::modI_proj_mask() {
1740   return INT_RDX_REG_mask();
1741 }
1742 
1743 // Register for DIVL projection of divmodL
1744 RegMask Matcher::divL_proj_mask() {
1745   return LONG_RAX_REG_mask();
1746 }
1747 
1748 // Register for MODL projection of divmodL
1749 RegMask Matcher::modL_proj_mask() {
1750   return LONG_RDX_REG_mask();
1751 }
1752 
1753 // Register for saving SP into on method handle invokes. Not used on x86_64.
1754 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
1755     return NO_REG_mask();
1756 }
1757 
1758 %}
1759 
1760 //----------ENCODING BLOCK-----------------------------------------------------
1761 // This block specifies the encoding classes used by the compiler to
1762 // output byte streams.  Encoding classes are parameterized macros
1763 // used by Machine Instruction Nodes in order to generate the bit
1764 // encoding of the instruction.  Operands specify their base encoding
1765 // interface with the interface keyword.  There are currently
1766 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
1767 // COND_INTER.  REG_INTER causes an operand to generate a function
1768 // which returns its register number when queried.  CONST_INTER causes
1769 // an operand to generate a function which returns the value of the
1770 // constant when queried.  MEMORY_INTER causes an operand to generate
1771 // four functions which return the Base Register, the Index Register,
1772 // the Scale Value, and the Offset Value of the operand when queried.
1773 // COND_INTER causes an operand to generate six functions which return
1774 // the encoding code (ie - encoding bits for the instruction)
1775 // associated with each basic boolean condition for a conditional
1776 // instruction.
1777 //
1778 // Instructions specify two basic values for encoding.  Again, a
1779 // function is available to check if the constant displacement is an
1780 // oop. They use the ins_encode keyword to specify their encoding
1781 // classes (which must be a sequence of enc_class names, and their
1782 // parameters, specified in the encoding block), and they use the
1783 // opcode keyword to specify, in order, their primary, secondary, and
1784 // tertiary opcode.  Only the opcode sections which a particular
1785 // instruction needs for encoding need to be specified.
1786 encode %{
1787   // Build emit functions for each basic byte or larger field in the
1788   // intel encoding scheme (opcode, rm, sib, immediate), and call them
1789   // from C++ code in the enc_class source block.  Emit functions will
1790   // live in the main source block for now.  In future, we can
1791   // generalize this by adding a syntax that specifies the sizes of
1792   // fields in an order, so that the adlc can build the emit functions
1793   // automagically
1794 
1795   // Emit primary opcode
1796   enc_class OpcP
1797   %{
1798     emit_opcode(cbuf, $primary);
1799   %}
1800 
1801   // Emit secondary opcode
1802   enc_class OpcS
1803   %{
1804     emit_opcode(cbuf, $secondary);
1805   %}
1806 
1807   // Emit tertiary opcode
1808   enc_class OpcT
1809   %{
1810     emit_opcode(cbuf, $tertiary);
1811   %}
1812 
1813   // Emit opcode directly
1814   enc_class Opcode(immI d8)
1815   %{
1816     emit_opcode(cbuf, $d8$$constant);
1817   %}
1818 
1819   // Emit size prefix
1820   enc_class SizePrefix
1821   %{
1822     emit_opcode(cbuf, 0x66);
1823   %}
1824 
1825   enc_class reg(rRegI reg)
1826   %{
1827     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
1828   %}
1829 
1830   enc_class reg_reg(rRegI dst, rRegI src)
1831   %{
1832     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1833   %}
1834 
1835   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
1836   %{
1837     emit_opcode(cbuf, $opcode$$constant);
1838     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1839   %}
1840 
1841   enc_class cdql_enc(no_rax_rdx_RegI div)
1842   %{
1843     // Full implementation of Java idiv and irem; checks for
1844     // special case as described in JVM spec., p.243 &amp; p.271.
1845     //
1846     //         normal case                           special case
1847     //
1848     // input : rax: dividend                         min_int
1849     //         reg: divisor                          -1
1850     //
1851     // output: rax: quotient  (= rax idiv reg)       min_int
1852     //         rdx: remainder (= rax irem reg)       0
1853     //
1854     //  Code sequnce:
1855     //
1856     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
1857     //    5:   75 07/08                jne    e &lt;normal&gt;
1858     //    7:   33 d2                   xor    %edx,%edx
1859     //  [div &gt;= 8 -&gt; offset + 1]
1860     //  [REX_B]
1861     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
1862     //    c:   74 03/04                je     11 &lt;done&gt;
1863     // 000000000000000e &lt;normal&gt;:
1864     //    e:   99                      cltd
1865     //  [div &gt;= 8 -&gt; offset + 1]
1866     //  [REX_B]
1867     //    f:   f7 f9                   idiv   $div
1868     // 0000000000000011 &lt;done&gt;:
1869 
1870     // cmp    $0x80000000,%eax
1871     emit_opcode(cbuf, 0x3d);
1872     emit_d8(cbuf, 0x00);
1873     emit_d8(cbuf, 0x00);
1874     emit_d8(cbuf, 0x00);
1875     emit_d8(cbuf, 0x80);
1876 
1877     // jne    e &lt;normal&gt;
1878     emit_opcode(cbuf, 0x75);
1879     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
1880 
1881     // xor    %edx,%edx
1882     emit_opcode(cbuf, 0x33);
1883     emit_d8(cbuf, 0xD2);
1884 
1885     // cmp    $0xffffffffffffffff,%ecx
1886     if ($div$$reg &gt;= 8) {
1887       emit_opcode(cbuf, Assembler::REX_B);
1888     }
1889     emit_opcode(cbuf, 0x83);
1890     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1891     emit_d8(cbuf, 0xFF);
1892 
1893     // je     11 &lt;done&gt;
1894     emit_opcode(cbuf, 0x74);
1895     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
1896 
1897     // &lt;normal&gt;
1898     // cltd
1899     emit_opcode(cbuf, 0x99);
1900 
1901     // idivl (note: must be emitted by the user of this rule)
1902     // &lt;done&gt;
1903   %}
1904 
1905   enc_class cdqq_enc(no_rax_rdx_RegL div)
1906   %{
1907     // Full implementation of Java ldiv and lrem; checks for
1908     // special case as described in JVM spec., p.243 &amp; p.271.
1909     //
1910     //         normal case                           special case
1911     //
1912     // input : rax: dividend                         min_long
1913     //         reg: divisor                          -1
1914     //
1915     // output: rax: quotient  (= rax idiv reg)       min_long
1916     //         rdx: remainder (= rax irem reg)       0
1917     //
1918     //  Code sequnce:
1919     //
1920     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
1921     //    7:   00 00 80
1922     //    a:   48 39 d0                cmp    %rdx,%rax
1923     //    d:   75 08                   jne    17 &lt;normal&gt;
1924     //    f:   33 d2                   xor    %edx,%edx
1925     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
1926     //   15:   74 05                   je     1c &lt;done&gt;
1927     // 0000000000000017 &lt;normal&gt;:
1928     //   17:   48 99                   cqto
1929     //   19:   48 f7 f9                idiv   $div
1930     // 000000000000001c &lt;done&gt;:
1931 
1932     // mov    $0x8000000000000000,%rdx
1933     emit_opcode(cbuf, Assembler::REX_W);
1934     emit_opcode(cbuf, 0xBA);
1935     emit_d8(cbuf, 0x00);
1936     emit_d8(cbuf, 0x00);
1937     emit_d8(cbuf, 0x00);
1938     emit_d8(cbuf, 0x00);
1939     emit_d8(cbuf, 0x00);
1940     emit_d8(cbuf, 0x00);
1941     emit_d8(cbuf, 0x00);
1942     emit_d8(cbuf, 0x80);
1943 
1944     // cmp    %rdx,%rax
1945     emit_opcode(cbuf, Assembler::REX_W);
1946     emit_opcode(cbuf, 0x39);
1947     emit_d8(cbuf, 0xD0);
1948 
1949     // jne    17 &lt;normal&gt;
1950     emit_opcode(cbuf, 0x75);
1951     emit_d8(cbuf, 0x08);
1952 
1953     // xor    %edx,%edx
1954     emit_opcode(cbuf, 0x33);
1955     emit_d8(cbuf, 0xD2);
1956 
1957     // cmp    $0xffffffffffffffff,$div
1958     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
1959     emit_opcode(cbuf, 0x83);
1960     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1961     emit_d8(cbuf, 0xFF);
1962 
1963     // je     1e &lt;done&gt;
1964     emit_opcode(cbuf, 0x74);
1965     emit_d8(cbuf, 0x05);
1966 
1967     // &lt;normal&gt;
1968     // cqto
1969     emit_opcode(cbuf, Assembler::REX_W);
1970     emit_opcode(cbuf, 0x99);
1971 
1972     // idivq (note: must be emitted by the user of this rule)
1973     // &lt;done&gt;
1974   %}
1975 
1976   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
1977   enc_class OpcSE(immI imm)
1978   %{
1979     // Emit primary opcode and set sign-extend bit
1980     // Check for 8-bit immediate, and set sign extend bit in opcode
1981     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1982       emit_opcode(cbuf, $primary | 0x02);
1983     } else {
1984       // 32-bit immediate
1985       emit_opcode(cbuf, $primary);
1986     }
1987   %}
1988 
1989   enc_class OpcSErm(rRegI dst, immI imm)
1990   %{
1991     // OpcSEr/m
1992     int dstenc = $dst$$reg;
1993     if (dstenc &gt;= 8) {
1994       emit_opcode(cbuf, Assembler::REX_B);
1995       dstenc -= 8;
1996     }
1997     // Emit primary opcode and set sign-extend bit
1998     // Check for 8-bit immediate, and set sign extend bit in opcode
1999     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2000       emit_opcode(cbuf, $primary | 0x02);
2001     } else {
2002       // 32-bit immediate
2003       emit_opcode(cbuf, $primary);
2004     }
2005     // Emit r/m byte with secondary opcode, after primary opcode.
2006     emit_rm(cbuf, 0x3, $secondary, dstenc);
2007   %}
2008 
2009   enc_class OpcSErm_wide(rRegL dst, immI imm)
2010   %{
2011     // OpcSEr/m
2012     int dstenc = $dst$$reg;
2013     if (dstenc &lt; 8) {
2014       emit_opcode(cbuf, Assembler::REX_W);
2015     } else {
2016       emit_opcode(cbuf, Assembler::REX_WB);
2017       dstenc -= 8;
2018     }
2019     // Emit primary opcode and set sign-extend bit
2020     // Check for 8-bit immediate, and set sign extend bit in opcode
2021     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2022       emit_opcode(cbuf, $primary | 0x02);
2023     } else {
2024       // 32-bit immediate
2025       emit_opcode(cbuf, $primary);
2026     }
2027     // Emit r/m byte with secondary opcode, after primary opcode.
2028     emit_rm(cbuf, 0x3, $secondary, dstenc);
2029   %}
2030 
2031   enc_class Con8or32(immI imm)
2032   %{
2033     // Check for 8-bit immediate, and set sign extend bit in opcode
2034     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2035       $$$emit8$imm$$constant;
2036     } else {
2037       // 32-bit immediate
2038       $$$emit32$imm$$constant;
2039     }
2040   %}
2041 
2042   enc_class opc2_reg(rRegI dst)
2043   %{
2044     // BSWAP
2045     emit_cc(cbuf, $secondary, $dst$$reg);
2046   %}
2047 
2048   enc_class opc3_reg(rRegI dst)
2049   %{
2050     // BSWAP
2051     emit_cc(cbuf, $tertiary, $dst$$reg);
2052   %}
2053 
2054   enc_class reg_opc(rRegI div)
2055   %{
2056     // INC, DEC, IDIV, IMOD, JMP indirect, ...
2057     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
2058   %}
2059 
2060   enc_class enc_cmov(cmpOp cop)
2061   %{
2062     // CMOV
2063     $$$emit8$primary;
2064     emit_cc(cbuf, $secondary, $cop$$cmpcode);
2065   %}
2066 
2067   enc_class enc_PartialSubtypeCheck()
2068   %{
2069     Register Rrdi = as_Register(RDI_enc); // result register
2070     Register Rrax = as_Register(RAX_enc); // super class
2071     Register Rrcx = as_Register(RCX_enc); // killed
2072     Register Rrsi = as_Register(RSI_enc); // sub class
2073     Label miss;
2074     const bool set_cond_codes = true;
2075 
2076     MacroAssembler _masm(&amp;cbuf);
2077     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
2078                                      NULL, &amp;miss,
2079                                      /*set_cond_codes:*/ true);
2080     if ($primary) {
2081       __ xorptr(Rrdi, Rrdi);
2082     }
2083     __ bind(miss);
2084   %}
2085 
2086   enc_class clear_avx %{
2087     debug_only(int off0 = cbuf.insts_size());
2088     if (ra_-&gt;C-&gt;max_vector_size() &gt; 16) {
2089       // Clear upper bits of YMM registers when current compiled code uses
2090       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
2091       MacroAssembler _masm(&amp;cbuf);
2092       __ vzeroupper();
2093     }
2094     debug_only(int off1 = cbuf.insts_size());
2095     assert(off1 - off0 == clear_avx_size(), "correct size prediction");
2096   %}
2097 
2098   enc_class Java_To_Runtime(method meth) %{
2099     // No relocation needed
2100     MacroAssembler _masm(&amp;cbuf);
2101     __ mov64(r10, (int64_t) $meth$$method);
2102     __ call(r10);
2103   %}
2104 
2105   enc_class Java_To_Interpreter(method meth)
2106   %{
2107     // CALL Java_To_Interpreter
2108     // This is the instruction starting address for relocation info.
2109     cbuf.set_insts_mark();
2110     $$$emit8$primary;
2111     // CALL directly to the runtime
2112     emit_d32_reloc(cbuf,
2113                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2114                    runtime_call_Relocation::spec(),
2115                    RELOC_DISP32);
2116   %}
2117 
2118   enc_class Java_Static_Call(method meth)
2119   %{
2120     // JAVA STATIC CALL
2121     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
2122     // determine who we intended to call.
2123     cbuf.set_insts_mark();
2124     $$$emit8$primary;
2125 
2126     if (!_method) {
2127       emit_d32_reloc(cbuf,
2128                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2129                      runtime_call_Relocation::spec(),
2130                      RELOC_DISP32);
2131     } else if (_optimized_virtual) {
2132       emit_d32_reloc(cbuf,
2133                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2134                      opt_virtual_call_Relocation::spec(),
2135                      RELOC_DISP32);
2136     } else {
2137       emit_d32_reloc(cbuf,
2138                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2139                      static_call_Relocation::spec(),
2140                      RELOC_DISP32);
2141     }
2142     if (_method) {
2143       // Emit stubs for static call.
2144       address mark = cbuf.insts_mark();
2145       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf, mark);
2146       if (stub == NULL) {
2147         ciEnv::current()-&gt;record_failure("CodeCache is full");
2148         return;
2149       }
2150     }
2151   %}
2152 
2153   enc_class Java_Dynamic_Call(method meth) %{
2154     MacroAssembler _masm(&amp;cbuf);
2155     __ ic_call((address)$meth$$method);
2156   %}
2157 
2158   enc_class Java_Compiled_Call(method meth)
2159   %{
2160     // JAVA COMPILED CALL
2161     int disp = in_bytes(Method:: from_compiled_offset());
2162 
2163     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
2164     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, "compiled_code_offset isn't small");
2165 
2166     // callq *disp(%rax)
2167     cbuf.set_insts_mark();
2168     $$$emit8$primary;
2169     if (disp &lt; 0x80) {
2170       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
2171       emit_d8(cbuf, disp); // Displacement
2172     } else {
2173       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
2174       emit_d32(cbuf, disp); // Displacement
2175     }
2176   %}
2177 
2178   enc_class reg_opc_imm(rRegI dst, immI8 shift)
2179   %{
2180     // SAL, SAR, SHR
2181     int dstenc = $dst$$reg;
2182     if (dstenc &gt;= 8) {
2183       emit_opcode(cbuf, Assembler::REX_B);
2184       dstenc -= 8;
2185     }
2186     $$$emit8$primary;
2187     emit_rm(cbuf, 0x3, $secondary, dstenc);
2188     $$$emit8$shift$$constant;
2189   %}
2190 
2191   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
2192   %{
2193     // SAL, SAR, SHR
2194     int dstenc = $dst$$reg;
2195     if (dstenc &lt; 8) {
2196       emit_opcode(cbuf, Assembler::REX_W);
2197     } else {
2198       emit_opcode(cbuf, Assembler::REX_WB);
2199       dstenc -= 8;
2200     }
2201     $$$emit8$primary;
2202     emit_rm(cbuf, 0x3, $secondary, dstenc);
2203     $$$emit8$shift$$constant;
2204   %}
2205 
2206   enc_class load_immI(rRegI dst, immI src)
2207   %{
2208     int dstenc = $dst$$reg;
2209     if (dstenc &gt;= 8) {
2210       emit_opcode(cbuf, Assembler::REX_B);
2211       dstenc -= 8;
2212     }
2213     emit_opcode(cbuf, 0xB8 | dstenc);
2214     $$$emit32$src$$constant;
2215   %}
2216 
2217   enc_class load_immL(rRegL dst, immL src)
2218   %{
2219     int dstenc = $dst$$reg;
2220     if (dstenc &lt; 8) {
2221       emit_opcode(cbuf, Assembler::REX_W);
2222     } else {
2223       emit_opcode(cbuf, Assembler::REX_WB);
2224       dstenc -= 8;
2225     }
2226     emit_opcode(cbuf, 0xB8 | dstenc);
2227     emit_d64(cbuf, $src$$constant);
2228   %}
2229 
2230   enc_class load_immUL32(rRegL dst, immUL32 src)
2231   %{
2232     // same as load_immI, but this time we care about zeroes in the high word
2233     int dstenc = $dst$$reg;
2234     if (dstenc &gt;= 8) {
2235       emit_opcode(cbuf, Assembler::REX_B);
2236       dstenc -= 8;
2237     }
2238     emit_opcode(cbuf, 0xB8 | dstenc);
2239     $$$emit32$src$$constant;
2240   %}
2241 
2242   enc_class load_immL32(rRegL dst, immL32 src)
2243   %{
2244     int dstenc = $dst$$reg;
2245     if (dstenc &lt; 8) {
2246       emit_opcode(cbuf, Assembler::REX_W);
2247     } else {
2248       emit_opcode(cbuf, Assembler::REX_WB);
2249       dstenc -= 8;
2250     }
2251     emit_opcode(cbuf, 0xC7);
2252     emit_rm(cbuf, 0x03, 0x00, dstenc);
2253     $$$emit32$src$$constant;
2254   %}
2255 
2256   enc_class load_immP31(rRegP dst, immP32 src)
2257   %{
2258     // same as load_immI, but this time we care about zeroes in the high word
2259     int dstenc = $dst$$reg;
2260     if (dstenc &gt;= 8) {
2261       emit_opcode(cbuf, Assembler::REX_B);
2262       dstenc -= 8;
2263     }
2264     emit_opcode(cbuf, 0xB8 | dstenc);
2265     $$$emit32$src$$constant;
2266   %}
2267 
2268   enc_class load_immP(rRegP dst, immP src)
2269   %{
2270     int dstenc = $dst$$reg;
2271     if (dstenc &lt; 8) {
2272       emit_opcode(cbuf, Assembler::REX_W);
2273     } else {
2274       emit_opcode(cbuf, Assembler::REX_WB);
2275       dstenc -= 8;
2276     }
2277     emit_opcode(cbuf, 0xB8 | dstenc);
2278     // This next line should be generated from ADLC
2279     if ($src-&gt;constant_reloc() != relocInfo::none) {
2280       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
2281     } else {
2282       emit_d64(cbuf, $src$$constant);
2283     }
2284   %}
2285 
2286   enc_class Con32(immI src)
2287   %{
2288     // Output immediate
2289     $$$emit32$src$$constant;
2290   %}
2291 
2292   enc_class Con32F_as_bits(immF src)
2293   %{
2294     // Output Float immediate bits
2295     jfloat jf = $src$$constant;
2296     jint jf_as_bits = jint_cast(jf);
2297     emit_d32(cbuf, jf_as_bits);
2298   %}
2299 
2300   enc_class Con16(immI src)
2301   %{
2302     // Output immediate
2303     $$$emit16$src$$constant;
2304   %}
2305 
2306   // How is this different from Con32??? XXX
2307   enc_class Con_d32(immI src)
2308   %{
2309     emit_d32(cbuf,$src$$constant);
2310   %}
2311 
2312   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
2313     // Output immediate memory reference
2314     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
2315     emit_d32(cbuf, 0x00);
2316   %}
2317 
2318   enc_class lock_prefix()
2319   %{
2320     if (os::is_MP()) {
2321       emit_opcode(cbuf, 0xF0); // lock
2322     }
2323   %}
2324 
2325   enc_class REX_mem(memory mem)
2326   %{
2327     if ($mem$$base &gt;= 8) {
2328       if ($mem$$index &lt; 8) {
2329         emit_opcode(cbuf, Assembler::REX_B);
2330       } else {
2331         emit_opcode(cbuf, Assembler::REX_XB);
2332       }
2333     } else {
2334       if ($mem$$index &gt;= 8) {
2335         emit_opcode(cbuf, Assembler::REX_X);
2336       }
2337     }
2338   %}
2339 
2340   enc_class REX_mem_wide(memory mem)
2341   %{
2342     if ($mem$$base &gt;= 8) {
2343       if ($mem$$index &lt; 8) {
2344         emit_opcode(cbuf, Assembler::REX_WB);
2345       } else {
2346         emit_opcode(cbuf, Assembler::REX_WXB);
2347       }
2348     } else {
2349       if ($mem$$index &lt; 8) {
2350         emit_opcode(cbuf, Assembler::REX_W);
2351       } else {
2352         emit_opcode(cbuf, Assembler::REX_WX);
2353       }
2354     }
2355   %}
2356 
2357   // for byte regs
2358   enc_class REX_breg(rRegI reg)
2359   %{
2360     if ($reg$$reg &gt;= 4) {
2361       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2362     }
2363   %}
2364 
2365   // for byte regs
2366   enc_class REX_reg_breg(rRegI dst, rRegI src)
2367   %{
2368     if ($dst$$reg &lt; 8) {
2369       if ($src$$reg &gt;= 4) {
2370         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2371       }
2372     } else {
2373       if ($src$$reg &lt; 8) {
2374         emit_opcode(cbuf, Assembler::REX_R);
2375       } else {
2376         emit_opcode(cbuf, Assembler::REX_RB);
2377       }
2378     }
2379   %}
2380 
2381   // for byte regs
2382   enc_class REX_breg_mem(rRegI reg, memory mem)
2383   %{
2384     if ($reg$$reg &lt; 8) {
2385       if ($mem$$base &lt; 8) {
2386         if ($mem$$index &gt;= 8) {
2387           emit_opcode(cbuf, Assembler::REX_X);
2388         } else if ($reg$$reg &gt;= 4) {
2389           emit_opcode(cbuf, Assembler::REX);
2390         }
2391       } else {
2392         if ($mem$$index &lt; 8) {
2393           emit_opcode(cbuf, Assembler::REX_B);
2394         } else {
2395           emit_opcode(cbuf, Assembler::REX_XB);
2396         }
2397       }
2398     } else {
2399       if ($mem$$base &lt; 8) {
2400         if ($mem$$index &lt; 8) {
2401           emit_opcode(cbuf, Assembler::REX_R);
2402         } else {
2403           emit_opcode(cbuf, Assembler::REX_RX);
2404         }
2405       } else {
2406         if ($mem$$index &lt; 8) {
2407           emit_opcode(cbuf, Assembler::REX_RB);
2408         } else {
2409           emit_opcode(cbuf, Assembler::REX_RXB);
2410         }
2411       }
2412     }
2413   %}
2414 
2415   enc_class REX_reg(rRegI reg)
2416   %{
2417     if ($reg$$reg &gt;= 8) {
2418       emit_opcode(cbuf, Assembler::REX_B);
2419     }
2420   %}
2421 
2422   enc_class REX_reg_wide(rRegI reg)
2423   %{
2424     if ($reg$$reg &lt; 8) {
2425       emit_opcode(cbuf, Assembler::REX_W);
2426     } else {
2427       emit_opcode(cbuf, Assembler::REX_WB);
2428     }
2429   %}
2430 
2431   enc_class REX_reg_reg(rRegI dst, rRegI src)
2432   %{
2433     if ($dst$$reg &lt; 8) {
2434       if ($src$$reg &gt;= 8) {
2435         emit_opcode(cbuf, Assembler::REX_B);
2436       }
2437     } else {
2438       if ($src$$reg &lt; 8) {
2439         emit_opcode(cbuf, Assembler::REX_R);
2440       } else {
2441         emit_opcode(cbuf, Assembler::REX_RB);
2442       }
2443     }
2444   %}
2445 
2446   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
2447   %{
2448     if ($dst$$reg &lt; 8) {
2449       if ($src$$reg &lt; 8) {
2450         emit_opcode(cbuf, Assembler::REX_W);
2451       } else {
2452         emit_opcode(cbuf, Assembler::REX_WB);
2453       }
2454     } else {
2455       if ($src$$reg &lt; 8) {
2456         emit_opcode(cbuf, Assembler::REX_WR);
2457       } else {
2458         emit_opcode(cbuf, Assembler::REX_WRB);
2459       }
2460     }
2461   %}
2462 
2463   enc_class REX_reg_mem(rRegI reg, memory mem)
2464   %{
2465     if ($reg$$reg &lt; 8) {
2466       if ($mem$$base &lt; 8) {
2467         if ($mem$$index &gt;= 8) {
2468           emit_opcode(cbuf, Assembler::REX_X);
2469         }
2470       } else {
2471         if ($mem$$index &lt; 8) {
2472           emit_opcode(cbuf, Assembler::REX_B);
2473         } else {
2474           emit_opcode(cbuf, Assembler::REX_XB);
2475         }
2476       }
2477     } else {
2478       if ($mem$$base &lt; 8) {
2479         if ($mem$$index &lt; 8) {
2480           emit_opcode(cbuf, Assembler::REX_R);
2481         } else {
2482           emit_opcode(cbuf, Assembler::REX_RX);
2483         }
2484       } else {
2485         if ($mem$$index &lt; 8) {
2486           emit_opcode(cbuf, Assembler::REX_RB);
2487         } else {
2488           emit_opcode(cbuf, Assembler::REX_RXB);
2489         }
2490       }
2491     }
2492   %}
2493 
2494   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
2495   %{
2496     if ($reg$$reg &lt; 8) {
2497       if ($mem$$base &lt; 8) {
2498         if ($mem$$index &lt; 8) {
2499           emit_opcode(cbuf, Assembler::REX_W);
2500         } else {
2501           emit_opcode(cbuf, Assembler::REX_WX);
2502         }
2503       } else {
2504         if ($mem$$index &lt; 8) {
2505           emit_opcode(cbuf, Assembler::REX_WB);
2506         } else {
2507           emit_opcode(cbuf, Assembler::REX_WXB);
2508         }
2509       }
2510     } else {
2511       if ($mem$$base &lt; 8) {
2512         if ($mem$$index &lt; 8) {
2513           emit_opcode(cbuf, Assembler::REX_WR);
2514         } else {
2515           emit_opcode(cbuf, Assembler::REX_WRX);
2516         }
2517       } else {
2518         if ($mem$$index &lt; 8) {
2519           emit_opcode(cbuf, Assembler::REX_WRB);
2520         } else {
2521           emit_opcode(cbuf, Assembler::REX_WRXB);
2522         }
2523       }
2524     }
2525   %}
2526 
2527   enc_class reg_mem(rRegI ereg, memory mem)
2528   %{
2529     // High registers handle in encode_RegMem
2530     int reg = $ereg$$reg;
2531     int base = $mem$$base;
2532     int index = $mem$$index;
2533     int scale = $mem$$scale;
2534     int disp = $mem$$disp;
2535     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
2536 
2537     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
2538   %}
2539 
2540   enc_class RM_opc_mem(immI rm_opcode, memory mem)
2541   %{
2542     int rm_byte_opcode = $rm_opcode$$constant;
2543 
2544     // High registers handle in encode_RegMem
2545     int base = $mem$$base;
2546     int index = $mem$$index;
2547     int scale = $mem$$scale;
2548     int displace = $mem$$disp;
2549 
2550     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
2551                                             // working with static
2552                                             // globals
2553     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
2554                   disp_reloc);
2555   %}
2556 
2557   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
2558   %{
2559     int reg_encoding = $dst$$reg;
2560     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
2561     int index        = 0x04;            // 0x04 indicates no index
2562     int scale        = 0x00;            // 0x00 indicates no scale
2563     int displace     = $src1$$constant; // 0x00 indicates no displacement
2564     relocInfo::relocType disp_reloc = relocInfo::none;
2565     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
2566                   disp_reloc);
2567   %}
2568 
2569   enc_class neg_reg(rRegI dst)
2570   %{
2571     int dstenc = $dst$$reg;
2572     if (dstenc &gt;= 8) {
2573       emit_opcode(cbuf, Assembler::REX_B);
2574       dstenc -= 8;
2575     }
2576     // NEG $dst
2577     emit_opcode(cbuf, 0xF7);
2578     emit_rm(cbuf, 0x3, 0x03, dstenc);
2579   %}
2580 
2581   enc_class neg_reg_wide(rRegI dst)
2582   %{
2583     int dstenc = $dst$$reg;
2584     if (dstenc &lt; 8) {
2585       emit_opcode(cbuf, Assembler::REX_W);
2586     } else {
2587       emit_opcode(cbuf, Assembler::REX_WB);
2588       dstenc -= 8;
2589     }
2590     // NEG $dst
2591     emit_opcode(cbuf, 0xF7);
2592     emit_rm(cbuf, 0x3, 0x03, dstenc);
2593   %}
2594 
2595   enc_class setLT_reg(rRegI dst)
2596   %{
2597     int dstenc = $dst$$reg;
2598     if (dstenc &gt;= 8) {
2599       emit_opcode(cbuf, Assembler::REX_B);
2600       dstenc -= 8;
2601     } else if (dstenc &gt;= 4) {
2602       emit_opcode(cbuf, Assembler::REX);
2603     }
2604     // SETLT $dst
2605     emit_opcode(cbuf, 0x0F);
2606     emit_opcode(cbuf, 0x9C);
2607     emit_rm(cbuf, 0x3, 0x0, dstenc);
2608   %}
2609 
2610   enc_class setNZ_reg(rRegI dst)
2611   %{
2612     int dstenc = $dst$$reg;
2613     if (dstenc &gt;= 8) {
2614       emit_opcode(cbuf, Assembler::REX_B);
2615       dstenc -= 8;
2616     } else if (dstenc &gt;= 4) {
2617       emit_opcode(cbuf, Assembler::REX);
2618     }
2619     // SETNZ $dst
2620     emit_opcode(cbuf, 0x0F);
2621     emit_opcode(cbuf, 0x95);
2622     emit_rm(cbuf, 0x3, 0x0, dstenc);
2623   %}
2624 
2625 
2626   // Compare the lonogs and set -1, 0, or 1 into dst
2627   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
2628   %{
2629     int src1enc = $src1$$reg;
2630     int src2enc = $src2$$reg;
2631     int dstenc = $dst$$reg;
2632 
2633     // cmpq $src1, $src2
2634     if (src1enc &lt; 8) {
2635       if (src2enc &lt; 8) {
2636         emit_opcode(cbuf, Assembler::REX_W);
2637       } else {
2638         emit_opcode(cbuf, Assembler::REX_WB);
2639       }
2640     } else {
2641       if (src2enc &lt; 8) {
2642         emit_opcode(cbuf, Assembler::REX_WR);
2643       } else {
2644         emit_opcode(cbuf, Assembler::REX_WRB);
2645       }
2646     }
2647     emit_opcode(cbuf, 0x3B);
2648     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
2649 
2650     // movl $dst, -1
2651     if (dstenc &gt;= 8) {
2652       emit_opcode(cbuf, Assembler::REX_B);
2653     }
2654     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
2655     emit_d32(cbuf, -1);
2656 
2657     // jl,s done
2658     emit_opcode(cbuf, 0x7C);
2659     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
2660 
2661     // setne $dst
2662     if (dstenc &gt;= 4) {
2663       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
2664     }
2665     emit_opcode(cbuf, 0x0F);
2666     emit_opcode(cbuf, 0x95);
2667     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
2668 
2669     // movzbl $dst, $dst
2670     if (dstenc &gt;= 4) {
2671       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
2672     }
2673     emit_opcode(cbuf, 0x0F);
2674     emit_opcode(cbuf, 0xB6);
2675     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
2676   %}
2677 
2678   enc_class Push_ResultXD(regD dst) %{
2679     MacroAssembler _masm(&amp;cbuf);
2680     __ fstp_d(Address(rsp, 0));
2681     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
2682     __ addptr(rsp, 8);
2683   %}
2684 
2685   enc_class Push_SrcXD(regD src) %{
2686     MacroAssembler _masm(&amp;cbuf);
2687     __ subptr(rsp, 8);
2688     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
2689     __ fld_d(Address(rsp, 0));
2690   %}
2691 
2692 
2693   enc_class enc_rethrow()
2694   %{
2695     cbuf.set_insts_mark();
2696     emit_opcode(cbuf, 0xE9); // jmp entry
2697     emit_d32_reloc(cbuf,
2698                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
2699                    runtime_call_Relocation::spec(),
2700                    RELOC_DISP32);
2701   %}
2702 
2703 %}
2704 
2705 
2706 
2707 //----------FRAME--------------------------------------------------------------
2708 // Definition of frame structure and management information.
2709 //
2710 //  S T A C K   L A Y O U T    Allocators stack-slot number
2711 //                             |   (to get allocators register number
2712 //  G  Owned by    |        |  v    add OptoReg::stack0())
2713 //  r   CALLER     |        |
2714 //  o     |        +--------+      pad to even-align allocators stack-slot
2715 //  w     V        |  pad0  |        numbers; owned by CALLER
2716 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
2717 //  h     ^        |   in   |  5
2718 //        |        |  args  |  4   Holes in incoming args owned by SELF
2719 //  |     |        |        |  3
2720 //  |     |        +--------+
2721 //  V     |        | old out|      Empty on Intel, window on Sparc
2722 //        |    old |preserve|      Must be even aligned.
2723 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
2724 //        |        |   in   |  3   area for Intel ret address
2725 //     Owned by    |preserve|      Empty on Sparc.
2726 //       SELF      +--------+
2727 //        |        |  pad2  |  2   pad to align old SP
2728 //        |        +--------+  1
2729 //        |        | locks  |  0
2730 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
2731 //        |        |  pad1  | 11   pad to align new SP
2732 //        |        +--------+
2733 //        |        |        | 10
2734 //        |        | spills |  9   spills
2735 //        V        |        |  8   (pad0 slot for callee)
2736 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
2737 //        ^        |  out   |  7
2738 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
2739 //     Owned by    +--------+
2740 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
2741 //        |    new |preserve|      Must be even-aligned.
2742 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
2743 //        |        |        |
2744 //
2745 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
2746 //         known from SELF's arguments and the Java calling convention.
2747 //         Region 6-7 is determined per call site.
2748 // Note 2: If the calling convention leaves holes in the incoming argument
2749 //         area, those holes are owned by SELF.  Holes in the outgoing area
2750 //         are owned by the CALLEE.  Holes should not be nessecary in the
2751 //         incoming area, as the Java calling convention is completely under
2752 //         the control of the AD file.  Doubles can be sorted and packed to
2753 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
2754 //         varargs C calling conventions.
2755 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
2756 //         even aligned with pad0 as needed.
2757 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
2758 //         region 6-11 is even aligned; it may be padded out more so that
2759 //         the region from SP to FP meets the minimum stack alignment.
2760 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
2761 //         alignment.  Region 11, pad1, may be dynamically extended so that
2762 //         SP meets the minimum alignment.
2763 
2764 frame
2765 %{
2766   // What direction does stack grow in (assumed to be same for C &amp; Java)
2767   stack_direction(TOWARDS_LOW);
2768 
2769   // These three registers define part of the calling convention
2770   // between compiled code and the interpreter.
2771   inline_cache_reg(RAX);                // Inline Cache Register
2772   interpreter_method_oop_reg(RBX);      // Method Oop Register when
2773                                         // calling interpreter
2774 
2775   // Optional: name the operand used by cisc-spilling to access
2776   // [stack_pointer + offset]
2777   cisc_spilling_operand_name(indOffset32);
2778 
2779   // Number of stack slots consumed by locking an object
2780   sync_stack_slots(2);
2781 
2782   // Compiled code's Frame Pointer
2783   frame_pointer(RSP);
2784 
2785   // Interpreter stores its frame pointer in a register which is
2786   // stored to the stack by I2CAdaptors.
2787   // I2CAdaptors convert from interpreted java to compiled java.
2788   interpreter_frame_pointer(RBP);
2789 
2790   // Stack alignment requirement
2791   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
2792 
2793   // Number of stack slots between incoming argument block and the start of
2794   // a new frame.  The PROLOG must add this many slots to the stack.  The
2795   // EPILOG must remove this many slots.  amd64 needs two slots for
2796   // return address.
2797   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
2798 
2799   // Number of outgoing stack slots killed above the out_preserve_stack_slots
2800   // for calls to C.  Supports the var-args backing area for register parms.
2801   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
2802 
2803   // The after-PROLOG location of the return address.  Location of
2804   // return address specifies a type (REG or STACK) and a number
2805   // representing the register number (i.e. - use a register name) or
2806   // stack slot.
2807   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
2808   // Otherwise, it is above the locks and verification slot and alignment word
2809   return_addr(STACK - 2 +
2810               round_to((Compile::current()-&gt;in_preserve_stack_slots() +
2811                         Compile::current()-&gt;fixed_slots()),
2812                        stack_alignment_in_slots()));
2813 
2814   // Body of function which returns an integer array locating
2815   // arguments either in registers or in stack slots.  Passed an array
2816   // of ideal registers called "sig" and a "length" count.  Stack-slot
2817   // offsets are based on outgoing arguments, i.e. a CALLER setting up
2818   // arguments for a CALLEE.  Incoming stack arguments are
2819   // automatically biased by the preserve_stack_slots field above.
2820 
2821   calling_convention
2822   %{
2823     // No difference between ingoing/outgoing just pass false
2824     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
2825   %}
2826 
2827   c_calling_convention
2828   %{
2829     // This is obviously always outgoing
2830     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
2831   %}
2832 
2833   // Location of compiled Java return values.  Same as C for now.
2834   return_value
2835   %{
2836     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
2837            "only return normal values");
2838 
2839     static const int lo[Op_RegL + 1] = {
2840       0,
2841       0,
2842       RAX_num,  // Op_RegN
2843       RAX_num,  // Op_RegI
2844       RAX_num,  // Op_RegP
2845       XMM0_num, // Op_RegF
2846       XMM0_num, // Op_RegD
2847       RAX_num   // Op_RegL
2848     };
2849     static const int hi[Op_RegL + 1] = {
2850       0,
2851       0,
2852       OptoReg::Bad, // Op_RegN
2853       OptoReg::Bad, // Op_RegI
2854       RAX_H_num,    // Op_RegP
2855       OptoReg::Bad, // Op_RegF
2856       XMM0b_num,    // Op_RegD
2857       RAX_H_num     // Op_RegL
2858     };
2859     // Excluded flags and vector registers.
2860     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, "missing type");
2861     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
2862   %}
2863 %}
2864 
2865 //----------ATTRIBUTES---------------------------------------------------------
2866 //----------Operand Attributes-------------------------------------------------
2867 op_attrib op_cost(0);        // Required cost attribute
2868 
2869 //----------Instruction Attributes---------------------------------------------
2870 ins_attrib ins_cost(100);       // Required cost attribute
2871 ins_attrib ins_size(8);         // Required size attribute (in bits)
2872 ins_attrib ins_short_branch(0); // Required flag: is this instruction
2873                                 // a non-matching short branch variant
2874                                 // of some long branch?
2875 ins_attrib ins_alignment(1);    // Required alignment attribute (must
2876                                 // be a power of 2) specifies the
2877                                 // alignment that some part of the
2878                                 // instruction (not necessarily the
2879                                 // start) requires.  If &gt; 1, a
2880                                 // compute_padding() function must be
2881                                 // provided for the instruction
2882 
2883 //----------OPERANDS-----------------------------------------------------------
2884 // Operand definitions must precede instruction definitions for correct parsing
2885 // in the ADLC because operands constitute user defined types which are used in
2886 // instruction definitions.
2887 
2888 //----------Simple Operands----------------------------------------------------
2889 // Immediate Operands
2890 // Integer Immediate
2891 operand immI()
2892 %{
2893   match(ConI);
2894 
2895   op_cost(10);
2896   format %{ %}
2897   interface(CONST_INTER);
2898 %}
2899 
2900 // Constant for test vs zero
2901 operand immI0()
2902 %{
2903   predicate(n-&gt;get_int() == 0);
2904   match(ConI);
2905 
2906   op_cost(0);
2907   format %{ %}
2908   interface(CONST_INTER);
2909 %}
2910 
2911 // Constant for increment
2912 operand immI1()
2913 %{
2914   predicate(n-&gt;get_int() == 1);
2915   match(ConI);
2916 
2917   op_cost(0);
2918   format %{ %}
2919   interface(CONST_INTER);
2920 %}
2921 
2922 // Constant for decrement
2923 operand immI_M1()
2924 %{
2925   predicate(n-&gt;get_int() == -1);
2926   match(ConI);
2927 
2928   op_cost(0);
2929   format %{ %}
2930   interface(CONST_INTER);
2931 %}
2932 
2933 // Valid scale values for addressing modes
2934 operand immI2()
2935 %{
2936   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
2937   match(ConI);
2938 
2939   format %{ %}
2940   interface(CONST_INTER);
2941 %}
2942 
2943 operand immI8()
2944 %{
2945   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
2946   match(ConI);
2947 
2948   op_cost(5);
2949   format %{ %}
2950   interface(CONST_INTER);
2951 %}
2952 
2953 operand immI16()
2954 %{
2955   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
2956   match(ConI);
2957 
2958   op_cost(10);
2959   format %{ %}
2960   interface(CONST_INTER);
2961 %}
2962 
2963 // Int Immediate non-negative
2964 operand immU31()
2965 %{
2966   predicate(n-&gt;get_int() &gt;= 0);
2967   match(ConI);
2968 
2969   op_cost(0);
2970   format %{ %}
2971   interface(CONST_INTER);
2972 %}
2973 
2974 // Constant for long shifts
2975 operand immI_32()
2976 %{
2977   predicate( n-&gt;get_int() == 32 );
2978   match(ConI);
2979 
2980   op_cost(0);
2981   format %{ %}
2982   interface(CONST_INTER);
2983 %}
2984 
2985 // Constant for long shifts
2986 operand immI_64()
2987 %{
2988   predicate( n-&gt;get_int() == 64 );
2989   match(ConI);
2990 
2991   op_cost(0);
2992   format %{ %}
2993   interface(CONST_INTER);
2994 %}
2995 
2996 // Pointer Immediate
2997 operand immP()
2998 %{
2999   match(ConP);
3000 
3001   op_cost(10);
3002   format %{ %}
3003   interface(CONST_INTER);
3004 %}
3005 
3006 // NULL Pointer Immediate
3007 operand immP0()
3008 %{
3009   predicate(n-&gt;get_ptr() == 0);
3010   match(ConP);
3011 
3012   op_cost(5);
3013   format %{ %}
3014   interface(CONST_INTER);
3015 %}
3016 
3017 // Pointer Immediate
3018 operand immN() %{
3019   match(ConN);
3020 
3021   op_cost(10);
3022   format %{ %}
3023   interface(CONST_INTER);
3024 %}
3025 
3026 operand immNKlass() %{
3027   match(ConNKlass);
3028 
3029   op_cost(10);
3030   format %{ %}
3031   interface(CONST_INTER);
3032 %}
3033 
3034 // NULL Pointer Immediate
3035 operand immN0() %{
3036   predicate(n-&gt;get_narrowcon() == 0);
3037   match(ConN);
3038 
3039   op_cost(5);
3040   format %{ %}
3041   interface(CONST_INTER);
3042 %}
3043 
3044 operand immP31()
3045 %{
3046   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
3047             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
3048   match(ConP);
3049 
3050   op_cost(5);
3051   format %{ %}
3052   interface(CONST_INTER);
3053 %}
3054 
3055 
3056 // Long Immediate
3057 operand immL()
3058 %{
3059   match(ConL);
3060 
3061   op_cost(20);
3062   format %{ %}
3063   interface(CONST_INTER);
3064 %}
3065 
3066 // Long Immediate 8-bit
3067 operand immL8()
3068 %{
3069   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
3070   match(ConL);
3071 
3072   op_cost(5);
3073   format %{ %}
3074   interface(CONST_INTER);
3075 %}
3076 
3077 // Long Immediate 32-bit unsigned
3078 operand immUL32()
3079 %{
3080   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
3081   match(ConL);
3082 
3083   op_cost(10);
3084   format %{ %}
3085   interface(CONST_INTER);
3086 %}
3087 
3088 // Long Immediate 32-bit signed
3089 operand immL32()
3090 %{
3091   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
3092   match(ConL);
3093 
3094   op_cost(15);
3095   format %{ %}
3096   interface(CONST_INTER);
3097 %}
3098 
3099 // Long Immediate zero
3100 operand immL0()
3101 %{
3102   predicate(n-&gt;get_long() == 0L);
3103   match(ConL);
3104 
3105   op_cost(10);
3106   format %{ %}
3107   interface(CONST_INTER);
3108 %}
3109 
3110 // Constant for increment
3111 operand immL1()
3112 %{
3113   predicate(n-&gt;get_long() == 1);
3114   match(ConL);
3115 
3116   format %{ %}
3117   interface(CONST_INTER);
3118 %}
3119 
3120 // Constant for decrement
3121 operand immL_M1()
3122 %{
3123   predicate(n-&gt;get_long() == -1);
3124   match(ConL);
3125 
3126   format %{ %}
3127   interface(CONST_INTER);
3128 %}
3129 
3130 // Long Immediate: the value 10
3131 operand immL10()
3132 %{
3133   predicate(n-&gt;get_long() == 10);
3134   match(ConL);
3135 
3136   format %{ %}
3137   interface(CONST_INTER);
3138 %}
3139 
3140 // Long immediate from 0 to 127.
3141 // Used for a shorter form of long mul by 10.
3142 operand immL_127()
3143 %{
3144   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
3145   match(ConL);
3146 
3147   op_cost(10);
3148   format %{ %}
3149   interface(CONST_INTER);
3150 %}
3151 
3152 // Long Immediate: low 32-bit mask
3153 operand immL_32bits()
3154 %{
3155   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
3156   match(ConL);
3157   op_cost(20);
3158 
3159   format %{ %}
3160   interface(CONST_INTER);
3161 %}
3162 
3163 // Float Immediate zero
3164 operand immF0()
3165 %{
3166   predicate(jint_cast(n-&gt;getf()) == 0);
3167   match(ConF);
3168 
3169   op_cost(5);
3170   format %{ %}
3171   interface(CONST_INTER);
3172 %}
3173 
3174 // Float Immediate
3175 operand immF()
3176 %{
3177   match(ConF);
3178 
3179   op_cost(15);
3180   format %{ %}
3181   interface(CONST_INTER);
3182 %}
3183 
3184 // Double Immediate zero
3185 operand immD0()
3186 %{
3187   predicate(jlong_cast(n-&gt;getd()) == 0);
3188   match(ConD);
3189 
3190   op_cost(5);
3191   format %{ %}
3192   interface(CONST_INTER);
3193 %}
3194 
3195 // Double Immediate
3196 operand immD()
3197 %{
3198   match(ConD);
3199 
3200   op_cost(15);
3201   format %{ %}
3202   interface(CONST_INTER);
3203 %}
3204 
3205 // Immediates for special shifts (sign extend)
3206 
3207 // Constants for increment
3208 operand immI_16()
3209 %{
3210   predicate(n-&gt;get_int() == 16);
3211   match(ConI);
3212 
3213   format %{ %}
3214   interface(CONST_INTER);
3215 %}
3216 
3217 operand immI_24()
3218 %{
3219   predicate(n-&gt;get_int() == 24);
3220   match(ConI);
3221 
3222   format %{ %}
3223   interface(CONST_INTER);
3224 %}
3225 
3226 // Constant for byte-wide masking
3227 operand immI_255()
3228 %{
3229   predicate(n-&gt;get_int() == 255);
3230   match(ConI);
3231 
3232   format %{ %}
3233   interface(CONST_INTER);
3234 %}
3235 
3236 // Constant for short-wide masking
3237 operand immI_65535()
3238 %{
3239   predicate(n-&gt;get_int() == 65535);
3240   match(ConI);
3241 
3242   format %{ %}
3243   interface(CONST_INTER);
3244 %}
3245 
3246 // Constant for byte-wide masking
3247 operand immL_255()
3248 %{
3249   predicate(n-&gt;get_long() == 255);
3250   match(ConL);
3251 
3252   format %{ %}
3253   interface(CONST_INTER);
3254 %}
3255 
3256 // Constant for short-wide masking
3257 operand immL_65535()
3258 %{
3259   predicate(n-&gt;get_long() == 65535);
3260   match(ConL);
3261 
3262   format %{ %}
3263   interface(CONST_INTER);
3264 %}
3265 
3266 // Register Operands
3267 // Integer Register
3268 operand rRegI()
3269 %{
3270   constraint(ALLOC_IN_RC(int_reg));
3271   match(RegI);
3272 
3273   match(rax_RegI);
3274   match(rbx_RegI);
3275   match(rcx_RegI);
3276   match(rdx_RegI);
3277   match(rdi_RegI);
3278 
3279   format %{ %}
3280   interface(REG_INTER);
3281 %}
3282 
3283 // Special Registers
3284 operand rax_RegI()
3285 %{
3286   constraint(ALLOC_IN_RC(int_rax_reg));
3287   match(RegI);
3288   match(rRegI);
3289 
3290   format %{ "RAX" %}
3291   interface(REG_INTER);
3292 %}
3293 
3294 // Special Registers
3295 operand rbx_RegI()
3296 %{
3297   constraint(ALLOC_IN_RC(int_rbx_reg));
3298   match(RegI);
3299   match(rRegI);
3300 
3301   format %{ "RBX" %}
3302   interface(REG_INTER);
3303 %}
3304 
3305 operand rcx_RegI()
3306 %{
3307   constraint(ALLOC_IN_RC(int_rcx_reg));
3308   match(RegI);
3309   match(rRegI);
3310 
3311   format %{ "RCX" %}
3312   interface(REG_INTER);
3313 %}
3314 
3315 operand rdx_RegI()
3316 %{
3317   constraint(ALLOC_IN_RC(int_rdx_reg));
3318   match(RegI);
3319   match(rRegI);
3320 
3321   format %{ "RDX" %}
3322   interface(REG_INTER);
3323 %}
3324 
3325 operand rdi_RegI()
3326 %{
3327   constraint(ALLOC_IN_RC(int_rdi_reg));
3328   match(RegI);
3329   match(rRegI);
3330 
3331   format %{ "RDI" %}
3332   interface(REG_INTER);
3333 %}
3334 
3335 operand no_rcx_RegI()
3336 %{
3337   constraint(ALLOC_IN_RC(int_no_rcx_reg));
3338   match(RegI);
3339   match(rax_RegI);
3340   match(rbx_RegI);
3341   match(rdx_RegI);
3342   match(rdi_RegI);
3343 
3344   format %{ %}
3345   interface(REG_INTER);
3346 %}
3347 
3348 operand no_rax_rdx_RegI()
3349 %{
3350   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
3351   match(RegI);
3352   match(rbx_RegI);
3353   match(rcx_RegI);
3354   match(rdi_RegI);
3355 
3356   format %{ %}
3357   interface(REG_INTER);
3358 %}
3359 
3360 // Pointer Register
3361 operand any_RegP()
3362 %{
3363   constraint(ALLOC_IN_RC(any_reg));
3364   match(RegP);
3365   match(rax_RegP);
3366   match(rbx_RegP);
3367   match(rdi_RegP);
3368   match(rsi_RegP);
3369   match(rbp_RegP);
3370   match(r15_RegP);
3371   match(rRegP);
3372 
3373   format %{ %}
3374   interface(REG_INTER);
3375 %}
3376 
3377 operand rRegP()
3378 %{
3379   constraint(ALLOC_IN_RC(ptr_reg));
3380   match(RegP);
3381   match(rax_RegP);
3382   match(rbx_RegP);
3383   match(rdi_RegP);
3384   match(rsi_RegP);
3385   match(rbp_RegP);  // See Q&amp;A below about
3386   match(r15_RegP);  // r15_RegP and rbp_RegP.
3387 
3388   format %{ %}
3389   interface(REG_INTER);
3390 %}
3391 
3392 operand rRegN() %{
3393   constraint(ALLOC_IN_RC(int_reg));
3394   match(RegN);
3395 
3396   format %{ %}
3397   interface(REG_INTER);
3398 %}
3399 
3400 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
3401 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
3402 // It's fine for an instruction input that expects rRegP to match a r15_RegP.
3403 // The output of an instruction is controlled by the allocator, which respects
3404 // register class masks, not match rules.  Unless an instruction mentions
3405 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
3406 // by the allocator as an input.
3407 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
3408 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
3409 // result, RBP is not included in the output of the instruction either.
3410 
3411 operand no_rax_RegP()
3412 %{
3413   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
3414   match(RegP);
3415   match(rbx_RegP);
3416   match(rsi_RegP);
3417   match(rdi_RegP);
3418 
3419   format %{ %}
3420   interface(REG_INTER);
3421 %}
3422 
3423 // This operand is not allowed to use RBP even if
3424 // RBP is not used to hold the frame pointer.
3425 operand no_rbp_RegP()
3426 %{
3427   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
3428   match(RegP);
3429   match(rbx_RegP);
3430   match(rsi_RegP);
3431   match(rdi_RegP);
3432 
3433   format %{ %}
3434   interface(REG_INTER);
3435 %}
3436 
3437 operand no_rax_rbx_RegP()
3438 %{
3439   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
3440   match(RegP);
3441   match(rsi_RegP);
3442   match(rdi_RegP);
3443 
3444   format %{ %}
3445   interface(REG_INTER);
3446 %}
3447 
3448 // Special Registers
3449 // Return a pointer value
3450 operand rax_RegP()
3451 %{
3452   constraint(ALLOC_IN_RC(ptr_rax_reg));
3453   match(RegP);
3454   match(rRegP);
3455 
3456   format %{ %}
3457   interface(REG_INTER);
3458 %}
3459 
3460 // Special Registers
3461 // Return a compressed pointer value
3462 operand rax_RegN()
3463 %{
3464   constraint(ALLOC_IN_RC(int_rax_reg));
3465   match(RegN);
3466   match(rRegN);
3467 
3468   format %{ %}
3469   interface(REG_INTER);
3470 %}
3471 
3472 // Used in AtomicAdd
3473 operand rbx_RegP()
3474 %{
3475   constraint(ALLOC_IN_RC(ptr_rbx_reg));
3476   match(RegP);
3477   match(rRegP);
3478 
3479   format %{ %}
3480   interface(REG_INTER);
3481 %}
3482 
3483 operand rsi_RegP()
3484 %{
3485   constraint(ALLOC_IN_RC(ptr_rsi_reg));
3486   match(RegP);
3487   match(rRegP);
3488 
3489   format %{ %}
3490   interface(REG_INTER);
3491 %}
3492 
3493 // Used in rep stosq
3494 operand rdi_RegP()
3495 %{
3496   constraint(ALLOC_IN_RC(ptr_rdi_reg));
3497   match(RegP);
3498   match(rRegP);
3499 
3500   format %{ %}
3501   interface(REG_INTER);
3502 %}
3503 
3504 operand r15_RegP()
3505 %{
3506   constraint(ALLOC_IN_RC(ptr_r15_reg));
3507   match(RegP);
3508   match(rRegP);
3509 
3510   format %{ %}
3511   interface(REG_INTER);
3512 %}
3513 
3514 operand rRegL()
3515 %{
3516   constraint(ALLOC_IN_RC(long_reg));
3517   match(RegL);
3518   match(rax_RegL);
3519   match(rdx_RegL);
3520 
3521   format %{ %}
3522   interface(REG_INTER);
3523 %}
3524 
3525 // Special Registers
3526 operand no_rax_rdx_RegL()
3527 %{
3528   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3529   match(RegL);
3530   match(rRegL);
3531 
3532   format %{ %}
3533   interface(REG_INTER);
3534 %}
3535 
3536 operand no_rax_RegL()
3537 %{
3538   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3539   match(RegL);
3540   match(rRegL);
3541   match(rdx_RegL);
3542 
3543   format %{ %}
3544   interface(REG_INTER);
3545 %}
3546 
3547 operand no_rcx_RegL()
3548 %{
3549   constraint(ALLOC_IN_RC(long_no_rcx_reg));
3550   match(RegL);
3551   match(rRegL);
3552 
3553   format %{ %}
3554   interface(REG_INTER);
3555 %}
3556 
3557 operand rax_RegL()
3558 %{
3559   constraint(ALLOC_IN_RC(long_rax_reg));
3560   match(RegL);
3561   match(rRegL);
3562 
3563   format %{ "RAX" %}
3564   interface(REG_INTER);
3565 %}
3566 
3567 operand rcx_RegL()
3568 %{
3569   constraint(ALLOC_IN_RC(long_rcx_reg));
3570   match(RegL);
3571   match(rRegL);
3572 
3573   format %{ %}
3574   interface(REG_INTER);
3575 %}
3576 
3577 operand rdx_RegL()
3578 %{
3579   constraint(ALLOC_IN_RC(long_rdx_reg));
3580   match(RegL);
3581   match(rRegL);
3582 
3583   format %{ %}
3584   interface(REG_INTER);
3585 %}
3586 
3587 // Flags register, used as output of compare instructions
3588 operand rFlagsReg()
3589 %{
3590   constraint(ALLOC_IN_RC(int_flags));
3591   match(RegFlags);
3592 
3593   format %{ "RFLAGS" %}
3594   interface(REG_INTER);
3595 %}
3596 
3597 // Flags register, used as output of FLOATING POINT compare instructions
3598 operand rFlagsRegU()
3599 %{
3600   constraint(ALLOC_IN_RC(int_flags));
3601   match(RegFlags);
3602 
3603   format %{ "RFLAGS_U" %}
3604   interface(REG_INTER);
3605 %}
3606 
3607 operand rFlagsRegUCF() %{
3608   constraint(ALLOC_IN_RC(int_flags));
3609   match(RegFlags);
3610   predicate(false);
3611 
3612   format %{ "RFLAGS_U_CF" %}
3613   interface(REG_INTER);
3614 %}
3615 
3616 // Float register operands
3617 operand regF() %{
3618    constraint(ALLOC_IN_RC(float_reg));
3619    match(RegF);
3620 
3621    format %{ %}
3622    interface(REG_INTER);
3623 %}
3624 
3625 // Double register operands
3626 operand regD() %{
3627    constraint(ALLOC_IN_RC(double_reg));
3628    match(RegD);
3629 
3630    format %{ %}
3631    interface(REG_INTER);
3632 %}
3633 
3634 // Vectors
3635 operand vecS() %{
3636   constraint(ALLOC_IN_RC(vectors_reg));
3637   match(VecS);
3638 
3639   format %{ %}
3640   interface(REG_INTER);
3641 %}
3642 
3643 operand vecD() %{
3644   constraint(ALLOC_IN_RC(vectord_reg));
3645   match(VecD);
3646 
3647   format %{ %}
3648   interface(REG_INTER);
3649 %}
3650 
3651 operand vecX() %{
3652   constraint(ALLOC_IN_RC(vectorx_reg));
3653   match(VecX);
3654 
3655   format %{ %}
3656   interface(REG_INTER);
3657 %}
3658 
3659 operand vecY() %{
3660   constraint(ALLOC_IN_RC(vectory_reg));
3661   match(VecY);
3662 
3663   format %{ %}
3664   interface(REG_INTER);
3665 %}
3666 
3667 //----------Memory Operands----------------------------------------------------
3668 // Direct Memory Operand
3669 // operand direct(immP addr)
3670 // %{
3671 //   match(addr);
3672 
3673 //   format %{ "[$addr]" %}
3674 //   interface(MEMORY_INTER) %{
3675 //     base(0xFFFFFFFF);
3676 //     index(0x4);
3677 //     scale(0x0);
3678 //     disp($addr);
3679 //   %}
3680 // %}
3681 
3682 // Indirect Memory Operand
3683 operand indirect(any_RegP reg)
3684 %{
3685   constraint(ALLOC_IN_RC(ptr_reg));
3686   match(reg);
3687 
3688   format %{ "[$reg]" %}
3689   interface(MEMORY_INTER) %{
3690     base($reg);
3691     index(0x4);
3692     scale(0x0);
3693     disp(0x0);
3694   %}
3695 %}
3696 
3697 // Indirect Memory Plus Short Offset Operand
3698 operand indOffset8(any_RegP reg, immL8 off)
3699 %{
3700   constraint(ALLOC_IN_RC(ptr_reg));
3701   match(AddP reg off);
3702 
3703   format %{ "[$reg + $off (8-bit)]" %}
3704   interface(MEMORY_INTER) %{
3705     base($reg);
3706     index(0x4);
3707     scale(0x0);
3708     disp($off);
3709   %}
3710 %}
3711 
3712 // Indirect Memory Plus Long Offset Operand
3713 operand indOffset32(any_RegP reg, immL32 off)
3714 %{
3715   constraint(ALLOC_IN_RC(ptr_reg));
3716   match(AddP reg off);
3717 
3718   format %{ "[$reg + $off (32-bit)]" %}
3719   interface(MEMORY_INTER) %{
3720     base($reg);
3721     index(0x4);
3722     scale(0x0);
3723     disp($off);
3724   %}
3725 %}
3726 
3727 // Indirect Memory Plus Index Register Plus Offset Operand
3728 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
3729 %{
3730   constraint(ALLOC_IN_RC(ptr_reg));
3731   match(AddP (AddP reg lreg) off);
3732 
3733   op_cost(10);
3734   format %{"[$reg + $off + $lreg]" %}
3735   interface(MEMORY_INTER) %{
3736     base($reg);
3737     index($lreg);
3738     scale(0x0);
3739     disp($off);
3740   %}
3741 %}
3742 
3743 // Indirect Memory Plus Index Register Plus Offset Operand
3744 operand indIndex(any_RegP reg, rRegL lreg)
3745 %{
3746   constraint(ALLOC_IN_RC(ptr_reg));
3747   match(AddP reg lreg);
3748 
3749   op_cost(10);
3750   format %{"[$reg + $lreg]" %}
3751   interface(MEMORY_INTER) %{
3752     base($reg);
3753     index($lreg);
3754     scale(0x0);
3755     disp(0x0);
3756   %}
3757 %}
3758 
3759 // Indirect Memory Times Scale Plus Index Register
3760 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
3761 %{
3762   constraint(ALLOC_IN_RC(ptr_reg));
3763   match(AddP reg (LShiftL lreg scale));
3764 
3765   op_cost(10);
3766   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3767   interface(MEMORY_INTER) %{
3768     base($reg);
3769     index($lreg);
3770     scale($scale);
3771     disp(0x0);
3772   %}
3773 %}
3774 
3775 operand indPosIndexScale(any_RegP reg, rRegI idx, immI2 scale)
3776 %{
3777   constraint(ALLOC_IN_RC(ptr_reg));
3778   predicate(n-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3779   match(AddP reg (LShiftL (ConvI2L idx) scale));
3780 
3781   op_cost(10);
3782   format %{"[$reg + pos $idx &lt;&lt; $scale]" %}
3783   interface(MEMORY_INTER) %{
3784     base($reg);
3785     index($idx);
3786     scale($scale);
3787     disp(0x0);
3788   %}
3789 %}
3790 
3791 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3792 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
3793 %{
3794   constraint(ALLOC_IN_RC(ptr_reg));
3795   match(AddP (AddP reg (LShiftL lreg scale)) off);
3796 
3797   op_cost(10);
3798   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3799   interface(MEMORY_INTER) %{
3800     base($reg);
3801     index($lreg);
3802     scale($scale);
3803     disp($off);
3804   %}
3805 %}
3806 
3807 // Indirect Memory Plus Positive Index Register Plus Offset Operand
3808 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
3809 %{
3810   constraint(ALLOC_IN_RC(ptr_reg));
3811   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3812   match(AddP (AddP reg (ConvI2L idx)) off);
3813 
3814   op_cost(10);
3815   format %{"[$reg + $off + $idx]" %}
3816   interface(MEMORY_INTER) %{
3817     base($reg);
3818     index($idx);
3819     scale(0x0);
3820     disp($off);
3821   %}
3822 %}
3823 
3824 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3825 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
3826 %{
3827   constraint(ALLOC_IN_RC(ptr_reg));
3828   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3829   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
3830 
3831   op_cost(10);
3832   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3833   interface(MEMORY_INTER) %{
3834     base($reg);
3835     index($idx);
3836     scale($scale);
3837     disp($off);
3838   %}
3839 %}
3840 
3841 // Indirect Narrow Oop Plus Offset Operand
3842 // Note: x86 architecture doesn't support "scale * index + offset" without a base
3843 // we can't free r12 even with Universe::narrow_oop_base() == NULL.
3844 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
3845   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));
3846   constraint(ALLOC_IN_RC(ptr_reg));
3847   match(AddP (DecodeN reg) off);
3848 
3849   op_cost(10);
3850   format %{"[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)" %}
3851   interface(MEMORY_INTER) %{
3852     base(0xc); // R12
3853     index($reg);
3854     scale(0x3);
3855     disp($off);
3856   %}
3857 %}
3858 
3859 // Indirect Memory Operand
3860 operand indirectNarrow(rRegN reg)
3861 %{
3862   predicate(Universe::narrow_oop_shift() == 0);
3863   constraint(ALLOC_IN_RC(ptr_reg));
3864   match(DecodeN reg);
3865 
3866   format %{ "[$reg]" %}
3867   interface(MEMORY_INTER) %{
3868     base($reg);
3869     index(0x4);
3870     scale(0x0);
3871     disp(0x0);
3872   %}
3873 %}
3874 
3875 // Indirect Memory Plus Short Offset Operand
3876 operand indOffset8Narrow(rRegN reg, immL8 off)
3877 %{
3878   predicate(Universe::narrow_oop_shift() == 0);
3879   constraint(ALLOC_IN_RC(ptr_reg));
3880   match(AddP (DecodeN reg) off);
3881 
3882   format %{ "[$reg + $off (8-bit)]" %}
3883   interface(MEMORY_INTER) %{
3884     base($reg);
3885     index(0x4);
3886     scale(0x0);
3887     disp($off);
3888   %}
3889 %}
3890 
3891 // Indirect Memory Plus Long Offset Operand
3892 operand indOffset32Narrow(rRegN reg, immL32 off)
3893 %{
3894   predicate(Universe::narrow_oop_shift() == 0);
3895   constraint(ALLOC_IN_RC(ptr_reg));
3896   match(AddP (DecodeN reg) off);
3897 
3898   format %{ "[$reg + $off (32-bit)]" %}
3899   interface(MEMORY_INTER) %{
3900     base($reg);
3901     index(0x4);
3902     scale(0x0);
3903     disp($off);
3904   %}
3905 %}
3906 
3907 // Indirect Memory Plus Index Register Plus Offset Operand
3908 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
3909 %{
3910   predicate(Universe::narrow_oop_shift() == 0);
3911   constraint(ALLOC_IN_RC(ptr_reg));
3912   match(AddP (AddP (DecodeN reg) lreg) off);
3913 
3914   op_cost(10);
3915   format %{"[$reg + $off + $lreg]" %}
3916   interface(MEMORY_INTER) %{
3917     base($reg);
3918     index($lreg);
3919     scale(0x0);
3920     disp($off);
3921   %}
3922 %}
3923 
3924 // Indirect Memory Plus Index Register Plus Offset Operand
3925 operand indIndexNarrow(rRegN reg, rRegL lreg)
3926 %{
3927   predicate(Universe::narrow_oop_shift() == 0);
3928   constraint(ALLOC_IN_RC(ptr_reg));
3929   match(AddP (DecodeN reg) lreg);
3930 
3931   op_cost(10);
3932   format %{"[$reg + $lreg]" %}
3933   interface(MEMORY_INTER) %{
3934     base($reg);
3935     index($lreg);
3936     scale(0x0);
3937     disp(0x0);
3938   %}
3939 %}
3940 
3941 // Indirect Memory Times Scale Plus Index Register
3942 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
3943 %{
3944   predicate(Universe::narrow_oop_shift() == 0);
3945   constraint(ALLOC_IN_RC(ptr_reg));
3946   match(AddP (DecodeN reg) (LShiftL lreg scale));
3947 
3948   op_cost(10);
3949   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3950   interface(MEMORY_INTER) %{
3951     base($reg);
3952     index($lreg);
3953     scale($scale);
3954     disp(0x0);
3955   %}
3956 %}
3957 
3958 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3959 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
3960 %{
3961   predicate(Universe::narrow_oop_shift() == 0);
3962   constraint(ALLOC_IN_RC(ptr_reg));
3963   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
3964 
3965   op_cost(10);
3966   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3967   interface(MEMORY_INTER) %{
3968     base($reg);
3969     index($lreg);
3970     scale($scale);
3971     disp($off);
3972   %}
3973 %}
3974 
3975 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
3976 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
3977 %{
3978   constraint(ALLOC_IN_RC(ptr_reg));
3979   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3980   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
3981 
3982   op_cost(10);
3983   format %{"[$reg + $off + $idx]" %}
3984   interface(MEMORY_INTER) %{
3985     base($reg);
3986     index($idx);
3987     scale(0x0);
3988     disp($off);
3989   %}
3990 %}
3991 
3992 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3993 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
3994 %{
3995   constraint(ALLOC_IN_RC(ptr_reg));
3996   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3997   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
3998 
3999   op_cost(10);
4000   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
4001   interface(MEMORY_INTER) %{
4002     base($reg);
4003     index($idx);
4004     scale($scale);
4005     disp($off);
4006   %}
4007 %}
4008 
4009 //----------Special Memory Operands--------------------------------------------
4010 // Stack Slot Operand - This operand is used for loading and storing temporary
4011 //                      values on the stack where a match requires a value to
4012 //                      flow through memory.
4013 operand stackSlotP(sRegP reg)
4014 %{
4015   constraint(ALLOC_IN_RC(stack_slots));
4016   // No match rule because this operand is only generated in matching
4017 
4018   format %{ "[$reg]" %}
4019   interface(MEMORY_INTER) %{
4020     base(0x4);   // RSP
4021     index(0x4);  // No Index
4022     scale(0x0);  // No Scale
4023     disp($reg);  // Stack Offset
4024   %}
4025 %}
4026 
4027 operand stackSlotI(sRegI reg)
4028 %{
4029   constraint(ALLOC_IN_RC(stack_slots));
4030   // No match rule because this operand is only generated in matching
4031 
4032   format %{ "[$reg]" %}
4033   interface(MEMORY_INTER) %{
4034     base(0x4);   // RSP
4035     index(0x4);  // No Index
4036     scale(0x0);  // No Scale
4037     disp($reg);  // Stack Offset
4038   %}
4039 %}
4040 
4041 operand stackSlotF(sRegF reg)
4042 %{
4043   constraint(ALLOC_IN_RC(stack_slots));
4044   // No match rule because this operand is only generated in matching
4045 
4046   format %{ "[$reg]" %}
4047   interface(MEMORY_INTER) %{
4048     base(0x4);   // RSP
4049     index(0x4);  // No Index
4050     scale(0x0);  // No Scale
4051     disp($reg);  // Stack Offset
4052   %}
4053 %}
4054 
4055 operand stackSlotD(sRegD reg)
4056 %{
4057   constraint(ALLOC_IN_RC(stack_slots));
4058   // No match rule because this operand is only generated in matching
4059 
4060   format %{ "[$reg]" %}
4061   interface(MEMORY_INTER) %{
4062     base(0x4);   // RSP
4063     index(0x4);  // No Index
4064     scale(0x0);  // No Scale
4065     disp($reg);  // Stack Offset
4066   %}
4067 %}
4068 operand stackSlotL(sRegL reg)
4069 %{
4070   constraint(ALLOC_IN_RC(stack_slots));
4071   // No match rule because this operand is only generated in matching
4072 
4073   format %{ "[$reg]" %}
4074   interface(MEMORY_INTER) %{
4075     base(0x4);   // RSP
4076     index(0x4);  // No Index
4077     scale(0x0);  // No Scale
4078     disp($reg);  // Stack Offset
4079   %}
4080 %}
4081 
4082 //----------Conditional Branch Operands----------------------------------------
4083 // Comparison Op  - This is the operation of the comparison, and is limited to
4084 //                  the following set of codes:
4085 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
4086 //
4087 // Other attributes of the comparison, such as unsignedness, are specified
4088 // by the comparison instruction that sets a condition code flags register.
4089 // That result is represented by a flags operand whose subtype is appropriate
4090 // to the unsignedness (etc.) of the comparison.
4091 //
4092 // Later, the instruction which matches both the Comparison Op (a Bool) and
4093 // the flags (produced by the Cmp) specifies the coding of the comparison op
4094 // by matching a specific subtype of Bool operand below, such as cmpOpU.
4095 
4096 // Comparision Code
4097 operand cmpOp()
4098 %{
4099   match(Bool);
4100 
4101   format %{ "" %}
4102   interface(COND_INTER) %{
4103     equal(0x4, "e");
4104     not_equal(0x5, "ne");
4105     less(0xC, "l");
4106     greater_equal(0xD, "ge");
4107     less_equal(0xE, "le");
4108     greater(0xF, "g");
4109     overflow(0x0, "o");
4110     no_overflow(0x1, "no");
4111   %}
4112 %}
4113 
4114 // Comparison Code, unsigned compare.  Used by FP also, with
4115 // C2 (unordered) turned into GT or LT already.  The other bits
4116 // C0 and C3 are turned into Carry &amp; Zero flags.
4117 operand cmpOpU()
4118 %{
4119   match(Bool);
4120 
4121   format %{ "" %}
4122   interface(COND_INTER) %{
4123     equal(0x4, "e");
4124     not_equal(0x5, "ne");
4125     less(0x2, "b");
4126     greater_equal(0x3, "nb");
4127     less_equal(0x6, "be");
4128     greater(0x7, "nbe");
4129     overflow(0x0, "o");
4130     no_overflow(0x1, "no");
4131   %}
4132 %}
4133 
4134 
4135 // Floating comparisons that don't require any fixup for the unordered case
4136 operand cmpOpUCF() %{
4137   match(Bool);
4138   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
4139             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
4140             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
4141             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
4142   format %{ "" %}
4143   interface(COND_INTER) %{
4144     equal(0x4, "e");
4145     not_equal(0x5, "ne");
4146     less(0x2, "b");
4147     greater_equal(0x3, "nb");
4148     less_equal(0x6, "be");
4149     greater(0x7, "nbe");
4150     overflow(0x0, "o");
4151     no_overflow(0x1, "no");
4152   %}
4153 %}
4154 
4155 
4156 // Floating comparisons that can be fixed up with extra conditional jumps
4157 operand cmpOpUCF2() %{
4158   match(Bool);
4159   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
4160             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
4161   format %{ "" %}
4162   interface(COND_INTER) %{
4163     equal(0x4, "e");
4164     not_equal(0x5, "ne");
4165     less(0x2, "b");
4166     greater_equal(0x3, "nb");
4167     less_equal(0x6, "be");
4168     greater(0x7, "nbe");
4169     overflow(0x0, "o");
4170     no_overflow(0x1, "no");
4171   %}
4172 %}
4173 
4174 
4175 //----------OPERAND CLASSES----------------------------------------------------
4176 // Operand Classes are groups of operands that are used as to simplify
4177 // instruction definitions by not requiring the AD writer to specify separate
4178 // instructions for every form of operand when the instruction accepts
4179 // multiple operand types with the same basic encoding and format.  The classic
4180 // case of this is memory operands.
4181 
4182 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
4183                indIndexScale, indPosIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
4184                indCompressedOopOffset,
4185                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
4186                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
4187                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
4188 
4189 //----------PIPELINE-----------------------------------------------------------
4190 // Rules which define the behavior of the target architectures pipeline.
4191 pipeline %{
4192 
4193 //----------ATTRIBUTES---------------------------------------------------------
4194 attributes %{
4195   variable_size_instructions;        // Fixed size instructions
4196   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
4197   instruction_unit_size = 1;         // An instruction is 1 bytes long
4198   instruction_fetch_unit_size = 16;  // The processor fetches one line
4199   instruction_fetch_units = 1;       // of 16 bytes
4200 
4201   // List of nop instructions
4202   nops( MachNop );
4203 %}
4204 
4205 //----------RESOURCES----------------------------------------------------------
4206 // Resources are the functional units available to the machine
4207 
4208 // Generic P2/P3 pipeline
4209 // 3 decoders, only D0 handles big operands; a "bundle" is the limit of
4210 // 3 instructions decoded per cycle.
4211 // 2 load/store ops per cycle, 1 branch, 1 FPU,
4212 // 3 ALU op, only ALU0 handles mul instructions.
4213 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
4214            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
4215            BR, FPU,
4216            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
4217 
4218 //----------PIPELINE DESCRIPTION-----------------------------------------------
4219 // Pipeline Description specifies the stages in the machine's pipeline
4220 
4221 // Generic P2/P3 pipeline
4222 pipe_desc(S0, S1, S2, S3, S4, S5);
4223 
4224 //----------PIPELINE CLASSES---------------------------------------------------
4225 // Pipeline Classes describe the stages in which input and output are
4226 // referenced by the hardware pipeline.
4227 
4228 // Naming convention: ialu or fpu
4229 // Then: _reg
4230 // Then: _reg if there is a 2nd register
4231 // Then: _long if it's a pair of instructions implementing a long
4232 // Then: _fat if it requires the big decoder
4233 //   Or: _mem if it requires the big decoder and a memory unit.
4234 
4235 // Integer ALU reg operation
4236 pipe_class ialu_reg(rRegI dst)
4237 %{
4238     single_instruction;
4239     dst    : S4(write);
4240     dst    : S3(read);
4241     DECODE : S0;        // any decoder
4242     ALU    : S3;        // any alu
4243 %}
4244 
4245 // Long ALU reg operation
4246 pipe_class ialu_reg_long(rRegL dst)
4247 %{
4248     instruction_count(2);
4249     dst    : S4(write);
4250     dst    : S3(read);
4251     DECODE : S0(2);     // any 2 decoders
4252     ALU    : S3(2);     // both alus
4253 %}
4254 
4255 // Integer ALU reg operation using big decoder
4256 pipe_class ialu_reg_fat(rRegI dst)
4257 %{
4258     single_instruction;
4259     dst    : S4(write);
4260     dst    : S3(read);
4261     D0     : S0;        // big decoder only
4262     ALU    : S3;        // any alu
4263 %}
4264 
4265 // Long ALU reg operation using big decoder
4266 pipe_class ialu_reg_long_fat(rRegL dst)
4267 %{
4268     instruction_count(2);
4269     dst    : S4(write);
4270     dst    : S3(read);
4271     D0     : S0(2);     // big decoder only; twice
4272     ALU    : S3(2);     // any 2 alus
4273 %}
4274 
4275 // Integer ALU reg-reg operation
4276 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
4277 %{
4278     single_instruction;
4279     dst    : S4(write);
4280     src    : S3(read);
4281     DECODE : S0;        // any decoder
4282     ALU    : S3;        // any alu
4283 %}
4284 
4285 // Long ALU reg-reg operation
4286 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
4287 %{
4288     instruction_count(2);
4289     dst    : S4(write);
4290     src    : S3(read);
4291     DECODE : S0(2);     // any 2 decoders
4292     ALU    : S3(2);     // both alus
4293 %}
4294 
4295 // Integer ALU reg-reg operation
4296 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
4297 %{
4298     single_instruction;
4299     dst    : S4(write);
4300     src    : S3(read);
4301     D0     : S0;        // big decoder only
4302     ALU    : S3;        // any alu
4303 %}
4304 
4305 // Long ALU reg-reg operation
4306 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
4307 %{
4308     instruction_count(2);
4309     dst    : S4(write);
4310     src    : S3(read);
4311     D0     : S0(2);     // big decoder only; twice
4312     ALU    : S3(2);     // both alus
4313 %}
4314 
4315 // Integer ALU reg-mem operation
4316 pipe_class ialu_reg_mem(rRegI dst, memory mem)
4317 %{
4318     single_instruction;
4319     dst    : S5(write);
4320     mem    : S3(read);
4321     D0     : S0;        // big decoder only
4322     ALU    : S4;        // any alu
4323     MEM    : S3;        // any mem
4324 %}
4325 
4326 // Integer mem operation (prefetch)
4327 pipe_class ialu_mem(memory mem)
4328 %{
4329     single_instruction;
4330     mem    : S3(read);
4331     D0     : S0;        // big decoder only
4332     MEM    : S3;        // any mem
4333 %}
4334 
4335 // Integer Store to Memory
4336 pipe_class ialu_mem_reg(memory mem, rRegI src)
4337 %{
4338     single_instruction;
4339     mem    : S3(read);
4340     src    : S5(read);
4341     D0     : S0;        // big decoder only
4342     ALU    : S4;        // any alu
4343     MEM    : S3;
4344 %}
4345 
4346 // // Long Store to Memory
4347 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
4348 // %{
4349 //     instruction_count(2);
4350 //     mem    : S3(read);
4351 //     src    : S5(read);
4352 //     D0     : S0(2);          // big decoder only; twice
4353 //     ALU    : S4(2);     // any 2 alus
4354 //     MEM    : S3(2);  // Both mems
4355 // %}
4356 
4357 // Integer Store to Memory
4358 pipe_class ialu_mem_imm(memory mem)
4359 %{
4360     single_instruction;
4361     mem    : S3(read);
4362     D0     : S0;        // big decoder only
4363     ALU    : S4;        // any alu
4364     MEM    : S3;
4365 %}
4366 
4367 // Integer ALU0 reg-reg operation
4368 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
4369 %{
4370     single_instruction;
4371     dst    : S4(write);
4372     src    : S3(read);
4373     D0     : S0;        // Big decoder only
4374     ALU0   : S3;        // only alu0
4375 %}
4376 
4377 // Integer ALU0 reg-mem operation
4378 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
4379 %{
4380     single_instruction;
4381     dst    : S5(write);
4382     mem    : S3(read);
4383     D0     : S0;        // big decoder only
4384     ALU0   : S4;        // ALU0 only
4385     MEM    : S3;        // any mem
4386 %}
4387 
4388 // Integer ALU reg-reg operation
4389 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
4390 %{
4391     single_instruction;
4392     cr     : S4(write);
4393     src1   : S3(read);
4394     src2   : S3(read);
4395     DECODE : S0;        // any decoder
4396     ALU    : S3;        // any alu
4397 %}
4398 
4399 // Integer ALU reg-imm operation
4400 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
4401 %{
4402     single_instruction;
4403     cr     : S4(write);
4404     src1   : S3(read);
4405     DECODE : S0;        // any decoder
4406     ALU    : S3;        // any alu
4407 %}
4408 
4409 // Integer ALU reg-mem operation
4410 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
4411 %{
4412     single_instruction;
4413     cr     : S4(write);
4414     src1   : S3(read);
4415     src2   : S3(read);
4416     D0     : S0;        // big decoder only
4417     ALU    : S4;        // any alu
4418     MEM    : S3;
4419 %}
4420 
4421 // Conditional move reg-reg
4422 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
4423 %{
4424     instruction_count(4);
4425     y      : S4(read);
4426     q      : S3(read);
4427     p      : S3(read);
4428     DECODE : S0(4);     // any decoder
4429 %}
4430 
4431 // Conditional move reg-reg
4432 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
4433 %{
4434     single_instruction;
4435     dst    : S4(write);
4436     src    : S3(read);
4437     cr     : S3(read);
4438     DECODE : S0;        // any decoder
4439 %}
4440 
4441 // Conditional move reg-mem
4442 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
4443 %{
4444     single_instruction;
4445     dst    : S4(write);
4446     src    : S3(read);
4447     cr     : S3(read);
4448     DECODE : S0;        // any decoder
4449     MEM    : S3;
4450 %}
4451 
4452 // Conditional move reg-reg long
4453 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
4454 %{
4455     single_instruction;
4456     dst    : S4(write);
4457     src    : S3(read);
4458     cr     : S3(read);
4459     DECODE : S0(2);     // any 2 decoders
4460 %}
4461 
4462 // XXX
4463 // // Conditional move double reg-reg
4464 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
4465 // %{
4466 //     single_instruction;
4467 //     dst    : S4(write);
4468 //     src    : S3(read);
4469 //     cr     : S3(read);
4470 //     DECODE : S0;     // any decoder
4471 // %}
4472 
4473 // Float reg-reg operation
4474 pipe_class fpu_reg(regD dst)
4475 %{
4476     instruction_count(2);
4477     dst    : S3(read);
4478     DECODE : S0(2);     // any 2 decoders
4479     FPU    : S3;
4480 %}
4481 
4482 // Float reg-reg operation
4483 pipe_class fpu_reg_reg(regD dst, regD src)
4484 %{
4485     instruction_count(2);
4486     dst    : S4(write);
4487     src    : S3(read);
4488     DECODE : S0(2);     // any 2 decoders
4489     FPU    : S3;
4490 %}
4491 
4492 // Float reg-reg operation
4493 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
4494 %{
4495     instruction_count(3);
4496     dst    : S4(write);
4497     src1   : S3(read);
4498     src2   : S3(read);
4499     DECODE : S0(3);     // any 3 decoders
4500     FPU    : S3(2);
4501 %}
4502 
4503 // Float reg-reg operation
4504 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
4505 %{
4506     instruction_count(4);
4507     dst    : S4(write);
4508     src1   : S3(read);
4509     src2   : S3(read);
4510     src3   : S3(read);
4511     DECODE : S0(4);     // any 3 decoders
4512     FPU    : S3(2);
4513 %}
4514 
4515 // Float reg-reg operation
4516 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
4517 %{
4518     instruction_count(4);
4519     dst    : S4(write);
4520     src1   : S3(read);
4521     src2   : S3(read);
4522     src3   : S3(read);
4523     DECODE : S1(3);     // any 3 decoders
4524     D0     : S0;        // Big decoder only
4525     FPU    : S3(2);
4526     MEM    : S3;
4527 %}
4528 
4529 // Float reg-mem operation
4530 pipe_class fpu_reg_mem(regD dst, memory mem)
4531 %{
4532     instruction_count(2);
4533     dst    : S5(write);
4534     mem    : S3(read);
4535     D0     : S0;        // big decoder only
4536     DECODE : S1;        // any decoder for FPU POP
4537     FPU    : S4;
4538     MEM    : S3;        // any mem
4539 %}
4540 
4541 // Float reg-mem operation
4542 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
4543 %{
4544     instruction_count(3);
4545     dst    : S5(write);
4546     src1   : S3(read);
4547     mem    : S3(read);
4548     D0     : S0;        // big decoder only
4549     DECODE : S1(2);     // any decoder for FPU POP
4550     FPU    : S4;
4551     MEM    : S3;        // any mem
4552 %}
4553 
4554 // Float mem-reg operation
4555 pipe_class fpu_mem_reg(memory mem, regD src)
4556 %{
4557     instruction_count(2);
4558     src    : S5(read);
4559     mem    : S3(read);
4560     DECODE : S0;        // any decoder for FPU PUSH
4561     D0     : S1;        // big decoder only
4562     FPU    : S4;
4563     MEM    : S3;        // any mem
4564 %}
4565 
4566 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
4567 %{
4568     instruction_count(3);
4569     src1   : S3(read);
4570     src2   : S3(read);
4571     mem    : S3(read);
4572     DECODE : S0(2);     // any decoder for FPU PUSH
4573     D0     : S1;        // big decoder only
4574     FPU    : S4;
4575     MEM    : S3;        // any mem
4576 %}
4577 
4578 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
4579 %{
4580     instruction_count(3);
4581     src1   : S3(read);
4582     src2   : S3(read);
4583     mem    : S4(read);
4584     DECODE : S0;        // any decoder for FPU PUSH
4585     D0     : S0(2);     // big decoder only
4586     FPU    : S4;
4587     MEM    : S3(2);     // any mem
4588 %}
4589 
4590 pipe_class fpu_mem_mem(memory dst, memory src1)
4591 %{
4592     instruction_count(2);
4593     src1   : S3(read);
4594     dst    : S4(read);
4595     D0     : S0(2);     // big decoder only
4596     MEM    : S3(2);     // any mem
4597 %}
4598 
4599 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
4600 %{
4601     instruction_count(3);
4602     src1   : S3(read);
4603     src2   : S3(read);
4604     dst    : S4(read);
4605     D0     : S0(3);     // big decoder only
4606     FPU    : S4;
4607     MEM    : S3(3);     // any mem
4608 %}
4609 
4610 pipe_class fpu_mem_reg_con(memory mem, regD src1)
4611 %{
4612     instruction_count(3);
4613     src1   : S4(read);
4614     mem    : S4(read);
4615     DECODE : S0;        // any decoder for FPU PUSH
4616     D0     : S0(2);     // big decoder only
4617     FPU    : S4;
4618     MEM    : S3(2);     // any mem
4619 %}
4620 
4621 // Float load constant
4622 pipe_class fpu_reg_con(regD dst)
4623 %{
4624     instruction_count(2);
4625     dst    : S5(write);
4626     D0     : S0;        // big decoder only for the load
4627     DECODE : S1;        // any decoder for FPU POP
4628     FPU    : S4;
4629     MEM    : S3;        // any mem
4630 %}
4631 
4632 // Float load constant
4633 pipe_class fpu_reg_reg_con(regD dst, regD src)
4634 %{
4635     instruction_count(3);
4636     dst    : S5(write);
4637     src    : S3(read);
4638     D0     : S0;        // big decoder only for the load
4639     DECODE : S1(2);     // any decoder for FPU POP
4640     FPU    : S4;
4641     MEM    : S3;        // any mem
4642 %}
4643 
4644 // UnConditional branch
4645 pipe_class pipe_jmp(label labl)
4646 %{
4647     single_instruction;
4648     BR   : S3;
4649 %}
4650 
4651 // Conditional branch
4652 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
4653 %{
4654     single_instruction;
4655     cr    : S1(read);
4656     BR    : S3;
4657 %}
4658 
4659 // Allocation idiom
4660 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
4661 %{
4662     instruction_count(1); force_serialization;
4663     fixed_latency(6);
4664     heap_ptr : S3(read);
4665     DECODE   : S0(3);
4666     D0       : S2;
4667     MEM      : S3;
4668     ALU      : S3(2);
4669     dst      : S5(write);
4670     BR       : S5;
4671 %}
4672 
4673 // Generic big/slow expanded idiom
4674 pipe_class pipe_slow()
4675 %{
4676     instruction_count(10); multiple_bundles; force_serialization;
4677     fixed_latency(100);
4678     D0  : S0(2);
4679     MEM : S3(2);
4680 %}
4681 
4682 // The real do-nothing guy
4683 pipe_class empty()
4684 %{
4685     instruction_count(0);
4686 %}
4687 
4688 // Define the class for the Nop node
4689 define
4690 %{
4691    MachNop = empty;
4692 %}
4693 
4694 %}
4695 
4696 //----------INSTRUCTIONS-------------------------------------------------------
4697 //
4698 // match      -- States which machine-independent subtree may be replaced
4699 //               by this instruction.
4700 // ins_cost   -- The estimated cost of this instruction is used by instruction
4701 //               selection to identify a minimum cost tree of machine
4702 //               instructions that matches a tree of machine-independent
4703 //               instructions.
4704 // format     -- A string providing the disassembly for this instruction.
4705 //               The value of an instruction's operand may be inserted
4706 //               by referring to it with a '$' prefix.
4707 // opcode     -- Three instruction opcodes may be provided.  These are referred
4708 //               to within an encode class as $primary, $secondary, and $tertiary
4709 //               rrspectively.  The primary opcode is commonly used to
4710 //               indicate the type of machine instruction, while secondary
4711 //               and tertiary are often used for prefix options or addressing
4712 //               modes.
4713 // ins_encode -- A list of encode classes with parameters. The encode class
4714 //               name must have been defined in an 'enc_class' specification
4715 //               in the encode section of the architecture description.
4716 
4717 
4718 //----------Load/Store/Move Instructions---------------------------------------
4719 //----------Load Instructions--------------------------------------------------
4720 
4721 // Load Byte (8 bit signed)
4722 instruct loadB(rRegI dst, memory mem)
4723 %{
4724   match(Set dst (LoadB mem));
4725 
4726   ins_cost(125);
4727   format %{ "movsbl  $dst, $mem\t# byte" %}
4728 
4729   ins_encode %{
4730     __ movsbl($dst$$Register, $mem$$Address);
4731   %}
4732 
4733   ins_pipe(ialu_reg_mem);
4734 %}
4735 
4736 // Load Byte (8 bit signed) into Long Register
4737 instruct loadB2L(rRegL dst, memory mem)
4738 %{
4739   match(Set dst (ConvI2L (LoadB mem)));
4740 
4741   ins_cost(125);
4742   format %{ "movsbq  $dst, $mem\t# byte -&gt; long" %}
4743 
4744   ins_encode %{
4745     __ movsbq($dst$$Register, $mem$$Address);
4746   %}
4747 
4748   ins_pipe(ialu_reg_mem);
4749 %}
4750 
4751 // Load Unsigned Byte (8 bit UNsigned)
4752 instruct loadUB(rRegI dst, memory mem)
4753 %{
4754   match(Set dst (LoadUB mem));
4755 
4756   ins_cost(125);
4757   format %{ "movzbl  $dst, $mem\t# ubyte" %}
4758 
4759   ins_encode %{
4760     __ movzbl($dst$$Register, $mem$$Address);
4761   %}
4762 
4763   ins_pipe(ialu_reg_mem);
4764 %}
4765 
4766 // Load Unsigned Byte (8 bit UNsigned) into Long Register
4767 instruct loadUB2L(rRegL dst, memory mem)
4768 %{
4769   match(Set dst (ConvI2L (LoadUB mem)));
4770 
4771   ins_cost(125);
4772   format %{ "movzbq  $dst, $mem\t# ubyte -&gt; long" %}
4773 
4774   ins_encode %{
4775     __ movzbq($dst$$Register, $mem$$Address);
4776   %}
4777 
4778   ins_pipe(ialu_reg_mem);
4779 %}
4780 
4781 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
4782 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4783   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
4784   effect(KILL cr);
4785 
4786   format %{ "movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t"
4787             "andl    $dst, right_n_bits($mask, 8)" %}
4788   ins_encode %{
4789     Register Rdst = $dst$$Register;
4790     __ movzbq(Rdst, $mem$$Address);
4791     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
4792   %}
4793   ins_pipe(ialu_reg_mem);
4794 %}
4795 
4796 // Load Short (16 bit signed)
4797 instruct loadS(rRegI dst, memory mem)
4798 %{
4799   match(Set dst (LoadS mem));
4800 
4801   ins_cost(125);
4802   format %{ "movswl $dst, $mem\t# short" %}
4803 
4804   ins_encode %{
4805     __ movswl($dst$$Register, $mem$$Address);
4806   %}
4807 
4808   ins_pipe(ialu_reg_mem);
4809 %}
4810 
4811 // Load Short (16 bit signed) to Byte (8 bit signed)
4812 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4813   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
4814 
4815   ins_cost(125);
4816   format %{ "movsbl $dst, $mem\t# short -&gt; byte" %}
4817   ins_encode %{
4818     __ movsbl($dst$$Register, $mem$$Address);
4819   %}
4820   ins_pipe(ialu_reg_mem);
4821 %}
4822 
4823 // Load Short (16 bit signed) into Long Register
4824 instruct loadS2L(rRegL dst, memory mem)
4825 %{
4826   match(Set dst (ConvI2L (LoadS mem)));
4827 
4828   ins_cost(125);
4829   format %{ "movswq $dst, $mem\t# short -&gt; long" %}
4830 
4831   ins_encode %{
4832     __ movswq($dst$$Register, $mem$$Address);
4833   %}
4834 
4835   ins_pipe(ialu_reg_mem);
4836 %}
4837 
4838 // Load Unsigned Short/Char (16 bit UNsigned)
4839 instruct loadUS(rRegI dst, memory mem)
4840 %{
4841   match(Set dst (LoadUS mem));
4842 
4843   ins_cost(125);
4844   format %{ "movzwl  $dst, $mem\t# ushort/char" %}
4845 
4846   ins_encode %{
4847     __ movzwl($dst$$Register, $mem$$Address);
4848   %}
4849 
4850   ins_pipe(ialu_reg_mem);
4851 %}
4852 
4853 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
4854 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4855   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
4856 
4857   ins_cost(125);
4858   format %{ "movsbl $dst, $mem\t# ushort -&gt; byte" %}
4859   ins_encode %{
4860     __ movsbl($dst$$Register, $mem$$Address);
4861   %}
4862   ins_pipe(ialu_reg_mem);
4863 %}
4864 
4865 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
4866 instruct loadUS2L(rRegL dst, memory mem)
4867 %{
4868   match(Set dst (ConvI2L (LoadUS mem)));
4869 
4870   ins_cost(125);
4871   format %{ "movzwq  $dst, $mem\t# ushort/char -&gt; long" %}
4872 
4873   ins_encode %{
4874     __ movzwq($dst$$Register, $mem$$Address);
4875   %}
4876 
4877   ins_pipe(ialu_reg_mem);
4878 %}
4879 
4880 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
4881 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4882   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4883 
4884   format %{ "movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long" %}
4885   ins_encode %{
4886     __ movzbq($dst$$Register, $mem$$Address);
4887   %}
4888   ins_pipe(ialu_reg_mem);
4889 %}
4890 
4891 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
4892 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4893   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4894   effect(KILL cr);
4895 
4896   format %{ "movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t"
4897             "andl    $dst, right_n_bits($mask, 16)" %}
4898   ins_encode %{
4899     Register Rdst = $dst$$Register;
4900     __ movzwq(Rdst, $mem$$Address);
4901     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
4902   %}
4903   ins_pipe(ialu_reg_mem);
4904 %}
4905 
4906 // Load Integer
4907 instruct loadI(rRegI dst, memory mem)
4908 %{
4909   match(Set dst (LoadI mem));
4910 
4911   ins_cost(125);
4912   format %{ "movl    $dst, $mem\t# int" %}
4913 
4914   ins_encode %{
4915     __ movl($dst$$Register, $mem$$Address);
4916   %}
4917 
4918   ins_pipe(ialu_reg_mem);
4919 %}
4920 
4921 // Load Integer (32 bit signed) to Byte (8 bit signed)
4922 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4923   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
4924 
4925   ins_cost(125);
4926   format %{ "movsbl  $dst, $mem\t# int -&gt; byte" %}
4927   ins_encode %{
4928     __ movsbl($dst$$Register, $mem$$Address);
4929   %}
4930   ins_pipe(ialu_reg_mem);
4931 %}
4932 
4933 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
4934 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
4935   match(Set dst (AndI (LoadI mem) mask));
4936 
4937   ins_cost(125);
4938   format %{ "movzbl  $dst, $mem\t# int -&gt; ubyte" %}
4939   ins_encode %{
4940     __ movzbl($dst$$Register, $mem$$Address);
4941   %}
4942   ins_pipe(ialu_reg_mem);
4943 %}
4944 
4945 // Load Integer (32 bit signed) to Short (16 bit signed)
4946 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
4947   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
4948 
4949   ins_cost(125);
4950   format %{ "movswl  $dst, $mem\t# int -&gt; short" %}
4951   ins_encode %{
4952     __ movswl($dst$$Register, $mem$$Address);
4953   %}
4954   ins_pipe(ialu_reg_mem);
4955 %}
4956 
4957 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
4958 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
4959   match(Set dst (AndI (LoadI mem) mask));
4960 
4961   ins_cost(125);
4962   format %{ "movzwl  $dst, $mem\t# int -&gt; ushort/char" %}
4963   ins_encode %{
4964     __ movzwl($dst$$Register, $mem$$Address);
4965   %}
4966   ins_pipe(ialu_reg_mem);
4967 %}
4968 
4969 // Load Integer into Long Register
4970 instruct loadI2L(rRegL dst, memory mem)
4971 %{
4972   match(Set dst (ConvI2L (LoadI mem)));
4973 
4974   ins_cost(125);
4975   format %{ "movslq  $dst, $mem\t# int -&gt; long" %}
4976 
4977   ins_encode %{
4978     __ movslq($dst$$Register, $mem$$Address);
4979   %}
4980 
4981   ins_pipe(ialu_reg_mem);
4982 %}
4983 
4984 // Load Integer with mask 0xFF into Long Register
4985 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4986   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4987 
4988   format %{ "movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long" %}
4989   ins_encode %{
4990     __ movzbq($dst$$Register, $mem$$Address);
4991   %}
4992   ins_pipe(ialu_reg_mem);
4993 %}
4994 
4995 // Load Integer with mask 0xFFFF into Long Register
4996 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
4997   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4998 
4999   format %{ "movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long" %}
5000   ins_encode %{
5001     __ movzwq($dst$$Register, $mem$$Address);
5002   %}
5003   ins_pipe(ialu_reg_mem);
5004 %}
5005 
5006 // Load Integer with a 31-bit mask into Long Register
5007 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
5008   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
5009   effect(KILL cr);
5010 
5011   format %{ "movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t"
5012             "andl    $dst, $mask" %}
5013   ins_encode %{
5014     Register Rdst = $dst$$Register;
5015     __ movl(Rdst, $mem$$Address);
5016     __ andl(Rdst, $mask$$constant);
5017   %}
5018   ins_pipe(ialu_reg_mem);
5019 %}
5020 
5021 // Load Unsigned Integer into Long Register
5022 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
5023 %{
5024   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
5025 
5026   ins_cost(125);
5027   format %{ "movl    $dst, $mem\t# uint -&gt; long" %}
5028 
5029   ins_encode %{
5030     __ movl($dst$$Register, $mem$$Address);
5031   %}
5032 
5033   ins_pipe(ialu_reg_mem);
5034 %}
5035 
5036 // Load Long
5037 instruct loadL(rRegL dst, memory mem)
5038 %{
5039   match(Set dst (LoadL mem));
5040 
5041   ins_cost(125);
5042   format %{ "movq    $dst, $mem\t# long" %}
5043 
5044   ins_encode %{
5045     __ movq($dst$$Register, $mem$$Address);
5046   %}
5047 
5048   ins_pipe(ialu_reg_mem); // XXX
5049 %}
5050 
5051 // Load Range
5052 instruct loadRange(rRegI dst, memory mem)
5053 %{
5054   match(Set dst (LoadRange mem));
5055 
5056   ins_cost(125); // XXX
5057   format %{ "movl    $dst, $mem\t# range" %}
5058   opcode(0x8B);
5059   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
5060   ins_pipe(ialu_reg_mem);
5061 %}
5062 
5063 // Load Pointer
5064 instruct loadP(rRegP dst, memory mem)
5065 %{
5066   match(Set dst (LoadP mem));
5067 
5068   ins_cost(125); // XXX
5069   format %{ "movq    $dst, $mem\t# ptr" %}
5070   opcode(0x8B);
5071   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5072   ins_pipe(ialu_reg_mem); // XXX
5073 %}
5074 
5075 // Load Compressed Pointer
5076 instruct loadN(rRegN dst, memory mem)
5077 %{
5078    match(Set dst (LoadN mem));
5079 
5080    ins_cost(125); // XXX
5081    format %{ "movl    $dst, $mem\t# compressed ptr" %}
5082    ins_encode %{
5083      __ movl($dst$$Register, $mem$$Address);
5084    %}
5085    ins_pipe(ialu_reg_mem); // XXX
5086 %}
5087 
5088 
5089 // Load Klass Pointer
5090 instruct loadKlass(rRegP dst, memory mem)
5091 %{
5092   match(Set dst (LoadKlass mem));
5093 
5094   ins_cost(125); // XXX
5095   format %{ "movq    $dst, $mem\t# class" %}
5096   opcode(0x8B);
5097   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5098   ins_pipe(ialu_reg_mem); // XXX
5099 %}
5100 
5101 // Load narrow Klass Pointer
5102 instruct loadNKlass(rRegN dst, memory mem)
5103 %{
5104   match(Set dst (LoadNKlass mem));
5105 
5106   ins_cost(125); // XXX
5107   format %{ "movl    $dst, $mem\t# compressed klass ptr" %}
5108   ins_encode %{
5109     __ movl($dst$$Register, $mem$$Address);
5110   %}
5111   ins_pipe(ialu_reg_mem); // XXX
5112 %}
5113 
5114 // Load Float
5115 instruct loadF(regF dst, memory mem)
5116 %{
5117   match(Set dst (LoadF mem));
5118 
5119   ins_cost(145); // XXX
5120   format %{ "movss   $dst, $mem\t# float" %}
5121   ins_encode %{
5122     __ movflt($dst$$XMMRegister, $mem$$Address);
5123   %}
5124   ins_pipe(pipe_slow); // XXX
5125 %}
5126 
5127 // Load Double
5128 instruct loadD_partial(regD dst, memory mem)
5129 %{
5130   predicate(!UseXmmLoadAndClearUpper);
5131   match(Set dst (LoadD mem));
5132 
5133   ins_cost(145); // XXX
5134   format %{ "movlpd  $dst, $mem\t# double" %}
5135   ins_encode %{
5136     __ movdbl($dst$$XMMRegister, $mem$$Address);
5137   %}
5138   ins_pipe(pipe_slow); // XXX
5139 %}
5140 
5141 instruct loadD(regD dst, memory mem)
5142 %{
5143   predicate(UseXmmLoadAndClearUpper);
5144   match(Set dst (LoadD mem));
5145 
5146   ins_cost(145); // XXX
5147   format %{ "movsd   $dst, $mem\t# double" %}
5148   ins_encode %{
5149     __ movdbl($dst$$XMMRegister, $mem$$Address);
5150   %}
5151   ins_pipe(pipe_slow); // XXX
5152 %}
5153 
5154 // Load Effective Address
5155 instruct leaP8(rRegP dst, indOffset8 mem)
5156 %{
5157   match(Set dst mem);
5158 
5159   ins_cost(110); // XXX
5160   format %{ "leaq    $dst, $mem\t# ptr 8" %}
5161   opcode(0x8D);
5162   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5163   ins_pipe(ialu_reg_reg_fat);
5164 %}
5165 
5166 instruct leaP32(rRegP dst, indOffset32 mem)
5167 %{
5168   match(Set dst mem);
5169 
5170   ins_cost(110);
5171   format %{ "leaq    $dst, $mem\t# ptr 32" %}
5172   opcode(0x8D);
5173   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5174   ins_pipe(ialu_reg_reg_fat);
5175 %}
5176 
5177 // instruct leaPIdx(rRegP dst, indIndex mem)
5178 // %{
5179 //   match(Set dst mem);
5180 
5181 //   ins_cost(110);
5182 //   format %{ "leaq    $dst, $mem\t# ptr idx" %}
5183 //   opcode(0x8D);
5184 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5185 //   ins_pipe(ialu_reg_reg_fat);
5186 // %}
5187 
5188 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
5189 %{
5190   match(Set dst mem);
5191 
5192   ins_cost(110);
5193   format %{ "leaq    $dst, $mem\t# ptr idxoff" %}
5194   opcode(0x8D);
5195   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5196   ins_pipe(ialu_reg_reg_fat);
5197 %}
5198 
5199 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
5200 %{
5201   match(Set dst mem);
5202 
5203   ins_cost(110);
5204   format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
5205   opcode(0x8D);
5206   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5207   ins_pipe(ialu_reg_reg_fat);
5208 %}
5209 
5210 instruct leaPPosIdxScale(rRegP dst, indPosIndexScale mem)
5211 %{
5212   match(Set dst mem);
5213 
5214   ins_cost(110);
5215   format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
5216   opcode(0x8D);
5217   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5218   ins_pipe(ialu_reg_reg_fat);
5219 %}
5220 
5221 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
5222 %{
5223   match(Set dst mem);
5224 
5225   ins_cost(110);
5226   format %{ "leaq    $dst, $mem\t# ptr idxscaleoff" %}
5227   opcode(0x8D);
5228   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5229   ins_pipe(ialu_reg_reg_fat);
5230 %}
5231 
5232 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
5233 %{
5234   match(Set dst mem);
5235 
5236   ins_cost(110);
5237   format %{ "leaq    $dst, $mem\t# ptr posidxoff" %}
5238   opcode(0x8D);
5239   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5240   ins_pipe(ialu_reg_reg_fat);
5241 %}
5242 
5243 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
5244 %{
5245   match(Set dst mem);
5246 
5247   ins_cost(110);
5248   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoff" %}
5249   opcode(0x8D);
5250   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5251   ins_pipe(ialu_reg_reg_fat);
5252 %}
5253 
5254 // Load Effective Address which uses Narrow (32-bits) oop
5255 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
5256 %{
5257   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));
5258   match(Set dst mem);
5259 
5260   ins_cost(110);
5261   format %{ "leaq    $dst, $mem\t# ptr compressedoopoff32" %}
5262   opcode(0x8D);
5263   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5264   ins_pipe(ialu_reg_reg_fat);
5265 %}
5266 
5267 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
5268 %{
5269   predicate(Universe::narrow_oop_shift() == 0);
5270   match(Set dst mem);
5271 
5272   ins_cost(110); // XXX
5273   format %{ "leaq    $dst, $mem\t# ptr off8narrow" %}
5274   opcode(0x8D);
5275   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5276   ins_pipe(ialu_reg_reg_fat);
5277 %}
5278 
5279 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
5280 %{
5281   predicate(Universe::narrow_oop_shift() == 0);
5282   match(Set dst mem);
5283 
5284   ins_cost(110);
5285   format %{ "leaq    $dst, $mem\t# ptr off32narrow" %}
5286   opcode(0x8D);
5287   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5288   ins_pipe(ialu_reg_reg_fat);
5289 %}
5290 
5291 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
5292 %{
5293   predicate(Universe::narrow_oop_shift() == 0);
5294   match(Set dst mem);
5295 
5296   ins_cost(110);
5297   format %{ "leaq    $dst, $mem\t# ptr idxoffnarrow" %}
5298   opcode(0x8D);
5299   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5300   ins_pipe(ialu_reg_reg_fat);
5301 %}
5302 
5303 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
5304 %{
5305   predicate(Universe::narrow_oop_shift() == 0);
5306   match(Set dst mem);
5307 
5308   ins_cost(110);
5309   format %{ "leaq    $dst, $mem\t# ptr idxscalenarrow" %}
5310   opcode(0x8D);
5311   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5312   ins_pipe(ialu_reg_reg_fat);
5313 %}
5314 
5315 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
5316 %{
5317   predicate(Universe::narrow_oop_shift() == 0);
5318   match(Set dst mem);
5319 
5320   ins_cost(110);
5321   format %{ "leaq    $dst, $mem\t# ptr idxscaleoffnarrow" %}
5322   opcode(0x8D);
5323   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5324   ins_pipe(ialu_reg_reg_fat);
5325 %}
5326 
5327 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
5328 %{
5329   predicate(Universe::narrow_oop_shift() == 0);
5330   match(Set dst mem);
5331 
5332   ins_cost(110);
5333   format %{ "leaq    $dst, $mem\t# ptr posidxoffnarrow" %}
5334   opcode(0x8D);
5335   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5336   ins_pipe(ialu_reg_reg_fat);
5337 %}
5338 
5339 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
5340 %{
5341   predicate(Universe::narrow_oop_shift() == 0);
5342   match(Set dst mem);
5343 
5344   ins_cost(110);
5345   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoffnarrow" %}
5346   opcode(0x8D);
5347   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5348   ins_pipe(ialu_reg_reg_fat);
5349 %}
5350 
5351 instruct loadConI(rRegI dst, immI src)
5352 %{
5353   match(Set dst src);
5354 
5355   format %{ "movl    $dst, $src\t# int" %}
5356   ins_encode(load_immI(dst, src));
5357   ins_pipe(ialu_reg_fat); // XXX
5358 %}
5359 
5360 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
5361 %{
5362   match(Set dst src);
5363   effect(KILL cr);
5364 
5365   ins_cost(50);
5366   format %{ "xorl    $dst, $dst\t# int" %}
5367   opcode(0x33); /* + rd */
5368   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5369   ins_pipe(ialu_reg);
5370 %}
5371 
5372 instruct loadConL(rRegL dst, immL src)
5373 %{
5374   match(Set dst src);
5375 
5376   ins_cost(150);
5377   format %{ "movq    $dst, $src\t# long" %}
5378   ins_encode(load_immL(dst, src));
5379   ins_pipe(ialu_reg);
5380 %}
5381 
5382 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
5383 %{
5384   match(Set dst src);
5385   effect(KILL cr);
5386 
5387   ins_cost(50);
5388   format %{ "xorl    $dst, $dst\t# long" %}
5389   opcode(0x33); /* + rd */
5390   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5391   ins_pipe(ialu_reg); // XXX
5392 %}
5393 
5394 instruct loadConUL32(rRegL dst, immUL32 src)
5395 %{
5396   match(Set dst src);
5397 
5398   ins_cost(60);
5399   format %{ "movl    $dst, $src\t# long (unsigned 32-bit)" %}
5400   ins_encode(load_immUL32(dst, src));
5401   ins_pipe(ialu_reg);
5402 %}
5403 
5404 instruct loadConL32(rRegL dst, immL32 src)
5405 %{
5406   match(Set dst src);
5407 
5408   ins_cost(70);
5409   format %{ "movq    $dst, $src\t# long (32-bit)" %}
5410   ins_encode(load_immL32(dst, src));
5411   ins_pipe(ialu_reg);
5412 %}
5413 
5414 instruct loadConP(rRegP dst, immP con) %{
5415   match(Set dst con);
5416 
5417   format %{ "movq    $dst, $con\t# ptr" %}
5418   ins_encode(load_immP(dst, con));
5419   ins_pipe(ialu_reg_fat); // XXX
5420 %}
5421 
5422 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
5423 %{
5424   match(Set dst src);
5425   effect(KILL cr);
5426 
5427   ins_cost(50);
5428   format %{ "xorl    $dst, $dst\t# ptr" %}
5429   opcode(0x33); /* + rd */
5430   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5431   ins_pipe(ialu_reg);
5432 %}
5433 
5434 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
5435 %{
5436   match(Set dst src);
5437   effect(KILL cr);
5438 
5439   ins_cost(60);
5440   format %{ "movl    $dst, $src\t# ptr (positive 32-bit)" %}
5441   ins_encode(load_immP31(dst, src));
5442   ins_pipe(ialu_reg);
5443 %}
5444 
5445 instruct loadConF(regF dst, immF con) %{
5446   match(Set dst con);
5447   ins_cost(125);
5448   format %{ "movss   $dst, [$constantaddress]\t# load from constant table: float=$con" %}
5449   ins_encode %{
5450     __ movflt($dst$$XMMRegister, $constantaddress($con));
5451   %}
5452   ins_pipe(pipe_slow);
5453 %}
5454 
5455 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
5456   match(Set dst src);
5457   effect(KILL cr);
5458   format %{ "xorq    $dst, $src\t# compressed NULL ptr" %}
5459   ins_encode %{
5460     __ xorq($dst$$Register, $dst$$Register);
5461   %}
5462   ins_pipe(ialu_reg);
5463 %}
5464 
5465 instruct loadConN(rRegN dst, immN src) %{
5466   match(Set dst src);
5467 
5468   ins_cost(125);
5469   format %{ "movl    $dst, $src\t# compressed ptr" %}
5470   ins_encode %{
5471     address con = (address)$src$$constant;
5472     if (con == NULL) {
5473       ShouldNotReachHere();
5474     } else {
5475       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
5476     }
5477   %}
5478   ins_pipe(ialu_reg_fat); // XXX
5479 %}
5480 
5481 instruct loadConNKlass(rRegN dst, immNKlass src) %{
5482   match(Set dst src);
5483 
5484   ins_cost(125);
5485   format %{ "movl    $dst, $src\t# compressed klass ptr" %}
5486   ins_encode %{
5487     address con = (address)$src$$constant;
5488     if (con == NULL) {
5489       ShouldNotReachHere();
5490     } else {
5491       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
5492     }
5493   %}
5494   ins_pipe(ialu_reg_fat); // XXX
5495 %}
5496 
5497 instruct loadConF0(regF dst, immF0 src)
5498 %{
5499   match(Set dst src);
5500   ins_cost(100);
5501 
5502   format %{ "xorps   $dst, $dst\t# float 0.0" %}
5503   ins_encode %{
5504     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
5505   %}
5506   ins_pipe(pipe_slow);
5507 %}
5508 
5509 // Use the same format since predicate() can not be used here.
5510 instruct loadConD(regD dst, immD con) %{
5511   match(Set dst con);
5512   ins_cost(125);
5513   format %{ "movsd   $dst, [$constantaddress]\t# load from constant table: double=$con" %}
5514   ins_encode %{
5515     __ movdbl($dst$$XMMRegister, $constantaddress($con));
5516   %}
5517   ins_pipe(pipe_slow);
5518 %}
5519 
5520 instruct loadConD0(regD dst, immD0 src)
5521 %{
5522   match(Set dst src);
5523   ins_cost(100);
5524 
5525   format %{ "xorpd   $dst, $dst\t# double 0.0" %}
5526   ins_encode %{
5527     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
5528   %}
5529   ins_pipe(pipe_slow);
5530 %}
5531 
5532 instruct loadSSI(rRegI dst, stackSlotI src)
5533 %{
5534   match(Set dst src);
5535 
5536   ins_cost(125);
5537   format %{ "movl    $dst, $src\t# int stk" %}
5538   opcode(0x8B);
5539   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
5540   ins_pipe(ialu_reg_mem);
5541 %}
5542 
5543 instruct loadSSL(rRegL dst, stackSlotL src)
5544 %{
5545   match(Set dst src);
5546 
5547   ins_cost(125);
5548   format %{ "movq    $dst, $src\t# long stk" %}
5549   opcode(0x8B);
5550   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5551   ins_pipe(ialu_reg_mem);
5552 %}
5553 
5554 instruct loadSSP(rRegP dst, stackSlotP src)
5555 %{
5556   match(Set dst src);
5557 
5558   ins_cost(125);
5559   format %{ "movq    $dst, $src\t# ptr stk" %}
5560   opcode(0x8B);
5561   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5562   ins_pipe(ialu_reg_mem);
5563 %}
5564 
5565 instruct loadSSF(regF dst, stackSlotF src)
5566 %{
5567   match(Set dst src);
5568 
5569   ins_cost(125);
5570   format %{ "movss   $dst, $src\t# float stk" %}
5571   ins_encode %{
5572     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
5573   %}
5574   ins_pipe(pipe_slow); // XXX
5575 %}
5576 
5577 // Use the same format since predicate() can not be used here.
5578 instruct loadSSD(regD dst, stackSlotD src)
5579 %{
5580   match(Set dst src);
5581 
5582   ins_cost(125);
5583   format %{ "movsd   $dst, $src\t# double stk" %}
5584   ins_encode  %{
5585     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
5586   %}
5587   ins_pipe(pipe_slow); // XXX
5588 %}
5589 
5590 // Prefetch instructions for allocation.
5591 // Must be safe to execute with invalid address (cannot fault).
5592 
5593 instruct prefetchAlloc( memory mem ) %{
5594   predicate(AllocatePrefetchInstr==3);
5595   match(PrefetchAllocation mem);
5596   ins_cost(125);
5597 
5598   format %{ "PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified" %}
5599   ins_encode %{
5600     __ prefetchw($mem$$Address);
5601   %}
5602   ins_pipe(ialu_mem);
5603 %}
5604 
5605 instruct prefetchAllocNTA( memory mem ) %{
5606   predicate(AllocatePrefetchInstr==0);
5607   match(PrefetchAllocation mem);
5608   ins_cost(125);
5609 
5610   format %{ "PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write" %}
5611   ins_encode %{
5612     __ prefetchnta($mem$$Address);
5613   %}
5614   ins_pipe(ialu_mem);
5615 %}
5616 
5617 instruct prefetchAllocT0( memory mem ) %{
5618   predicate(AllocatePrefetchInstr==1);
5619   match(PrefetchAllocation mem);
5620   ins_cost(125);
5621 
5622   format %{ "PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write" %}
5623   ins_encode %{
5624     __ prefetcht0($mem$$Address);
5625   %}
5626   ins_pipe(ialu_mem);
5627 %}
5628 
5629 instruct prefetchAllocT2( memory mem ) %{
5630   predicate(AllocatePrefetchInstr==2);
5631   match(PrefetchAllocation mem);
5632   ins_cost(125);
5633 
5634   format %{ "PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write" %}
5635   ins_encode %{
5636     __ prefetcht2($mem$$Address);
5637   %}
5638   ins_pipe(ialu_mem);
5639 %}
5640 
5641 //----------Store Instructions-------------------------------------------------
5642 
5643 // Store Byte
5644 instruct storeB(memory mem, rRegI src)
5645 %{
5646   match(Set mem (StoreB mem src));
5647 
5648   ins_cost(125); // XXX
5649   format %{ "movb    $mem, $src\t# byte" %}
5650   opcode(0x88);
5651   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
5652   ins_pipe(ialu_mem_reg);
5653 %}
5654 
5655 // Store Char/Short
5656 instruct storeC(memory mem, rRegI src)
5657 %{
5658   match(Set mem (StoreC mem src));
5659 
5660   ins_cost(125); // XXX
5661   format %{ "movw    $mem, $src\t# char/short" %}
5662   opcode(0x89);
5663   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5664   ins_pipe(ialu_mem_reg);
5665 %}
5666 
5667 // Store Integer
5668 instruct storeI(memory mem, rRegI src)
5669 %{
5670   match(Set mem (StoreI mem src));
5671 
5672   ins_cost(125); // XXX
5673   format %{ "movl    $mem, $src\t# int" %}
5674   opcode(0x89);
5675   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5676   ins_pipe(ialu_mem_reg);
5677 %}
5678 
5679 // Store Long
5680 instruct storeL(memory mem, rRegL src)
5681 %{
5682   match(Set mem (StoreL mem src));
5683 
5684   ins_cost(125); // XXX
5685   format %{ "movq    $mem, $src\t# long" %}
5686   opcode(0x89);
5687   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5688   ins_pipe(ialu_mem_reg); // XXX
5689 %}
5690 
5691 // Store Pointer
5692 instruct storeP(memory mem, any_RegP src)
5693 %{
5694   match(Set mem (StoreP mem src));
5695 
5696   ins_cost(125); // XXX
5697   format %{ "movq    $mem, $src\t# ptr" %}
5698   opcode(0x89);
5699   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5700   ins_pipe(ialu_mem_reg);
5701 %}
5702 
5703 instruct storeImmP0(memory mem, immP0 zero)
5704 %{
5705   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5706   match(Set mem (StoreP mem zero));
5707 
5708   ins_cost(125); // XXX
5709   format %{ "movq    $mem, R12\t# ptr (R12_heapbase==0)" %}
5710   ins_encode %{
5711     __ movq($mem$$Address, r12);
5712   %}
5713   ins_pipe(ialu_mem_reg);
5714 %}
5715 
5716 // Store NULL Pointer, mark word, or other simple pointer constant.
5717 instruct storeImmP(memory mem, immP31 src)
5718 %{
5719   match(Set mem (StoreP mem src));
5720 
5721   ins_cost(150); // XXX
5722   format %{ "movq    $mem, $src\t# ptr" %}
5723   opcode(0xC7); /* C7 /0 */
5724   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5725   ins_pipe(ialu_mem_imm);
5726 %}
5727 
5728 // Store Compressed Pointer
5729 instruct storeN(memory mem, rRegN src)
5730 %{
5731   match(Set mem (StoreN mem src));
5732 
5733   ins_cost(125); // XXX
5734   format %{ "movl    $mem, $src\t# compressed ptr" %}
5735   ins_encode %{
5736     __ movl($mem$$Address, $src$$Register);
5737   %}
5738   ins_pipe(ialu_mem_reg);
5739 %}
5740 
5741 instruct storeNKlass(memory mem, rRegN src)
5742 %{
5743   match(Set mem (StoreNKlass mem src));
5744 
5745   ins_cost(125); // XXX
5746   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5747   ins_encode %{
5748     __ movl($mem$$Address, $src$$Register);
5749   %}
5750   ins_pipe(ialu_mem_reg);
5751 %}
5752 
5753 instruct storeImmN0(memory mem, immN0 zero)
5754 %{
5755   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);
5756   match(Set mem (StoreN mem zero));
5757 
5758   ins_cost(125); // XXX
5759   format %{ "movl    $mem, R12\t# compressed ptr (R12_heapbase==0)" %}
5760   ins_encode %{
5761     __ movl($mem$$Address, r12);
5762   %}
5763   ins_pipe(ialu_mem_reg);
5764 %}
5765 
5766 instruct storeImmN(memory mem, immN src)
5767 %{
5768   match(Set mem (StoreN mem src));
5769 
5770   ins_cost(150); // XXX
5771   format %{ "movl    $mem, $src\t# compressed ptr" %}
5772   ins_encode %{
5773     address con = (address)$src$$constant;
5774     if (con == NULL) {
5775       __ movl($mem$$Address, (int32_t)0);
5776     } else {
5777       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
5778     }
5779   %}
5780   ins_pipe(ialu_mem_imm);
5781 %}
5782 
5783 instruct storeImmNKlass(memory mem, immNKlass src)
5784 %{
5785   match(Set mem (StoreNKlass mem src));
5786 
5787   ins_cost(150); // XXX
5788   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5789   ins_encode %{
5790     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
5791   %}
5792   ins_pipe(ialu_mem_imm);
5793 %}
5794 
5795 // Store Integer Immediate
5796 instruct storeImmI0(memory mem, immI0 zero)
5797 %{
5798   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5799   match(Set mem (StoreI mem zero));
5800 
5801   ins_cost(125); // XXX
5802   format %{ "movl    $mem, R12\t# int (R12_heapbase==0)" %}
5803   ins_encode %{
5804     __ movl($mem$$Address, r12);
5805   %}
5806   ins_pipe(ialu_mem_reg);
5807 %}
5808 
5809 instruct storeImmI(memory mem, immI src)
5810 %{
5811   match(Set mem (StoreI mem src));
5812 
5813   ins_cost(150);
5814   format %{ "movl    $mem, $src\t# int" %}
5815   opcode(0xC7); /* C7 /0 */
5816   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5817   ins_pipe(ialu_mem_imm);
5818 %}
5819 
5820 // Store Long Immediate
5821 instruct storeImmL0(memory mem, immL0 zero)
5822 %{
5823   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5824   match(Set mem (StoreL mem zero));
5825 
5826   ins_cost(125); // XXX
5827   format %{ "movq    $mem, R12\t# long (R12_heapbase==0)" %}
5828   ins_encode %{
5829     __ movq($mem$$Address, r12);
5830   %}
5831   ins_pipe(ialu_mem_reg);
5832 %}
5833 
5834 instruct storeImmL(memory mem, immL32 src)
5835 %{
5836   match(Set mem (StoreL mem src));
5837 
5838   ins_cost(150);
5839   format %{ "movq    $mem, $src\t# long" %}
5840   opcode(0xC7); /* C7 /0 */
5841   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5842   ins_pipe(ialu_mem_imm);
5843 %}
5844 
5845 // Store Short/Char Immediate
5846 instruct storeImmC0(memory mem, immI0 zero)
5847 %{
5848   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5849   match(Set mem (StoreC mem zero));
5850 
5851   ins_cost(125); // XXX
5852   format %{ "movw    $mem, R12\t# short/char (R12_heapbase==0)" %}
5853   ins_encode %{
5854     __ movw($mem$$Address, r12);
5855   %}
5856   ins_pipe(ialu_mem_reg);
5857 %}
5858 
5859 instruct storeImmI16(memory mem, immI16 src)
5860 %{
5861   predicate(UseStoreImmI16);
5862   match(Set mem (StoreC mem src));
5863 
5864   ins_cost(150);
5865   format %{ "movw    $mem, $src\t# short/char" %}
5866   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
5867   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
5868   ins_pipe(ialu_mem_imm);
5869 %}
5870 
5871 // Store Byte Immediate
5872 instruct storeImmB0(memory mem, immI0 zero)
5873 %{
5874   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5875   match(Set mem (StoreB mem zero));
5876 
5877   ins_cost(125); // XXX
5878   format %{ "movb    $mem, R12\t# short/char (R12_heapbase==0)" %}
5879   ins_encode %{
5880     __ movb($mem$$Address, r12);
5881   %}
5882   ins_pipe(ialu_mem_reg);
5883 %}
5884 
5885 instruct storeImmB(memory mem, immI8 src)
5886 %{
5887   match(Set mem (StoreB mem src));
5888 
5889   ins_cost(150); // XXX
5890   format %{ "movb    $mem, $src\t# byte" %}
5891   opcode(0xC6); /* C6 /0 */
5892   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5893   ins_pipe(ialu_mem_imm);
5894 %}
5895 
5896 // Store CMS card-mark Immediate
5897 instruct storeImmCM0_reg(memory mem, immI0 zero)
5898 %{
5899   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5900   match(Set mem (StoreCM mem zero));
5901 
5902   ins_cost(125); // XXX
5903   format %{ "movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)" %}
5904   ins_encode %{
5905     __ movb($mem$$Address, r12);
5906   %}
5907   ins_pipe(ialu_mem_reg);
5908 %}
5909 
5910 instruct storeImmCM0(memory mem, immI0 src)
5911 %{
5912   match(Set mem (StoreCM mem src));
5913 
5914   ins_cost(150); // XXX
5915   format %{ "movb    $mem, $src\t# CMS card-mark byte 0" %}
5916   opcode(0xC6); /* C6 /0 */
5917   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5918   ins_pipe(ialu_mem_imm);
5919 %}
5920 
5921 // Store Float
5922 instruct storeF(memory mem, regF src)
5923 %{
5924   match(Set mem (StoreF mem src));
5925 
5926   ins_cost(95); // XXX
5927   format %{ "movss   $mem, $src\t# float" %}
5928   ins_encode %{
5929     __ movflt($mem$$Address, $src$$XMMRegister);
5930   %}
5931   ins_pipe(pipe_slow); // XXX
5932 %}
5933 
5934 // Store immediate Float value (it is faster than store from XMM register)
5935 instruct storeF0(memory mem, immF0 zero)
5936 %{
5937   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5938   match(Set mem (StoreF mem zero));
5939 
5940   ins_cost(25); // XXX
5941   format %{ "movl    $mem, R12\t# float 0. (R12_heapbase==0)" %}
5942   ins_encode %{
5943     __ movl($mem$$Address, r12);
5944   %}
5945   ins_pipe(ialu_mem_reg);
5946 %}
5947 
5948 instruct storeF_imm(memory mem, immF src)
5949 %{
5950   match(Set mem (StoreF mem src));
5951 
5952   ins_cost(50);
5953   format %{ "movl    $mem, $src\t# float" %}
5954   opcode(0xC7); /* C7 /0 */
5955   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5956   ins_pipe(ialu_mem_imm);
5957 %}
5958 
5959 // Store Double
5960 instruct storeD(memory mem, regD src)
5961 %{
5962   match(Set mem (StoreD mem src));
5963 
5964   ins_cost(95); // XXX
5965   format %{ "movsd   $mem, $src\t# double" %}
5966   ins_encode %{
5967     __ movdbl($mem$$Address, $src$$XMMRegister);
5968   %}
5969   ins_pipe(pipe_slow); // XXX
5970 %}
5971 
5972 // Store immediate double 0.0 (it is faster than store from XMM register)
5973 instruct storeD0_imm(memory mem, immD0 src)
5974 %{
5975   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
5976   match(Set mem (StoreD mem src));
5977 
5978   ins_cost(50);
5979   format %{ "movq    $mem, $src\t# double 0." %}
5980   opcode(0xC7); /* C7 /0 */
5981   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5982   ins_pipe(ialu_mem_imm);
5983 %}
5984 
5985 instruct storeD0(memory mem, immD0 zero)
5986 %{
5987   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5988   match(Set mem (StoreD mem zero));
5989 
5990   ins_cost(25); // XXX
5991   format %{ "movq    $mem, R12\t# double 0. (R12_heapbase==0)" %}
5992   ins_encode %{
5993     __ movq($mem$$Address, r12);
5994   %}
5995   ins_pipe(ialu_mem_reg);
5996 %}
5997 
5998 instruct storeSSI(stackSlotI dst, rRegI src)
5999 %{
6000   match(Set dst src);
6001 
6002   ins_cost(100);
6003   format %{ "movl    $dst, $src\t# int stk" %}
6004   opcode(0x89);
6005   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
6006   ins_pipe( ialu_mem_reg );
6007 %}
6008 
6009 instruct storeSSL(stackSlotL dst, rRegL src)
6010 %{
6011   match(Set dst src);
6012 
6013   ins_cost(100);
6014   format %{ "movq    $dst, $src\t# long stk" %}
6015   opcode(0x89);
6016   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
6017   ins_pipe(ialu_mem_reg);
6018 %}
6019 
6020 instruct storeSSP(stackSlotP dst, rRegP src)
6021 %{
6022   match(Set dst src);
6023 
6024   ins_cost(100);
6025   format %{ "movq    $dst, $src\t# ptr stk" %}
6026   opcode(0x89);
6027   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
6028   ins_pipe(ialu_mem_reg);
6029 %}
6030 
6031 instruct storeSSF(stackSlotF dst, regF src)
6032 %{
6033   match(Set dst src);
6034 
6035   ins_cost(95); // XXX
6036   format %{ "movss   $dst, $src\t# float stk" %}
6037   ins_encode %{
6038     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
6039   %}
6040   ins_pipe(pipe_slow); // XXX
6041 %}
6042 
6043 instruct storeSSD(stackSlotD dst, regD src)
6044 %{
6045   match(Set dst src);
6046 
6047   ins_cost(95); // XXX
6048   format %{ "movsd   $dst, $src\t# double stk" %}
6049   ins_encode %{
6050     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
6051   %}
6052   ins_pipe(pipe_slow); // XXX
6053 %}
6054 
6055 //----------BSWAP Instructions-------------------------------------------------
6056 instruct bytes_reverse_int(rRegI dst) %{
6057   match(Set dst (ReverseBytesI dst));
6058 
6059   format %{ "bswapl  $dst" %}
6060   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
6061   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
6062   ins_pipe( ialu_reg );
6063 %}
6064 
6065 instruct bytes_reverse_long(rRegL dst) %{
6066   match(Set dst (ReverseBytesL dst));
6067 
6068   format %{ "bswapq  $dst" %}
6069   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
6070   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
6071   ins_pipe( ialu_reg);
6072 %}
6073 
6074 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
6075   match(Set dst (ReverseBytesUS dst));
6076   effect(KILL cr);
6077 
6078   format %{ "bswapl  $dst\n\t"
6079             "shrl    $dst,16\n\t" %}
6080   ins_encode %{
6081     __ bswapl($dst$$Register);
6082     __ shrl($dst$$Register, 16);
6083   %}
6084   ins_pipe( ialu_reg );
6085 %}
6086 
6087 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
6088   match(Set dst (ReverseBytesS dst));
6089   effect(KILL cr);
6090 
6091   format %{ "bswapl  $dst\n\t"
6092             "sar     $dst,16\n\t" %}
6093   ins_encode %{
6094     __ bswapl($dst$$Register);
6095     __ sarl($dst$$Register, 16);
6096   %}
6097   ins_pipe( ialu_reg );
6098 %}
6099 
6100 //---------- Zeros Count Instructions ------------------------------------------
6101 
6102 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6103   predicate(UseCountLeadingZerosInstruction);
6104   match(Set dst (CountLeadingZerosI src));
6105   effect(KILL cr);
6106 
6107   format %{ "lzcntl  $dst, $src\t# count leading zeros (int)" %}
6108   ins_encode %{
6109     __ lzcntl($dst$$Register, $src$$Register);
6110   %}
6111   ins_pipe(ialu_reg);
6112 %}
6113 
6114 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
6115   predicate(!UseCountLeadingZerosInstruction);
6116   match(Set dst (CountLeadingZerosI src));
6117   effect(KILL cr);
6118 
6119   format %{ "bsrl    $dst, $src\t# count leading zeros (int)\n\t"
6120             "jnz     skip\n\t"
6121             "movl    $dst, -1\n"
6122       "skip:\n\t"
6123             "negl    $dst\n\t"
6124             "addl    $dst, 31" %}
6125   ins_encode %{
6126     Register Rdst = $dst$$Register;
6127     Register Rsrc = $src$$Register;
6128     Label skip;
6129     __ bsrl(Rdst, Rsrc);
6130     __ jccb(Assembler::notZero, skip);
6131     __ movl(Rdst, -1);
6132     __ bind(skip);
6133     __ negl(Rdst);
6134     __ addl(Rdst, BitsPerInt - 1);
6135   %}
6136   ins_pipe(ialu_reg);
6137 %}
6138 
6139 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6140   predicate(UseCountLeadingZerosInstruction);
6141   match(Set dst (CountLeadingZerosL src));
6142   effect(KILL cr);
6143 
6144   format %{ "lzcntq  $dst, $src\t# count leading zeros (long)" %}
6145   ins_encode %{
6146     __ lzcntq($dst$$Register, $src$$Register);
6147   %}
6148   ins_pipe(ialu_reg);
6149 %}
6150 
6151 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
6152   predicate(!UseCountLeadingZerosInstruction);
6153   match(Set dst (CountLeadingZerosL src));
6154   effect(KILL cr);
6155 
6156   format %{ "bsrq    $dst, $src\t# count leading zeros (long)\n\t"
6157             "jnz     skip\n\t"
6158             "movl    $dst, -1\n"
6159       "skip:\n\t"
6160             "negl    $dst\n\t"
6161             "addl    $dst, 63" %}
6162   ins_encode %{
6163     Register Rdst = $dst$$Register;
6164     Register Rsrc = $src$$Register;
6165     Label skip;
6166     __ bsrq(Rdst, Rsrc);
6167     __ jccb(Assembler::notZero, skip);
6168     __ movl(Rdst, -1);
6169     __ bind(skip);
6170     __ negl(Rdst);
6171     __ addl(Rdst, BitsPerLong - 1);
6172   %}
6173   ins_pipe(ialu_reg);
6174 %}
6175 
6176 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6177   predicate(UseCountTrailingZerosInstruction);
6178   match(Set dst (CountTrailingZerosI src));
6179   effect(KILL cr);
6180 
6181   format %{ "tzcntl    $dst, $src\t# count trailing zeros (int)" %}
6182   ins_encode %{
6183     __ tzcntl($dst$$Register, $src$$Register);
6184   %}
6185   ins_pipe(ialu_reg);
6186 %}
6187 
6188 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
6189   predicate(!UseCountTrailingZerosInstruction);
6190   match(Set dst (CountTrailingZerosI src));
6191   effect(KILL cr);
6192 
6193   format %{ "bsfl    $dst, $src\t# count trailing zeros (int)\n\t"
6194             "jnz     done\n\t"
6195             "movl    $dst, 32\n"
6196       "done:" %}
6197   ins_encode %{
6198     Register Rdst = $dst$$Register;
6199     Label done;
6200     __ bsfl(Rdst, $src$$Register);
6201     __ jccb(Assembler::notZero, done);
6202     __ movl(Rdst, BitsPerInt);
6203     __ bind(done);
6204   %}
6205   ins_pipe(ialu_reg);
6206 %}
6207 
6208 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6209   predicate(UseCountTrailingZerosInstruction);
6210   match(Set dst (CountTrailingZerosL src));
6211   effect(KILL cr);
6212 
6213   format %{ "tzcntq    $dst, $src\t# count trailing zeros (long)" %}
6214   ins_encode %{
6215     __ tzcntq($dst$$Register, $src$$Register);
6216   %}
6217   ins_pipe(ialu_reg);
6218 %}
6219 
6220 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
6221   predicate(!UseCountTrailingZerosInstruction);
6222   match(Set dst (CountTrailingZerosL src));
6223   effect(KILL cr);
6224 
6225   format %{ "bsfq    $dst, $src\t# count trailing zeros (long)\n\t"
6226             "jnz     done\n\t"
6227             "movl    $dst, 64\n"
6228       "done:" %}
6229   ins_encode %{
6230     Register Rdst = $dst$$Register;
6231     Label done;
6232     __ bsfq(Rdst, $src$$Register);
6233     __ jccb(Assembler::notZero, done);
6234     __ movl(Rdst, BitsPerLong);
6235     __ bind(done);
6236   %}
6237   ins_pipe(ialu_reg);
6238 %}
6239 
6240 
6241 //---------- Population Count Instructions -------------------------------------
6242 
6243 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
6244   predicate(UsePopCountInstruction);
6245   match(Set dst (PopCountI src));
6246   effect(KILL cr);
6247 
6248   format %{ "popcnt  $dst, $src" %}
6249   ins_encode %{
6250     __ popcntl($dst$$Register, $src$$Register);
6251   %}
6252   ins_pipe(ialu_reg);
6253 %}
6254 
6255 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6256   predicate(UsePopCountInstruction);
6257   match(Set dst (PopCountI (LoadI mem)));
6258   effect(KILL cr);
6259 
6260   format %{ "popcnt  $dst, $mem" %}
6261   ins_encode %{
6262     __ popcntl($dst$$Register, $mem$$Address);
6263   %}
6264   ins_pipe(ialu_reg);
6265 %}
6266 
6267 // Note: Long.bitCount(long) returns an int.
6268 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
6269   predicate(UsePopCountInstruction);
6270   match(Set dst (PopCountL src));
6271   effect(KILL cr);
6272 
6273   format %{ "popcnt  $dst, $src" %}
6274   ins_encode %{
6275     __ popcntq($dst$$Register, $src$$Register);
6276   %}
6277   ins_pipe(ialu_reg);
6278 %}
6279 
6280 // Note: Long.bitCount(long) returns an int.
6281 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6282   predicate(UsePopCountInstruction);
6283   match(Set dst (PopCountL (LoadL mem)));
6284   effect(KILL cr);
6285 
6286   format %{ "popcnt  $dst, $mem" %}
6287   ins_encode %{
6288     __ popcntq($dst$$Register, $mem$$Address);
6289   %}
6290   ins_pipe(ialu_reg);
6291 %}
6292 
6293 
6294 //----------MemBar Instructions-----------------------------------------------
6295 // Memory barrier flavors
6296 
6297 instruct membar_acquire()
6298 %{
6299   match(MemBarAcquire);
6300   match(LoadFence);
6301   ins_cost(0);
6302 
6303   size(0);
6304   format %{ "MEMBAR-acquire ! (empty encoding)" %}
6305   ins_encode();
6306   ins_pipe(empty);
6307 %}
6308 
6309 instruct membar_acquire_lock()
6310 %{
6311   match(MemBarAcquireLock);
6312   ins_cost(0);
6313 
6314   size(0);
6315   format %{ "MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)" %}
6316   ins_encode();
6317   ins_pipe(empty);
6318 %}
6319 
6320 instruct membar_release()
6321 %{
6322   match(MemBarRelease);
6323   match(StoreFence);
6324   ins_cost(0);
6325 
6326   size(0);
6327   format %{ "MEMBAR-release ! (empty encoding)" %}
6328   ins_encode();
6329   ins_pipe(empty);
6330 %}
6331 
6332 instruct membar_release_lock()
6333 %{
6334   match(MemBarReleaseLock);
6335   ins_cost(0);
6336 
6337   size(0);
6338   format %{ "MEMBAR-release (a FastUnlock follows so empty encoding)" %}
6339   ins_encode();
6340   ins_pipe(empty);
6341 %}
6342 
<a name="1" id="anc1"></a><span class="new">6343 instruct onspinwait()</span>
<span class="new">6344 %{</span>
<span class="new">6345   match(OnSpinWait);</span>
<span class="new">6346   ins_cost(200);</span>
<span class="new">6347 </span>
<span class="new">6348   format %{</span>
<span class="new">6349     $$template</span>
<span class="new">6350     if (os::is_MP()) {</span>
<span class="new">6351       $$emit$$"pause\t! membar_onspinwait"</span>
<span class="new">6352     } else {</span>
<span class="new">6353       $$emit$$"MEMBAR-onspinwait ! (empty encoding)"</span>
<span class="new">6354     }</span>
<span class="new">6355   %}</span>
<span class="new">6356   ins_encode %{</span>
<span class="new">6357     __ pause();</span>
<span class="new">6358   %}</span>
<span class="new">6359   ins_pipe(pipe_slow);</span>
<span class="new">6360 %}</span>
<span class="new">6361 </span>
6362 instruct membar_volatile(rFlagsReg cr) %{
6363   match(MemBarVolatile);
6364   effect(KILL cr);
6365   ins_cost(400);
6366 
6367   format %{
6368     $$template
6369     if (os::is_MP()) {
6370       $$emit$$"lock addl [rsp + #0], 0\t! membar_volatile"
6371     } else {
6372       $$emit$$"MEMBAR-volatile ! (empty encoding)"
6373     }
6374   %}
6375   ins_encode %{
6376     __ membar(Assembler::StoreLoad);
6377   %}
6378   ins_pipe(pipe_slow);
6379 %}
6380 
6381 instruct unnecessary_membar_volatile()
6382 %{
6383   match(MemBarVolatile);
6384   predicate(Matcher::post_store_load_barrier(n));
6385   ins_cost(0);
6386 
6387   size(0);
6388   format %{ "MEMBAR-volatile (unnecessary so empty encoding)" %}
6389   ins_encode();
6390   ins_pipe(empty);
6391 %}
6392 
6393 instruct membar_storestore() %{
6394   match(MemBarStoreStore);
6395   ins_cost(0);
6396 
6397   size(0);
6398   format %{ "MEMBAR-storestore (empty encoding)" %}
6399   ins_encode( );
6400   ins_pipe(empty);
6401 %}
6402 
6403 //----------Move Instructions--------------------------------------------------
6404 
6405 instruct castX2P(rRegP dst, rRegL src)
6406 %{
6407   match(Set dst (CastX2P src));
6408 
6409   format %{ "movq    $dst, $src\t# long-&gt;ptr" %}
6410   ins_encode %{
6411     if ($dst$$reg != $src$$reg) {
6412       __ movptr($dst$$Register, $src$$Register);
6413     }
6414   %}
6415   ins_pipe(ialu_reg_reg); // XXX
6416 %}
6417 
6418 instruct castP2X(rRegL dst, rRegP src)
6419 %{
6420   match(Set dst (CastP2X src));
6421 
6422   format %{ "movq    $dst, $src\t# ptr -&gt; long" %}
6423   ins_encode %{
6424     if ($dst$$reg != $src$$reg) {
6425       __ movptr($dst$$Register, $src$$Register);
6426     }
6427   %}
6428   ins_pipe(ialu_reg_reg); // XXX
6429 %}
6430 
6431 // Convert oop into int for vectors alignment masking
6432 instruct convP2I(rRegI dst, rRegP src)
6433 %{
6434   match(Set dst (ConvL2I (CastP2X src)));
6435 
6436   format %{ "movl    $dst, $src\t# ptr -&gt; int" %}
6437   ins_encode %{
6438     __ movl($dst$$Register, $src$$Register);
6439   %}
6440   ins_pipe(ialu_reg_reg); // XXX
6441 %}
6442 
6443 // Convert compressed oop into int for vectors alignment masking
6444 // in case of 32bit oops (heap &lt; 4Gb).
6445 instruct convN2I(rRegI dst, rRegN src)
6446 %{
6447   predicate(Universe::narrow_oop_shift() == 0);
6448   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6449 
6450   format %{ "movl    $dst, $src\t# compressed ptr -&gt; int" %}
6451   ins_encode %{
6452     __ movl($dst$$Register, $src$$Register);
6453   %}
6454   ins_pipe(ialu_reg_reg); // XXX
6455 %}
6456 
6457 // Convert oop pointer into compressed form
6458 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
6459   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
6460   match(Set dst (EncodeP src));
6461   effect(KILL cr);
6462   format %{ "encode_heap_oop $dst,$src" %}
6463   ins_encode %{
6464     Register s = $src$$Register;
6465     Register d = $dst$$Register;
6466     if (s != d) {
6467       __ movq(d, s);
6468     }
6469     __ encode_heap_oop(d);
6470   %}
6471   ins_pipe(ialu_reg_long);
6472 %}
6473 
6474 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6475   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
6476   match(Set dst (EncodeP src));
6477   effect(KILL cr);
6478   format %{ "encode_heap_oop_not_null $dst,$src" %}
6479   ins_encode %{
6480     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
6481   %}
6482   ins_pipe(ialu_reg_long);
6483 %}
6484 
6485 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
6486   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6487             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
6488   match(Set dst (DecodeN src));
6489   effect(KILL cr);
6490   format %{ "decode_heap_oop $dst,$src" %}
6491   ins_encode %{
6492     Register s = $src$$Register;
6493     Register d = $dst$$Register;
6494     if (s != d) {
6495       __ movq(d, s);
6496     }
6497     __ decode_heap_oop(d);
6498   %}
6499   ins_pipe(ialu_reg_long);
6500 %}
6501 
6502 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6503   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
6504             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
6505   match(Set dst (DecodeN src));
6506   effect(KILL cr);
6507   format %{ "decode_heap_oop_not_null $dst,$src" %}
6508   ins_encode %{
6509     Register s = $src$$Register;
6510     Register d = $dst$$Register;
6511     if (s != d) {
6512       __ decode_heap_oop_not_null(d, s);
6513     } else {
6514       __ decode_heap_oop_not_null(d);
6515     }
6516   %}
6517   ins_pipe(ialu_reg_long);
6518 %}
6519 
6520 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6521   match(Set dst (EncodePKlass src));
6522   effect(KILL cr);
6523   format %{ "encode_klass_not_null $dst,$src" %}
6524   ins_encode %{
6525     __ encode_klass_not_null($dst$$Register, $src$$Register);
6526   %}
6527   ins_pipe(ialu_reg_long);
6528 %}
6529 
6530 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6531   match(Set dst (DecodeNKlass src));
6532   effect(KILL cr);
6533   format %{ "decode_klass_not_null $dst,$src" %}
6534   ins_encode %{
6535     Register s = $src$$Register;
6536     Register d = $dst$$Register;
6537     if (s != d) {
6538       __ decode_klass_not_null(d, s);
6539     } else {
6540       __ decode_klass_not_null(d);
6541     }
6542   %}
6543   ins_pipe(ialu_reg_long);
6544 %}
6545 
6546 
6547 //----------Conditional Move---------------------------------------------------
6548 // Jump
6549 // dummy instruction for generating temp registers
6550 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
6551   match(Jump (LShiftL switch_val shift));
6552   ins_cost(350);
6553   predicate(false);
6554   effect(TEMP dest);
6555 
6556   format %{ "leaq    $dest, [$constantaddress]\n\t"
6557             "jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t" %}
6558   ins_encode %{
6559     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6560     // to do that and the compiler is using that register as one it can allocate.
6561     // So we build it all by hand.
6562     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
6563     // ArrayAddress dispatch(table, index);
6564     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
6565     __ lea($dest$$Register, $constantaddress);
6566     __ jmp(dispatch);
6567   %}
6568   ins_pipe(pipe_jmp);
6569 %}
6570 
6571 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
6572   match(Jump (AddL (LShiftL switch_val shift) offset));
6573   ins_cost(350);
6574   effect(TEMP dest);
6575 
6576   format %{ "leaq    $dest, [$constantaddress]\n\t"
6577             "jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t" %}
6578   ins_encode %{
6579     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6580     // to do that and the compiler is using that register as one it can allocate.
6581     // So we build it all by hand.
6582     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6583     // ArrayAddress dispatch(table, index);
6584     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6585     __ lea($dest$$Register, $constantaddress);
6586     __ jmp(dispatch);
6587   %}
6588   ins_pipe(pipe_jmp);
6589 %}
6590 
6591 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
6592   match(Jump switch_val);
6593   ins_cost(350);
6594   effect(TEMP dest);
6595 
6596   format %{ "leaq    $dest, [$constantaddress]\n\t"
6597             "jmp     [$dest + $switch_val]\n\t" %}
6598   ins_encode %{
6599     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6600     // to do that and the compiler is using that register as one it can allocate.
6601     // So we build it all by hand.
6602     // Address index(noreg, switch_reg, Address::times_1);
6603     // ArrayAddress dispatch(table, index);
6604     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
6605     __ lea($dest$$Register, $constantaddress);
6606     __ jmp(dispatch);
6607   %}
6608   ins_pipe(pipe_jmp);
6609 %}
6610 
6611 // Conditional move
6612 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
6613 %{
6614   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6615 
6616   ins_cost(200); // XXX
6617   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6618   opcode(0x0F, 0x40);
6619   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6620   ins_pipe(pipe_cmov_reg);
6621 %}
6622 
6623 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
6624   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6625 
6626   ins_cost(200); // XXX
6627   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6628   opcode(0x0F, 0x40);
6629   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6630   ins_pipe(pipe_cmov_reg);
6631 %}
6632 
6633 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
6634   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6635   ins_cost(200);
6636   expand %{
6637     cmovI_regU(cop, cr, dst, src);
6638   %}
6639 %}
6640 
6641 // Conditional move
6642 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
6643   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6644 
6645   ins_cost(250); // XXX
6646   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6647   opcode(0x0F, 0x40);
6648   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6649   ins_pipe(pipe_cmov_mem);
6650 %}
6651 
6652 // Conditional move
6653 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
6654 %{
6655   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6656 
6657   ins_cost(250); // XXX
6658   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6659   opcode(0x0F, 0x40);
6660   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6661   ins_pipe(pipe_cmov_mem);
6662 %}
6663 
6664 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
6665   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6666   ins_cost(250);
6667   expand %{
6668     cmovI_memU(cop, cr, dst, src);
6669   %}
6670 %}
6671 
6672 // Conditional move
6673 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
6674 %{
6675   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6676 
6677   ins_cost(200); // XXX
6678   format %{ "cmovl$cop $dst, $src\t# signed, compressed ptr" %}
6679   opcode(0x0F, 0x40);
6680   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6681   ins_pipe(pipe_cmov_reg);
6682 %}
6683 
6684 // Conditional move
6685 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
6686 %{
6687   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6688 
6689   ins_cost(200); // XXX
6690   format %{ "cmovl$cop $dst, $src\t# unsigned, compressed ptr" %}
6691   opcode(0x0F, 0x40);
6692   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6693   ins_pipe(pipe_cmov_reg);
6694 %}
6695 
6696 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
6697   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6698   ins_cost(200);
6699   expand %{
6700     cmovN_regU(cop, cr, dst, src);
6701   %}
6702 %}
6703 
6704 // Conditional move
6705 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
6706 %{
6707   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6708 
6709   ins_cost(200); // XXX
6710   format %{ "cmovq$cop $dst, $src\t# signed, ptr" %}
6711   opcode(0x0F, 0x40);
6712   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6713   ins_pipe(pipe_cmov_reg);  // XXX
6714 %}
6715 
6716 // Conditional move
6717 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
6718 %{
6719   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6720 
6721   ins_cost(200); // XXX
6722   format %{ "cmovq$cop $dst, $src\t# unsigned, ptr" %}
6723   opcode(0x0F, 0x40);
6724   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6725   ins_pipe(pipe_cmov_reg); // XXX
6726 %}
6727 
6728 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
6729   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6730   ins_cost(200);
6731   expand %{
6732     cmovP_regU(cop, cr, dst, src);
6733   %}
6734 %}
6735 
6736 // DISABLED: Requires the ADLC to emit a bottom_type call that
6737 // correctly meets the two pointer arguments; one is an incoming
6738 // register but the other is a memory operand.  ALSO appears to
6739 // be buggy with implicit null checks.
6740 //
6741 //// Conditional move
6742 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
6743 //%{
6744 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6745 //  ins_cost(250);
6746 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6747 //  opcode(0x0F,0x40);
6748 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6749 //  ins_pipe( pipe_cmov_mem );
6750 //%}
6751 //
6752 //// Conditional move
6753 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
6754 //%{
6755 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6756 //  ins_cost(250);
6757 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6758 //  opcode(0x0F,0x40);
6759 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6760 //  ins_pipe( pipe_cmov_mem );
6761 //%}
6762 
6763 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
6764 %{
6765   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6766 
6767   ins_cost(200); // XXX
6768   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6769   opcode(0x0F, 0x40);
6770   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6771   ins_pipe(pipe_cmov_reg);  // XXX
6772 %}
6773 
6774 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
6775 %{
6776   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6777 
6778   ins_cost(200); // XXX
6779   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6780   opcode(0x0F, 0x40);
6781   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6782   ins_pipe(pipe_cmov_mem);  // XXX
6783 %}
6784 
6785 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
6786 %{
6787   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6788 
6789   ins_cost(200); // XXX
6790   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6791   opcode(0x0F, 0x40);
6792   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6793   ins_pipe(pipe_cmov_reg); // XXX
6794 %}
6795 
6796 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
6797   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6798   ins_cost(200);
6799   expand %{
6800     cmovL_regU(cop, cr, dst, src);
6801   %}
6802 %}
6803 
6804 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
6805 %{
6806   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6807 
6808   ins_cost(200); // XXX
6809   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6810   opcode(0x0F, 0x40);
6811   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6812   ins_pipe(pipe_cmov_mem); // XXX
6813 %}
6814 
6815 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
6816   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6817   ins_cost(200);
6818   expand %{
6819     cmovL_memU(cop, cr, dst, src);
6820   %}
6821 %}
6822 
6823 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
6824 %{
6825   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6826 
6827   ins_cost(200); // XXX
6828   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6829             "movss     $dst, $src\n"
6830     "skip:" %}
6831   ins_encode %{
6832     Label Lskip;
6833     // Invert sense of branch from sense of CMOV
6834     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6835     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6836     __ bind(Lskip);
6837   %}
6838   ins_pipe(pipe_slow);
6839 %}
6840 
6841 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
6842 // %{
6843 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
6844 
6845 //   ins_cost(200); // XXX
6846 //   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6847 //             "movss     $dst, $src\n"
6848 //     "skip:" %}
6849 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
6850 //   ins_pipe(pipe_slow);
6851 // %}
6852 
6853 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
6854 %{
6855   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6856 
6857   ins_cost(200); // XXX
6858   format %{ "jn$cop    skip\t# unsigned cmove float\n\t"
6859             "movss     $dst, $src\n"
6860     "skip:" %}
6861   ins_encode %{
6862     Label Lskip;
6863     // Invert sense of branch from sense of CMOV
6864     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6865     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6866     __ bind(Lskip);
6867   %}
6868   ins_pipe(pipe_slow);
6869 %}
6870 
6871 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
6872   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6873   ins_cost(200);
6874   expand %{
6875     cmovF_regU(cop, cr, dst, src);
6876   %}
6877 %}
6878 
6879 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
6880 %{
6881   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6882 
6883   ins_cost(200); // XXX
6884   format %{ "jn$cop    skip\t# signed cmove double\n\t"
6885             "movsd     $dst, $src\n"
6886     "skip:" %}
6887   ins_encode %{
6888     Label Lskip;
6889     // Invert sense of branch from sense of CMOV
6890     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6891     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6892     __ bind(Lskip);
6893   %}
6894   ins_pipe(pipe_slow);
6895 %}
6896 
6897 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
6898 %{
6899   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6900 
6901   ins_cost(200); // XXX
6902   format %{ "jn$cop    skip\t# unsigned cmove double\n\t"
6903             "movsd     $dst, $src\n"
6904     "skip:" %}
6905   ins_encode %{
6906     Label Lskip;
6907     // Invert sense of branch from sense of CMOV
6908     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6909     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6910     __ bind(Lskip);
6911   %}
6912   ins_pipe(pipe_slow);
6913 %}
6914 
6915 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
6916   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6917   ins_cost(200);
6918   expand %{
6919     cmovD_regU(cop, cr, dst, src);
6920   %}
6921 %}
6922 
6923 //----------Arithmetic Instructions--------------------------------------------
6924 //----------Addition Instructions----------------------------------------------
6925 
6926 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
6927 %{
6928   match(Set dst (AddI dst src));
6929   effect(KILL cr);
6930 
6931   format %{ "addl    $dst, $src\t# int" %}
6932   opcode(0x03);
6933   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
6934   ins_pipe(ialu_reg_reg);
6935 %}
6936 
6937 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
6938 %{
6939   match(Set dst (AddI dst src));
6940   effect(KILL cr);
6941 
6942   format %{ "addl    $dst, $src\t# int" %}
6943   opcode(0x81, 0x00); /* /0 id */
6944   ins_encode(OpcSErm(dst, src), Con8or32(src));
6945   ins_pipe( ialu_reg );
6946 %}
6947 
6948 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
6949 %{
6950   match(Set dst (AddI dst (LoadI src)));
6951   effect(KILL cr);
6952 
6953   ins_cost(125); // XXX
6954   format %{ "addl    $dst, $src\t# int" %}
6955   opcode(0x03);
6956   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
6957   ins_pipe(ialu_reg_mem);
6958 %}
6959 
6960 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
6961 %{
6962   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6963   effect(KILL cr);
6964 
6965   ins_cost(150); // XXX
6966   format %{ "addl    $dst, $src\t# int" %}
6967   opcode(0x01); /* Opcode 01 /r */
6968   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
6969   ins_pipe(ialu_mem_reg);
6970 %}
6971 
6972 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
6973 %{
6974   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6975   effect(KILL cr);
6976 
6977   ins_cost(125); // XXX
6978   format %{ "addl    $dst, $src\t# int" %}
6979   opcode(0x81); /* Opcode 81 /0 id */
6980   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
6981   ins_pipe(ialu_mem_imm);
6982 %}
6983 
6984 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
6985 %{
6986   predicate(UseIncDec);
6987   match(Set dst (AddI dst src));
6988   effect(KILL cr);
6989 
6990   format %{ "incl    $dst\t# int" %}
6991   opcode(0xFF, 0x00); // FF /0
6992   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6993   ins_pipe(ialu_reg);
6994 %}
6995 
6996 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
6997 %{
6998   predicate(UseIncDec);
6999   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
7000   effect(KILL cr);
7001 
7002   ins_cost(125); // XXX
7003   format %{ "incl    $dst\t# int" %}
7004   opcode(0xFF); /* Opcode FF /0 */
7005   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
7006   ins_pipe(ialu_mem_imm);
7007 %}
7008 
7009 // XXX why does that use AddI
7010 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
7011 %{
7012   predicate(UseIncDec);
7013   match(Set dst (AddI dst src));
7014   effect(KILL cr);
7015 
7016   format %{ "decl    $dst\t# int" %}
7017   opcode(0xFF, 0x01); // FF /1
7018   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7019   ins_pipe(ialu_reg);
7020 %}
7021 
7022 // XXX why does that use AddI
7023 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
7024 %{
7025   predicate(UseIncDec);
7026   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
7027   effect(KILL cr);
7028 
7029   ins_cost(125); // XXX
7030   format %{ "decl    $dst\t# int" %}
7031   opcode(0xFF); /* Opcode FF /1 */
7032   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
7033   ins_pipe(ialu_mem_imm);
7034 %}
7035 
7036 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
7037 %{
7038   match(Set dst (AddI src0 src1));
7039 
7040   ins_cost(110);
7041   format %{ "addr32 leal $dst, [$src0 + $src1]\t# int" %}
7042   opcode(0x8D); /* 0x8D /r */
7043   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7044   ins_pipe(ialu_reg_reg);
7045 %}
7046 
7047 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7048 %{
7049   match(Set dst (AddL dst src));
7050   effect(KILL cr);
7051 
7052   format %{ "addq    $dst, $src\t# long" %}
7053   opcode(0x03);
7054   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7055   ins_pipe(ialu_reg_reg);
7056 %}
7057 
7058 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
7059 %{
7060   match(Set dst (AddL dst src));
7061   effect(KILL cr);
7062 
7063   format %{ "addq    $dst, $src\t# long" %}
7064   opcode(0x81, 0x00); /* /0 id */
7065   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7066   ins_pipe( ialu_reg );
7067 %}
7068 
7069 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7070 %{
7071   match(Set dst (AddL dst (LoadL src)));
7072   effect(KILL cr);
7073 
7074   ins_cost(125); // XXX
7075   format %{ "addq    $dst, $src\t# long" %}
7076   opcode(0x03);
7077   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7078   ins_pipe(ialu_reg_mem);
7079 %}
7080 
7081 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7082 %{
7083   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7084   effect(KILL cr);
7085 
7086   ins_cost(150); // XXX
7087   format %{ "addq    $dst, $src\t# long" %}
7088   opcode(0x01); /* Opcode 01 /r */
7089   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7090   ins_pipe(ialu_mem_reg);
7091 %}
7092 
7093 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7094 %{
7095   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7096   effect(KILL cr);
7097 
7098   ins_cost(125); // XXX
7099   format %{ "addq    $dst, $src\t# long" %}
7100   opcode(0x81); /* Opcode 81 /0 id */
7101   ins_encode(REX_mem_wide(dst),
7102              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
7103   ins_pipe(ialu_mem_imm);
7104 %}
7105 
7106 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
7107 %{
7108   predicate(UseIncDec);
7109   match(Set dst (AddL dst src));
7110   effect(KILL cr);
7111 
7112   format %{ "incq    $dst\t# long" %}
7113   opcode(0xFF, 0x00); // FF /0
7114   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7115   ins_pipe(ialu_reg);
7116 %}
7117 
7118 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
7119 %{
7120   predicate(UseIncDec);
7121   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7122   effect(KILL cr);
7123 
7124   ins_cost(125); // XXX
7125   format %{ "incq    $dst\t# long" %}
7126   opcode(0xFF); /* Opcode FF /0 */
7127   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
7128   ins_pipe(ialu_mem_imm);
7129 %}
7130 
7131 // XXX why does that use AddL
7132 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
7133 %{
7134   predicate(UseIncDec);
7135   match(Set dst (AddL dst src));
7136   effect(KILL cr);
7137 
7138   format %{ "decq    $dst\t# long" %}
7139   opcode(0xFF, 0x01); // FF /1
7140   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7141   ins_pipe(ialu_reg);
7142 %}
7143 
7144 // XXX why does that use AddL
7145 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
7146 %{
7147   predicate(UseIncDec);
7148   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7149   effect(KILL cr);
7150 
7151   ins_cost(125); // XXX
7152   format %{ "decq    $dst\t# long" %}
7153   opcode(0xFF); /* Opcode FF /1 */
7154   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
7155   ins_pipe(ialu_mem_imm);
7156 %}
7157 
7158 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
7159 %{
7160   match(Set dst (AddL src0 src1));
7161 
7162   ins_cost(110);
7163   format %{ "leaq    $dst, [$src0 + $src1]\t# long" %}
7164   opcode(0x8D); /* 0x8D /r */
7165   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7166   ins_pipe(ialu_reg_reg);
7167 %}
7168 
7169 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
7170 %{
7171   match(Set dst (AddP dst src));
7172   effect(KILL cr);
7173 
7174   format %{ "addq    $dst, $src\t# ptr" %}
7175   opcode(0x03);
7176   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7177   ins_pipe(ialu_reg_reg);
7178 %}
7179 
7180 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
7181 %{
7182   match(Set dst (AddP dst src));
7183   effect(KILL cr);
7184 
7185   format %{ "addq    $dst, $src\t# ptr" %}
7186   opcode(0x81, 0x00); /* /0 id */
7187   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7188   ins_pipe( ialu_reg );
7189 %}
7190 
7191 // XXX addP mem ops ????
7192 
7193 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
7194 %{
7195   match(Set dst (AddP src0 src1));
7196 
7197   ins_cost(110);
7198   format %{ "leaq    $dst, [$src0 + $src1]\t# ptr" %}
7199   opcode(0x8D); /* 0x8D /r */
7200   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
7201   ins_pipe(ialu_reg_reg);
7202 %}
7203 
7204 instruct checkCastPP(rRegP dst)
7205 %{
7206   match(Set dst (CheckCastPP dst));
7207 
7208   size(0);
7209   format %{ "# checkcastPP of $dst" %}
7210   ins_encode(/* empty encoding */);
7211   ins_pipe(empty);
7212 %}
7213 
7214 instruct castPP(rRegP dst)
7215 %{
7216   match(Set dst (CastPP dst));
7217 
7218   size(0);
7219   format %{ "# castPP of $dst" %}
7220   ins_encode(/* empty encoding */);
7221   ins_pipe(empty);
7222 %}
7223 
7224 instruct castII(rRegI dst)
7225 %{
7226   match(Set dst (CastII dst));
7227 
7228   size(0);
7229   format %{ "# castII of $dst" %}
7230   ins_encode(/* empty encoding */);
7231   ins_cost(0);
7232   ins_pipe(empty);
7233 %}
7234 
7235 // LoadP-locked same as a regular LoadP when used with compare-swap
7236 instruct loadPLocked(rRegP dst, memory mem)
7237 %{
7238   match(Set dst (LoadPLocked mem));
7239 
7240   ins_cost(125); // XXX
7241   format %{ "movq    $dst, $mem\t# ptr locked" %}
7242   opcode(0x8B);
7243   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
7244   ins_pipe(ialu_reg_mem); // XXX
7245 %}
7246 
7247 // Conditional-store of the updated heap-top.
7248 // Used during allocation of the shared heap.
7249 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
7250 
7251 instruct storePConditional(memory heap_top_ptr,
7252                            rax_RegP oldval, rRegP newval,
7253                            rFlagsReg cr)
7254 %{
7255   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
7256 
7257   format %{ "cmpxchgq $heap_top_ptr, $newval\t# (ptr) "
7258             "If rax == $heap_top_ptr then store $newval into $heap_top_ptr" %}
7259   opcode(0x0F, 0xB1);
7260   ins_encode(lock_prefix,
7261              REX_reg_mem_wide(newval, heap_top_ptr),
7262              OpcP, OpcS,
7263              reg_mem(newval, heap_top_ptr));
7264   ins_pipe(pipe_cmpxchg);
7265 %}
7266 
7267 // Conditional-store of an int value.
7268 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7269 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
7270 %{
7271   match(Set cr (StoreIConditional mem (Binary oldval newval)));
7272   effect(KILL oldval);
7273 
7274   format %{ "cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7275   opcode(0x0F, 0xB1);
7276   ins_encode(lock_prefix,
7277              REX_reg_mem(newval, mem),
7278              OpcP, OpcS,
7279              reg_mem(newval, mem));
7280   ins_pipe(pipe_cmpxchg);
7281 %}
7282 
7283 // Conditional-store of a long value.
7284 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7285 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
7286 %{
7287   match(Set cr (StoreLConditional mem (Binary oldval newval)));
7288   effect(KILL oldval);
7289 
7290   format %{ "cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7291   opcode(0x0F, 0xB1);
7292   ins_encode(lock_prefix,
7293              REX_reg_mem_wide(newval, mem),
7294              OpcP, OpcS,
7295              reg_mem(newval, mem));
7296   ins_pipe(pipe_cmpxchg);
7297 %}
7298 
7299 
7300 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
7301 instruct compareAndSwapP(rRegI res,
7302                          memory mem_ptr,
7303                          rax_RegP oldval, rRegP newval,
7304                          rFlagsReg cr)
7305 %{
7306   predicate(VM_Version::supports_cx8());
7307   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
7308   effect(KILL cr, KILL oldval);
7309 
7310   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7311             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7312             "sete    $res\n\t"
7313             "movzbl  $res, $res" %}
7314   opcode(0x0F, 0xB1);
7315   ins_encode(lock_prefix,
7316              REX_reg_mem_wide(newval, mem_ptr),
7317              OpcP, OpcS,
7318              reg_mem(newval, mem_ptr),
7319              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7320              REX_reg_breg(res, res), // movzbl
7321              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7322   ins_pipe( pipe_cmpxchg );
7323 %}
7324 
7325 instruct compareAndSwapL(rRegI res,
7326                          memory mem_ptr,
7327                          rax_RegL oldval, rRegL newval,
7328                          rFlagsReg cr)
7329 %{
7330   predicate(VM_Version::supports_cx8());
7331   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
7332   effect(KILL cr, KILL oldval);
7333 
7334   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7335             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7336             "sete    $res\n\t"
7337             "movzbl  $res, $res" %}
7338   opcode(0x0F, 0xB1);
7339   ins_encode(lock_prefix,
7340              REX_reg_mem_wide(newval, mem_ptr),
7341              OpcP, OpcS,
7342              reg_mem(newval, mem_ptr),
7343              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7344              REX_reg_breg(res, res), // movzbl
7345              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7346   ins_pipe( pipe_cmpxchg );
7347 %}
7348 
7349 instruct compareAndSwapI(rRegI res,
7350                          memory mem_ptr,
7351                          rax_RegI oldval, rRegI newval,
7352                          rFlagsReg cr)
7353 %{
7354   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
7355   effect(KILL cr, KILL oldval);
7356 
7357   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7358             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7359             "sete    $res\n\t"
7360             "movzbl  $res, $res" %}
7361   opcode(0x0F, 0xB1);
7362   ins_encode(lock_prefix,
7363              REX_reg_mem(newval, mem_ptr),
7364              OpcP, OpcS,
7365              reg_mem(newval, mem_ptr),
7366              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7367              REX_reg_breg(res, res), // movzbl
7368              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7369   ins_pipe( pipe_cmpxchg );
7370 %}
7371 
7372 
7373 instruct compareAndSwapN(rRegI res,
7374                           memory mem_ptr,
7375                           rax_RegN oldval, rRegN newval,
7376                           rFlagsReg cr) %{
7377   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
7378   effect(KILL cr, KILL oldval);
7379 
7380   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7381             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7382             "sete    $res\n\t"
7383             "movzbl  $res, $res" %}
7384   opcode(0x0F, 0xB1);
7385   ins_encode(lock_prefix,
7386              REX_reg_mem(newval, mem_ptr),
7387              OpcP, OpcS,
7388              reg_mem(newval, mem_ptr),
7389              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7390              REX_reg_breg(res, res), // movzbl
7391              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7392   ins_pipe( pipe_cmpxchg );
7393 %}
7394 
7395 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
7396   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7397   match(Set dummy (GetAndAddI mem add));
7398   effect(KILL cr);
7399   format %{ "ADDL  [$mem],$add" %}
7400   ins_encode %{
7401     if (os::is_MP()) { __ lock(); }
7402     __ addl($mem$$Address, $add$$constant);
7403   %}
7404   ins_pipe( pipe_cmpxchg );
7405 %}
7406 
7407 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
7408   match(Set newval (GetAndAddI mem newval));
7409   effect(KILL cr);
7410   format %{ "XADDL  [$mem],$newval" %}
7411   ins_encode %{
7412     if (os::is_MP()) { __ lock(); }
7413     __ xaddl($mem$$Address, $newval$$Register);
7414   %}
7415   ins_pipe( pipe_cmpxchg );
7416 %}
7417 
7418 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
7419   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7420   match(Set dummy (GetAndAddL mem add));
7421   effect(KILL cr);
7422   format %{ "ADDQ  [$mem],$add" %}
7423   ins_encode %{
7424     if (os::is_MP()) { __ lock(); }
7425     __ addq($mem$$Address, $add$$constant);
7426   %}
7427   ins_pipe( pipe_cmpxchg );
7428 %}
7429 
7430 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
7431   match(Set newval (GetAndAddL mem newval));
7432   effect(KILL cr);
7433   format %{ "XADDQ  [$mem],$newval" %}
7434   ins_encode %{
7435     if (os::is_MP()) { __ lock(); }
7436     __ xaddq($mem$$Address, $newval$$Register);
7437   %}
7438   ins_pipe( pipe_cmpxchg );
7439 %}
7440 
7441 instruct xchgI( memory mem, rRegI newval) %{
7442   match(Set newval (GetAndSetI mem newval));
7443   format %{ "XCHGL  $newval,[$mem]" %}
7444   ins_encode %{
7445     __ xchgl($newval$$Register, $mem$$Address);
7446   %}
7447   ins_pipe( pipe_cmpxchg );
7448 %}
7449 
7450 instruct xchgL( memory mem, rRegL newval) %{
7451   match(Set newval (GetAndSetL mem newval));
7452   format %{ "XCHGL  $newval,[$mem]" %}
7453   ins_encode %{
7454     __ xchgq($newval$$Register, $mem$$Address);
7455   %}
7456   ins_pipe( pipe_cmpxchg );
7457 %}
7458 
7459 instruct xchgP( memory mem, rRegP newval) %{
7460   match(Set newval (GetAndSetP mem newval));
7461   format %{ "XCHGQ  $newval,[$mem]" %}
7462   ins_encode %{
7463     __ xchgq($newval$$Register, $mem$$Address);
7464   %}
7465   ins_pipe( pipe_cmpxchg );
7466 %}
7467 
7468 instruct xchgN( memory mem, rRegN newval) %{
7469   match(Set newval (GetAndSetN mem newval));
7470   format %{ "XCHGL  $newval,$mem]" %}
7471   ins_encode %{
7472     __ xchgl($newval$$Register, $mem$$Address);
7473   %}
7474   ins_pipe( pipe_cmpxchg );
7475 %}
7476 
7477 //----------Subtraction Instructions-------------------------------------------
7478 
7479 // Integer Subtraction Instructions
7480 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7481 %{
7482   match(Set dst (SubI dst src));
7483   effect(KILL cr);
7484 
7485   format %{ "subl    $dst, $src\t# int" %}
7486   opcode(0x2B);
7487   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
7488   ins_pipe(ialu_reg_reg);
7489 %}
7490 
7491 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
7492 %{
7493   match(Set dst (SubI dst src));
7494   effect(KILL cr);
7495 
7496   format %{ "subl    $dst, $src\t# int" %}
7497   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7498   ins_encode(OpcSErm(dst, src), Con8or32(src));
7499   ins_pipe(ialu_reg);
7500 %}
7501 
7502 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
7503 %{
7504   match(Set dst (SubI dst (LoadI src)));
7505   effect(KILL cr);
7506 
7507   ins_cost(125);
7508   format %{ "subl    $dst, $src\t# int" %}
7509   opcode(0x2B);
7510   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
7511   ins_pipe(ialu_reg_mem);
7512 %}
7513 
7514 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
7515 %{
7516   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7517   effect(KILL cr);
7518 
7519   ins_cost(150);
7520   format %{ "subl    $dst, $src\t# int" %}
7521   opcode(0x29); /* Opcode 29 /r */
7522   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
7523   ins_pipe(ialu_mem_reg);
7524 %}
7525 
7526 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
7527 %{
7528   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7529   effect(KILL cr);
7530 
7531   ins_cost(125); // XXX
7532   format %{ "subl    $dst, $src\t# int" %}
7533   opcode(0x81); /* Opcode 81 /5 id */
7534   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7535   ins_pipe(ialu_mem_imm);
7536 %}
7537 
7538 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7539 %{
7540   match(Set dst (SubL dst src));
7541   effect(KILL cr);
7542 
7543   format %{ "subq    $dst, $src\t# long" %}
7544   opcode(0x2B);
7545   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7546   ins_pipe(ialu_reg_reg);
7547 %}
7548 
7549 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
7550 %{
7551   match(Set dst (SubL dst src));
7552   effect(KILL cr);
7553 
7554   format %{ "subq    $dst, $src\t# long" %}
7555   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7556   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7557   ins_pipe(ialu_reg);
7558 %}
7559 
7560 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7561 %{
7562   match(Set dst (SubL dst (LoadL src)));
7563   effect(KILL cr);
7564 
7565   ins_cost(125);
7566   format %{ "subq    $dst, $src\t# long" %}
7567   opcode(0x2B);
7568   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7569   ins_pipe(ialu_reg_mem);
7570 %}
7571 
7572 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7573 %{
7574   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7575   effect(KILL cr);
7576 
7577   ins_cost(150);
7578   format %{ "subq    $dst, $src\t# long" %}
7579   opcode(0x29); /* Opcode 29 /r */
7580   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7581   ins_pipe(ialu_mem_reg);
7582 %}
7583 
7584 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7585 %{
7586   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7587   effect(KILL cr);
7588 
7589   ins_cost(125); // XXX
7590   format %{ "subq    $dst, $src\t# long" %}
7591   opcode(0x81); /* Opcode 81 /5 id */
7592   ins_encode(REX_mem_wide(dst),
7593              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7594   ins_pipe(ialu_mem_imm);
7595 %}
7596 
7597 // Subtract from a pointer
7598 // XXX hmpf???
7599 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
7600 %{
7601   match(Set dst (AddP dst (SubI zero src)));
7602   effect(KILL cr);
7603 
7604   format %{ "subq    $dst, $src\t# ptr - int" %}
7605   opcode(0x2B);
7606   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7607   ins_pipe(ialu_reg_reg);
7608 %}
7609 
7610 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
7611 %{
7612   match(Set dst (SubI zero dst));
7613   effect(KILL cr);
7614 
7615   format %{ "negl    $dst\t# int" %}
7616   opcode(0xF7, 0x03);  // Opcode F7 /3
7617   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7618   ins_pipe(ialu_reg);
7619 %}
7620 
7621 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
7622 %{
7623   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
7624   effect(KILL cr);
7625 
7626   format %{ "negl    $dst\t# int" %}
7627   opcode(0xF7, 0x03);  // Opcode F7 /3
7628   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7629   ins_pipe(ialu_reg);
7630 %}
7631 
7632 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
7633 %{
7634   match(Set dst (SubL zero dst));
7635   effect(KILL cr);
7636 
7637   format %{ "negq    $dst\t# long" %}
7638   opcode(0xF7, 0x03);  // Opcode F7 /3
7639   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7640   ins_pipe(ialu_reg);
7641 %}
7642 
7643 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
7644 %{
7645   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
7646   effect(KILL cr);
7647 
7648   format %{ "negq    $dst\t# long" %}
7649   opcode(0xF7, 0x03);  // Opcode F7 /3
7650   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
7651   ins_pipe(ialu_reg);
7652 %}
7653 
7654 //----------Multiplication/Division Instructions-------------------------------
7655 // Integer Multiplication Instructions
7656 // Multiply Register
7657 
7658 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7659 %{
7660   match(Set dst (MulI dst src));
7661   effect(KILL cr);
7662 
7663   ins_cost(300);
7664   format %{ "imull   $dst, $src\t# int" %}
7665   opcode(0x0F, 0xAF);
7666   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
7667   ins_pipe(ialu_reg_reg_alu0);
7668 %}
7669 
7670 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
7671 %{
7672   match(Set dst (MulI src imm));
7673   effect(KILL cr);
7674 
7675   ins_cost(300);
7676   format %{ "imull   $dst, $src, $imm\t# int" %}
7677   opcode(0x69); /* 69 /r id */
7678   ins_encode(REX_reg_reg(dst, src),
7679              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7680   ins_pipe(ialu_reg_reg_alu0);
7681 %}
7682 
7683 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
7684 %{
7685   match(Set dst (MulI dst (LoadI src)));
7686   effect(KILL cr);
7687 
7688   ins_cost(350);
7689   format %{ "imull   $dst, $src\t# int" %}
7690   opcode(0x0F, 0xAF);
7691   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
7692   ins_pipe(ialu_reg_mem_alu0);
7693 %}
7694 
7695 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
7696 %{
7697   match(Set dst (MulI (LoadI src) imm));
7698   effect(KILL cr);
7699 
7700   ins_cost(300);
7701   format %{ "imull   $dst, $src, $imm\t# int" %}
7702   opcode(0x69); /* 69 /r id */
7703   ins_encode(REX_reg_mem(dst, src),
7704              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7705   ins_pipe(ialu_reg_mem_alu0);
7706 %}
7707 
7708 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7709 %{
7710   match(Set dst (MulL dst src));
7711   effect(KILL cr);
7712 
7713   ins_cost(300);
7714   format %{ "imulq   $dst, $src\t# long" %}
7715   opcode(0x0F, 0xAF);
7716   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
7717   ins_pipe(ialu_reg_reg_alu0);
7718 %}
7719 
7720 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
7721 %{
7722   match(Set dst (MulL src imm));
7723   effect(KILL cr);
7724 
7725   ins_cost(300);
7726   format %{ "imulq   $dst, $src, $imm\t# long" %}
7727   opcode(0x69); /* 69 /r id */
7728   ins_encode(REX_reg_reg_wide(dst, src),
7729              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7730   ins_pipe(ialu_reg_reg_alu0);
7731 %}
7732 
7733 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
7734 %{
7735   match(Set dst (MulL dst (LoadL src)));
7736   effect(KILL cr);
7737 
7738   ins_cost(350);
7739   format %{ "imulq   $dst, $src\t# long" %}
7740   opcode(0x0F, 0xAF);
7741   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
7742   ins_pipe(ialu_reg_mem_alu0);
7743 %}
7744 
7745 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
7746 %{
7747   match(Set dst (MulL (LoadL src) imm));
7748   effect(KILL cr);
7749 
7750   ins_cost(300);
7751   format %{ "imulq   $dst, $src, $imm\t# long" %}
7752   opcode(0x69); /* 69 /r id */
7753   ins_encode(REX_reg_mem_wide(dst, src),
7754              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7755   ins_pipe(ialu_reg_mem_alu0);
7756 %}
7757 
7758 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7759 %{
7760   match(Set dst (MulHiL src rax));
7761   effect(USE_KILL rax, KILL cr);
7762 
7763   ins_cost(300);
7764   format %{ "imulq   RDX:RAX, RAX, $src\t# mulhi" %}
7765   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7766   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7767   ins_pipe(ialu_reg_reg_alu0);
7768 %}
7769 
7770 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7771                    rFlagsReg cr)
7772 %{
7773   match(Set rax (DivI rax div));
7774   effect(KILL rdx, KILL cr);
7775 
7776   ins_cost(30*100+10*100); // XXX
7777   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7778             "jne,s   normal\n\t"
7779             "xorl    rdx, rdx\n\t"
7780             "cmpl    $div, -1\n\t"
7781             "je,s    done\n"
7782     "normal: cdql\n\t"
7783             "idivl   $div\n"
7784     "done:"        %}
7785   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7786   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7787   ins_pipe(ialu_reg_reg_alu0);
7788 %}
7789 
7790 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7791                    rFlagsReg cr)
7792 %{
7793   match(Set rax (DivL rax div));
7794   effect(KILL rdx, KILL cr);
7795 
7796   ins_cost(30*100+10*100); // XXX
7797   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7798             "cmpq    rax, rdx\n\t"
7799             "jne,s   normal\n\t"
7800             "xorl    rdx, rdx\n\t"
7801             "cmpq    $div, -1\n\t"
7802             "je,s    done\n"
7803     "normal: cdqq\n\t"
7804             "idivq   $div\n"
7805     "done:"        %}
7806   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7807   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7808   ins_pipe(ialu_reg_reg_alu0);
7809 %}
7810 
7811 // Integer DIVMOD with Register, both quotient and mod results
7812 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7813                              rFlagsReg cr)
7814 %{
7815   match(DivModI rax div);
7816   effect(KILL cr);
7817 
7818   ins_cost(30*100+10*100); // XXX
7819   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7820             "jne,s   normal\n\t"
7821             "xorl    rdx, rdx\n\t"
7822             "cmpl    $div, -1\n\t"
7823             "je,s    done\n"
7824     "normal: cdql\n\t"
7825             "idivl   $div\n"
7826     "done:"        %}
7827   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7828   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7829   ins_pipe(pipe_slow);
7830 %}
7831 
7832 // Long DIVMOD with Register, both quotient and mod results
7833 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7834                              rFlagsReg cr)
7835 %{
7836   match(DivModL rax div);
7837   effect(KILL cr);
7838 
7839   ins_cost(30*100+10*100); // XXX
7840   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7841             "cmpq    rax, rdx\n\t"
7842             "jne,s   normal\n\t"
7843             "xorl    rdx, rdx\n\t"
7844             "cmpq    $div, -1\n\t"
7845             "je,s    done\n"
7846     "normal: cdqq\n\t"
7847             "idivq   $div\n"
7848     "done:"        %}
7849   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7850   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7851   ins_pipe(pipe_slow);
7852 %}
7853 
7854 //----------- DivL-By-Constant-Expansions--------------------------------------
7855 // DivI cases are handled by the compiler
7856 
7857 // Magic constant, reciprocal of 10
7858 instruct loadConL_0x6666666666666667(rRegL dst)
7859 %{
7860   effect(DEF dst);
7861 
7862   format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
7863   ins_encode(load_immL(dst, 0x6666666666666667));
7864   ins_pipe(ialu_reg);
7865 %}
7866 
7867 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7868 %{
7869   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
7870 
7871   format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
7872   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7873   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7874   ins_pipe(ialu_reg_reg_alu0);
7875 %}
7876 
7877 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
7878 %{
7879   effect(USE_DEF dst, KILL cr);
7880 
7881   format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
7882   opcode(0xC1, 0x7); /* C1 /7 ib */
7883   ins_encode(reg_opc_imm_wide(dst, 0x3F));
7884   ins_pipe(ialu_reg);
7885 %}
7886 
7887 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
7888 %{
7889   effect(USE_DEF dst, KILL cr);
7890 
7891   format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
7892   opcode(0xC1, 0x7); /* C1 /7 ib */
7893   ins_encode(reg_opc_imm_wide(dst, 0x2));
7894   ins_pipe(ialu_reg);
7895 %}
7896 
7897 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
7898 %{
7899   match(Set dst (DivL src div));
7900 
7901   ins_cost((5+8)*100);
7902   expand %{
7903     rax_RegL rax;                     // Killed temp
7904     rFlagsReg cr;                     // Killed
7905     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
7906     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
7907     sarL_rReg_63(src, cr);            // sarq  src, 63
7908     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
7909     subL_rReg(dst, src, cr);          // subl  rdx, src
7910   %}
7911 %}
7912 
7913 //-----------------------------------------------------------------------------
7914 
7915 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
7916                    rFlagsReg cr)
7917 %{
7918   match(Set rdx (ModI rax div));
7919   effect(KILL rax, KILL cr);
7920 
7921   ins_cost(300); // XXX
7922   format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
7923             "jne,s   normal\n\t"
7924             "xorl    rdx, rdx\n\t"
7925             "cmpl    $div, -1\n\t"
7926             "je,s    done\n"
7927     "normal: cdql\n\t"
7928             "idivl   $div\n"
7929     "done:"        %}
7930   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7931   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7932   ins_pipe(ialu_reg_reg_alu0);
7933 %}
7934 
7935 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
7936                    rFlagsReg cr)
7937 %{
7938   match(Set rdx (ModL rax div));
7939   effect(KILL rax, KILL cr);
7940 
7941   ins_cost(300); // XXX
7942   format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
7943             "cmpq    rax, rdx\n\t"
7944             "jne,s   normal\n\t"
7945             "xorl    rdx, rdx\n\t"
7946             "cmpq    $div, -1\n\t"
7947             "je,s    done\n"
7948     "normal: cdqq\n\t"
7949             "idivq   $div\n"
7950     "done:"        %}
7951   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7952   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7953   ins_pipe(ialu_reg_reg_alu0);
7954 %}
7955 
7956 // Integer Shift Instructions
7957 // Shift Left by one
7958 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7959 %{
7960   match(Set dst (LShiftI dst shift));
7961   effect(KILL cr);
7962 
7963   format %{ "sall    $dst, $shift" %}
7964   opcode(0xD1, 0x4); /* D1 /4 */
7965   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7966   ins_pipe(ialu_reg);
7967 %}
7968 
7969 // Shift Left by one
7970 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7971 %{
7972   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7973   effect(KILL cr);
7974 
7975   format %{ "sall    $dst, $shift\t" %}
7976   opcode(0xD1, 0x4); /* D1 /4 */
7977   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7978   ins_pipe(ialu_mem_imm);
7979 %}
7980 
7981 // Shift Left by 8-bit immediate
7982 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7983 %{
7984   match(Set dst (LShiftI dst shift));
7985   effect(KILL cr);
7986 
7987   format %{ "sall    $dst, $shift" %}
7988   opcode(0xC1, 0x4); /* C1 /4 ib */
7989   ins_encode(reg_opc_imm(dst, shift));
7990   ins_pipe(ialu_reg);
7991 %}
7992 
7993 // Shift Left by 8-bit immediate
7994 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7995 %{
7996   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7997   effect(KILL cr);
7998 
7999   format %{ "sall    $dst, $shift" %}
8000   opcode(0xC1, 0x4); /* C1 /4 ib */
8001   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8002   ins_pipe(ialu_mem_imm);
8003 %}
8004 
8005 // Shift Left by variable
8006 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8007 %{
8008   match(Set dst (LShiftI dst shift));
8009   effect(KILL cr);
8010 
8011   format %{ "sall    $dst, $shift" %}
8012   opcode(0xD3, 0x4); /* D3 /4 */
8013   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8014   ins_pipe(ialu_reg_reg);
8015 %}
8016 
8017 // Shift Left by variable
8018 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8019 %{
8020   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
8021   effect(KILL cr);
8022 
8023   format %{ "sall    $dst, $shift" %}
8024   opcode(0xD3, 0x4); /* D3 /4 */
8025   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8026   ins_pipe(ialu_mem_reg);
8027 %}
8028 
8029 // Arithmetic shift right by one
8030 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
8031 %{
8032   match(Set dst (RShiftI dst shift));
8033   effect(KILL cr);
8034 
8035   format %{ "sarl    $dst, $shift" %}
8036   opcode(0xD1, 0x7); /* D1 /7 */
8037   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8038   ins_pipe(ialu_reg);
8039 %}
8040 
8041 // Arithmetic shift right by one
8042 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8043 %{
8044   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8045   effect(KILL cr);
8046 
8047   format %{ "sarl    $dst, $shift" %}
8048   opcode(0xD1, 0x7); /* D1 /7 */
8049   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8050   ins_pipe(ialu_mem_imm);
8051 %}
8052 
8053 // Arithmetic Shift Right by 8-bit immediate
8054 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8055 %{
8056   match(Set dst (RShiftI dst shift));
8057   effect(KILL cr);
8058 
8059   format %{ "sarl    $dst, $shift" %}
8060   opcode(0xC1, 0x7); /* C1 /7 ib */
8061   ins_encode(reg_opc_imm(dst, shift));
8062   ins_pipe(ialu_mem_imm);
8063 %}
8064 
8065 // Arithmetic Shift Right by 8-bit immediate
8066 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8067 %{
8068   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8069   effect(KILL cr);
8070 
8071   format %{ "sarl    $dst, $shift" %}
8072   opcode(0xC1, 0x7); /* C1 /7 ib */
8073   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8074   ins_pipe(ialu_mem_imm);
8075 %}
8076 
8077 // Arithmetic Shift Right by variable
8078 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8079 %{
8080   match(Set dst (RShiftI dst shift));
8081   effect(KILL cr);
8082 
8083   format %{ "sarl    $dst, $shift" %}
8084   opcode(0xD3, 0x7); /* D3 /7 */
8085   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8086   ins_pipe(ialu_reg_reg);
8087 %}
8088 
8089 // Arithmetic Shift Right by variable
8090 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8091 %{
8092   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8093   effect(KILL cr);
8094 
8095   format %{ "sarl    $dst, $shift" %}
8096   opcode(0xD3, 0x7); /* D3 /7 */
8097   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8098   ins_pipe(ialu_mem_reg);
8099 %}
8100 
8101 // Logical shift right by one
8102 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
8103 %{
8104   match(Set dst (URShiftI dst shift));
8105   effect(KILL cr);
8106 
8107   format %{ "shrl    $dst, $shift" %}
8108   opcode(0xD1, 0x5); /* D1 /5 */
8109   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8110   ins_pipe(ialu_reg);
8111 %}
8112 
8113 // Logical shift right by one
8114 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8115 %{
8116   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8117   effect(KILL cr);
8118 
8119   format %{ "shrl    $dst, $shift" %}
8120   opcode(0xD1, 0x5); /* D1 /5 */
8121   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8122   ins_pipe(ialu_mem_imm);
8123 %}
8124 
8125 // Logical Shift Right by 8-bit immediate
8126 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8127 %{
8128   match(Set dst (URShiftI dst shift));
8129   effect(KILL cr);
8130 
8131   format %{ "shrl    $dst, $shift" %}
8132   opcode(0xC1, 0x5); /* C1 /5 ib */
8133   ins_encode(reg_opc_imm(dst, shift));
8134   ins_pipe(ialu_reg);
8135 %}
8136 
8137 // Logical Shift Right by 8-bit immediate
8138 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8139 %{
8140   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8141   effect(KILL cr);
8142 
8143   format %{ "shrl    $dst, $shift" %}
8144   opcode(0xC1, 0x5); /* C1 /5 ib */
8145   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8146   ins_pipe(ialu_mem_imm);
8147 %}
8148 
8149 // Logical Shift Right by variable
8150 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8151 %{
8152   match(Set dst (URShiftI dst shift));
8153   effect(KILL cr);
8154 
8155   format %{ "shrl    $dst, $shift" %}
8156   opcode(0xD3, 0x5); /* D3 /5 */
8157   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8158   ins_pipe(ialu_reg_reg);
8159 %}
8160 
8161 // Logical Shift Right by variable
8162 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8163 %{
8164   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8165   effect(KILL cr);
8166 
8167   format %{ "shrl    $dst, $shift" %}
8168   opcode(0xD3, 0x5); /* D3 /5 */
8169   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8170   ins_pipe(ialu_mem_reg);
8171 %}
8172 
8173 // Long Shift Instructions
8174 // Shift Left by one
8175 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8176 %{
8177   match(Set dst (LShiftL dst shift));
8178   effect(KILL cr);
8179 
8180   format %{ "salq    $dst, $shift" %}
8181   opcode(0xD1, 0x4); /* D1 /4 */
8182   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8183   ins_pipe(ialu_reg);
8184 %}
8185 
8186 // Shift Left by one
8187 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8188 %{
8189   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8190   effect(KILL cr);
8191 
8192   format %{ "salq    $dst, $shift" %}
8193   opcode(0xD1, 0x4); /* D1 /4 */
8194   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8195   ins_pipe(ialu_mem_imm);
8196 %}
8197 
8198 // Shift Left by 8-bit immediate
8199 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8200 %{
8201   match(Set dst (LShiftL dst shift));
8202   effect(KILL cr);
8203 
8204   format %{ "salq    $dst, $shift" %}
8205   opcode(0xC1, 0x4); /* C1 /4 ib */
8206   ins_encode(reg_opc_imm_wide(dst, shift));
8207   ins_pipe(ialu_reg);
8208 %}
8209 
8210 // Shift Left by 8-bit immediate
8211 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8212 %{
8213   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8214   effect(KILL cr);
8215 
8216   format %{ "salq    $dst, $shift" %}
8217   opcode(0xC1, 0x4); /* C1 /4 ib */
8218   ins_encode(REX_mem_wide(dst), OpcP,
8219              RM_opc_mem(secondary, dst), Con8or32(shift));
8220   ins_pipe(ialu_mem_imm);
8221 %}
8222 
8223 // Shift Left by variable
8224 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8225 %{
8226   match(Set dst (LShiftL dst shift));
8227   effect(KILL cr);
8228 
8229   format %{ "salq    $dst, $shift" %}
8230   opcode(0xD3, 0x4); /* D3 /4 */
8231   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8232   ins_pipe(ialu_reg_reg);
8233 %}
8234 
8235 // Shift Left by variable
8236 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8237 %{
8238   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8239   effect(KILL cr);
8240 
8241   format %{ "salq    $dst, $shift" %}
8242   opcode(0xD3, 0x4); /* D3 /4 */
8243   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8244   ins_pipe(ialu_mem_reg);
8245 %}
8246 
8247 // Arithmetic shift right by one
8248 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8249 %{
8250   match(Set dst (RShiftL dst shift));
8251   effect(KILL cr);
8252 
8253   format %{ "sarq    $dst, $shift" %}
8254   opcode(0xD1, 0x7); /* D1 /7 */
8255   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8256   ins_pipe(ialu_reg);
8257 %}
8258 
8259 // Arithmetic shift right by one
8260 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8261 %{
8262   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8263   effect(KILL cr);
8264 
8265   format %{ "sarq    $dst, $shift" %}
8266   opcode(0xD1, 0x7); /* D1 /7 */
8267   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8268   ins_pipe(ialu_mem_imm);
8269 %}
8270 
8271 // Arithmetic Shift Right by 8-bit immediate
8272 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8273 %{
8274   match(Set dst (RShiftL dst shift));
8275   effect(KILL cr);
8276 
8277   format %{ "sarq    $dst, $shift" %}
8278   opcode(0xC1, 0x7); /* C1 /7 ib */
8279   ins_encode(reg_opc_imm_wide(dst, shift));
8280   ins_pipe(ialu_mem_imm);
8281 %}
8282 
8283 // Arithmetic Shift Right by 8-bit immediate
8284 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8285 %{
8286   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8287   effect(KILL cr);
8288 
8289   format %{ "sarq    $dst, $shift" %}
8290   opcode(0xC1, 0x7); /* C1 /7 ib */
8291   ins_encode(REX_mem_wide(dst), OpcP,
8292              RM_opc_mem(secondary, dst), Con8or32(shift));
8293   ins_pipe(ialu_mem_imm);
8294 %}
8295 
8296 // Arithmetic Shift Right by variable
8297 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8298 %{
8299   match(Set dst (RShiftL dst shift));
8300   effect(KILL cr);
8301 
8302   format %{ "sarq    $dst, $shift" %}
8303   opcode(0xD3, 0x7); /* D3 /7 */
8304   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8305   ins_pipe(ialu_reg_reg);
8306 %}
8307 
8308 // Arithmetic Shift Right by variable
8309 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8310 %{
8311   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8312   effect(KILL cr);
8313 
8314   format %{ "sarq    $dst, $shift" %}
8315   opcode(0xD3, 0x7); /* D3 /7 */
8316   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8317   ins_pipe(ialu_mem_reg);
8318 %}
8319 
8320 // Logical shift right by one
8321 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8322 %{
8323   match(Set dst (URShiftL dst shift));
8324   effect(KILL cr);
8325 
8326   format %{ "shrq    $dst, $shift" %}
8327   opcode(0xD1, 0x5); /* D1 /5 */
8328   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
8329   ins_pipe(ialu_reg);
8330 %}
8331 
8332 // Logical shift right by one
8333 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8334 %{
8335   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8336   effect(KILL cr);
8337 
8338   format %{ "shrq    $dst, $shift" %}
8339   opcode(0xD1, 0x5); /* D1 /5 */
8340   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8341   ins_pipe(ialu_mem_imm);
8342 %}
8343 
8344 // Logical Shift Right by 8-bit immediate
8345 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8346 %{
8347   match(Set dst (URShiftL dst shift));
8348   effect(KILL cr);
8349 
8350   format %{ "shrq    $dst, $shift" %}
8351   opcode(0xC1, 0x5); /* C1 /5 ib */
8352   ins_encode(reg_opc_imm_wide(dst, shift));
8353   ins_pipe(ialu_reg);
8354 %}
8355 
8356 
8357 // Logical Shift Right by 8-bit immediate
8358 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8359 %{
8360   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8361   effect(KILL cr);
8362 
8363   format %{ "shrq    $dst, $shift" %}
8364   opcode(0xC1, 0x5); /* C1 /5 ib */
8365   ins_encode(REX_mem_wide(dst), OpcP,
8366              RM_opc_mem(secondary, dst), Con8or32(shift));
8367   ins_pipe(ialu_mem_imm);
8368 %}
8369 
8370 // Logical Shift Right by variable
8371 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8372 %{
8373   match(Set dst (URShiftL dst shift));
8374   effect(KILL cr);
8375 
8376   format %{ "shrq    $dst, $shift" %}
8377   opcode(0xD3, 0x5); /* D3 /5 */
8378   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8379   ins_pipe(ialu_reg_reg);
8380 %}
8381 
8382 // Logical Shift Right by variable
8383 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8384 %{
8385   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8386   effect(KILL cr);
8387 
8388   format %{ "shrq    $dst, $shift" %}
8389   opcode(0xD3, 0x5); /* D3 /5 */
8390   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8391   ins_pipe(ialu_mem_reg);
8392 %}
8393 
8394 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
8395 // This idiom is used by the compiler for the i2b bytecode.
8396 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
8397 %{
8398   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
8399 
8400   format %{ "movsbl  $dst, $src\t# i2b" %}
8401   opcode(0x0F, 0xBE);
8402   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8403   ins_pipe(ialu_reg_reg);
8404 %}
8405 
8406 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
8407 // This idiom is used by the compiler the i2s bytecode.
8408 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
8409 %{
8410   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
8411 
8412   format %{ "movswl  $dst, $src\t# i2s" %}
8413   opcode(0x0F, 0xBF);
8414   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8415   ins_pipe(ialu_reg_reg);
8416 %}
8417 
8418 // ROL/ROR instructions
8419 
8420 // ROL expand
8421 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
8422   effect(KILL cr, USE_DEF dst);
8423 
8424   format %{ "roll    $dst" %}
8425   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8426   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8427   ins_pipe(ialu_reg);
8428 %}
8429 
8430 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
8431   effect(USE_DEF dst, USE shift, KILL cr);
8432 
8433   format %{ "roll    $dst, $shift" %}
8434   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8435   ins_encode( reg_opc_imm(dst, shift) );
8436   ins_pipe(ialu_reg);
8437 %}
8438 
8439 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8440 %{
8441   effect(USE_DEF dst, USE shift, KILL cr);
8442 
8443   format %{ "roll    $dst, $shift" %}
8444   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8445   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8446   ins_pipe(ialu_reg_reg);
8447 %}
8448 // end of ROL expand
8449 
8450 // Rotate Left by one
8451 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8452 %{
8453   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8454 
8455   expand %{
8456     rolI_rReg_imm1(dst, cr);
8457   %}
8458 %}
8459 
8460 // Rotate Left by 8-bit immediate
8461 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8462 %{
8463   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8464   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8465 
8466   expand %{
8467     rolI_rReg_imm8(dst, lshift, cr);
8468   %}
8469 %}
8470 
8471 // Rotate Left by variable
8472 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8473 %{
8474   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
8475 
8476   expand %{
8477     rolI_rReg_CL(dst, shift, cr);
8478   %}
8479 %}
8480 
8481 // Rotate Left by variable
8482 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8483 %{
8484   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
8485 
8486   expand %{
8487     rolI_rReg_CL(dst, shift, cr);
8488   %}
8489 %}
8490 
8491 // ROR expand
8492 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
8493 %{
8494   effect(USE_DEF dst, KILL cr);
8495 
8496   format %{ "rorl    $dst" %}
8497   opcode(0xD1, 0x1); /* D1 /1 */
8498   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8499   ins_pipe(ialu_reg);
8500 %}
8501 
8502 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
8503 %{
8504   effect(USE_DEF dst, USE shift, KILL cr);
8505 
8506   format %{ "rorl    $dst, $shift" %}
8507   opcode(0xC1, 0x1); /* C1 /1 ib */
8508   ins_encode(reg_opc_imm(dst, shift));
8509   ins_pipe(ialu_reg);
8510 %}
8511 
8512 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8513 %{
8514   effect(USE_DEF dst, USE shift, KILL cr);
8515 
8516   format %{ "rorl    $dst, $shift" %}
8517   opcode(0xD3, 0x1); /* D3 /1 */
8518   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8519   ins_pipe(ialu_reg_reg);
8520 %}
8521 // end of ROR expand
8522 
8523 // Rotate Right by one
8524 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8525 %{
8526   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8527 
8528   expand %{
8529     rorI_rReg_imm1(dst, cr);
8530   %}
8531 %}
8532 
8533 // Rotate Right by 8-bit immediate
8534 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8535 %{
8536   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8537   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8538 
8539   expand %{
8540     rorI_rReg_imm8(dst, rshift, cr);
8541   %}
8542 %}
8543 
8544 // Rotate Right by variable
8545 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8546 %{
8547   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
8548 
8549   expand %{
8550     rorI_rReg_CL(dst, shift, cr);
8551   %}
8552 %}
8553 
8554 // Rotate Right by variable
8555 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8556 %{
8557   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
8558 
8559   expand %{
8560     rorI_rReg_CL(dst, shift, cr);
8561   %}
8562 %}
8563 
8564 // for long rotate
8565 // ROL expand
8566 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
8567   effect(USE_DEF dst, KILL cr);
8568 
8569   format %{ "rolq    $dst" %}
8570   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8571   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8572   ins_pipe(ialu_reg);
8573 %}
8574 
8575 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
8576   effect(USE_DEF dst, USE shift, KILL cr);
8577 
8578   format %{ "rolq    $dst, $shift" %}
8579   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8580   ins_encode( reg_opc_imm_wide(dst, shift) );
8581   ins_pipe(ialu_reg);
8582 %}
8583 
8584 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8585 %{
8586   effect(USE_DEF dst, USE shift, KILL cr);
8587 
8588   format %{ "rolq    $dst, $shift" %}
8589   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8590   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8591   ins_pipe(ialu_reg_reg);
8592 %}
8593 // end of ROL expand
8594 
8595 // Rotate Left by one
8596 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8597 %{
8598   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8599 
8600   expand %{
8601     rolL_rReg_imm1(dst, cr);
8602   %}
8603 %}
8604 
8605 // Rotate Left by 8-bit immediate
8606 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8607 %{
8608   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8609   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8610 
8611   expand %{
8612     rolL_rReg_imm8(dst, lshift, cr);
8613   %}
8614 %}
8615 
8616 // Rotate Left by variable
8617 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8618 %{
8619   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
8620 
8621   expand %{
8622     rolL_rReg_CL(dst, shift, cr);
8623   %}
8624 %}
8625 
8626 // Rotate Left by variable
8627 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8628 %{
8629   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
8630 
8631   expand %{
8632     rolL_rReg_CL(dst, shift, cr);
8633   %}
8634 %}
8635 
8636 // ROR expand
8637 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
8638 %{
8639   effect(USE_DEF dst, KILL cr);
8640 
8641   format %{ "rorq    $dst" %}
8642   opcode(0xD1, 0x1); /* D1 /1 */
8643   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8644   ins_pipe(ialu_reg);
8645 %}
8646 
8647 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
8648 %{
8649   effect(USE_DEF dst, USE shift, KILL cr);
8650 
8651   format %{ "rorq    $dst, $shift" %}
8652   opcode(0xC1, 0x1); /* C1 /1 ib */
8653   ins_encode(reg_opc_imm_wide(dst, shift));
8654   ins_pipe(ialu_reg);
8655 %}
8656 
8657 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8658 %{
8659   effect(USE_DEF dst, USE shift, KILL cr);
8660 
8661   format %{ "rorq    $dst, $shift" %}
8662   opcode(0xD3, 0x1); /* D3 /1 */
8663   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8664   ins_pipe(ialu_reg_reg);
8665 %}
8666 // end of ROR expand
8667 
8668 // Rotate Right by one
8669 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8670 %{
8671   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8672 
8673   expand %{
8674     rorL_rReg_imm1(dst, cr);
8675   %}
8676 %}
8677 
8678 // Rotate Right by 8-bit immediate
8679 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8680 %{
8681   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8682   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8683 
8684   expand %{
8685     rorL_rReg_imm8(dst, rshift, cr);
8686   %}
8687 %}
8688 
8689 // Rotate Right by variable
8690 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8691 %{
8692   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
8693 
8694   expand %{
8695     rorL_rReg_CL(dst, shift, cr);
8696   %}
8697 %}
8698 
8699 // Rotate Right by variable
8700 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8701 %{
8702   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
8703 
8704   expand %{
8705     rorL_rReg_CL(dst, shift, cr);
8706   %}
8707 %}
8708 
8709 // Logical Instructions
8710 
8711 // Integer Logical Instructions
8712 
8713 // And Instructions
8714 // And Register with Register
8715 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8716 %{
8717   match(Set dst (AndI dst src));
8718   effect(KILL cr);
8719 
8720   format %{ "andl    $dst, $src\t# int" %}
8721   opcode(0x23);
8722   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8723   ins_pipe(ialu_reg_reg);
8724 %}
8725 
8726 // And Register with Immediate 255
8727 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
8728 %{
8729   match(Set dst (AndI dst src));
8730 
8731   format %{ "movzbl  $dst, $dst\t# int &amp; 0xFF" %}
8732   opcode(0x0F, 0xB6);
8733   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8734   ins_pipe(ialu_reg);
8735 %}
8736 
8737 // And Register with Immediate 255 and promote to long
8738 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
8739 %{
8740   match(Set dst (ConvI2L (AndI src mask)));
8741 
8742   format %{ "movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long" %}
8743   opcode(0x0F, 0xB6);
8744   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8745   ins_pipe(ialu_reg);
8746 %}
8747 
8748 // And Register with Immediate 65535
8749 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
8750 %{
8751   match(Set dst (AndI dst src));
8752 
8753   format %{ "movzwl  $dst, $dst\t# int &amp; 0xFFFF" %}
8754   opcode(0x0F, 0xB7);
8755   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8756   ins_pipe(ialu_reg);
8757 %}
8758 
8759 // And Register with Immediate 65535 and promote to long
8760 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
8761 %{
8762   match(Set dst (ConvI2L (AndI src mask)));
8763 
8764   format %{ "movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long" %}
8765   opcode(0x0F, 0xB7);
8766   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8767   ins_pipe(ialu_reg);
8768 %}
8769 
8770 // And Register with Immediate
8771 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8772 %{
8773   match(Set dst (AndI dst src));
8774   effect(KILL cr);
8775 
8776   format %{ "andl    $dst, $src\t# int" %}
8777   opcode(0x81, 0x04); /* Opcode 81 /4 */
8778   ins_encode(OpcSErm(dst, src), Con8or32(src));
8779   ins_pipe(ialu_reg);
8780 %}
8781 
8782 // And Register with Memory
8783 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8784 %{
8785   match(Set dst (AndI dst (LoadI src)));
8786   effect(KILL cr);
8787 
8788   ins_cost(125);
8789   format %{ "andl    $dst, $src\t# int" %}
8790   opcode(0x23);
8791   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8792   ins_pipe(ialu_reg_mem);
8793 %}
8794 
8795 // And Memory with Register
8796 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8797 %{
8798   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8799   effect(KILL cr);
8800 
8801   ins_cost(150);
8802   format %{ "andl    $dst, $src\t# int" %}
8803   opcode(0x21); /* Opcode 21 /r */
8804   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8805   ins_pipe(ialu_mem_reg);
8806 %}
8807 
8808 // And Memory with Immediate
8809 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
8810 %{
8811   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8812   effect(KILL cr);
8813 
8814   ins_cost(125);
8815   format %{ "andl    $dst, $src\t# int" %}
8816   opcode(0x81, 0x4); /* Opcode 81 /4 id */
8817   ins_encode(REX_mem(dst), OpcSE(src),
8818              RM_opc_mem(secondary, dst), Con8or32(src));
8819   ins_pipe(ialu_mem_imm);
8820 %}
8821 
8822 // BMI1 instructions
8823 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
8824   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
8825   predicate(UseBMI1Instructions);
8826   effect(KILL cr);
8827 
8828   ins_cost(125);
8829   format %{ "andnl  $dst, $src1, $src2" %}
8830 
8831   ins_encode %{
8832     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
8833   %}
8834   ins_pipe(ialu_reg_mem);
8835 %}
8836 
8837 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
8838   match(Set dst (AndI (XorI src1 minus_1) src2));
8839   predicate(UseBMI1Instructions);
8840   effect(KILL cr);
8841 
8842   format %{ "andnl  $dst, $src1, $src2" %}
8843 
8844   ins_encode %{
8845     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
8846   %}
8847   ins_pipe(ialu_reg);
8848 %}
8849 
8850 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
8851   match(Set dst (AndI (SubI imm_zero src) src));
8852   predicate(UseBMI1Instructions);
8853   effect(KILL cr);
8854 
8855   format %{ "blsil  $dst, $src" %}
8856 
8857   ins_encode %{
8858     __ blsil($dst$$Register, $src$$Register);
8859   %}
8860   ins_pipe(ialu_reg);
8861 %}
8862 
8863 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
8864   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
8865   predicate(UseBMI1Instructions);
8866   effect(KILL cr);
8867 
8868   ins_cost(125);
8869   format %{ "blsil  $dst, $src" %}
8870 
8871   ins_encode %{
8872     __ blsil($dst$$Register, $src$$Address);
8873   %}
8874   ins_pipe(ialu_reg_mem);
8875 %}
8876 
8877 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8878 %{
8879   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
8880   predicate(UseBMI1Instructions);
8881   effect(KILL cr);
8882 
8883   ins_cost(125);
8884   format %{ "blsmskl $dst, $src" %}
8885 
8886   ins_encode %{
8887     __ blsmskl($dst$$Register, $src$$Address);
8888   %}
8889   ins_pipe(ialu_reg_mem);
8890 %}
8891 
8892 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8893 %{
8894   match(Set dst (XorI (AddI src minus_1) src));
8895   predicate(UseBMI1Instructions);
8896   effect(KILL cr);
8897 
8898   format %{ "blsmskl $dst, $src" %}
8899 
8900   ins_encode %{
8901     __ blsmskl($dst$$Register, $src$$Register);
8902   %}
8903 
8904   ins_pipe(ialu_reg);
8905 %}
8906 
8907 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8908 %{
8909   match(Set dst (AndI (AddI src minus_1) src) );
8910   predicate(UseBMI1Instructions);
8911   effect(KILL cr);
8912 
8913   format %{ "blsrl  $dst, $src" %}
8914 
8915   ins_encode %{
8916     __ blsrl($dst$$Register, $src$$Register);
8917   %}
8918 
8919   ins_pipe(ialu_reg_mem);
8920 %}
8921 
8922 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8923 %{
8924   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
8925   predicate(UseBMI1Instructions);
8926   effect(KILL cr);
8927 
8928   ins_cost(125);
8929   format %{ "blsrl  $dst, $src" %}
8930 
8931   ins_encode %{
8932     __ blsrl($dst$$Register, $src$$Address);
8933   %}
8934 
8935   ins_pipe(ialu_reg);
8936 %}
8937 
8938 // Or Instructions
8939 // Or Register with Register
8940 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8941 %{
8942   match(Set dst (OrI dst src));
8943   effect(KILL cr);
8944 
8945   format %{ "orl     $dst, $src\t# int" %}
8946   opcode(0x0B);
8947   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8948   ins_pipe(ialu_reg_reg);
8949 %}
8950 
8951 // Or Register with Immediate
8952 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8953 %{
8954   match(Set dst (OrI dst src));
8955   effect(KILL cr);
8956 
8957   format %{ "orl     $dst, $src\t# int" %}
8958   opcode(0x81, 0x01); /* Opcode 81 /1 id */
8959   ins_encode(OpcSErm(dst, src), Con8or32(src));
8960   ins_pipe(ialu_reg);
8961 %}
8962 
8963 // Or Register with Memory
8964 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8965 %{
8966   match(Set dst (OrI dst (LoadI src)));
8967   effect(KILL cr);
8968 
8969   ins_cost(125);
8970   format %{ "orl     $dst, $src\t# int" %}
8971   opcode(0x0B);
8972   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8973   ins_pipe(ialu_reg_mem);
8974 %}
8975 
8976 // Or Memory with Register
8977 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8978 %{
8979   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8980   effect(KILL cr);
8981 
8982   ins_cost(150);
8983   format %{ "orl     $dst, $src\t# int" %}
8984   opcode(0x09); /* Opcode 09 /r */
8985   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8986   ins_pipe(ialu_mem_reg);
8987 %}
8988 
8989 // Or Memory with Immediate
8990 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
8991 %{
8992   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8993   effect(KILL cr);
8994 
8995   ins_cost(125);
8996   format %{ "orl     $dst, $src\t# int" %}
8997   opcode(0x81, 0x1); /* Opcode 81 /1 id */
8998   ins_encode(REX_mem(dst), OpcSE(src),
8999              RM_opc_mem(secondary, dst), Con8or32(src));
9000   ins_pipe(ialu_mem_imm);
9001 %}
9002 
9003 // Xor Instructions
9004 // Xor Register with Register
9005 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
9006 %{
9007   match(Set dst (XorI dst src));
9008   effect(KILL cr);
9009 
9010   format %{ "xorl    $dst, $src\t# int" %}
9011   opcode(0x33);
9012   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
9013   ins_pipe(ialu_reg_reg);
9014 %}
9015 
9016 // Xor Register with Immediate -1
9017 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
9018   match(Set dst (XorI dst imm));
9019 
9020   format %{ "not    $dst" %}
9021   ins_encode %{
9022      __ notl($dst$$Register);
9023   %}
9024   ins_pipe(ialu_reg);
9025 %}
9026 
9027 // Xor Register with Immediate
9028 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
9029 %{
9030   match(Set dst (XorI dst src));
9031   effect(KILL cr);
9032 
9033   format %{ "xorl    $dst, $src\t# int" %}
9034   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9035   ins_encode(OpcSErm(dst, src), Con8or32(src));
9036   ins_pipe(ialu_reg);
9037 %}
9038 
9039 // Xor Register with Memory
9040 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
9041 %{
9042   match(Set dst (XorI dst (LoadI src)));
9043   effect(KILL cr);
9044 
9045   ins_cost(125);
9046   format %{ "xorl    $dst, $src\t# int" %}
9047   opcode(0x33);
9048   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
9049   ins_pipe(ialu_reg_mem);
9050 %}
9051 
9052 // Xor Memory with Register
9053 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
9054 %{
9055   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9056   effect(KILL cr);
9057 
9058   ins_cost(150);
9059   format %{ "xorl    $dst, $src\t# int" %}
9060   opcode(0x31); /* Opcode 31 /r */
9061   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
9062   ins_pipe(ialu_mem_reg);
9063 %}
9064 
9065 // Xor Memory with Immediate
9066 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
9067 %{
9068   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9069   effect(KILL cr);
9070 
9071   ins_cost(125);
9072   format %{ "xorl    $dst, $src\t# int" %}
9073   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9074   ins_encode(REX_mem(dst), OpcSE(src),
9075              RM_opc_mem(secondary, dst), Con8or32(src));
9076   ins_pipe(ialu_mem_imm);
9077 %}
9078 
9079 
9080 // Long Logical Instructions
9081 
9082 // And Instructions
9083 // And Register with Register
9084 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9085 %{
9086   match(Set dst (AndL dst src));
9087   effect(KILL cr);
9088 
9089   format %{ "andq    $dst, $src\t# long" %}
9090   opcode(0x23);
9091   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9092   ins_pipe(ialu_reg_reg);
9093 %}
9094 
9095 // And Register with Immediate 255
9096 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
9097 %{
9098   match(Set dst (AndL dst src));
9099 
9100   format %{ "movzbq  $dst, $dst\t# long &amp; 0xFF" %}
9101   opcode(0x0F, 0xB6);
9102   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9103   ins_pipe(ialu_reg);
9104 %}
9105 
9106 // And Register with Immediate 65535
9107 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
9108 %{
9109   match(Set dst (AndL dst src));
9110 
9111   format %{ "movzwq  $dst, $dst\t# long &amp; 0xFFFF" %}
9112   opcode(0x0F, 0xB7);
9113   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9114   ins_pipe(ialu_reg);
9115 %}
9116 
9117 // And Register with Immediate
9118 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9119 %{
9120   match(Set dst (AndL dst src));
9121   effect(KILL cr);
9122 
9123   format %{ "andq    $dst, $src\t# long" %}
9124   opcode(0x81, 0x04); /* Opcode 81 /4 */
9125   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9126   ins_pipe(ialu_reg);
9127 %}
9128 
9129 // And Register with Memory
9130 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9131 %{
9132   match(Set dst (AndL dst (LoadL src)));
9133   effect(KILL cr);
9134 
9135   ins_cost(125);
9136   format %{ "andq    $dst, $src\t# long" %}
9137   opcode(0x23);
9138   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9139   ins_pipe(ialu_reg_mem);
9140 %}
9141 
9142 // And Memory with Register
9143 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9144 %{
9145   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9146   effect(KILL cr);
9147 
9148   ins_cost(150);
9149   format %{ "andq    $dst, $src\t# long" %}
9150   opcode(0x21); /* Opcode 21 /r */
9151   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9152   ins_pipe(ialu_mem_reg);
9153 %}
9154 
9155 // And Memory with Immediate
9156 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9157 %{
9158   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9159   effect(KILL cr);
9160 
9161   ins_cost(125);
9162   format %{ "andq    $dst, $src\t# long" %}
9163   opcode(0x81, 0x4); /* Opcode 81 /4 id */
9164   ins_encode(REX_mem_wide(dst), OpcSE(src),
9165              RM_opc_mem(secondary, dst), Con8or32(src));
9166   ins_pipe(ialu_mem_imm);
9167 %}
9168 
9169 // BMI1 instructions
9170 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
9171   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
9172   predicate(UseBMI1Instructions);
9173   effect(KILL cr);
9174 
9175   ins_cost(125);
9176   format %{ "andnq  $dst, $src1, $src2" %}
9177 
9178   ins_encode %{
9179     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
9180   %}
9181   ins_pipe(ialu_reg_mem);
9182 %}
9183 
9184 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
9185   match(Set dst (AndL (XorL src1 minus_1) src2));
9186   predicate(UseBMI1Instructions);
9187   effect(KILL cr);
9188 
9189   format %{ "andnq  $dst, $src1, $src2" %}
9190 
9191   ins_encode %{
9192   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
9193   %}
9194   ins_pipe(ialu_reg_mem);
9195 %}
9196 
9197 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
9198   match(Set dst (AndL (SubL imm_zero src) src));
9199   predicate(UseBMI1Instructions);
9200   effect(KILL cr);
9201 
9202   format %{ "blsiq  $dst, $src" %}
9203 
9204   ins_encode %{
9205     __ blsiq($dst$$Register, $src$$Register);
9206   %}
9207   ins_pipe(ialu_reg);
9208 %}
9209 
9210 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
9211   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
9212   predicate(UseBMI1Instructions);
9213   effect(KILL cr);
9214 
9215   ins_cost(125);
9216   format %{ "blsiq  $dst, $src" %}
9217 
9218   ins_encode %{
9219     __ blsiq($dst$$Register, $src$$Address);
9220   %}
9221   ins_pipe(ialu_reg_mem);
9222 %}
9223 
9224 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9225 %{
9226   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
9227   predicate(UseBMI1Instructions);
9228   effect(KILL cr);
9229 
9230   ins_cost(125);
9231   format %{ "blsmskq $dst, $src" %}
9232 
9233   ins_encode %{
9234     __ blsmskq($dst$$Register, $src$$Address);
9235   %}
9236   ins_pipe(ialu_reg_mem);
9237 %}
9238 
9239 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9240 %{
9241   match(Set dst (XorL (AddL src minus_1) src));
9242   predicate(UseBMI1Instructions);
9243   effect(KILL cr);
9244 
9245   format %{ "blsmskq $dst, $src" %}
9246 
9247   ins_encode %{
9248     __ blsmskq($dst$$Register, $src$$Register);
9249   %}
9250 
9251   ins_pipe(ialu_reg);
9252 %}
9253 
9254 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9255 %{
9256   match(Set dst (AndL (AddL src minus_1) src) );
9257   predicate(UseBMI1Instructions);
9258   effect(KILL cr);
9259 
9260   format %{ "blsrq  $dst, $src" %}
9261 
9262   ins_encode %{
9263     __ blsrq($dst$$Register, $src$$Register);
9264   %}
9265 
9266   ins_pipe(ialu_reg);
9267 %}
9268 
9269 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9270 %{
9271   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
9272   predicate(UseBMI1Instructions);
9273   effect(KILL cr);
9274 
9275   ins_cost(125);
9276   format %{ "blsrq  $dst, $src" %}
9277 
9278   ins_encode %{
9279     __ blsrq($dst$$Register, $src$$Address);
9280   %}
9281 
9282   ins_pipe(ialu_reg);
9283 %}
9284 
9285 // Or Instructions
9286 // Or Register with Register
9287 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9288 %{
9289   match(Set dst (OrL dst src));
9290   effect(KILL cr);
9291 
9292   format %{ "orq     $dst, $src\t# long" %}
9293   opcode(0x0B);
9294   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9295   ins_pipe(ialu_reg_reg);
9296 %}
9297 
9298 // Use any_RegP to match R15 (TLS register) without spilling.
9299 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
9300   match(Set dst (OrL dst (CastP2X src)));
9301   effect(KILL cr);
9302 
9303   format %{ "orq     $dst, $src\t# long" %}
9304   opcode(0x0B);
9305   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9306   ins_pipe(ialu_reg_reg);
9307 %}
9308 
9309 
9310 // Or Register with Immediate
9311 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9312 %{
9313   match(Set dst (OrL dst src));
9314   effect(KILL cr);
9315 
9316   format %{ "orq     $dst, $src\t# long" %}
9317   opcode(0x81, 0x01); /* Opcode 81 /1 id */
9318   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9319   ins_pipe(ialu_reg);
9320 %}
9321 
9322 // Or Register with Memory
9323 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9324 %{
9325   match(Set dst (OrL dst (LoadL src)));
9326   effect(KILL cr);
9327 
9328   ins_cost(125);
9329   format %{ "orq     $dst, $src\t# long" %}
9330   opcode(0x0B);
9331   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9332   ins_pipe(ialu_reg_mem);
9333 %}
9334 
9335 // Or Memory with Register
9336 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9337 %{
9338   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9339   effect(KILL cr);
9340 
9341   ins_cost(150);
9342   format %{ "orq     $dst, $src\t# long" %}
9343   opcode(0x09); /* Opcode 09 /r */
9344   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9345   ins_pipe(ialu_mem_reg);
9346 %}
9347 
9348 // Or Memory with Immediate
9349 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9350 %{
9351   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9352   effect(KILL cr);
9353 
9354   ins_cost(125);
9355   format %{ "orq     $dst, $src\t# long" %}
9356   opcode(0x81, 0x1); /* Opcode 81 /1 id */
9357   ins_encode(REX_mem_wide(dst), OpcSE(src),
9358              RM_opc_mem(secondary, dst), Con8or32(src));
9359   ins_pipe(ialu_mem_imm);
9360 %}
9361 
9362 // Xor Instructions
9363 // Xor Register with Register
9364 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9365 %{
9366   match(Set dst (XorL dst src));
9367   effect(KILL cr);
9368 
9369   format %{ "xorq    $dst, $src\t# long" %}
9370   opcode(0x33);
9371   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9372   ins_pipe(ialu_reg_reg);
9373 %}
9374 
9375 // Xor Register with Immediate -1
9376 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
9377   match(Set dst (XorL dst imm));
9378 
9379   format %{ "notq   $dst" %}
9380   ins_encode %{
9381      __ notq($dst$$Register);
9382   %}
9383   ins_pipe(ialu_reg);
9384 %}
9385 
9386 // Xor Register with Immediate
9387 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9388 %{
9389   match(Set dst (XorL dst src));
9390   effect(KILL cr);
9391 
9392   format %{ "xorq    $dst, $src\t# long" %}
9393   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9394   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9395   ins_pipe(ialu_reg);
9396 %}
9397 
9398 // Xor Register with Memory
9399 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9400 %{
9401   match(Set dst (XorL dst (LoadL src)));
9402   effect(KILL cr);
9403 
9404   ins_cost(125);
9405   format %{ "xorq    $dst, $src\t# long" %}
9406   opcode(0x33);
9407   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9408   ins_pipe(ialu_reg_mem);
9409 %}
9410 
9411 // Xor Memory with Register
9412 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9413 %{
9414   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9415   effect(KILL cr);
9416 
9417   ins_cost(150);
9418   format %{ "xorq    $dst, $src\t# long" %}
9419   opcode(0x31); /* Opcode 31 /r */
9420   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9421   ins_pipe(ialu_mem_reg);
9422 %}
9423 
9424 // Xor Memory with Immediate
9425 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9426 %{
9427   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9428   effect(KILL cr);
9429 
9430   ins_cost(125);
9431   format %{ "xorq    $dst, $src\t# long" %}
9432   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9433   ins_encode(REX_mem_wide(dst), OpcSE(src),
9434              RM_opc_mem(secondary, dst), Con8or32(src));
9435   ins_pipe(ialu_mem_imm);
9436 %}
9437 
9438 // Convert Int to Boolean
9439 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
9440 %{
9441   match(Set dst (Conv2B src));
9442   effect(KILL cr);
9443 
9444   format %{ "testl   $src, $src\t# ci2b\n\t"
9445             "setnz   $dst\n\t"
9446             "movzbl  $dst, $dst" %}
9447   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
9448              setNZ_reg(dst),
9449              REX_reg_breg(dst, dst), // movzbl
9450              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9451   ins_pipe(pipe_slow); // XXX
9452 %}
9453 
9454 // Convert Pointer to Boolean
9455 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
9456 %{
9457   match(Set dst (Conv2B src));
9458   effect(KILL cr);
9459 
9460   format %{ "testq   $src, $src\t# cp2b\n\t"
9461             "setnz   $dst\n\t"
9462             "movzbl  $dst, $dst" %}
9463   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
9464              setNZ_reg(dst),
9465              REX_reg_breg(dst, dst), // movzbl
9466              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9467   ins_pipe(pipe_slow); // XXX
9468 %}
9469 
9470 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
9471 %{
9472   match(Set dst (CmpLTMask p q));
9473   effect(KILL cr);
9474 
9475   ins_cost(400);
9476   format %{ "cmpl    $p, $q\t# cmpLTMask\n\t"
9477             "setlt   $dst\n\t"
9478             "movzbl  $dst, $dst\n\t"
9479             "negl    $dst" %}
9480   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
9481              setLT_reg(dst),
9482              REX_reg_breg(dst, dst), // movzbl
9483              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
9484              neg_reg(dst));
9485   ins_pipe(pipe_slow);
9486 %}
9487 
9488 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
9489 %{
9490   match(Set dst (CmpLTMask dst zero));
9491   effect(KILL cr);
9492 
9493   ins_cost(100);
9494   format %{ "sarl    $dst, #31\t# cmpLTMask0" %}
9495   ins_encode %{
9496   __ sarl($dst$$Register, 31);
9497   %}
9498   ins_pipe(ialu_reg);
9499 %}
9500 
9501 /* Better to save a register than avoid a branch */
9502 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9503 %{
9504   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
9505   effect(KILL cr);
9506   ins_cost(300);
9507   format %{ "subl   $p,$q\t# cadd_cmpLTMask\n\t"
9508             "jge    done\n\t"
9509             "addl   $p,$y\n"
9510             "done:  " %}
9511   ins_encode %{
9512     Register Rp = $p$$Register;
9513     Register Rq = $q$$Register;
9514     Register Ry = $y$$Register;
9515     Label done;
9516     __ subl(Rp, Rq);
9517     __ jccb(Assembler::greaterEqual, done);
9518     __ addl(Rp, Ry);
9519     __ bind(done);
9520   %}
9521   ins_pipe(pipe_cmplt);
9522 %}
9523 
9524 /* Better to save a register than avoid a branch */
9525 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9526 %{
9527   match(Set y (AndI (CmpLTMask p q) y));
9528   effect(KILL cr);
9529 
9530   ins_cost(300);
9531 
9532   format %{ "cmpl     $p, $q\t# and_cmpLTMask\n\t"
9533             "jlt      done\n\t"
9534             "xorl     $y, $y\n"
9535             "done:  " %}
9536   ins_encode %{
9537     Register Rp = $p$$Register;
9538     Register Rq = $q$$Register;
9539     Register Ry = $y$$Register;
9540     Label done;
9541     __ cmpl(Rp, Rq);
9542     __ jccb(Assembler::less, done);
9543     __ xorl(Ry, Ry);
9544     __ bind(done);
9545   %}
9546   ins_pipe(pipe_cmplt);
9547 %}
9548 
9549 
9550 //---------- FP Instructions------------------------------------------------
9551 
9552 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
9553 %{
9554   match(Set cr (CmpF src1 src2));
9555 
9556   ins_cost(145);
9557   format %{ "ucomiss $src1, $src2\n\t"
9558             "jnp,s   exit\n\t"
9559             "pushfq\t# saw NaN, set CF\n\t"
9560             "andq    [rsp], #0xffffff2b\n\t"
9561             "popfq\n"
9562     "exit:" %}
9563   ins_encode %{
9564     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9565     emit_cmpfp_fixup(_masm);
9566   %}
9567   ins_pipe(pipe_slow);
9568 %}
9569 
9570 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
9571   match(Set cr (CmpF src1 src2));
9572 
9573   ins_cost(100);
9574   format %{ "ucomiss $src1, $src2" %}
9575   ins_encode %{
9576     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9577   %}
9578   ins_pipe(pipe_slow);
9579 %}
9580 
9581 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
9582 %{
9583   match(Set cr (CmpF src1 (LoadF src2)));
9584 
9585   ins_cost(145);
9586   format %{ "ucomiss $src1, $src2\n\t"
9587             "jnp,s   exit\n\t"
9588             "pushfq\t# saw NaN, set CF\n\t"
9589             "andq    [rsp], #0xffffff2b\n\t"
9590             "popfq\n"
9591     "exit:" %}
9592   ins_encode %{
9593     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9594     emit_cmpfp_fixup(_masm);
9595   %}
9596   ins_pipe(pipe_slow);
9597 %}
9598 
9599 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
9600   match(Set cr (CmpF src1 (LoadF src2)));
9601 
9602   ins_cost(100);
9603   format %{ "ucomiss $src1, $src2" %}
9604   ins_encode %{
9605     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9606   %}
9607   ins_pipe(pipe_slow);
9608 %}
9609 
9610 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
9611   match(Set cr (CmpF src con));
9612 
9613   ins_cost(145);
9614   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9615             "jnp,s   exit\n\t"
9616             "pushfq\t# saw NaN, set CF\n\t"
9617             "andq    [rsp], #0xffffff2b\n\t"
9618             "popfq\n"
9619     "exit:" %}
9620   ins_encode %{
9621     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9622     emit_cmpfp_fixup(_masm);
9623   %}
9624   ins_pipe(pipe_slow);
9625 %}
9626 
9627 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
9628   match(Set cr (CmpF src con));
9629   ins_cost(100);
9630   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con" %}
9631   ins_encode %{
9632     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9633   %}
9634   ins_pipe(pipe_slow);
9635 %}
9636 
9637 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
9638 %{
9639   match(Set cr (CmpD src1 src2));
9640 
9641   ins_cost(145);
9642   format %{ "ucomisd $src1, $src2\n\t"
9643             "jnp,s   exit\n\t"
9644             "pushfq\t# saw NaN, set CF\n\t"
9645             "andq    [rsp], #0xffffff2b\n\t"
9646             "popfq\n"
9647     "exit:" %}
9648   ins_encode %{
9649     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9650     emit_cmpfp_fixup(_masm);
9651   %}
9652   ins_pipe(pipe_slow);
9653 %}
9654 
9655 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
9656   match(Set cr (CmpD src1 src2));
9657 
9658   ins_cost(100);
9659   format %{ "ucomisd $src1, $src2 test" %}
9660   ins_encode %{
9661     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9662   %}
9663   ins_pipe(pipe_slow);
9664 %}
9665 
9666 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
9667 %{
9668   match(Set cr (CmpD src1 (LoadD src2)));
9669 
9670   ins_cost(145);
9671   format %{ "ucomisd $src1, $src2\n\t"
9672             "jnp,s   exit\n\t"
9673             "pushfq\t# saw NaN, set CF\n\t"
9674             "andq    [rsp], #0xffffff2b\n\t"
9675             "popfq\n"
9676     "exit:" %}
9677   ins_encode %{
9678     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9679     emit_cmpfp_fixup(_masm);
9680   %}
9681   ins_pipe(pipe_slow);
9682 %}
9683 
9684 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
9685   match(Set cr (CmpD src1 (LoadD src2)));
9686 
9687   ins_cost(100);
9688   format %{ "ucomisd $src1, $src2" %}
9689   ins_encode %{
9690     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9691   %}
9692   ins_pipe(pipe_slow);
9693 %}
9694 
9695 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
9696   match(Set cr (CmpD src con));
9697 
9698   ins_cost(145);
9699   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9700             "jnp,s   exit\n\t"
9701             "pushfq\t# saw NaN, set CF\n\t"
9702             "andq    [rsp], #0xffffff2b\n\t"
9703             "popfq\n"
9704     "exit:" %}
9705   ins_encode %{
9706     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9707     emit_cmpfp_fixup(_masm);
9708   %}
9709   ins_pipe(pipe_slow);
9710 %}
9711 
9712 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
9713   match(Set cr (CmpD src con));
9714   ins_cost(100);
9715   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con" %}
9716   ins_encode %{
9717     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9718   %}
9719   ins_pipe(pipe_slow);
9720 %}
9721 
9722 // Compare into -1,0,1
9723 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
9724 %{
9725   match(Set dst (CmpF3 src1 src2));
9726   effect(KILL cr);
9727 
9728   ins_cost(275);
9729   format %{ "ucomiss $src1, $src2\n\t"
9730             "movl    $dst, #-1\n\t"
9731             "jp,s    done\n\t"
9732             "jb,s    done\n\t"
9733             "setne   $dst\n\t"
9734             "movzbl  $dst, $dst\n"
9735     "done:" %}
9736   ins_encode %{
9737     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9738     emit_cmpfp3(_masm, $dst$$Register);
9739   %}
9740   ins_pipe(pipe_slow);
9741 %}
9742 
9743 // Compare into -1,0,1
9744 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
9745 %{
9746   match(Set dst (CmpF3 src1 (LoadF src2)));
9747   effect(KILL cr);
9748 
9749   ins_cost(275);
9750   format %{ "ucomiss $src1, $src2\n\t"
9751             "movl    $dst, #-1\n\t"
9752             "jp,s    done\n\t"
9753             "jb,s    done\n\t"
9754             "setne   $dst\n\t"
9755             "movzbl  $dst, $dst\n"
9756     "done:" %}
9757   ins_encode %{
9758     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9759     emit_cmpfp3(_masm, $dst$$Register);
9760   %}
9761   ins_pipe(pipe_slow);
9762 %}
9763 
9764 // Compare into -1,0,1
9765 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
9766   match(Set dst (CmpF3 src con));
9767   effect(KILL cr);
9768 
9769   ins_cost(275);
9770   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9771             "movl    $dst, #-1\n\t"
9772             "jp,s    done\n\t"
9773             "jb,s    done\n\t"
9774             "setne   $dst\n\t"
9775             "movzbl  $dst, $dst\n"
9776     "done:" %}
9777   ins_encode %{
9778     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9779     emit_cmpfp3(_masm, $dst$$Register);
9780   %}
9781   ins_pipe(pipe_slow);
9782 %}
9783 
9784 // Compare into -1,0,1
9785 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
9786 %{
9787   match(Set dst (CmpD3 src1 src2));
9788   effect(KILL cr);
9789 
9790   ins_cost(275);
9791   format %{ "ucomisd $src1, $src2\n\t"
9792             "movl    $dst, #-1\n\t"
9793             "jp,s    done\n\t"
9794             "jb,s    done\n\t"
9795             "setne   $dst\n\t"
9796             "movzbl  $dst, $dst\n"
9797     "done:" %}
9798   ins_encode %{
9799     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9800     emit_cmpfp3(_masm, $dst$$Register);
9801   %}
9802   ins_pipe(pipe_slow);
9803 %}
9804 
9805 // Compare into -1,0,1
9806 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
9807 %{
9808   match(Set dst (CmpD3 src1 (LoadD src2)));
9809   effect(KILL cr);
9810 
9811   ins_cost(275);
9812   format %{ "ucomisd $src1, $src2\n\t"
9813             "movl    $dst, #-1\n\t"
9814             "jp,s    done\n\t"
9815             "jb,s    done\n\t"
9816             "setne   $dst\n\t"
9817             "movzbl  $dst, $dst\n"
9818     "done:" %}
9819   ins_encode %{
9820     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9821     emit_cmpfp3(_masm, $dst$$Register);
9822   %}
9823   ins_pipe(pipe_slow);
9824 %}
9825 
9826 // Compare into -1,0,1
9827 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
9828   match(Set dst (CmpD3 src con));
9829   effect(KILL cr);
9830 
9831   ins_cost(275);
9832   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9833             "movl    $dst, #-1\n\t"
9834             "jp,s    done\n\t"
9835             "jb,s    done\n\t"
9836             "setne   $dst\n\t"
9837             "movzbl  $dst, $dst\n"
9838     "done:" %}
9839   ins_encode %{
9840     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9841     emit_cmpfp3(_masm, $dst$$Register);
9842   %}
9843   ins_pipe(pipe_slow);
9844 %}
9845 
9846 // -----------Trig and Trancendental Instructions------------------------------
9847 instruct cosD_reg(regD dst) %{
9848   match(Set dst (CosD dst));
9849 
9850   format %{ "dcos   $dst\n\t" %}
9851   opcode(0xD9, 0xFF);
9852   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9853   ins_pipe( pipe_slow );
9854 %}
9855 
9856 instruct sinD_reg(regD dst) %{
9857   match(Set dst (SinD dst));
9858 
9859   format %{ "dsin   $dst\n\t" %}
9860   opcode(0xD9, 0xFE);
9861   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9862   ins_pipe( pipe_slow );
9863 %}
9864 
9865 instruct tanD_reg(regD dst) %{
9866   match(Set dst (TanD dst));
9867 
9868   format %{ "dtan   $dst\n\t" %}
9869   ins_encode( Push_SrcXD(dst),
9870               Opcode(0xD9), Opcode(0xF2),   //fptan
9871               Opcode(0xDD), Opcode(0xD8),   //fstp st
9872               Push_ResultXD(dst) );
9873   ins_pipe( pipe_slow );
9874 %}
9875 
9876 instruct log10D_reg(regD dst) %{
9877   // The source and result Double operands in XMM registers
9878   match(Set dst (Log10D dst));
9879   // fldlg2       ; push log_10(2) on the FPU stack; full 80-bit number
9880   // fyl2x        ; compute log_10(2) * log_2(x)
9881   format %{ "fldlg2\t\t\t#Log10\n\t"
9882             "fyl2x\t\t\t# Q=Log10*Log_2(x)\n\t"
9883          %}
9884    ins_encode(Opcode(0xD9), Opcode(0xEC),   // fldlg2
9885               Push_SrcXD(dst),
9886               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9887               Push_ResultXD(dst));
9888 
9889   ins_pipe( pipe_slow );
9890 %}
9891 
9892 instruct powD_reg(regD dst, regD src0, regD src1, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9893   match(Set dst (PowD src0 src1));  // Raise src0 to the src1'th power
9894   effect(KILL rax, KILL rdx, KILL rcx, KILL cr);
9895   format %{ "fast_pow $src0 $src1 -&gt; $dst  // KILL $rax, $rcx, $rdx" %}
9896   ins_encode %{
9897     __ subptr(rsp, 8);
9898     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
9899     __ fld_d(Address(rsp, 0));
9900     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
9901     __ fld_d(Address(rsp, 0));
9902     __ fast_pow();
9903     __ fstp_d(Address(rsp, 0));
9904     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9905     __ addptr(rsp, 8);
9906   %}
9907   ins_pipe( pipe_slow );
9908 %}
9909 
9910 //----------Arithmetic Conversion Instructions---------------------------------
9911 
9912 instruct roundFloat_nop(regF dst)
9913 %{
9914   match(Set dst (RoundFloat dst));
9915 
9916   ins_cost(0);
9917   ins_encode();
9918   ins_pipe(empty);
9919 %}
9920 
9921 instruct roundDouble_nop(regD dst)
9922 %{
9923   match(Set dst (RoundDouble dst));
9924 
9925   ins_cost(0);
9926   ins_encode();
9927   ins_pipe(empty);
9928 %}
9929 
9930 instruct convF2D_reg_reg(regD dst, regF src)
9931 %{
9932   match(Set dst (ConvF2D src));
9933 
9934   format %{ "cvtss2sd $dst, $src" %}
9935   ins_encode %{
9936     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
9937   %}
9938   ins_pipe(pipe_slow); // XXX
9939 %}
9940 
9941 instruct convF2D_reg_mem(regD dst, memory src)
9942 %{
9943   match(Set dst (ConvF2D (LoadF src)));
9944 
9945   format %{ "cvtss2sd $dst, $src" %}
9946   ins_encode %{
9947     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
9948   %}
9949   ins_pipe(pipe_slow); // XXX
9950 %}
9951 
9952 instruct convD2F_reg_reg(regF dst, regD src)
9953 %{
9954   match(Set dst (ConvD2F src));
9955 
9956   format %{ "cvtsd2ss $dst, $src" %}
9957   ins_encode %{
9958     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
9959   %}
9960   ins_pipe(pipe_slow); // XXX
9961 %}
9962 
9963 instruct convD2F_reg_mem(regF dst, memory src)
9964 %{
9965   match(Set dst (ConvD2F (LoadD src)));
9966 
9967   format %{ "cvtsd2ss $dst, $src" %}
9968   ins_encode %{
9969     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
9970   %}
9971   ins_pipe(pipe_slow); // XXX
9972 %}
9973 
9974 // XXX do mem variants
9975 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
9976 %{
9977   match(Set dst (ConvF2I src));
9978   effect(KILL cr);
9979 
9980   format %{ "cvttss2sil $dst, $src\t# f2i\n\t"
9981             "cmpl    $dst, #0x80000000\n\t"
9982             "jne,s   done\n\t"
9983             "subq    rsp, #8\n\t"
9984             "movss   [rsp], $src\n\t"
9985             "call    f2i_fixup\n\t"
9986             "popq    $dst\n"
9987     "done:   "%}
9988   ins_encode %{
9989     Label done;
9990     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
9991     __ cmpl($dst$$Register, 0x80000000);
9992     __ jccb(Assembler::notEqual, done);
9993     __ subptr(rsp, 8);
9994     __ movflt(Address(rsp, 0), $src$$XMMRegister);
9995     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
9996     __ pop($dst$$Register);
9997     __ bind(done);
9998   %}
9999   ins_pipe(pipe_slow);
10000 %}
10001 
10002 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10003 %{
10004   match(Set dst (ConvF2L src));
10005   effect(KILL cr);
10006 
10007   format %{ "cvttss2siq $dst, $src\t# f2l\n\t"
10008             "cmpq    $dst, [0x8000000000000000]\n\t"
10009             "jne,s   done\n\t"
10010             "subq    rsp, #8\n\t"
10011             "movss   [rsp], $src\n\t"
10012             "call    f2l_fixup\n\t"
10013             "popq    $dst\n"
10014     "done:   "%}
10015   ins_encode %{
10016     Label done;
10017     __ cvttss2siq($dst$$Register, $src$$XMMRegister);
10018     __ cmp64($dst$$Register,
10019              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10020     __ jccb(Assembler::notEqual, done);
10021     __ subptr(rsp, 8);
10022     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10023     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
10024     __ pop($dst$$Register);
10025     __ bind(done);
10026   %}
10027   ins_pipe(pipe_slow);
10028 %}
10029 
10030 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10031 %{
10032   match(Set dst (ConvD2I src));
10033   effect(KILL cr);
10034 
10035   format %{ "cvttsd2sil $dst, $src\t# d2i\n\t"
10036             "cmpl    $dst, #0x80000000\n\t"
10037             "jne,s   done\n\t"
10038             "subq    rsp, #8\n\t"
10039             "movsd   [rsp], $src\n\t"
10040             "call    d2i_fixup\n\t"
10041             "popq    $dst\n"
10042     "done:   "%}
10043   ins_encode %{
10044     Label done;
10045     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10046     __ cmpl($dst$$Register, 0x80000000);
10047     __ jccb(Assembler::notEqual, done);
10048     __ subptr(rsp, 8);
10049     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10050     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
10051     __ pop($dst$$Register);
10052     __ bind(done);
10053   %}
10054   ins_pipe(pipe_slow);
10055 %}
10056 
10057 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10058 %{
10059   match(Set dst (ConvD2L src));
10060   effect(KILL cr);
10061 
10062   format %{ "cvttsd2siq $dst, $src\t# d2l\n\t"
10063             "cmpq    $dst, [0x8000000000000000]\n\t"
10064             "jne,s   done\n\t"
10065             "subq    rsp, #8\n\t"
10066             "movsd   [rsp], $src\n\t"
10067             "call    d2l_fixup\n\t"
10068             "popq    $dst\n"
10069     "done:   "%}
10070   ins_encode %{
10071     Label done;
10072     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);
10073     __ cmp64($dst$$Register,
10074              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10075     __ jccb(Assembler::notEqual, done);
10076     __ subptr(rsp, 8);
10077     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10078     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
10079     __ pop($dst$$Register);
10080     __ bind(done);
10081   %}
10082   ins_pipe(pipe_slow);
10083 %}
10084 
10085 instruct convI2F_reg_reg(regF dst, rRegI src)
10086 %{
10087   predicate(!UseXmmI2F);
10088   match(Set dst (ConvI2F src));
10089 
10090   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10091   ins_encode %{
10092     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10093   %}
10094   ins_pipe(pipe_slow); // XXX
10095 %}
10096 
10097 instruct convI2F_reg_mem(regF dst, memory src)
10098 %{
10099   match(Set dst (ConvI2F (LoadI src)));
10100 
10101   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10102   ins_encode %{
10103     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10104   %}
10105   ins_pipe(pipe_slow); // XXX
10106 %}
10107 
10108 instruct convI2D_reg_reg(regD dst, rRegI src)
10109 %{
10110   predicate(!UseXmmI2D);
10111   match(Set dst (ConvI2D src));
10112 
10113   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10114   ins_encode %{
10115     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10116   %}
10117   ins_pipe(pipe_slow); // XXX
10118 %}
10119 
10120 instruct convI2D_reg_mem(regD dst, memory src)
10121 %{
10122   match(Set dst (ConvI2D (LoadI src)));
10123 
10124   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10125   ins_encode %{
10126     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10127   %}
10128   ins_pipe(pipe_slow); // XXX
10129 %}
10130 
10131 instruct convXI2F_reg(regF dst, rRegI src)
10132 %{
10133   predicate(UseXmmI2F);
10134   match(Set dst (ConvI2F src));
10135 
10136   format %{ "movdl $dst, $src\n\t"
10137             "cvtdq2psl $dst, $dst\t# i2f" %}
10138   ins_encode %{
10139     __ movdl($dst$$XMMRegister, $src$$Register);
10140     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10141   %}
10142   ins_pipe(pipe_slow); // XXX
10143 %}
10144 
10145 instruct convXI2D_reg(regD dst, rRegI src)
10146 %{
10147   predicate(UseXmmI2D);
10148   match(Set dst (ConvI2D src));
10149 
10150   format %{ "movdl $dst, $src\n\t"
10151             "cvtdq2pdl $dst, $dst\t# i2d" %}
10152   ins_encode %{
10153     __ movdl($dst$$XMMRegister, $src$$Register);
10154     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10155   %}
10156   ins_pipe(pipe_slow); // XXX
10157 %}
10158 
10159 instruct convL2F_reg_reg(regF dst, rRegL src)
10160 %{
10161   match(Set dst (ConvL2F src));
10162 
10163   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10164   ins_encode %{
10165     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10166   %}
10167   ins_pipe(pipe_slow); // XXX
10168 %}
10169 
10170 instruct convL2F_reg_mem(regF dst, memory src)
10171 %{
10172   match(Set dst (ConvL2F (LoadL src)));
10173 
10174   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10175   ins_encode %{
10176     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10177   %}
10178   ins_pipe(pipe_slow); // XXX
10179 %}
10180 
10181 instruct convL2D_reg_reg(regD dst, rRegL src)
10182 %{
10183   match(Set dst (ConvL2D src));
10184 
10185   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10186   ins_encode %{
10187     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10188   %}
10189   ins_pipe(pipe_slow); // XXX
10190 %}
10191 
10192 instruct convL2D_reg_mem(regD dst, memory src)
10193 %{
10194   match(Set dst (ConvL2D (LoadL src)));
10195 
10196   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10197   ins_encode %{
10198     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10199   %}
10200   ins_pipe(pipe_slow); // XXX
10201 %}
10202 
10203 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10204 %{
10205   match(Set dst (ConvI2L src));
10206 
10207   ins_cost(125);
10208   format %{ "movslq  $dst, $src\t# i2l" %}
10209   ins_encode %{
10210     __ movslq($dst$$Register, $src$$Register);
10211   %}
10212   ins_pipe(ialu_reg_reg);
10213 %}
10214 
10215 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10216 // %{
10217 //   match(Set dst (ConvI2L src));
10218 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10219 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10220 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10221 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10222 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10223 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10224 
10225 //   format %{ "movl    $dst, $src\t# unsigned i2l" %}
10226 //   ins_encode(enc_copy(dst, src));
10227 // //   opcode(0x63); // needs REX.W
10228 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10229 //   ins_pipe(ialu_reg_reg);
10230 // %}
10231 
10232 // Zero-extend convert int to long
10233 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10234 %{
10235   match(Set dst (AndL (ConvI2L src) mask));
10236 
10237   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10238   ins_encode %{
10239     if ($dst$$reg != $src$$reg) {
10240       __ movl($dst$$Register, $src$$Register);
10241     }
10242   %}
10243   ins_pipe(ialu_reg_reg);
10244 %}
10245 
10246 // Zero-extend convert int to long
10247 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10248 %{
10249   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10250 
10251   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10252   ins_encode %{
10253     __ movl($dst$$Register, $src$$Address);
10254   %}
10255   ins_pipe(ialu_reg_mem);
10256 %}
10257 
10258 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10259 %{
10260   match(Set dst (AndL src mask));
10261 
10262   format %{ "movl    $dst, $src\t# zero-extend long" %}
10263   ins_encode %{
10264     __ movl($dst$$Register, $src$$Register);
10265   %}
10266   ins_pipe(ialu_reg_reg);
10267 %}
10268 
10269 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10270 %{
10271   match(Set dst (ConvL2I src));
10272 
10273   format %{ "movl    $dst, $src\t# l2i" %}
10274   ins_encode %{
10275     __ movl($dst$$Register, $src$$Register);
10276   %}
10277   ins_pipe(ialu_reg_reg);
10278 %}
10279 
10280 
10281 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10282   match(Set dst (MoveF2I src));
10283   effect(DEF dst, USE src);
10284 
10285   ins_cost(125);
10286   format %{ "movl    $dst, $src\t# MoveF2I_stack_reg" %}
10287   ins_encode %{
10288     __ movl($dst$$Register, Address(rsp, $src$$disp));
10289   %}
10290   ins_pipe(ialu_reg_mem);
10291 %}
10292 
10293 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10294   match(Set dst (MoveI2F src));
10295   effect(DEF dst, USE src);
10296 
10297   ins_cost(125);
10298   format %{ "movss   $dst, $src\t# MoveI2F_stack_reg" %}
10299   ins_encode %{
10300     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10301   %}
10302   ins_pipe(pipe_slow);
10303 %}
10304 
10305 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10306   match(Set dst (MoveD2L src));
10307   effect(DEF dst, USE src);
10308 
10309   ins_cost(125);
10310   format %{ "movq    $dst, $src\t# MoveD2L_stack_reg" %}
10311   ins_encode %{
10312     __ movq($dst$$Register, Address(rsp, $src$$disp));
10313   %}
10314   ins_pipe(ialu_reg_mem);
10315 %}
10316 
10317 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10318   predicate(!UseXmmLoadAndClearUpper);
10319   match(Set dst (MoveL2D src));
10320   effect(DEF dst, USE src);
10321 
10322   ins_cost(125);
10323   format %{ "movlpd  $dst, $src\t# MoveL2D_stack_reg" %}
10324   ins_encode %{
10325     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10326   %}
10327   ins_pipe(pipe_slow);
10328 %}
10329 
10330 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10331   predicate(UseXmmLoadAndClearUpper);
10332   match(Set dst (MoveL2D src));
10333   effect(DEF dst, USE src);
10334 
10335   ins_cost(125);
10336   format %{ "movsd   $dst, $src\t# MoveL2D_stack_reg" %}
10337   ins_encode %{
10338     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10339   %}
10340   ins_pipe(pipe_slow);
10341 %}
10342 
10343 
10344 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10345   match(Set dst (MoveF2I src));
10346   effect(DEF dst, USE src);
10347 
10348   ins_cost(95); // XXX
10349   format %{ "movss   $dst, $src\t# MoveF2I_reg_stack" %}
10350   ins_encode %{
10351     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10352   %}
10353   ins_pipe(pipe_slow);
10354 %}
10355 
10356 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10357   match(Set dst (MoveI2F src));
10358   effect(DEF dst, USE src);
10359 
10360   ins_cost(100);
10361   format %{ "movl    $dst, $src\t# MoveI2F_reg_stack" %}
10362   ins_encode %{
10363     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10364   %}
10365   ins_pipe( ialu_mem_reg );
10366 %}
10367 
10368 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10369   match(Set dst (MoveD2L src));
10370   effect(DEF dst, USE src);
10371 
10372   ins_cost(95); // XXX
10373   format %{ "movsd   $dst, $src\t# MoveL2D_reg_stack" %}
10374   ins_encode %{
10375     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10376   %}
10377   ins_pipe(pipe_slow);
10378 %}
10379 
10380 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10381   match(Set dst (MoveL2D src));
10382   effect(DEF dst, USE src);
10383 
10384   ins_cost(100);
10385   format %{ "movq    $dst, $src\t# MoveL2D_reg_stack" %}
10386   ins_encode %{
10387     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10388   %}
10389   ins_pipe(ialu_mem_reg);
10390 %}
10391 
10392 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10393   match(Set dst (MoveF2I src));
10394   effect(DEF dst, USE src);
10395   ins_cost(85);
10396   format %{ "movd    $dst,$src\t# MoveF2I" %}
10397   ins_encode %{
10398     __ movdl($dst$$Register, $src$$XMMRegister);
10399   %}
10400   ins_pipe( pipe_slow );
10401 %}
10402 
10403 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10404   match(Set dst (MoveD2L src));
10405   effect(DEF dst, USE src);
10406   ins_cost(85);
10407   format %{ "movd    $dst,$src\t# MoveD2L" %}
10408   ins_encode %{
10409     __ movdq($dst$$Register, $src$$XMMRegister);
10410   %}
10411   ins_pipe( pipe_slow );
10412 %}
10413 
10414 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10415   match(Set dst (MoveI2F src));
10416   effect(DEF dst, USE src);
10417   ins_cost(100);
10418   format %{ "movd    $dst,$src\t# MoveI2F" %}
10419   ins_encode %{
10420     __ movdl($dst$$XMMRegister, $src$$Register);
10421   %}
10422   ins_pipe( pipe_slow );
10423 %}
10424 
10425 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10426   match(Set dst (MoveL2D src));
10427   effect(DEF dst, USE src);
10428   ins_cost(100);
10429   format %{ "movd    $dst,$src\t# MoveL2D" %}
10430   ins_encode %{
10431      __ movdq($dst$$XMMRegister, $src$$Register);
10432   %}
10433   ins_pipe( pipe_slow );
10434 %}
10435 
10436 
10437 // =======================================================================
10438 // fast clearing of an array
10439 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10440                   rFlagsReg cr)
10441 %{
10442   predicate(!UseFastStosb);
10443   match(Set dummy (ClearArray cnt base));
10444   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10445 
10446   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10447             "rep     stosq\t# Store rax to *rdi++ while rcx--" %}
10448   ins_encode %{
10449     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10450   %}
10451   ins_pipe(pipe_slow);
10452 %}
10453 
10454 instruct rep_fast_stosb(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10455                         rFlagsReg cr)
10456 %{
10457   predicate(UseFastStosb);
10458   match(Set dummy (ClearArray cnt base));
10459   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10460   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10461             "shlq    rcx,3\t# Convert doublewords to bytes\n\t"
10462             "rep     stosb\t# Store rax to *rdi++ while rcx--" %}
10463   ins_encode %{
10464     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10465   %}
10466   ins_pipe( pipe_slow );
10467 %}
10468 
10469 instruct string_compareL(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10470                          rax_RegI result, regD tmp1, rFlagsReg cr)
10471 %{
10472   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10473   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10474   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10475 
10476   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10477   ins_encode %{
10478     __ string_compare($str1$$Register, $str2$$Register,
10479                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10480                       $tmp1$$XMMRegister, StrIntrinsicNode::LL);
10481   %}
10482   ins_pipe( pipe_slow );
10483 %}
10484 
10485 instruct string_compareU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10486                          rax_RegI result, regD tmp1, rFlagsReg cr)
10487 %{
10488   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10489   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10490   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10491 
10492   format %{ "String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10493   ins_encode %{
10494     __ string_compare($str1$$Register, $str2$$Register,
10495                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10496                       $tmp1$$XMMRegister, StrIntrinsicNode::UU);
10497   %}
10498   ins_pipe( pipe_slow );
10499 %}
10500 
10501 instruct string_compareLU(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10502                           rax_RegI result, regD tmp1, rFlagsReg cr)
10503 %{
10504   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
10505   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10506   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10507 
10508   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10509   ins_encode %{
10510     __ string_compare($str1$$Register, $str2$$Register,
10511                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10512                       $tmp1$$XMMRegister, StrIntrinsicNode::LU);
10513   %}
10514   ins_pipe( pipe_slow );
10515 %}
10516 
10517 instruct string_compareUL(rsi_RegP str1, rdx_RegI cnt1, rdi_RegP str2, rcx_RegI cnt2,
10518                           rax_RegI result, regD tmp1, rFlagsReg cr)
10519 %{
10520   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
10521   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10522   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10523 
10524   format %{ "String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10525   ins_encode %{
10526     __ string_compare($str2$$Register, $str1$$Register,
10527                       $cnt2$$Register, $cnt1$$Register, $result$$Register,
10528                       $tmp1$$XMMRegister, StrIntrinsicNode::UL);
10529   %}
10530   ins_pipe( pipe_slow );
10531 %}
10532 
10533 // fast search of substring with known size.
10534 instruct string_indexof_conL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10535                              rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10536 %{
10537   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
10538   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10539   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10540 
10541   format %{ "String IndexOf byte[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10542   ins_encode %{
10543     int icnt2 = (int)$int_cnt2$$constant;
10544     if (icnt2 &gt;= 16) {
10545       // IndexOf for constant substrings with size &gt;= 16 elements
10546       // which don't need to be loaded through stack.
10547       __ string_indexofC8($str1$$Register, $str2$$Register,
10548                           $cnt1$$Register, $cnt2$$Register,
10549                           icnt2, $result$$Register,
10550                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
10551     } else {
10552       // Small strings are loaded through stack if they cross page boundary.
10553       __ string_indexof($str1$$Register, $str2$$Register,
10554                         $cnt1$$Register, $cnt2$$Register,
10555                         icnt2, $result$$Register,
10556                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
10557     }
10558   %}
10559   ins_pipe( pipe_slow );
10560 %}
10561 
10562 // fast search of substring with known size.
10563 instruct string_indexof_conU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10564                              rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10565 %{
10566   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
10567   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10568   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10569 
10570   format %{ "String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10571   ins_encode %{
10572     int icnt2 = (int)$int_cnt2$$constant;
10573     if (icnt2 &gt;= 8) {
10574       // IndexOf for constant substrings with size &gt;= 8 elements
10575       // which don't need to be loaded through stack.
10576       __ string_indexofC8($str1$$Register, $str2$$Register,
10577                           $cnt1$$Register, $cnt2$$Register,
10578                           icnt2, $result$$Register,
10579                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
10580     } else {
10581       // Small strings are loaded through stack if they cross page boundary.
10582       __ string_indexof($str1$$Register, $str2$$Register,
10583                         $cnt1$$Register, $cnt2$$Register,
10584                         icnt2, $result$$Register,
10585                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
10586     }
10587   %}
10588   ins_pipe( pipe_slow );
10589 %}
10590 
10591 // fast search of substring with known size.
10592 instruct string_indexof_conUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10593                              rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10594 %{
10595   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
10596   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10597   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10598 
10599   format %{ "String IndexOf char[] $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10600   ins_encode %{
10601     int icnt2 = (int)$int_cnt2$$constant;
10602     if (icnt2 &gt;= 8) {
10603       // IndexOf for constant substrings with size &gt;= 8 elements
10604       // which don't need to be loaded through stack.
10605       __ string_indexofC8($str1$$Register, $str2$$Register,
10606                           $cnt1$$Register, $cnt2$$Register,
10607                           icnt2, $result$$Register,
10608                           $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
10609     } else {
10610       // Small strings are loaded through stack if they cross page boundary.
10611       __ string_indexof($str1$$Register, $str2$$Register,
10612                         $cnt1$$Register, $cnt2$$Register,
10613                         icnt2, $result$$Register,
10614                         $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
10615     }
10616   %}
10617   ins_pipe( pipe_slow );
10618 %}
10619 
10620 instruct string_indexofL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10621                          rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10622 %{
10623   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL));
10624   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10625   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10626 
10627   format %{ "String IndexOf byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10628   ins_encode %{
10629     __ string_indexof($str1$$Register, $str2$$Register,
10630                       $cnt1$$Register, $cnt2$$Register,
10631                       (-1), $result$$Register,
10632                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::LL);
10633   %}
10634   ins_pipe( pipe_slow );
10635 %}
10636 
10637 instruct string_indexofU(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10638                          rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10639 %{
10640   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU));
10641   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10642   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10643 
10644   format %{ "String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10645   ins_encode %{
10646     __ string_indexof($str1$$Register, $str2$$Register,
10647                       $cnt1$$Register, $cnt2$$Register,
10648                       (-1), $result$$Register,
10649                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UU);
10650   %}
10651   ins_pipe( pipe_slow );
10652 %}
10653 
10654 instruct string_indexofUL(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10655                          rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10656 %{
10657   predicate(UseSSE42Intrinsics &amp;&amp; (((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL));
10658   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10659   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10660 
10661   format %{ "String IndexOf char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10662   ins_encode %{
10663     __ string_indexof($str1$$Register, $str2$$Register,
10664                       $cnt1$$Register, $cnt2$$Register,
10665                       (-1), $result$$Register,
10666                       $vec$$XMMRegister, $tmp$$Register, StrIntrinsicNode::UL);
10667   %}
10668   ins_pipe( pipe_slow );
10669 %}
10670 
10671 instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,
10672                               rbx_RegI result, regD vec1, regD vec2, regD vec3, rcx_RegI tmp, rFlagsReg cr)
10673 %{
10674   predicate(UseSSE42Intrinsics);
10675   match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));
10676   effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);
10677   format %{ "String IndexOf char[] $str1,$cnt1,$ch -&gt; $result   // KILL all" %}
10678   ins_encode %{
10679     __ string_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,
10680                            $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);
10681   %}
10682   ins_pipe( pipe_slow );
10683 %}
10684 
10685 // fast string equals
10686 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
10687                        regD tmp1, regD tmp2, rbx_RegI tmp3, rFlagsReg cr)
10688 %{
10689   match(Set result (StrEquals (Binary str1 str2) cnt));
10690   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
10691 
10692   format %{ "String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3" %}
10693   ins_encode %{
10694     __ arrays_equals(false, $str1$$Register, $str2$$Register,
10695                      $cnt$$Register, $result$$Register, $tmp3$$Register,
10696                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
10697   %}
10698   ins_pipe( pipe_slow );
10699 %}
10700 
10701 // fast array equals
10702 instruct array_equalsB(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
10703                        regD tmp1, regD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
10704 %{
10705   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
10706   match(Set result (AryEq ary1 ary2));
10707   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
10708 
10709   format %{ "Array Equals byte[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4" %}
10710   ins_encode %{
10711     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
10712                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
10713                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, false /* char */);
10714   %}
10715   ins_pipe( pipe_slow );
10716 %}
10717 
10718 instruct array_equalsC(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
10719                       regD tmp1, regD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
10720 %{
10721   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
10722   match(Set result (AryEq ary1 ary2));
10723   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
10724 
10725   format %{ "Array Equals char[] $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4" %}
10726   ins_encode %{
10727     __ arrays_equals(true, $ary1$$Register, $ary2$$Register,
10728                      $tmp3$$Register, $result$$Register, $tmp4$$Register,
10729                      $tmp1$$XMMRegister, $tmp2$$XMMRegister, true /* char */);
10730   %}
10731   ins_pipe( pipe_slow );
10732 %}
10733 
10734 instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,
10735                       regD tmp1, regD tmp2, rbx_RegI tmp3, rFlagsReg cr)
10736 %{
10737   match(Set result (HasNegatives ary1 len));
10738   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL len, KILL tmp3, KILL cr);
10739 
10740   format %{ "has negatives byte[] $ary1,$len -&gt; $result   // KILL $tmp1, $tmp2, $tmp3" %}
10741   ins_encode %{
10742     __ has_negatives($ary1$$Register, $len$$Register,
10743                      $result$$Register, $tmp3$$Register,
10744                      $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10745   %}
10746   ins_pipe( pipe_slow );
10747 %}
10748 
10749 // fast char[] to byte[] compression
10750 instruct string_compress(rsi_RegP src, rdi_RegP dst, rdx_RegI len, regD tmp1, regD tmp2, regD tmp3, regD tmp4,
10751                          rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
10752   match(Set result (StrCompressedCopy src (Binary dst len)));
10753   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
10754 
10755   format %{ "String Compress $src,$dst -&gt; $result    // KILL RAX, RCX, RDX" %}
10756   ins_encode %{
10757     __ char_array_compress($src$$Register, $dst$$Register, $len$$Register,
10758                            $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
10759                            $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
10760   %}
10761   ins_pipe( pipe_slow );
10762 %}
10763 
10764 // fast byte[] to char[] inflation
10765 instruct string_inflate(Universe dummy, rsi_RegP src, rdi_RegP dst, rdx_RegI len,
10766                         regD tmp1, rcx_RegI tmp2, rFlagsReg cr) %{
10767   match(Set dummy (StrInflatedCopy src (Binary dst len)));
10768   effect(TEMP tmp1, TEMP tmp2, USE_KILL src, USE_KILL dst, USE_KILL len, KILL cr);
10769 
10770   format %{ "String Inflate $src,$dst    // KILL $tmp1, $tmp2" %}
10771   ins_encode %{
10772     __ byte_array_inflate($src$$Register, $dst$$Register, $len$$Register,
10773                           $tmp1$$XMMRegister, $tmp2$$Register);
10774   %}
10775   ins_pipe( pipe_slow );
10776 %}
10777 
10778 // encode char[] to byte[] in ISO_8859_1
10779 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
10780                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
10781                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
10782   match(Set result (EncodeISOArray src (Binary dst len)));
10783   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
10784 
10785   format %{ "Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI " %}
10786   ins_encode %{
10787     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
10788                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
10789                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
10790   %}
10791   ins_pipe( pipe_slow );
10792 %}
10793 
10794 //----------Overflow Math Instructions-----------------------------------------
10795 
10796 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10797 %{
10798   match(Set cr (OverflowAddI op1 op2));
10799   effect(DEF cr, USE_KILL op1, USE op2);
10800 
10801   format %{ "addl    $op1, $op2\t# overflow check int" %}
10802 
10803   ins_encode %{
10804     __ addl($op1$$Register, $op2$$Register);
10805   %}
10806   ins_pipe(ialu_reg_reg);
10807 %}
10808 
10809 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
10810 %{
10811   match(Set cr (OverflowAddI op1 op2));
10812   effect(DEF cr, USE_KILL op1, USE op2);
10813 
10814   format %{ "addl    $op1, $op2\t# overflow check int" %}
10815 
10816   ins_encode %{
10817     __ addl($op1$$Register, $op2$$constant);
10818   %}
10819   ins_pipe(ialu_reg_reg);
10820 %}
10821 
10822 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10823 %{
10824   match(Set cr (OverflowAddL op1 op2));
10825   effect(DEF cr, USE_KILL op1, USE op2);
10826 
10827   format %{ "addq    $op1, $op2\t# overflow check long" %}
10828   ins_encode %{
10829     __ addq($op1$$Register, $op2$$Register);
10830   %}
10831   ins_pipe(ialu_reg_reg);
10832 %}
10833 
10834 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
10835 %{
10836   match(Set cr (OverflowAddL op1 op2));
10837   effect(DEF cr, USE_KILL op1, USE op2);
10838 
10839   format %{ "addq    $op1, $op2\t# overflow check long" %}
10840   ins_encode %{
10841     __ addq($op1$$Register, $op2$$constant);
10842   %}
10843   ins_pipe(ialu_reg_reg);
10844 %}
10845 
10846 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10847 %{
10848   match(Set cr (OverflowSubI op1 op2));
10849 
10850   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10851   ins_encode %{
10852     __ cmpl($op1$$Register, $op2$$Register);
10853   %}
10854   ins_pipe(ialu_reg_reg);
10855 %}
10856 
10857 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10858 %{
10859   match(Set cr (OverflowSubI op1 op2));
10860 
10861   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10862   ins_encode %{
10863     __ cmpl($op1$$Register, $op2$$constant);
10864   %}
10865   ins_pipe(ialu_reg_reg);
10866 %}
10867 
10868 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
10869 %{
10870   match(Set cr (OverflowSubL op1 op2));
10871 
10872   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10873   ins_encode %{
10874     __ cmpq($op1$$Register, $op2$$Register);
10875   %}
10876   ins_pipe(ialu_reg_reg);
10877 %}
10878 
10879 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
10880 %{
10881   match(Set cr (OverflowSubL op1 op2));
10882 
10883   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10884   ins_encode %{
10885     __ cmpq($op1$$Register, $op2$$constant);
10886   %}
10887   ins_pipe(ialu_reg_reg);
10888 %}
10889 
10890 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
10891 %{
10892   match(Set cr (OverflowSubI zero op2));
10893   effect(DEF cr, USE_KILL op2);
10894 
10895   format %{ "negl    $op2\t# overflow check int" %}
10896   ins_encode %{
10897     __ negl($op2$$Register);
10898   %}
10899   ins_pipe(ialu_reg_reg);
10900 %}
10901 
10902 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
10903 %{
10904   match(Set cr (OverflowSubL zero op2));
10905   effect(DEF cr, USE_KILL op2);
10906 
10907   format %{ "negq    $op2\t# overflow check long" %}
10908   ins_encode %{
10909     __ negq($op2$$Register);
10910   %}
10911   ins_pipe(ialu_reg_reg);
10912 %}
10913 
10914 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10915 %{
10916   match(Set cr (OverflowMulI op1 op2));
10917   effect(DEF cr, USE_KILL op1, USE op2);
10918 
10919   format %{ "imull    $op1, $op2\t# overflow check int" %}
10920   ins_encode %{
10921     __ imull($op1$$Register, $op2$$Register);
10922   %}
10923   ins_pipe(ialu_reg_reg_alu0);
10924 %}
10925 
10926 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
10927 %{
10928   match(Set cr (OverflowMulI op1 op2));
10929   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10930 
10931   format %{ "imull    $tmp, $op1, $op2\t# overflow check int" %}
10932   ins_encode %{
10933     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
10934   %}
10935   ins_pipe(ialu_reg_reg_alu0);
10936 %}
10937 
10938 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10939 %{
10940   match(Set cr (OverflowMulL op1 op2));
10941   effect(DEF cr, USE_KILL op1, USE op2);
10942 
10943   format %{ "imulq    $op1, $op2\t# overflow check long" %}
10944   ins_encode %{
10945     __ imulq($op1$$Register, $op2$$Register);
10946   %}
10947   ins_pipe(ialu_reg_reg_alu0);
10948 %}
10949 
10950 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
10951 %{
10952   match(Set cr (OverflowMulL op1 op2));
10953   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10954 
10955   format %{ "imulq    $tmp, $op1, $op2\t# overflow check long" %}
10956   ins_encode %{
10957     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
10958   %}
10959   ins_pipe(ialu_reg_reg_alu0);
10960 %}
10961 
10962 
10963 //----------Control Flow Instructions------------------------------------------
10964 // Signed compare Instructions
10965 
10966 // XXX more variants!!
10967 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10968 %{
10969   match(Set cr (CmpI op1 op2));
10970   effect(DEF cr, USE op1, USE op2);
10971 
10972   format %{ "cmpl    $op1, $op2" %}
10973   opcode(0x3B);  /* Opcode 3B /r */
10974   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10975   ins_pipe(ialu_cr_reg_reg);
10976 %}
10977 
10978 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10979 %{
10980   match(Set cr (CmpI op1 op2));
10981 
10982   format %{ "cmpl    $op1, $op2" %}
10983   opcode(0x81, 0x07); /* Opcode 81 /7 */
10984   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10985   ins_pipe(ialu_cr_reg_imm);
10986 %}
10987 
10988 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
10989 %{
10990   match(Set cr (CmpI op1 (LoadI op2)));
10991 
10992   ins_cost(500); // XXX
10993   format %{ "cmpl    $op1, $op2" %}
10994   opcode(0x3B); /* Opcode 3B /r */
10995   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10996   ins_pipe(ialu_cr_reg_mem);
10997 %}
10998 
10999 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
11000 %{
11001   match(Set cr (CmpI src zero));
11002 
11003   format %{ "testl   $src, $src" %}
11004   opcode(0x85);
11005   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11006   ins_pipe(ialu_cr_reg_imm);
11007 %}
11008 
11009 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
11010 %{
11011   match(Set cr (CmpI (AndI src con) zero));
11012 
11013   format %{ "testl   $src, $con" %}
11014   opcode(0xF7, 0x00);
11015   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
11016   ins_pipe(ialu_cr_reg_imm);
11017 %}
11018 
11019 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
11020 %{
11021   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
11022 
11023   format %{ "testl   $src, $mem" %}
11024   opcode(0x85);
11025   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
11026   ins_pipe(ialu_cr_reg_mem);
11027 %}
11028 
11029 // Unsigned compare Instructions; really, same as signed except they
11030 // produce an rFlagsRegU instead of rFlagsReg.
11031 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
11032 %{
11033   match(Set cr (CmpU op1 op2));
11034 
11035   format %{ "cmpl    $op1, $op2\t# unsigned" %}
11036   opcode(0x3B); /* Opcode 3B /r */
11037   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
11038   ins_pipe(ialu_cr_reg_reg);
11039 %}
11040 
11041 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
11042 %{
11043   match(Set cr (CmpU op1 op2));
11044 
11045   format %{ "cmpl    $op1, $op2\t# unsigned" %}
11046   opcode(0x81,0x07); /* Opcode 81 /7 */
11047   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
11048   ins_pipe(ialu_cr_reg_imm);
11049 %}
11050 
11051 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
11052 %{
11053   match(Set cr (CmpU op1 (LoadI op2)));
11054 
11055   ins_cost(500); // XXX
11056   format %{ "cmpl    $op1, $op2\t# unsigned" %}
11057   opcode(0x3B); /* Opcode 3B /r */
11058   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
11059   ins_pipe(ialu_cr_reg_mem);
11060 %}
11061 
11062 // // // Cisc-spilled version of cmpU_rReg
11063 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
11064 // //%{
11065 // //  match(Set cr (CmpU (LoadI op1) op2));
11066 // //
11067 // //  format %{ "CMPu   $op1,$op2" %}
11068 // //  ins_cost(500);
11069 // //  opcode(0x39);  /* Opcode 39 /r */
11070 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11071 // //%}
11072 
11073 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
11074 %{
11075   match(Set cr (CmpU src zero));
11076 
11077   format %{ "testl  $src, $src\t# unsigned" %}
11078   opcode(0x85);
11079   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
11080   ins_pipe(ialu_cr_reg_imm);
11081 %}
11082 
11083 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
11084 %{
11085   match(Set cr (CmpP op1 op2));
11086 
11087   format %{ "cmpq    $op1, $op2\t# ptr" %}
11088   opcode(0x3B); /* Opcode 3B /r */
11089   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11090   ins_pipe(ialu_cr_reg_reg);
11091 %}
11092 
11093 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
11094 %{
11095   match(Set cr (CmpP op1 (LoadP op2)));
11096 
11097   ins_cost(500); // XXX
11098   format %{ "cmpq    $op1, $op2\t# ptr" %}
11099   opcode(0x3B); /* Opcode 3B /r */
11100   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11101   ins_pipe(ialu_cr_reg_mem);
11102 %}
11103 
11104 // // // Cisc-spilled version of cmpP_rReg
11105 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
11106 // //%{
11107 // //  match(Set cr (CmpP (LoadP op1) op2));
11108 // //
11109 // //  format %{ "CMPu   $op1,$op2" %}
11110 // //  ins_cost(500);
11111 // //  opcode(0x39);  /* Opcode 39 /r */
11112 // //  ins_encode( OpcP, reg_mem( op1, op2) );
11113 // //%}
11114 
11115 // XXX this is generalized by compP_rReg_mem???
11116 // Compare raw pointer (used in out-of-heap check).
11117 // Only works because non-oop pointers must be raw pointers
11118 // and raw pointers have no anti-dependencies.
11119 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
11120 %{
11121   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);
11122   match(Set cr (CmpP op1 (LoadP op2)));
11123 
11124   format %{ "cmpq    $op1, $op2\t# raw ptr" %}
11125   opcode(0x3B); /* Opcode 3B /r */
11126   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11127   ins_pipe(ialu_cr_reg_mem);
11128 %}
11129 
11130 // This will generate a signed flags result. This should be OK since
11131 // any compare to a zero should be eq/neq.
11132 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
11133 %{
11134   match(Set cr (CmpP src zero));
11135 
11136   format %{ "testq   $src, $src\t# ptr" %}
11137   opcode(0x85);
11138   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11139   ins_pipe(ialu_cr_reg_imm);
11140 %}
11141 
11142 // This will generate a signed flags result. This should be OK since
11143 // any compare to a zero should be eq/neq.
11144 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
11145 %{
11146   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
11147   match(Set cr (CmpP (LoadP op) zero));
11148 
11149   ins_cost(500); // XXX
11150   format %{ "testq   $op, 0xffffffffffffffff\t# ptr" %}
11151   opcode(0xF7); /* Opcode F7 /0 */
11152   ins_encode(REX_mem_wide(op),
11153              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
11154   ins_pipe(ialu_cr_reg_imm);
11155 %}
11156 
11157 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
11158 %{
11159   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
11160   match(Set cr (CmpP (LoadP mem) zero));
11161 
11162   format %{ "cmpq    R12, $mem\t# ptr (R12_heapbase==0)" %}
11163   ins_encode %{
11164     __ cmpq(r12, $mem$$Address);
11165   %}
11166   ins_pipe(ialu_cr_reg_mem);
11167 %}
11168 
11169 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
11170 %{
11171   match(Set cr (CmpN op1 op2));
11172 
11173   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
11174   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
11175   ins_pipe(ialu_cr_reg_reg);
11176 %}
11177 
11178 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
11179 %{
11180   match(Set cr (CmpN src (LoadN mem)));
11181 
11182   format %{ "cmpl    $src, $mem\t# compressed ptr" %}
11183   ins_encode %{
11184     __ cmpl($src$$Register, $mem$$Address);
11185   %}
11186   ins_pipe(ialu_cr_reg_mem);
11187 %}
11188 
11189 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
11190   match(Set cr (CmpN op1 op2));
11191 
11192   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
11193   ins_encode %{
11194     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
11195   %}
11196   ins_pipe(ialu_cr_reg_imm);
11197 %}
11198 
11199 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
11200 %{
11201   match(Set cr (CmpN src (LoadN mem)));
11202 
11203   format %{ "cmpl    $mem, $src\t# compressed ptr" %}
11204   ins_encode %{
11205     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
11206   %}
11207   ins_pipe(ialu_cr_reg_mem);
11208 %}
11209 
11210 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
11211   match(Set cr (CmpN op1 op2));
11212 
11213   format %{ "cmpl    $op1, $op2\t# compressed klass ptr" %}
11214   ins_encode %{
11215     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11216   %}
11217   ins_pipe(ialu_cr_reg_imm);
11218 %}
11219 
11220 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11221 %{
11222   match(Set cr (CmpN src (LoadNKlass mem)));
11223 
11224   format %{ "cmpl    $mem, $src\t# compressed klass ptr" %}
11225   ins_encode %{
11226     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11227   %}
11228   ins_pipe(ialu_cr_reg_mem);
11229 %}
11230 
11231 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11232   match(Set cr (CmpN src zero));
11233 
11234   format %{ "testl   $src, $src\t# compressed ptr" %}
11235   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11236   ins_pipe(ialu_cr_reg_imm);
11237 %}
11238 
11239 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11240 %{
11241   predicate(Universe::narrow_oop_base() != NULL);
11242   match(Set cr (CmpN (LoadN mem) zero));
11243 
11244   ins_cost(500); // XXX
11245   format %{ "testl   $mem, 0xffffffff\t# compressed ptr" %}
11246   ins_encode %{
11247     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11248   %}
11249   ins_pipe(ialu_cr_reg_mem);
11250 %}
11251 
11252 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11253 %{
11254   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));
11255   match(Set cr (CmpN (LoadN mem) zero));
11256 
11257   format %{ "cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)" %}
11258   ins_encode %{
11259     __ cmpl(r12, $mem$$Address);
11260   %}
11261   ins_pipe(ialu_cr_reg_mem);
11262 %}
11263 
11264 // Yanked all unsigned pointer compare operations.
11265 // Pointer compares are done with CmpP which is already unsigned.
11266 
11267 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11268 %{
11269   match(Set cr (CmpL op1 op2));
11270 
11271   format %{ "cmpq    $op1, $op2" %}
11272   opcode(0x3B);  /* Opcode 3B /r */
11273   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11274   ins_pipe(ialu_cr_reg_reg);
11275 %}
11276 
11277 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11278 %{
11279   match(Set cr (CmpL op1 op2));
11280 
11281   format %{ "cmpq    $op1, $op2" %}
11282   opcode(0x81, 0x07); /* Opcode 81 /7 */
11283   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11284   ins_pipe(ialu_cr_reg_imm);
11285 %}
11286 
11287 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11288 %{
11289   match(Set cr (CmpL op1 (LoadL op2)));
11290 
11291   format %{ "cmpq    $op1, $op2" %}
11292   opcode(0x3B); /* Opcode 3B /r */
11293   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11294   ins_pipe(ialu_cr_reg_mem);
11295 %}
11296 
11297 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11298 %{
11299   match(Set cr (CmpL src zero));
11300 
11301   format %{ "testq   $src, $src" %}
11302   opcode(0x85);
11303   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11304   ins_pipe(ialu_cr_reg_imm);
11305 %}
11306 
11307 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11308 %{
11309   match(Set cr (CmpL (AndL src con) zero));
11310 
11311   format %{ "testq   $src, $con\t# long" %}
11312   opcode(0xF7, 0x00);
11313   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11314   ins_pipe(ialu_cr_reg_imm);
11315 %}
11316 
11317 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11318 %{
11319   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11320 
11321   format %{ "testq   $src, $mem" %}
11322   opcode(0x85);
11323   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11324   ins_pipe(ialu_cr_reg_mem);
11325 %}
11326 
11327 // Manifest a CmpL result in an integer register.  Very painful.
11328 // This is the test to avoid.
11329 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11330 %{
11331   match(Set dst (CmpL3 src1 src2));
11332   effect(KILL flags);
11333 
11334   ins_cost(275); // XXX
11335   format %{ "cmpq    $src1, $src2\t# CmpL3\n\t"
11336             "movl    $dst, -1\n\t"
11337             "jl,s    done\n\t"
11338             "setne   $dst\n\t"
11339             "movzbl  $dst, $dst\n\t"
11340     "done:" %}
11341   ins_encode(cmpl3_flag(src1, src2, dst));
11342   ins_pipe(pipe_slow);
11343 %}
11344 
11345 //----------Max and Min--------------------------------------------------------
11346 // Min Instructions
11347 
11348 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11349 %{
11350   effect(USE_DEF dst, USE src, USE cr);
11351 
11352   format %{ "cmovlgt $dst, $src\t# min" %}
11353   opcode(0x0F, 0x4F);
11354   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11355   ins_pipe(pipe_cmov_reg);
11356 %}
11357 
11358 
11359 instruct minI_rReg(rRegI dst, rRegI src)
11360 %{
11361   match(Set dst (MinI dst src));
11362 
11363   ins_cost(200);
11364   expand %{
11365     rFlagsReg cr;
11366     compI_rReg(cr, dst, src);
11367     cmovI_reg_g(dst, src, cr);
11368   %}
11369 %}
11370 
11371 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
11372 %{
11373   effect(USE_DEF dst, USE src, USE cr);
11374 
11375   format %{ "cmovllt $dst, $src\t# max" %}
11376   opcode(0x0F, 0x4C);
11377   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11378   ins_pipe(pipe_cmov_reg);
11379 %}
11380 
11381 
11382 instruct maxI_rReg(rRegI dst, rRegI src)
11383 %{
11384   match(Set dst (MaxI dst src));
11385 
11386   ins_cost(200);
11387   expand %{
11388     rFlagsReg cr;
11389     compI_rReg(cr, dst, src);
11390     cmovI_reg_l(dst, src, cr);
11391   %}
11392 %}
11393 
11394 // ============================================================================
11395 // Branch Instructions
11396 
11397 // Jump Direct - Label defines a relative address from JMP+1
11398 instruct jmpDir(label labl)
11399 %{
11400   match(Goto);
11401   effect(USE labl);
11402 
11403   ins_cost(300);
11404   format %{ "jmp     $labl" %}
11405   size(5);
11406   ins_encode %{
11407     Label* L = $labl$$label;
11408     __ jmp(*L, false); // Always long jump
11409   %}
11410   ins_pipe(pipe_jmp);
11411 %}
11412 
11413 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11414 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
11415 %{
11416   match(If cop cr);
11417   effect(USE labl);
11418 
11419   ins_cost(300);
11420   format %{ "j$cop     $labl" %}
11421   size(6);
11422   ins_encode %{
11423     Label* L = $labl$$label;
11424     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11425   %}
11426   ins_pipe(pipe_jcc);
11427 %}
11428 
11429 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11430 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
11431 %{
11432   match(CountedLoopEnd cop cr);
11433   effect(USE labl);
11434 
11435   ins_cost(300);
11436   format %{ "j$cop     $labl\t# loop end" %}
11437   size(6);
11438   ins_encode %{
11439     Label* L = $labl$$label;
11440     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11441   %}
11442   ins_pipe(pipe_jcc);
11443 %}
11444 
11445 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11446 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11447   match(CountedLoopEnd cop cmp);
11448   effect(USE labl);
11449 
11450   ins_cost(300);
11451   format %{ "j$cop,u   $labl\t# loop end" %}
11452   size(6);
11453   ins_encode %{
11454     Label* L = $labl$$label;
11455     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11456   %}
11457   ins_pipe(pipe_jcc);
11458 %}
11459 
11460 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11461   match(CountedLoopEnd cop cmp);
11462   effect(USE labl);
11463 
11464   ins_cost(200);
11465   format %{ "j$cop,u   $labl\t# loop end" %}
11466   size(6);
11467   ins_encode %{
11468     Label* L = $labl$$label;
11469     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11470   %}
11471   ins_pipe(pipe_jcc);
11472 %}
11473 
11474 // Jump Direct Conditional - using unsigned comparison
11475 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11476   match(If cop cmp);
11477   effect(USE labl);
11478 
11479   ins_cost(300);
11480   format %{ "j$cop,u  $labl" %}
11481   size(6);
11482   ins_encode %{
11483     Label* L = $labl$$label;
11484     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11485   %}
11486   ins_pipe(pipe_jcc);
11487 %}
11488 
11489 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11490   match(If cop cmp);
11491   effect(USE labl);
11492 
11493   ins_cost(200);
11494   format %{ "j$cop,u  $labl" %}
11495   size(6);
11496   ins_encode %{
11497     Label* L = $labl$$label;
11498     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11499   %}
11500   ins_pipe(pipe_jcc);
11501 %}
11502 
11503 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11504   match(If cop cmp);
11505   effect(USE labl);
11506 
11507   ins_cost(200);
11508   format %{ $$template
11509     if ($cop$$cmpcode == Assembler::notEqual) {
11510       $$emit$$"jp,u   $labl\n\t"
11511       $$emit$$"j$cop,u   $labl"
11512     } else {
11513       $$emit$$"jp,u   done\n\t"
11514       $$emit$$"j$cop,u   $labl\n\t"
11515       $$emit$$"done:"
11516     }
11517   %}
11518   ins_encode %{
11519     Label* l = $labl$$label;
11520     if ($cop$$cmpcode == Assembler::notEqual) {
11521       __ jcc(Assembler::parity, *l, false);
11522       __ jcc(Assembler::notEqual, *l, false);
11523     } else if ($cop$$cmpcode == Assembler::equal) {
11524       Label done;
11525       __ jccb(Assembler::parity, done);
11526       __ jcc(Assembler::equal, *l, false);
11527       __ bind(done);
11528     } else {
11529        ShouldNotReachHere();
11530     }
11531   %}
11532   ins_pipe(pipe_jcc);
11533 %}
11534 
11535 // ============================================================================
11536 // The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
11537 // superklass array for an instance of the superklass.  Set a hidden
11538 // internal cache on a hit (cache is checked with exposed code in
11539 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
11540 // encoding ALSO sets flags.
11541 
11542 instruct partialSubtypeCheck(rdi_RegP result,
11543                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11544                              rFlagsReg cr)
11545 %{
11546   match(Set result (PartialSubtypeCheck sub super));
11547   effect(KILL rcx, KILL cr);
11548 
11549   ins_cost(1100);  // slightly larger than the next version
11550   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11551             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11552             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11553             "repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t"
11554             "jne,s   miss\t\t# Missed: rdi not-zero\n\t"
11555             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11556             "xorq    $result, $result\t\t Hit: rdi zero\n\t"
11557     "miss:\t" %}
11558 
11559   opcode(0x1); // Force a XOR of RDI
11560   ins_encode(enc_PartialSubtypeCheck());
11561   ins_pipe(pipe_slow);
11562 %}
11563 
11564 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
11565                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11566                                      immP0 zero,
11567                                      rdi_RegP result)
11568 %{
11569   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
11570   effect(KILL rcx, KILL result);
11571 
11572   ins_cost(1000);
11573   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11574             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11575             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11576             "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
11577             "jne,s   miss\t\t# Missed: flags nz\n\t"
11578             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11579     "miss:\t" %}
11580 
11581   opcode(0x0); // No need to XOR RDI
11582   ins_encode(enc_PartialSubtypeCheck());
11583   ins_pipe(pipe_slow);
11584 %}
11585 
11586 // ============================================================================
11587 // Branch Instructions -- short offset versions
11588 //
11589 // These instructions are used to replace jumps of a long offset (the default
11590 // match) with jumps of a shorter offset.  These instructions are all tagged
11591 // with the ins_short_branch attribute, which causes the ADLC to suppress the
11592 // match rules in general matching.  Instead, the ADLC generates a conversion
11593 // method in the MachNode which can be used to do in-place replacement of the
11594 // long variant with the shorter variant.  The compiler will determine if a
11595 // branch can be taken by the is_short_branch_offset() predicate in the machine
11596 // specific code section of the file.
11597 
11598 // Jump Direct - Label defines a relative address from JMP+1
11599 instruct jmpDir_short(label labl) %{
11600   match(Goto);
11601   effect(USE labl);
11602 
11603   ins_cost(300);
11604   format %{ "jmp,s   $labl" %}
11605   size(2);
11606   ins_encode %{
11607     Label* L = $labl$$label;
11608     __ jmpb(*L);
11609   %}
11610   ins_pipe(pipe_jmp);
11611   ins_short_branch(1);
11612 %}
11613 
11614 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11615 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
11616   match(If cop cr);
11617   effect(USE labl);
11618 
11619   ins_cost(300);
11620   format %{ "j$cop,s   $labl" %}
11621   size(2);
11622   ins_encode %{
11623     Label* L = $labl$$label;
11624     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11625   %}
11626   ins_pipe(pipe_jcc);
11627   ins_short_branch(1);
11628 %}
11629 
11630 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11631 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
11632   match(CountedLoopEnd cop cr);
11633   effect(USE labl);
11634 
11635   ins_cost(300);
11636   format %{ "j$cop,s   $labl\t# loop end" %}
11637   size(2);
11638   ins_encode %{
11639     Label* L = $labl$$label;
11640     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11641   %}
11642   ins_pipe(pipe_jcc);
11643   ins_short_branch(1);
11644 %}
11645 
11646 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11647 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11648   match(CountedLoopEnd cop cmp);
11649   effect(USE labl);
11650 
11651   ins_cost(300);
11652   format %{ "j$cop,us  $labl\t# loop end" %}
11653   size(2);
11654   ins_encode %{
11655     Label* L = $labl$$label;
11656     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11657   %}
11658   ins_pipe(pipe_jcc);
11659   ins_short_branch(1);
11660 %}
11661 
11662 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11663   match(CountedLoopEnd cop cmp);
11664   effect(USE labl);
11665 
11666   ins_cost(300);
11667   format %{ "j$cop,us  $labl\t# loop end" %}
11668   size(2);
11669   ins_encode %{
11670     Label* L = $labl$$label;
11671     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11672   %}
11673   ins_pipe(pipe_jcc);
11674   ins_short_branch(1);
11675 %}
11676 
11677 // Jump Direct Conditional - using unsigned comparison
11678 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11679   match(If cop cmp);
11680   effect(USE labl);
11681 
11682   ins_cost(300);
11683   format %{ "j$cop,us  $labl" %}
11684   size(2);
11685   ins_encode %{
11686     Label* L = $labl$$label;
11687     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11688   %}
11689   ins_pipe(pipe_jcc);
11690   ins_short_branch(1);
11691 %}
11692 
11693 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11694   match(If cop cmp);
11695   effect(USE labl);
11696 
11697   ins_cost(300);
11698   format %{ "j$cop,us  $labl" %}
11699   size(2);
11700   ins_encode %{
11701     Label* L = $labl$$label;
11702     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11703   %}
11704   ins_pipe(pipe_jcc);
11705   ins_short_branch(1);
11706 %}
11707 
11708 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11709   match(If cop cmp);
11710   effect(USE labl);
11711 
11712   ins_cost(300);
11713   format %{ $$template
11714     if ($cop$$cmpcode == Assembler::notEqual) {
11715       $$emit$$"jp,u,s   $labl\n\t"
11716       $$emit$$"j$cop,u,s   $labl"
11717     } else {
11718       $$emit$$"jp,u,s   done\n\t"
11719       $$emit$$"j$cop,u,s  $labl\n\t"
11720       $$emit$$"done:"
11721     }
11722   %}
11723   size(4);
11724   ins_encode %{
11725     Label* l = $labl$$label;
11726     if ($cop$$cmpcode == Assembler::notEqual) {
11727       __ jccb(Assembler::parity, *l);
11728       __ jccb(Assembler::notEqual, *l);
11729     } else if ($cop$$cmpcode == Assembler::equal) {
11730       Label done;
11731       __ jccb(Assembler::parity, done);
11732       __ jccb(Assembler::equal, *l);
11733       __ bind(done);
11734     } else {
11735        ShouldNotReachHere();
11736     }
11737   %}
11738   ins_pipe(pipe_jcc);
11739   ins_short_branch(1);
11740 %}
11741 
11742 // ============================================================================
11743 // inlined locking and unlocking
11744 
11745 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
11746   predicate(Compile::current()-&gt;use_rtm());
11747   match(Set cr (FastLock object box));
11748   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
11749   ins_cost(300);
11750   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2" %}
11751   ins_encode %{
11752     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11753                  $scr$$Register, $cx1$$Register, $cx2$$Register,
11754                  _counters, _rtm_counters, _stack_rtm_counters,
11755                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11756                  true, ra_-&gt;C-&gt;profile_rtm());
11757   %}
11758   ins_pipe(pipe_slow);
11759 %}
11760 
11761 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
11762   predicate(!Compile::current()-&gt;use_rtm());
11763   match(Set cr (FastLock object box));
11764   effect(TEMP tmp, TEMP scr, USE_KILL box);
11765   ins_cost(300);
11766   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr" %}
11767   ins_encode %{
11768     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11769                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
11770   %}
11771   ins_pipe(pipe_slow);
11772 %}
11773 
11774 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
11775   match(Set cr (FastUnlock object box));
11776   effect(TEMP tmp, USE_KILL box);
11777   ins_cost(300);
11778   format %{ "fastunlock $object,$box\t! kills $box,$tmp" %}
11779   ins_encode %{
11780     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
11781   %}
11782   ins_pipe(pipe_slow);
11783 %}
11784 
11785 
11786 // ============================================================================
11787 // Safepoint Instructions
11788 instruct safePoint_poll(rFlagsReg cr)
11789 %{
11790   predicate(!Assembler::is_polling_page_far());
11791   match(SafePoint);
11792   effect(KILL cr);
11793 
11794   format %{ "testl  rax, [rip + #offset_to_poll_page]\t"
11795             "# Safepoint: poll for GC" %}
11796   ins_cost(125);
11797   ins_encode %{
11798     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
11799     __ testl(rax, addr);
11800   %}
11801   ins_pipe(ialu_reg_mem);
11802 %}
11803 
11804 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
11805 %{
11806   predicate(Assembler::is_polling_page_far());
11807   match(SafePoint poll);
11808   effect(KILL cr, USE poll);
11809 
11810   format %{ "testl  rax, [$poll]\t"
11811             "# Safepoint: poll for GC" %}
11812   ins_cost(125);
11813   ins_encode %{
11814     __ relocate(relocInfo::poll_type);
11815     __ testl(rax, Address($poll$$Register, 0));
11816   %}
11817   ins_pipe(ialu_reg_mem);
11818 %}
11819 
11820 // ============================================================================
11821 // Procedure Call/Return Instructions
11822 // Call Java Static Instruction
11823 // Note: If this code changes, the corresponding ret_addr_offset() and
11824 //       compute_padding() functions will have to be adjusted.
11825 instruct CallStaticJavaDirect(method meth) %{
11826   match(CallStaticJava);
11827   effect(USE meth);
11828 
11829   ins_cost(300);
11830   format %{ "call,static " %}
11831   opcode(0xE8); /* E8 cd */
11832   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
11833   ins_pipe(pipe_slow);
11834   ins_alignment(4);
11835 %}
11836 
11837 // Call Java Dynamic Instruction
11838 // Note: If this code changes, the corresponding ret_addr_offset() and
11839 //       compute_padding() functions will have to be adjusted.
11840 instruct CallDynamicJavaDirect(method meth)
11841 %{
11842   match(CallDynamicJava);
11843   effect(USE meth);
11844 
11845   ins_cost(300);
11846   format %{ "movq    rax, #Universe::non_oop_word()\n\t"
11847             "call,dynamic " %}
11848   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
11849   ins_pipe(pipe_slow);
11850   ins_alignment(4);
11851 %}
11852 
11853 // Call Runtime Instruction
11854 instruct CallRuntimeDirect(method meth)
11855 %{
11856   match(CallRuntime);
11857   effect(USE meth);
11858 
11859   ins_cost(300);
11860   format %{ "call,runtime " %}
11861   ins_encode(clear_avx, Java_To_Runtime(meth));
11862   ins_pipe(pipe_slow);
11863 %}
11864 
11865 // Call runtime without safepoint
11866 instruct CallLeafDirect(method meth)
11867 %{
11868   match(CallLeaf);
11869   effect(USE meth);
11870 
11871   ins_cost(300);
11872   format %{ "call_leaf,runtime " %}
11873   ins_encode(clear_avx, Java_To_Runtime(meth));
11874   ins_pipe(pipe_slow);
11875 %}
11876 
11877 // Call runtime without safepoint
11878 instruct CallLeafNoFPDirect(method meth)
11879 %{
11880   match(CallLeafNoFP);
11881   effect(USE meth);
11882 
11883   ins_cost(300);
11884   format %{ "call_leaf_nofp,runtime " %}
11885   ins_encode(Java_To_Runtime(meth));
11886   ins_pipe(pipe_slow);
11887 %}
11888 
11889 // Return Instruction
11890 // Remove the return address &amp; jump to it.
11891 // Notice: We always emit a nop after a ret to make sure there is room
11892 // for safepoint patching
11893 instruct Ret()
11894 %{
11895   match(Return);
11896 
11897   format %{ "ret" %}
11898   opcode(0xC3);
11899   ins_encode(OpcP);
11900   ins_pipe(pipe_jmp);
11901 %}
11902 
11903 // Tail Call; Jump from runtime stub to Java code.
11904 // Also known as an 'interprocedural jump'.
11905 // Target of jump will eventually return to caller.
11906 // TailJump below removes the return address.
11907 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
11908 %{
11909   match(TailCall jump_target method_oop);
11910 
11911   ins_cost(300);
11912   format %{ "jmp     $jump_target\t# rbx holds method oop" %}
11913   opcode(0xFF, 0x4); /* Opcode FF /4 */
11914   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
11915   ins_pipe(pipe_jmp);
11916 %}
11917 
11918 // Tail Jump; remove the return address; jump to target.
11919 // TailCall above leaves the return address around.
11920 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
11921 %{
11922   match(TailJump jump_target ex_oop);
11923 
11924   ins_cost(300);
11925   format %{ "popq    rdx\t# pop return address\n\t"
11926             "jmp     $jump_target" %}
11927   opcode(0xFF, 0x4); /* Opcode FF /4 */
11928   ins_encode(Opcode(0x5a), // popq rdx
11929              REX_reg(jump_target), OpcP, reg_opc(jump_target));
11930   ins_pipe(pipe_jmp);
11931 %}
11932 
11933 // Create exception oop: created by stack-crawling runtime code.
11934 // Created exception is now available to this handler, and is setup
11935 // just prior to jumping to this handler.  No code emitted.
11936 instruct CreateException(rax_RegP ex_oop)
11937 %{
11938   match(Set ex_oop (CreateEx));
11939 
11940   size(0);
11941   // use the following format syntax
11942   format %{ "# exception oop is in rax; no code emitted" %}
11943   ins_encode();
11944   ins_pipe(empty);
11945 %}
11946 
11947 // Rethrow exception:
11948 // The exception oop will come in the first argument position.
11949 // Then JUMP (not call) to the rethrow stub code.
11950 instruct RethrowException()
11951 %{
11952   match(Rethrow);
11953 
11954   // use the following format syntax
11955   format %{ "jmp     rethrow_stub" %}
11956   ins_encode(enc_rethrow);
11957   ins_pipe(pipe_jmp);
11958 %}
11959 
11960 
11961 // ============================================================================
11962 // This name is KNOWN by the ADLC and cannot be changed.
11963 // The ADLC forces a 'TypeRawPtr::BOTTOM' output type
11964 // for this guy.
11965 instruct tlsLoadP(r15_RegP dst) %{
11966   match(Set dst (ThreadLocal));
11967   effect(DEF dst);
11968 
11969   size(0);
11970   format %{ "# TLS is in R15" %}
11971   ins_encode( /*empty encoding*/ );
11972   ins_pipe(ialu_reg_reg);
11973 %}
11974 
11975 
11976 //----------PEEPHOLE RULES-----------------------------------------------------
11977 // These must follow all instruction definitions as they use the names
11978 // defined in the instructions definitions.
11979 //
11980 // peepmatch ( root_instr_name [preceding_instruction]* );
11981 //
11982 // peepconstraint %{
11983 // (instruction_number.operand_name relational_op instruction_number.operand_name
11984 //  [, ...] );
11985 // // instruction numbers are zero-based using left to right order in peepmatch
11986 //
11987 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
11988 // // provide an instruction_number.operand_name for each operand that appears
11989 // // in the replacement instruction's match rule
11990 //
11991 // ---------VM FLAGS---------------------------------------------------------
11992 //
11993 // All peephole optimizations can be turned off using -XX:-OptoPeephole
11994 //
11995 // Each peephole rule is given an identifying number starting with zero and
11996 // increasing by one in the order seen by the parser.  An individual peephole
11997 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
11998 // on the command-line.
11999 //
12000 // ---------CURRENT LIMITATIONS----------------------------------------------
12001 //
12002 // Only match adjacent instructions in same basic block
12003 // Only equality constraints
12004 // Only constraints between operands, not (0.dest_reg == RAX_enc)
12005 // Only one replacement instruction
12006 //
12007 // ---------EXAMPLE----------------------------------------------------------
12008 //
12009 // // pertinent parts of existing instructions in architecture description
12010 // instruct movI(rRegI dst, rRegI src)
12011 // %{
12012 //   match(Set dst (CopyI src));
12013 // %}
12014 //
12015 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
12016 // %{
12017 //   match(Set dst (AddI dst src));
12018 //   effect(KILL cr);
12019 // %}
12020 //
12021 // // Change (inc mov) to lea
12022 // peephole %{
12023 //   // increment preceeded by register-register move
12024 //   peepmatch ( incI_rReg movI );
12025 //   // require that the destination register of the increment
12026 //   // match the destination register of the move
12027 //   peepconstraint ( 0.dst == 1.dst );
12028 //   // construct a replacement instruction that sets
12029 //   // the destination to ( move's source register + one )
12030 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
12031 // %}
12032 //
12033 
12034 // Implementation no longer uses movX instructions since
12035 // machine-independent system no longer uses CopyX nodes.
12036 //
12037 // peephole
12038 // %{
12039 //   peepmatch (incI_rReg movI);
12040 //   peepconstraint (0.dst == 1.dst);
12041 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12042 // %}
12043 
12044 // peephole
12045 // %{
12046 //   peepmatch (decI_rReg movI);
12047 //   peepconstraint (0.dst == 1.dst);
12048 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12049 // %}
12050 
12051 // peephole
12052 // %{
12053 //   peepmatch (addI_rReg_imm movI);
12054 //   peepconstraint (0.dst == 1.dst);
12055 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
12056 // %}
12057 
12058 // peephole
12059 // %{
12060 //   peepmatch (incL_rReg movL);
12061 //   peepconstraint (0.dst == 1.dst);
12062 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12063 // %}
12064 
12065 // peephole
12066 // %{
12067 //   peepmatch (decL_rReg movL);
12068 //   peepconstraint (0.dst == 1.dst);
12069 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12070 // %}
12071 
12072 // peephole
12073 // %{
12074 //   peepmatch (addL_rReg_imm movL);
12075 //   peepconstraint (0.dst == 1.dst);
12076 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
12077 // %}
12078 
12079 // peephole
12080 // %{
12081 //   peepmatch (addP_rReg_imm movP);
12082 //   peepconstraint (0.dst == 1.dst);
12083 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
12084 // %}
12085 
12086 // // Change load of spilled value to only a spill
12087 // instruct storeI(memory mem, rRegI src)
12088 // %{
12089 //   match(Set mem (StoreI mem src));
12090 // %}
12091 //
12092 // instruct loadI(rRegI dst, memory mem)
12093 // %{
12094 //   match(Set dst (LoadI mem));
12095 // %}
12096 //
12097 
12098 peephole
12099 %{
12100   peepmatch (loadI storeI);
12101   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12102   peepreplace (storeI(1.mem 1.mem 1.src));
12103 %}
12104 
12105 peephole
12106 %{
12107   peepmatch (loadL storeL);
12108   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
12109   peepreplace (storeL(1.mem 1.mem 1.src));
12110 %}
12111 
12112 //----------SMARTSPILL RULES---------------------------------------------------
12113 // These must follow all instruction definitions as they use the names
12114 // defined in the instructions definitions.
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
