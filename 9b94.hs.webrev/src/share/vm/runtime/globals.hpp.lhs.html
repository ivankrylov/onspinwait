<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_RUNTIME_GLOBALS_HPP
  26 #define SHARE_VM_RUNTIME_GLOBALS_HPP
  27 
  28 #include &lt;float.h&gt;
  29 #include "utilities/debug.hpp"
  30 #include &lt;float.h&gt; // for DBL_MAX
  31 
  32 // use this for flags that are true per default in the tiered build
  33 // but false in non-tiered builds, and vice versa
  34 #ifdef TIERED
  35 #define  trueInTiered true
  36 #define falseInTiered false
  37 #else
  38 #define  trueInTiered false
  39 #define falseInTiered true
  40 #endif
  41 
  42 #ifdef TARGET_ARCH_x86
  43 # include "globals_x86.hpp"
  44 #endif
  45 #ifdef TARGET_ARCH_sparc
  46 # include "globals_sparc.hpp"
  47 #endif
  48 #ifdef TARGET_ARCH_zero
  49 # include "globals_zero.hpp"
  50 #endif
  51 #ifdef TARGET_ARCH_arm
  52 # include "globals_arm.hpp"
  53 #endif
  54 #ifdef TARGET_ARCH_ppc
  55 # include "globals_ppc.hpp"
  56 #endif
  57 #ifdef TARGET_ARCH_aarch64
  58 # include "globals_aarch64.hpp"
  59 #endif
  60 #ifdef TARGET_OS_FAMILY_linux
  61 # include "globals_linux.hpp"
  62 #endif
  63 #ifdef TARGET_OS_FAMILY_solaris
  64 # include "globals_solaris.hpp"
  65 #endif
  66 #ifdef TARGET_OS_FAMILY_windows
  67 # include "globals_windows.hpp"
  68 #endif
  69 #ifdef TARGET_OS_FAMILY_aix
  70 # include "globals_aix.hpp"
  71 #endif
  72 #ifdef TARGET_OS_FAMILY_bsd
  73 # include "globals_bsd.hpp"
  74 #endif
  75 #ifdef TARGET_OS_ARCH_linux_x86
  76 # include "globals_linux_x86.hpp"
  77 #endif
  78 #ifdef TARGET_OS_ARCH_linux_sparc
  79 # include "globals_linux_sparc.hpp"
  80 #endif
  81 #ifdef TARGET_OS_ARCH_linux_zero
  82 # include "globals_linux_zero.hpp"
  83 #endif
  84 #ifdef TARGET_OS_ARCH_solaris_x86
  85 # include "globals_solaris_x86.hpp"
  86 #endif
  87 #ifdef TARGET_OS_ARCH_solaris_sparc
  88 # include "globals_solaris_sparc.hpp"
  89 #endif
  90 #ifdef TARGET_OS_ARCH_windows_x86
  91 # include "globals_windows_x86.hpp"
  92 #endif
  93 #ifdef TARGET_OS_ARCH_linux_arm
  94 # include "globals_linux_arm.hpp"
  95 #endif
  96 #ifdef TARGET_OS_ARCH_linux_ppc
  97 # include "globals_linux_ppc.hpp"
  98 #endif
  99 #ifdef TARGET_OS_ARCH_linux_aarch64
 100 # include "globals_linux_aarch64.hpp"
 101 #endif
 102 #ifdef TARGET_OS_ARCH_aix_ppc
 103 # include "globals_aix_ppc.hpp"
 104 #endif
 105 #ifdef TARGET_OS_ARCH_bsd_x86
 106 # include "globals_bsd_x86.hpp"
 107 #endif
 108 #ifdef TARGET_OS_ARCH_bsd_zero
 109 # include "globals_bsd_zero.hpp"
 110 #endif
 111 #ifdef COMPILER1
 112 #ifdef TARGET_ARCH_x86
 113 # include "c1_globals_x86.hpp"
 114 #endif
 115 #ifdef TARGET_ARCH_sparc
 116 # include "c1_globals_sparc.hpp"
 117 #endif
 118 #ifdef TARGET_ARCH_arm
 119 # include "c1_globals_arm.hpp"
 120 #endif
 121 #ifdef TARGET_ARCH_aarch64
 122 # include "c1_globals_aarch64.hpp"
 123 #endif
 124 #ifdef TARGET_OS_FAMILY_linux
 125 # include "c1_globals_linux.hpp"
 126 #endif
 127 #ifdef TARGET_OS_FAMILY_solaris
 128 # include "c1_globals_solaris.hpp"
 129 #endif
 130 #ifdef TARGET_OS_FAMILY_windows
 131 # include "c1_globals_windows.hpp"
 132 #endif
 133 #ifdef TARGET_OS_FAMILY_aix
 134 # include "c1_globals_aix.hpp"
 135 #endif
 136 #ifdef TARGET_OS_FAMILY_bsd
 137 # include "c1_globals_bsd.hpp"
 138 #endif
 139 #ifdef TARGET_ARCH_ppc
 140 # include "c1_globals_ppc.hpp"
 141 #endif
 142 #endif
 143 #ifdef COMPILER2
 144 #ifdef TARGET_ARCH_x86
 145 # include "c2_globals_x86.hpp"
 146 #endif
 147 #ifdef TARGET_ARCH_sparc
 148 # include "c2_globals_sparc.hpp"
 149 #endif
 150 #ifdef TARGET_ARCH_arm
 151 # include "c2_globals_arm.hpp"
 152 #endif
 153 #ifdef TARGET_ARCH_ppc
 154 # include "c2_globals_ppc.hpp"
 155 #endif
 156 #ifdef TARGET_ARCH_aarch64
 157 # include "c2_globals_aarch64.hpp"
 158 #endif
 159 #ifdef TARGET_OS_FAMILY_linux
 160 # include "c2_globals_linux.hpp"
 161 #endif
 162 #ifdef TARGET_OS_FAMILY_solaris
 163 # include "c2_globals_solaris.hpp"
 164 #endif
 165 #ifdef TARGET_OS_FAMILY_windows
 166 # include "c2_globals_windows.hpp"
 167 #endif
 168 #ifdef TARGET_OS_FAMILY_aix
 169 # include "c2_globals_aix.hpp"
 170 #endif
 171 #ifdef TARGET_OS_FAMILY_bsd
 172 # include "c2_globals_bsd.hpp"
 173 #endif
 174 #endif
 175 #ifdef SHARK
 176 #ifdef TARGET_ARCH_zero
 177 # include "shark_globals_zero.hpp"
 178 #endif
 179 #endif
 180 
 181 #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !defined(SHARK) &amp;&amp; !INCLUDE_JVMCI
 182 define_pd_global(bool, BackgroundCompilation,        false);
 183 define_pd_global(bool, UseTLAB,                      false);
 184 define_pd_global(bool, CICompileOSR,                 false);
 185 define_pd_global(bool, UseTypeProfile,               false);
 186 define_pd_global(bool, UseOnStackReplacement,        false);
 187 define_pd_global(bool, InlineIntrinsics,             false);
 188 define_pd_global(bool, PreferInterpreterNativeStubs, true);
 189 define_pd_global(bool, ProfileInterpreter,           false);
 190 define_pd_global(bool, ProfileTraps,                 false);
 191 define_pd_global(bool, TieredCompilation,            false);
 192 
 193 define_pd_global(intx, CompileThreshold,             0);
 194 
 195 define_pd_global(intx, OnStackReplacePercentage,     0);
 196 define_pd_global(bool, ResizeTLAB,                   false);
 197 define_pd_global(intx, FreqInlineSize,               0);
 198 define_pd_global(size_t, NewSizeThreadIncrease,      4*K);
 199 define_pd_global(intx, InlineClassNatives,           true);
 200 define_pd_global(intx, InlineUnsafeOps,              true);
 201 define_pd_global(intx, InitialCodeCacheSize,         160*K);
 202 define_pd_global(intx, ReservedCodeCacheSize,        32*M);
 203 define_pd_global(intx, NonProfiledCodeHeapSize,      0);
 204 define_pd_global(intx, ProfiledCodeHeapSize,         0);
 205 define_pd_global(intx, NonNMethodCodeHeapSize,       32*M);
 206 
 207 define_pd_global(intx, CodeCacheExpansionSize,       32*K);
 208 define_pd_global(intx, CodeCacheMinBlockLength,      1);
 209 define_pd_global(intx, CodeCacheMinimumUseSpace,     200*K);
 210 define_pd_global(size_t, MetaspaceSize,              ScaleForWordSize(4*M));
 211 define_pd_global(bool, NeverActAsServerClassMachine, true);
 212 define_pd_global(uint64_t,MaxRAM,                    1ULL*G);
 213 #define CI_COMPILER_COUNT 0
 214 #else
 215 
 216 #if defined(COMPILER2) || INCLUDE_JVMCI
 217 #define CI_COMPILER_COUNT 2
 218 #else
 219 #define CI_COMPILER_COUNT 1
 220 #endif // COMPILER2 || INCLUDE_JVMCI
 221 
 222 #endif // no compilers
 223 
 224 // string type aliases used only in this file
 225 typedef const char* ccstr;
 226 typedef const char* ccstrlist;   // represents string arguments which accumulate
 227 
 228 struct Flag {
 229   enum Flags {
 230     // value origin
 231     DEFAULT          = 0,
 232     COMMAND_LINE     = 1,
 233     ENVIRON_VAR      = 2,
 234     CONFIG_FILE      = 3,
 235     MANAGEMENT       = 4,
 236     ERGONOMIC        = 5,
 237     ATTACH_ON_DEMAND = 6,
 238     INTERNAL         = 7,
 239 
 240     LAST_VALUE_ORIGIN = INTERNAL,
 241     VALUE_ORIGIN_BITS = 4,
 242     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 243 
 244     // flag kind
 245     KIND_PRODUCT            = 1 &lt;&lt; 4,
 246     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 247     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 248     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 249     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 250     KIND_DEVELOP            = 1 &lt;&lt; 9,
 251     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 252     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 253     KIND_C1                 = 1 &lt;&lt; 12,
 254     KIND_C2                 = 1 &lt;&lt; 13,
 255     KIND_ARCH               = 1 &lt;&lt; 14,
 256     KIND_SHARK              = 1 &lt;&lt; 15,
 257     KIND_LP64_PRODUCT       = 1 &lt;&lt; 16,
 258     KIND_COMMERCIAL         = 1 &lt;&lt; 17,
 259     KIND_JVMCI              = 1 &lt;&lt; 18,
 260 
 261     KIND_MASK = ~VALUE_ORIGIN_MASK
 262   };
 263 
 264   enum Error {
 265     // no error
 266     SUCCESS = 0,
 267     // flag name is missing
 268     MISSING_NAME,
 269     // flag value is missing
 270     MISSING_VALUE,
 271     // error parsing the textual form of the value
 272     WRONG_FORMAT,
 273     // flag is not writeable
 274     NON_WRITABLE,
 275     // flag value is outside of its bounds
 276     OUT_OF_BOUNDS,
 277     // flag value violates its constraint
 278     VIOLATES_CONSTRAINT,
 279     // there is no flag with the given name
 280     INVALID_FLAG,
 281     // other, unspecified error related to setting the flag
 282     ERR_OTHER
 283   };
 284 
 285   enum MsgType {
 286     NONE = 0,
 287     DIAGNOSTIC_FLAG_BUT_LOCKED,
 288     EXPERIMENTAL_FLAG_BUT_LOCKED,
 289     DEVELOPER_FLAG_BUT_PRODUCT_BUILD,
 290     NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD
 291   };
 292 
 293   const char* _type;
 294   const char* _name;
 295   void* _addr;
 296   NOT_PRODUCT(const char* _doc;)
 297   Flags _flags;
 298 
 299   // points to all Flags static array
 300   static Flag* flags;
 301 
 302   // number of flags
 303   static size_t numFlags;
 304 
 305   static Flag* find_flag(const char* name) { return find_flag(name, strlen(name), true, true); };
 306   static Flag* find_flag(const char* name, size_t length, bool allow_locked = false, bool return_flag = false);
 307   static Flag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
 308 
 309   void check_writable();
 310 
 311   bool is_bool() const;
 312   bool get_bool() const;
 313   void set_bool(bool value);
 314 
 315   bool is_int() const;
 316   int get_int() const;
 317   void set_int(int value);
 318 
 319   bool is_uint() const;
 320   uint get_uint() const;
 321   void set_uint(uint value);
 322 
 323   bool is_intx() const;
 324   intx get_intx() const;
 325   void set_intx(intx value);
 326 
 327   bool is_uintx() const;
 328   uintx get_uintx() const;
 329   void set_uintx(uintx value);
 330 
 331   bool is_uint64_t() const;
 332   uint64_t get_uint64_t() const;
 333   void set_uint64_t(uint64_t value);
 334 
 335   bool is_size_t() const;
 336   size_t get_size_t() const;
 337   void set_size_t(size_t value);
 338 
 339   bool is_double() const;
 340   double get_double() const;
 341   void set_double(double value);
 342 
 343   bool is_ccstr() const;
 344   bool ccstr_accumulates() const;
 345   ccstr get_ccstr() const;
 346   void set_ccstr(ccstr value);
 347 
 348   Flags get_origin();
 349   void set_origin(Flags origin);
 350 
 351   bool is_default();
 352   bool is_ergonomic();
 353   bool is_command_line();
 354 
 355   bool is_product() const;
 356   bool is_manageable() const;
 357   bool is_diagnostic() const;
 358   bool is_experimental() const;
 359   bool is_notproduct() const;
 360   bool is_develop() const;
 361   bool is_read_write() const;
 362   bool is_commercial() const;
 363 
 364   bool is_constant_in_binary() const;
 365 
 366   bool is_unlocker() const;
 367   bool is_unlocked() const;
 368   bool is_writeable() const;
 369   bool is_external() const;
 370 
 371   bool is_unlocker_ext() const;
 372   bool is_unlocked_ext() const;
 373   bool is_writeable_ext() const;
 374   bool is_external_ext() const;
 375 
 376   void unlock_diagnostic();
 377 
 378   Flag::MsgType get_locked_message(char*, int) const;
 379   void get_locked_message_ext(char*, int) const;
 380 
 381   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 382   void print_on(outputStream* st, bool withComments = false, bool printRanges = false);
 383   void print_kind(outputStream* st);
 384   void print_as_flag(outputStream* st);
 385 
 386   static const char* flag_error_str(Flag::Error error);
 387 };
 388 
 389 // debug flags control various aspects of the VM and are global accessible
 390 
 391 // use FlagSetting to temporarily change some debug flag
 392 // e.g. FlagSetting fs(DebugThisAndThat, true);
 393 // restored to previous value upon leaving scope
 394 class FlagSetting {
 395   bool val;
 396   bool* flag;
 397  public:
 398   FlagSetting(bool&amp; fl, bool newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 399   ~FlagSetting()                       { *flag = val; }
 400 };
 401 
 402 
 403 class CounterSetting {
 404   intx* counter;
 405  public:
 406   CounterSetting(intx* cnt) { counter = cnt; (*counter)++; }
 407   ~CounterSetting()         { (*counter)--; }
 408 };
 409 
 410 class IntFlagSetting {
 411   int val;
 412   int* flag;
 413  public:
 414   IntFlagSetting(int&amp; fl, int newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 415   ~IntFlagSetting()                     { *flag = val; }
 416 };
 417 
 418 class UIntFlagSetting {
 419   uint val;
 420   uint* flag;
 421  public:
 422   UIntFlagSetting(uint&amp; fl, uint newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 423   ~UIntFlagSetting()                       { *flag = val; }
 424 };
 425 
 426 class UIntXFlagSetting {
 427   uintx val;
 428   uintx* flag;
 429  public:
 430   UIntXFlagSetting(uintx&amp; fl, uintx newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 431   ~UIntXFlagSetting()                         { *flag = val; }
 432 };
 433 
 434 class DoubleFlagSetting {
 435   double val;
 436   double* flag;
 437  public:
 438   DoubleFlagSetting(double&amp; fl, double newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 439   ~DoubleFlagSetting()                           { *flag = val; }
 440 };
 441 
 442 class SizeTFlagSetting {
 443   size_t val;
 444   size_t* flag;
 445  public:
 446   SizeTFlagSetting(size_t&amp; fl, size_t newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 447   ~SizeTFlagSetting()                           { *flag = val; }
 448 };
 449 
 450 
 451 class CommandLineFlags {
 452 public:
 453   static Flag::Error boolAt(const char* name, size_t len, bool* value, bool allow_locked = false, bool return_flag = false);
 454   static Flag::Error boolAt(const char* name, bool* value, bool allow_locked = false, bool return_flag = false)      { return boolAt(name, strlen(name), value, allow_locked, return_flag); }
 455   static Flag::Error boolAtPut(Flag* flag, bool* value, Flag::Flags origin);
 456   static Flag::Error boolAtPut(const char* name, size_t len, bool* value, Flag::Flags origin);
 457   static Flag::Error boolAtPut(const char* name, bool* value, Flag::Flags origin)   { return boolAtPut(name, strlen(name), value, origin); }
 458 
 459   static Flag::Error intAt(const char* name, size_t len, int* value, bool allow_locked = false, bool return_flag = false);
 460   static Flag::Error intAt(const char* name, int* value, bool allow_locked = false, bool return_flag = false)      { return intAt(name, strlen(name), value, allow_locked, return_flag); }
 461   static Flag::Error intAtPut(Flag* flag, int* value, Flag::Flags origin);
 462   static Flag::Error intAtPut(const char* name, size_t len, int* value, Flag::Flags origin);
 463   static Flag::Error intAtPut(const char* name, int* value, Flag::Flags origin)   { return intAtPut(name, strlen(name), value, origin); }
 464 
 465   static Flag::Error uintAt(const char* name, size_t len, uint* value, bool allow_locked = false, bool return_flag = false);
 466   static Flag::Error uintAt(const char* name, uint* value, bool allow_locked = false, bool return_flag = false)      { return uintAt(name, strlen(name), value, allow_locked, return_flag); }
 467   static Flag::Error uintAtPut(Flag* flag, uint* value, Flag::Flags origin);
 468   static Flag::Error uintAtPut(const char* name, size_t len, uint* value, Flag::Flags origin);
 469   static Flag::Error uintAtPut(const char* name, uint* value, Flag::Flags origin)   { return uintAtPut(name, strlen(name), value, origin); }
 470 
 471   static Flag::Error intxAt(const char* name, size_t len, intx* value, bool allow_locked = false, bool return_flag = false);
 472   static Flag::Error intxAt(const char* name, intx* value, bool allow_locked = false, bool return_flag = false)      { return intxAt(name, strlen(name), value, allow_locked, return_flag); }
 473   static Flag::Error intxAtPut(Flag* flag, intx* value, Flag::Flags origin);
 474   static Flag::Error intxAtPut(const char* name, size_t len, intx* value, Flag::Flags origin);
 475   static Flag::Error intxAtPut(const char* name, intx* value, Flag::Flags origin)   { return intxAtPut(name, strlen(name), value, origin); }
 476 
 477   static Flag::Error uintxAt(const char* name, size_t len, uintx* value, bool allow_locked = false, bool return_flag = false);
 478   static Flag::Error uintxAt(const char* name, uintx* value, bool allow_locked = false, bool return_flag = false)    { return uintxAt(name, strlen(name), value, allow_locked, return_flag); }
 479   static Flag::Error uintxAtPut(Flag* flag, uintx* value, Flag::Flags origin);
 480   static Flag::Error uintxAtPut(const char* name, size_t len, uintx* value, Flag::Flags origin);
 481   static Flag::Error uintxAtPut(const char* name, uintx* value, Flag::Flags origin) { return uintxAtPut(name, strlen(name), value, origin); }
 482 
 483   static Flag::Error size_tAt(const char* name, size_t len, size_t* value, bool allow_locked = false, bool return_flag = false);
 484   static Flag::Error size_tAt(const char* name, size_t* value, bool allow_locked = false, bool return_flag = false)    { return size_tAt(name, strlen(name), value, allow_locked, return_flag); }
 485   static Flag::Error size_tAtPut(Flag* flag, size_t* value, Flag::Flags origin);
 486   static Flag::Error size_tAtPut(const char* name, size_t len, size_t* value, Flag::Flags origin);
 487   static Flag::Error size_tAtPut(const char* name, size_t* value, Flag::Flags origin) { return size_tAtPut(name, strlen(name), value, origin); }
 488 
 489   static Flag::Error uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked = false, bool return_flag = false);
 490   static Flag::Error uint64_tAt(const char* name, uint64_t* value, bool allow_locked = false, bool return_flag = false) { return uint64_tAt(name, strlen(name), value, allow_locked, return_flag); }
 491   static Flag::Error uint64_tAtPut(Flag* flag, uint64_t* value, Flag::Flags origin);
 492   static Flag::Error uint64_tAtPut(const char* name, size_t len, uint64_t* value, Flag::Flags origin);
 493   static Flag::Error uint64_tAtPut(const char* name, uint64_t* value, Flag::Flags origin) { return uint64_tAtPut(name, strlen(name), value, origin); }
 494 
 495   static Flag::Error doubleAt(const char* name, size_t len, double* value, bool allow_locked = false, bool return_flag = false);
 496   static Flag::Error doubleAt(const char* name, double* value, bool allow_locked = false, bool return_flag = false)    { return doubleAt(name, strlen(name), value, allow_locked, return_flag); }
 497   static Flag::Error doubleAtPut(Flag* flag, double* value, Flag::Flags origin);
 498   static Flag::Error doubleAtPut(const char* name, size_t len, double* value, Flag::Flags origin);
 499   static Flag::Error doubleAtPut(const char* name, double* value, Flag::Flags origin) { return doubleAtPut(name, strlen(name), value, origin); }
 500 
 501   static Flag::Error ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked = false, bool return_flag = false);
 502   static Flag::Error ccstrAt(const char* name, ccstr* value, bool allow_locked = false, bool return_flag = false)    { return ccstrAt(name, strlen(name), value, allow_locked, return_flag); }
 503   // Contract:  Flag will make private copy of the incoming value.
 504   // Outgoing value is always malloc-ed, and caller MUST call free.
 505   static Flag::Error ccstrAtPut(const char* name, size_t len, ccstr* value, Flag::Flags origin);
 506   static Flag::Error ccstrAtPut(const char* name, ccstr* value, Flag::Flags origin) { return ccstrAtPut(name, strlen(name), value, origin); }
 507 
 508   // Returns false if name is not a command line flag.
 509   static bool wasSetOnCmdline(const char* name, bool* value);
 510   static void printSetFlags(outputStream* out);
 511 
 512   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 513   static void printFlags(outputStream* out, bool withComments, bool printRanges = false);
 514 
 515   static void verify() PRODUCT_RETURN;
 516 };
 517 
 518 // use this for flags that are true by default in the debug version but
 519 // false in the optimized version, and vice versa
 520 #ifdef ASSERT
 521 #define trueInDebug  true
 522 #define falseInDebug false
 523 #else
 524 #define trueInDebug  false
 525 #define falseInDebug true
 526 #endif
 527 
 528 // use this for flags that are true per default in the product build
 529 // but false in development builds, and vice versa
 530 #ifdef PRODUCT
 531 #define trueInProduct  true
 532 #define falseInProduct false
 533 #else
 534 #define trueInProduct  false
 535 #define falseInProduct true
 536 #endif
 537 
 538 #ifdef JAVASE_EMBEDDED
 539 #define falseInEmbedded false
 540 #else
 541 #define falseInEmbedded true
 542 #endif
 543 
 544 // develop flags are settable / visible only during development and are constant in the PRODUCT version
 545 // product flags are always settable / visible
 546 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
 547 
 548 // A flag must be declared with one of the following types:
 549 // bool, int, uint, intx, uintx, size_t, ccstr, double, or uint64_t.
 550 // The type "ccstr" is an alias for "const char*" and is used
 551 // only in this file, because the macrology requires single-token type names.
 552 
 553 // Note: Diagnostic options not meant for VM tuning or for product modes.
 554 // They are to be used for VM quality assurance or field diagnosis
 555 // of VM bugs.  They are hidden so that users will not be encouraged to
 556 // try them as if they were VM ordinary execution options.  However, they
 557 // are available in the product version of the VM.  Under instruction
 558 // from support engineers, VM customers can turn them on to collect
 559 // diagnostic information about VM problems.  To use a VM diagnostic
 560 // option, you must first specify +UnlockDiagnosticVMOptions.
 561 // (This master switch also affects the behavior of -Xprintflags.)
 562 //
 563 // experimental flags are in support of features that are not
 564 //    part of the officially supported product, but are available
 565 //    for experimenting with. They could, for example, be performance
 566 //    features that may not have undergone full or rigorous QA, but which may
 567 //    help performance in some cases and released for experimentation
 568 //    by the community of users and developers. This flag also allows one to
 569 //    be able to build a fully supported product that nonetheless also
 570 //    ships with some unsupported, lightly tested, experimental features.
 571 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
 572 //    UnlockExperimentalVMOptions flag, which allows the control and
 573 //    modification of the experimental flags.
 574 //
 575 // Nota bene: neither diagnostic nor experimental options should be used casually,
 576 //    and they are not supported on production loads, except under explicit
 577 //    direction from support engineers.
 578 //
 579 // manageable flags are writeable external product flags.
 580 //    They are dynamically writeable through the JDK management interface
 581 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
 582 //    These flags are external exported interface (see CCC).  The list of
 583 //    manageable flags can be queried programmatically through the management
 584 //    interface.
 585 //
 586 //    A flag can be made as "manageable" only if
 587 //    - the flag is defined in a CCC as an external exported interface.
 588 //    - the VM implementation supports dynamic setting of the flag.
 589 //      This implies that the VM must *always* query the flag variable
 590 //      and not reuse state related to the flag state at any given time.
 591 //    - you want the flag to be queried programmatically by the customers.
 592 //
 593 // product_rw flags are writeable internal product flags.
 594 //    They are like "manageable" flags but for internal/private use.
 595 //    The list of product_rw flags are internal/private flags which
 596 //    may be changed/removed in a future release.  It can be set
 597 //    through the management interface to get/set value
 598 //    when the name of flag is supplied.
 599 //
 600 //    A flag can be made as "product_rw" only if
 601 //    - the VM implementation supports dynamic setting of the flag.
 602 //      This implies that the VM must *always* query the flag variable
 603 //      and not reuse state related to the flag state at any given time.
 604 //
 605 // Note that when there is a need to support develop flags to be writeable,
 606 // it can be done in the same way as product_rw.
 607 //
 608 // range is a macro that will expand to min and max arguments for range
 609 //    checking code if provided - see commandLineFlagRangeList.hpp
 610 //
 611 // constraint is a macro that will expand to custom function call
 612 //    for constraint checking if provided - see commandLineFlagConstraintList.hpp
 613 //
 614 
 615 #define RUNTIME_FLAGS(develop, develop_pd, product, product_pd, diagnostic, experimental, notproduct, manageable, product_rw, lp64_product, range, constraint) \
 616                                                                             \
 617   lp64_product(bool, UseCompressedOops, false,                              \
 618           "Use 32-bit object references in 64-bit VM. "                     \
 619           "lp64_product means flag is always constant in 32 bit VM")        \
 620                                                                             \
 621   lp64_product(bool, UseCompressedClassPointers, false,                     \
 622           "Use 32-bit class pointers in 64-bit VM. "                        \
 623           "lp64_product means flag is always constant in 32 bit VM")        \
 624                                                                             \
 625   notproduct(bool, CheckCompressedOops, true,                               \
 626           "Generate checks in encoding/decoding code in debug VM")          \
 627                                                                             \
 628   product_pd(size_t, HeapBaseMinAddress,                                    \
 629           "OS specific low limit for heap base address")                    \
 630                                                                             \
 631   product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
 632           "Heap allocation steps through preferred address regions to find" \
 633           " where it can allocate the heap. Number of steps to take per "   \
 634           "region.")                                                        \
 635           range(1, max_uintx)                                               \
 636                                                                             \
 637   diagnostic(bool, PrintCompressedOopsMode, false,                          \
 638           "Print compressed oops base address and encoding mode")           \
 639                                                                             \
 640   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 641           "Default object alignment in bytes, 8 is minimum")                \
 642           range(8, 256)                                                     \
 643           constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
 644                                                                             \
 645   product(bool, AssumeMP, false,                                            \
 646           "Instruct the VM to assume multiple processors are available")    \
 647                                                                             \
 648   /* UseMembar is theoretically a temp flag used for memory barrier      */ \
 649   /* removal testing.  It was supposed to be removed before FCS but has  */ \
 650   /* been re-added (see 6401008)                                         */ \
 651   product_pd(bool, UseMembar,                                               \
 652           "(Unstable) Issues membars on thread state transitions")          \
 653                                                                             \
 654   develop(bool, CleanChunkPoolAsync, falseInEmbedded,                       \
 655           "Clean the chunk pool asynchronously")                            \
 656                                                                             \
 657   experimental(bool, AlwaysSafeConstructors, false,                         \
 658           "Force safe construction, as if all fields are final.")           \
 659                                                                             \
 660   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 661           "Enable normal processing of flags relating to field diagnostics")\
 662                                                                             \
 663   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 664           "Enable normal processing of flags relating to experimental "     \
 665           "features")                                                       \
 666                                                                             \
 667   product(bool, JavaMonitorsInStackTrace, true,                             \
 668           "Print information about Java monitor locks when the stacks are"  \
 669           "dumped")                                                         \
 670                                                                             \
 671   product_pd(bool, UseLargePages,                                           \
 672           "Use large page memory")                                          \
 673                                                                             \
 674   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 675           "Allocate large pages individually for better affinity")          \
 676                                                                             \
 677   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 678           "Fail large pages individual allocation")                         \
 679                                                                             \
 680   product(bool, UseLargePagesInMetaspace, false,                            \
 681           "Use large page memory in metaspace. "                            \
 682           "Only used if UseLargePages is enabled.")                         \
 683                                                                             \
 684   develop(bool, TracePageSizes, false,                                      \
 685           "Trace page size selection and usage")                            \
 686                                                                             \
 687   product(bool, UseNUMA, false,                                             \
 688           "Use NUMA if available")                                          \
 689                                                                             \
 690   product(bool, UseNUMAInterleaving, false,                                 \
 691           "Interleave memory across NUMA nodes if available")               \
 692                                                                             \
 693   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 694           "Granularity to use for NUMA interleaving on Windows OS")         \
 695                                                                             \
 696   product(bool, ForceNUMA, false,                                           \
 697           "Force NUMA optimizations on single-node/UMA systems")            \
 698                                                                             \
 699   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 700           "Percentage (0-100) used to weight the current sample when "      \
 701           "computing exponentially decaying average for "                   \
 702           "AdaptiveNUMAChunkSizing")                                        \
 703           range(0, 100)                                                     \
 704                                                                             \
 705   product(size_t, NUMASpaceResizeRate, 1*G,                                 \
 706           "Do not reallocate more than this amount per collection")         \
 707                                                                             \
 708   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 709           "Enable adaptive chunk sizing for NUMA")                          \
 710                                                                             \
 711   product(bool, NUMAStats, false,                                           \
 712           "Print NUMA stats in detailed heap information")                  \
 713                                                                             \
 714   product(uintx, NUMAPageScanRate, 256,                                     \
 715           "Maximum number of pages to include in the page scan procedure")  \
 716                                                                             \
 717   product_pd(bool, NeedsDeoptSuspend,                                       \
 718           "True for register window machines (sparc/ia64)")                 \
 719                                                                             \
 720   product(intx, UseSSE, 99,                                                 \
 721           "Highest supported SSE instructions set on x86/x64")              \
 722           range(0, 99)                                                      \
 723                                                                             \
 724   product(bool, UseAES, false,                                              \
 725           "Control whether AES instructions can be used on x86/x64")        \
 726                                                                             \
 727   product(bool, UseSHA, false,                                              \
 728           "Control whether SHA instructions can be used "                   \
 729           "on SPARC and on ARM")                                            \
 730                                                                             \
 731   product(bool, UseGHASHIntrinsics, false,                                  \
 732           "Use intrinsics for GHASH versions of crypto")                    \
 733                                                                             \
 734   product(size_t, LargePageSizeInBytes, 0,                                  \
 735           "Large page size (0 to let VM choose the page size)")             \
 736                                                                             \
 737   product(size_t, LargePageHeapSizeThreshold, 128*M,                        \
 738           "Use large pages if maximum heap is at least this big")           \
 739                                                                             \
 740   product(bool, ForceTimeHighResolution, false,                             \
 741           "Using high time resolution (for Win32 only)")                    \
 742                                                                             \
 743   develop(bool, TraceItables, false,                                        \
 744           "Trace initialization and use of itables")                        \
 745                                                                             \
 746   develop(bool, TracePcPatching, false,                                     \
 747           "Trace usage of frame::patch_pc")                                 \
 748                                                                             \
 749   develop(bool, TraceJumps, false,                                          \
 750           "Trace assembly jumps in thread ring buffer")                     \
 751                                                                             \
 752   develop(bool, TraceRelocator, false,                                      \
 753           "Trace the bytecode relocator")                                   \
 754                                                                             \
 755   develop(bool, TraceLongCompiles, false,                                   \
 756           "Print out every time compilation is longer than "                \
 757           "a given threshold")                                              \
 758                                                                             \
 759   develop(bool, SafepointALot, false,                                       \
 760           "Generate a lot of safepoints. This works with "                  \
 761           "GuaranteedSafepointInterval")                                    \
 762                                                                             \
 763   product_pd(bool, BackgroundCompilation,                                   \
 764           "A thread requesting compilation is not blocked during "          \
 765           "compilation")                                                    \
 766                                                                             \
 767   product(bool, PrintVMQWaitTime, false,                                    \
 768           "Print out the waiting time in VM operation queue")               \
 769                                                                             \
 770   develop(bool, TraceOopMapGeneration, false,                               \
 771           "Show OopMapGeneration")                                          \
 772                                                                             \
 773   product(bool, MethodFlushing, true,                                       \
 774           "Reclamation of zombie and not-entrant methods")                  \
 775                                                                             \
 776   develop(bool, VerifyStack, false,                                         \
 777           "Verify stack of each thread when it is entering a runtime call") \
 778                                                                             \
 779   diagnostic(bool, ForceUnreachable, false,                                 \
 780           "Make all non code cache addresses to be unreachable by "         \
 781           "forcing use of 64bit literal fixups")                            \
 782                                                                             \
 783   notproduct(bool, StressDerivedPointers, false,                            \
 784           "Force scavenge when a derived pointer is detected on stack "     \
 785           "after rtm call")                                                 \
 786                                                                             \
 787   develop(bool, TraceDerivedPointers, false,                                \
 788           "Trace traversal of derived pointers on stack")                   \
 789                                                                             \
 790   notproduct(bool, TraceCodeBlobStacks, false,                              \
 791           "Trace stack-walk of codeblobs")                                  \
 792                                                                             \
 793   product(bool, PrintJNIResolving, false,                                   \
 794           "Used to implement -v:jni")                                       \
 795                                                                             \
 796   notproduct(bool, PrintRewrites, false,                                    \
 797           "Print methods that are being rewritten")                         \
 798                                                                             \
 799   product(bool, UseInlineCaches, true,                                      \
 800           "Use Inline Caches for virtual calls ")                           \
 801                                                                             \
 802   develop(bool, InlineArrayCopy, true,                                      \
 803           "Inline arraycopy native that is known to be part of "            \
 804           "base library DLL")                                               \
 805                                                                             \
 806   develop(bool, InlineObjectHash, true,                                     \
 807           "Inline Object::hashCode() native that is known to be part "      \
 808           "of base library DLL")                                            \
 809                                                                             \
 810   develop(bool, InlineNatives, true,                                        \
 811           "Inline natives that are known to be part of base library DLL")   \
 812                                                                             \
 813   develop(bool, InlineMathNatives, true,                                    \
 814           "Inline SinD, CosD, etc.")                                        \
 815                                                                             \
 816   develop(bool, InlineClassNatives, true,                                   \
 817           "Inline Class.isInstance, etc")                                   \
 818                                                                             \
 819   develop(bool, InlineThreadNatives, true,                                  \
 820           "Inline Thread.currentThread, etc")                               \
 821                                                                             \
 822   develop(bool, InlineUnsafeOps, true,                                      \
 823           "Inline memory ops (native methods) from Unsafe")                 \
 824                                                                             \
 825   product(bool, CriticalJNINatives, true,                                   \
 826           "Check for critical JNI entry points")                            \
 827                                                                             \
 828   notproduct(bool, StressCriticalJNINatives, false,                         \
 829           "Exercise register saving code in critical natives")              \
 830                                                                             \
 831   product(bool, UseSSE42Intrinsics, false,                                  \
 832           "SSE4.2 versions of intrinsics")                                  \
 833                                                                             \
 834   product(bool, UseAESIntrinsics, false,                                    \
 835           "Use intrinsics for AES versions of crypto")                      \
 836                                                                             \
 837   product(bool, UseSHA1Intrinsics, false,                                   \
 838           "Use intrinsics for SHA-1 crypto hash function. "                 \
 839           "Requires that UseSHA is enabled.")                               \
 840                                                                             \
 841   product(bool, UseSHA256Intrinsics, false,                                 \
 842           "Use intrinsics for SHA-224 and SHA-256 crypto hash functions. "  \
 843           "Requires that UseSHA is enabled.")                               \
 844                                                                             \
 845   product(bool, UseSHA512Intrinsics, false,                                 \
 846           "Use intrinsics for SHA-384 and SHA-512 crypto hash functions. "  \
 847           "Requires that UseSHA is enabled.")                               \
 848                                                                             \
 849   product(bool, UseCRC32Intrinsics, false,                                  \
 850           "use intrinsics for java.util.zip.CRC32")                         \
 851                                                                             \
 852   product(bool, UseCRC32CIntrinsics, false,                                 \
 853           "use intrinsics for java.util.zip.CRC32C")                        \
 854                                                                             \
 855   product(bool, UseAdler32Intrinsics, false,                                \
 856           "use intrinsics for java.util.zip.Adler32")                       \
 857                                                                             \
 858   diagnostic(ccstrlist, DisableIntrinsic, "",                               \
 859          "do not expand intrinsics whose (internal) names appear here")     \
 860                                                                             \
<a name="1" id="anc1"></a>


 861   develop(bool, TraceCallFixup, false,                                      \
 862           "Trace all call fixups")                                          \
 863                                                                             \
 864   develop(bool, DeoptimizeALot, false,                                      \
 865           "Deoptimize at every exit from the runtime system")               \
 866                                                                             \
 867   notproduct(ccstrlist, DeoptimizeOnlyAt, "",                               \
 868           "A comma separated list of bcis to deoptimize at")                \
 869                                                                             \
 870   product(bool, DeoptimizeRandom, false,                                    \
 871           "Deoptimize random frames on random exit from the runtime system")\
 872                                                                             \
 873   notproduct(bool, ZombieALot, false,                                       \
 874           "Create zombies (non-entrant) at exit from the runtime system")   \
 875                                                                             \
 876   product(bool, UnlinkSymbolsALot, false,                                   \
 877           "Unlink unreferenced symbols from the symbol table at safepoints")\
 878                                                                             \
 879   notproduct(bool, WalkStackALot, false,                                    \
 880           "Trace stack (no print) at every exit from the runtime system")   \
 881                                                                             \
 882   product(bool, Debugging, false,                                           \
 883           "Set when executing debug methods in debug.cpp "                  \
 884           "(to prevent triggering assertions)")                             \
 885                                                                             \
 886   notproduct(bool, StrictSafepointChecks, trueInDebug,                      \
 887           "Enable strict checks that safepoints cannot happen for threads " \
 888           "that use No_Safepoint_Verifier")                                 \
 889                                                                             \
 890   notproduct(bool, VerifyLastFrame, false,                                  \
 891           "Verify oops on last frame on entry to VM")                       \
 892                                                                             \
 893   develop(bool, TraceHandleAllocation, false,                               \
 894           "Print out warnings when suspiciously many handles are allocated")\
 895                                                                             \
 896   product(bool, FailOverToOldVerifier, true,                                \
 897           "Fail over to old verifier when split verifier fails")            \
 898                                                                             \
 899   develop(bool, ShowSafepointMsgs, false,                                   \
 900           "Show message about safepoint synchronization")                   \
 901                                                                             \
 902   product(bool, SafepointTimeout, false,                                    \
 903           "Time out and warn or fail after SafepointTimeoutDelay "          \
 904           "milliseconds if failed to reach safepoint")                      \
 905                                                                             \
 906   develop(bool, DieOnSafepointTimeout, false,                               \
 907           "Die upon failure to reach safepoint (see SafepointTimeout)")     \
 908                                                                             \
 909   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 910   /* typically, at most a few retries are needed                    */      \
 911   product(intx, SuspendRetryCount, 50,                                      \
 912           "Maximum retry count for an external suspend request")            \
 913           range(0, max_intx)                                                \
 914                                                                             \
 915   product(intx, SuspendRetryDelay, 5,                                       \
 916           "Milliseconds to delay per retry (* current_retry_count)")        \
 917           range(0, max_intx)                                                \
 918                                                                             \
 919   product(bool, AssertOnSuspendWaitFailure, false,                          \
 920           "Assert/Guarantee on external suspend wait failure")              \
 921                                                                             \
 922   product(bool, TraceSuspendWaitFailures, false,                            \
 923           "Trace external suspend wait failures")                           \
 924                                                                             \
 925   product(bool, MaxFDLimit, true,                                           \
 926           "Bump the number of file descriptors to maximum in Solaris")      \
 927                                                                             \
 928   diagnostic(bool, LogEvents, true,                                         \
 929           "Enable the various ring buffer event logs")                      \
 930                                                                             \
 931   diagnostic(uintx, LogEventsBufferEntries, 10,                             \
 932           "Number of ring buffer event logs")                               \
 933           range(1, NOT_LP64(1*K) LP64_ONLY(1*M))                            \
 934                                                                             \
 935   product(bool, BytecodeVerificationRemote, true,                           \
 936           "Enable the Java bytecode verifier for remote classes")           \
 937                                                                             \
 938   product(bool, BytecodeVerificationLocal, false,                           \
 939           "Enable the Java bytecode verifier for local classes")            \
 940                                                                             \
 941   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 942           "Force exceptions on FP stack under/overflow")                    \
 943                                                                             \
 944   develop(bool, VerifyStackAtCalls, false,                                  \
 945           "Verify that the stack pointer is unchanged after calls")         \
 946                                                                             \
 947   develop(bool, TraceJavaAssertions, false,                                 \
 948           "Trace java language assertions")                                 \
 949                                                                             \
 950   notproduct(bool, CheckAssertionStatusDirectives, false,                   \
 951           "Temporary - see javaClasses.cpp")                                \
 952                                                                             \
 953   notproduct(bool, PrintMallocFree, false,                                  \
 954           "Trace calls to C heap malloc/free allocation")                   \
 955                                                                             \
 956   product(bool, PrintOopAddress, false,                                     \
 957           "Always print the location of the oop")                           \
 958                                                                             \
 959   notproduct(bool, VerifyCodeCache, false,                                  \
 960           "Verify code cache on memory allocation/deallocation")            \
 961                                                                             \
 962   develop(bool, UseMallocOnly, false,                                       \
 963           "Use only malloc/free for allocation (no resource area/arena)")   \
 964                                                                             \
 965   develop(bool, PrintMalloc, false,                                         \
 966           "Print all malloc/free calls")                                    \
 967                                                                             \
 968   develop(bool, PrintMallocStatistics, false,                               \
 969           "Print malloc/free statistics")                                   \
 970                                                                             \
 971   develop(bool, ZapResourceArea, trueInDebug,                               \
 972           "Zap freed resource/arena space with 0xABABABAB")                 \
 973                                                                             \
 974   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 975           "Zap freed VM handle space with 0xBCBCBCBC")                      \
 976                                                                             \
 977   develop(bool, ZapJNIHandleArea, trueInDebug,                              \
 978           "Zap freed JNI handle space with 0xFEFEFEFE")                     \
 979                                                                             \
 980   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 981           "Zap allocated/freed stack segments with 0xFADFADED")             \
 982                                                                             \
 983   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 984           "Zap unused heap space with 0xBAADBABE")                          \
 985                                                                             \
 986   develop(bool, TraceZapUnusedHeapArea, false,                              \
 987           "Trace zapping of unused heap space")                             \
 988                                                                             \
 989   develop(bool, CheckZapUnusedHeapArea, false,                              \
 990           "Check zapping of unused heap space")                             \
 991                                                                             \
 992   develop(bool, ZapFillerObjects, trueInDebug,                              \
 993           "Zap filler objects with 0xDEAFBABE")                             \
 994                                                                             \
 995   develop(bool, PrintVMMessages, true,                                      \
 996           "Print VM messages on console")                                   \
 997                                                                             \
 998   product(bool, PrintGCApplicationConcurrentTime, false,                    \
 999           "Print the time the application has been running")                \
1000                                                                             \
1001   product(bool, PrintGCApplicationStoppedTime, false,                       \
1002           "Print the time the application has been stopped")                \
1003                                                                             \
1004   diagnostic(bool, VerboseVerification, false,                              \
1005           "Display detailed verification details")                          \
1006                                                                             \
1007   notproduct(uintx, ErrorHandlerTest, 0,                                    \
1008           "If &gt; 0, provokes an error after VM initialization; the value "   \
1009           "determines which error to provoke. See test_error_handler() "    \
1010           "in debug.cpp.")                                                  \
1011                                                                             \
1012   notproduct(uintx, TestCrashInErrorHandler, 0,                             \
1013           "If &gt; 0, provokes an error inside VM error handler (a secondary " \
1014           "crash). see test_error_handler() in debug.cpp.")                 \
1015                                                                             \
1016   notproduct(bool, TestSafeFetchInErrorHandler, false,                      \
1017           "If true, tests SafeFetch inside error handler.")                 \
1018                                                                             \
1019   develop(bool, Verbose, false,                                             \
1020           "Print additional debugging information from other modes")        \
1021                                                                             \
1022   develop(bool, PrintMiscellaneous, false,                                  \
1023           "Print uncategorized debugging information (requires +Verbose)")  \
1024                                                                             \
1025   develop(bool, WizardMode, false,                                          \
1026           "Print much more debugging information")                          \
1027                                                                             \
1028   product(bool, ShowMessageBoxOnError, false,                               \
1029           "Keep process alive on VM fatal error")                           \
1030                                                                             \
1031   product(bool, CreateCoredumpOnCrash, true,                                \
1032           "Create core/mini dump on VM fatal error")                        \
1033                                                                             \
1034   product(uintx, ErrorLogTimeout, 2 * 60,                                   \
1035           "Timeout, in seconds, to limit the time spent on writing an "     \
1036           "error log in case of a crash.")                                  \
1037                                                                             \
1038   product_pd(bool, UseOSErrorReporting,                                     \
1039           "Let VM fatal error propagate to the OS (ie. WER on Windows)")    \
1040                                                                             \
1041   product(bool, SuppressFatalErrorMessage, false,                           \
1042           "Report NO fatal error message (avoid deadlock)")                 \
1043                                                                             \
1044   product(ccstrlist, OnError, "",                                           \
1045           "Run user-defined commands on fatal error; see VMError.cpp "      \
1046           "for examples")                                                   \
1047                                                                             \
1048   product(ccstrlist, OnOutOfMemoryError, "",                                \
1049           "Run user-defined commands on first java.lang.OutOfMemoryError")  \
1050                                                                             \
1051   manageable(bool, HeapDumpBeforeFullGC, false,                             \
1052           "Dump heap to file before any major stop-the-world GC")           \
1053                                                                             \
1054   manageable(bool, HeapDumpAfterFullGC, false,                              \
1055           "Dump heap to file after any major stop-the-world GC")            \
1056                                                                             \
1057   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
1058           "Dump heap to file when java.lang.OutOfMemoryError is thrown")    \
1059                                                                             \
1060   manageable(ccstr, HeapDumpPath, NULL,                                     \
1061           "When HeapDumpOnOutOfMemoryError is on, the path (filename or "   \
1062           "directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof "   \
1063           "in the working directory)")                                      \
1064                                                                             \
1065   develop(size_t, SegmentedHeapDumpThreshold, 2*G,                          \
1066           "Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) "     \
1067           "when the heap usage is larger than this")                        \
1068                                                                             \
1069   develop(size_t, HeapDumpSegmentSize, 1*G,                                 \
1070           "Approximate segment size when generating a segmented heap dump") \
1071                                                                             \
1072   develop(bool, BreakAtWarning, false,                                      \
1073           "Execute breakpoint upon encountering VM warning")                \
1074                                                                             \
1075   develop(bool, TraceVMOperation, false,                                    \
1076           "Trace VM operations")                                            \
1077                                                                             \
1078   develop(bool, UseFakeTimers, false,                                       \
1079           "Tell whether the VM should use system time or a fake timer")     \
1080                                                                             \
1081   product(ccstr, NativeMemoryTracking, "off",                               \
1082           "Native memory tracking options")                                 \
1083                                                                             \
1084   diagnostic(bool, PrintNMTStatistics, false,                               \
1085           "Print native memory tracking summary data if it is on")          \
1086                                                                             \
1087   diagnostic(bool, LogCompilation, false,                                   \
1088           "Log compilation activity in detail to LogFile")                  \
1089                                                                             \
1090   product(bool, PrintCompilation, false,                                    \
1091           "Print compilations")                                             \
1092                                                                             \
1093   diagnostic(bool, TraceNMethodInstalls, false,                             \
1094           "Trace nmethod installation")                                     \
1095                                                                             \
1096   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
1097           "0: do not allow scavengable oops in the code cache; "            \
1098           "1: allow scavenging from the code cache; "                       \
1099           "2: emit as many constants as the compiler can see")              \
1100           range(0, 2)                                                       \
1101                                                                             \
1102   product(bool, AlwaysRestoreFPU, false,                                    \
1103           "Restore the FPU control word after every JNI call (expensive)")  \
1104                                                                             \
1105   diagnostic(bool, PrintCompilation2, false,                                \
1106           "Print additional statistics per compilation")                    \
1107                                                                             \
1108   diagnostic(bool, PrintAdapterHandlers, false,                             \
1109           "Print code generated for i2c/c2i adapters")                      \
1110                                                                             \
1111   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
1112           "Verify that i2c/c2i adapters are called properly")               \
1113                                                                             \
1114   develop(bool, VerifyAdapterSharing, false,                                \
1115           "Verify that the code for shared adapters is the equivalent")     \
1116                                                                             \
1117   diagnostic(bool, PrintAssembly, false,                                    \
1118           "Print assembly code (using external disassembler.so)")           \
1119                                                                             \
1120   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
1121           "Print options string passed to disassembler.so")                 \
1122                                                                             \
1123   notproduct(bool, PrintNMethodStatistics, false,                           \
1124           "Print a summary statistic for the generated nmethods")           \
1125                                                                             \
1126   diagnostic(bool, PrintNMethods, false,                                    \
1127           "Print assembly code for nmethods when generated")                \
1128                                                                             \
1129   diagnostic(intx, PrintNMethodsAtLevel, -1,                                \
1130           "Only print code for nmethods at the given compilation level")    \
1131                                                                             \
1132   diagnostic(bool, PrintNativeNMethods, false,                              \
1133           "Print assembly code for native nmethods when generated")         \
1134                                                                             \
1135   develop(bool, PrintDebugInfo, false,                                      \
1136           "Print debug information for all nmethods when generated")        \
1137                                                                             \
1138   develop(bool, PrintRelocations, false,                                    \
1139           "Print relocation information for all nmethods when generated")   \
1140                                                                             \
1141   develop(bool, PrintDependencies, false,                                   \
1142           "Print dependency information for all nmethods when generated")   \
1143                                                                             \
1144   develop(bool, PrintExceptionHandlers, false,                              \
1145           "Print exception handler tables for all nmethods when generated") \
1146                                                                             \
1147   develop(bool, StressCompiledExceptionHandlers, false,                     \
1148           "Exercise compiled exception handlers")                           \
1149                                                                             \
1150   develop(bool, InterceptOSException, false,                                \
1151           "Start debugger when an implicit OS (e.g. NULL) "                 \
1152           "exception happens")                                              \
1153                                                                             \
1154   product(bool, PrintCodeCache, false,                                      \
1155           "Print the code cache memory usage when exiting")                 \
1156                                                                             \
1157   develop(bool, PrintCodeCache2, false,                                     \
1158           "Print detailed usage information on the code cache when exiting")\
1159                                                                             \
1160   product(bool, PrintCodeCacheOnCompilation, false,                         \
1161           "Print the code cache memory usage each time a method is "        \
1162           "compiled")                                                       \
1163                                                                             \
1164   diagnostic(bool, PrintStubCode, false,                                    \
1165           "Print generated stub code")                                      \
1166                                                                             \
1167   product(bool, StackTraceInThrowable, true,                                \
1168           "Collect backtrace in throwable when exception happens")          \
1169                                                                             \
1170   product(bool, OmitStackTraceInFastThrow, true,                            \
1171           "Omit backtraces for some 'hot' exceptions in optimized code")    \
1172                                                                             \
1173   product(bool, ProfilerPrintByteCodeStatistics, false,                     \
1174           "Print bytecode statistics when dumping profiler output")         \
1175                                                                             \
1176   product(bool, ProfilerRecordPC, false,                                    \
1177           "Collect ticks for each 16 byte interval of compiled code")       \
1178                                                                             \
1179   product(bool, ProfileVM, false,                                           \
1180           "Profile ticks that fall within VM (either in the VM Thread "     \
1181           "or VM code called through stubs)")                               \
1182                                                                             \
1183   product(bool, ProfileIntervals, false,                                    \
1184           "Print profiles for each interval (see ProfileIntervalsTicks)")   \
1185                                                                             \
1186   notproduct(bool, ProfilerCheckIntervals, false,                           \
1187           "Collect and print information on spacing of profiler ticks")     \
1188                                                                             \
1189   product(bool, PrintWarnings, true,                                        \
1190           "Print JVM warnings to output stream")                            \
1191                                                                             \
1192   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
1193           "Print warnings for stalled SpinLocks")                           \
1194                                                                             \
1195   product(bool, RegisterFinalizersAtInit, true,                             \
1196           "Register finalizable objects at end of Object.&lt;init&gt; or "        \
1197           "after allocation")                                               \
1198                                                                             \
1199   develop(bool, RegisterReferences, true,                                   \
1200           "Tell whether the VM should register soft/weak/final/phantom "    \
1201           "references")                                                     \
1202                                                                             \
1203   develop(bool, IgnoreRewrites, false,                                      \
1204           "Suppress rewrites of bytecodes in the oopmap generator. "        \
1205           "This is unsafe!")                                                \
1206                                                                             \
1207   develop(bool, PrintCodeCacheExtension, false,                             \
1208           "Print extension of code cache")                                  \
1209                                                                             \
1210   develop(bool, UsePrivilegedStack, true,                                   \
1211           "Enable the security JVM functions")                              \
1212                                                                             \
1213   develop(bool, ProtectionDomainVerification, true,                         \
1214           "Verify protection domain before resolution in system dictionary")\
1215                                                                             \
1216   product(bool, ClassUnloading, true,                                       \
1217           "Do unloading of classes")                                        \
1218                                                                             \
1219   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
1220           "Do unloading of classes with a concurrent marking cycle")        \
1221                                                                             \
1222   develop(bool, DisableStartThread, false,                                  \
1223           "Disable starting of additional Java threads "                    \
1224           "(for debugging only)")                                           \
1225                                                                             \
1226   develop(bool, MemProfiling, false,                                        \
1227           "Write memory usage profiling to log file")                       \
1228                                                                             \
1229   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
1230           "Print the system dictionary at exit")                            \
1231                                                                             \
1232   experimental(intx, PredictedLoadedClassCount, 0,                          \
1233           "Experimental: Tune loaded class cache starting size")            \
1234                                                                             \
1235   diagnostic(bool, UnsyncloadClass, false,                                  \
1236           "Unstable: VM calls loadClass unsynchronized. Custom "            \
1237           "class loader must call VM synchronized for findClass "           \
1238           "and defineClass.")                                               \
1239                                                                             \
1240   product(bool, AlwaysLockClassLoader, false,                               \
1241           "Require the VM to acquire the class loader lock before calling " \
1242           "loadClass() even for class loaders registering "                 \
1243           "as parallel capable")                                            \
1244                                                                             \
1245   product(bool, AllowParallelDefineClass, false,                            \
1246           "Allow parallel defineClass requests for class loaders "          \
1247           "registering as parallel capable")                                \
1248                                                                             \
1249   product(bool, MustCallLoadClassInternal, false,                           \
1250           "Call loadClassInternal() rather than loadClass()")               \
1251                                                                             \
1252   product_pd(bool, DontYieldALot,                                           \
1253           "Throw away obvious excess yield calls")                          \
1254                                                                             \
1255   product_pd(bool, ConvertSleepToYield,                                     \
1256           "Convert sleep(0) to thread yield "                               \
1257           "(may be off for Solaris to improve GUI)")                        \
1258                                                                             \
1259   product(bool, ConvertYieldToSleep, false,                                 \
1260           "Convert yield to a sleep of MinSleepInterval to simulate Win32 " \
1261           "behavior")                                                       \
1262                                                                             \
1263   develop(bool, UseDetachedThreads, true,                                   \
1264           "Use detached threads that are recycled upon termination "        \
1265           "(for Solaris only)")                                             \
1266                                                                             \
1267   product(bool, UseLWPSynchronization, true,                                \
1268           "Use LWP-based instead of libthread-based synchronization "       \
1269           "(SPARC only)")                                                   \
1270                                                                             \
1271   experimental(ccstr, SyncKnobs, NULL,                                      \
1272                "(Unstable) Various monitor synchronization tunables")       \
1273                                                                             \
1274   experimental(intx, EmitSync, 0,                                           \
1275                "(Unsafe, Unstable) "                                        \
1276                "Control emission of inline sync fast-path code")            \
1277                                                                             \
1278   product(intx, MonitorBound, 0, "Bound Monitor population")                \
1279           range(0, max_jint)                                                \
1280                                                                             \
1281   product(bool, MonitorInUseLists, false, "Track Monitors for Deflation")   \
1282                                                                             \
1283   experimental(intx, SyncFlags, 0, "(Unsafe, Unstable) "                    \
1284                "Experimental Sync flags")                                   \
1285                                                                             \
1286   experimental(intx, SyncVerbose, 0, "(Unstable)")                          \
1287                                                                             \
1288   diagnostic(bool, InlineNotify, true, "intrinsify subset of notify")       \
1289                                                                             \
1290   experimental(intx, ClearFPUAtPark, 0, "(Unsafe, Unstable)")               \
1291                                                                             \
1292   experimental(intx, hashCode, 5,                                           \
1293                "(Unstable) select hashCode generation algorithm")           \
1294                                                                             \
1295   experimental(intx, WorkAroundNPTLTimedWaitHang, 0,                        \
1296                "(Unstable, Linux-specific) "                                \
1297                "avoid NPTL-FUTEX hang pthread_cond_timedwait")              \
1298                                                                             \
1299   product(bool, FilterSpuriousWakeups, true,                                \
1300           "When true prevents OS-level spurious, or premature, wakeups "    \
1301           "from Object.wait (Ignored for Windows)")                         \
1302                                                                             \
1303   experimental(intx, NativeMonitorTimeout, -1, "(Unstable)")                \
1304                                                                             \
1305   experimental(intx, NativeMonitorFlags, 0, "(Unstable)")                   \
1306                                                                             \
1307   experimental(intx, NativeMonitorSpinLimit, 20, "(Unstable)")              \
1308                                                                             \
1309   develop(bool, UsePthreads, false,                                         \
1310           "Use pthread-based instead of libthread-based synchronization "   \
1311           "(SPARC only)")                                                   \
1312                                                                             \
1313   product(bool, ReduceSignalUsage, false,                                   \
1314           "Reduce the use of OS signals in Java and/or the VM")             \
1315                                                                             \
1316   develop_pd(bool, ShareVtableStubs,                                        \
1317           "Share vtable stubs (smaller code but worse branch prediction")   \
1318                                                                             \
1319   develop(bool, LoadLineNumberTables, true,                                 \
1320           "Tell whether the class file parser loads line number tables")    \
1321                                                                             \
1322   develop(bool, LoadLocalVariableTables, true,                              \
1323           "Tell whether the class file parser loads local variable tables") \
1324                                                                             \
1325   develop(bool, LoadLocalVariableTypeTables, true,                          \
1326           "Tell whether the class file parser loads local variable type"    \
1327           "tables")                                                         \
1328                                                                             \
1329   product(bool, AllowUserSignalHandlers, false,                             \
1330           "Do not complain if the application installs signal handlers "    \
1331           "(Solaris &amp; Linux only)")                                         \
1332                                                                             \
1333   product(bool, UseSignalChaining, true,                                    \
1334           "Use signal-chaining to invoke signal handlers installed "        \
1335           "by the application (Solaris &amp; Linux only)")                      \
1336                                                                             \
1337   product(bool, UseAltSigs, false,                                          \
1338           "Use alternate signals instead of SIGUSR1 &amp; SIGUSR2 for VM "      \
1339           "internal signals (Solaris only)")                                \
1340                                                                             \
1341   product(bool, AllowJNIEnvProxy, false,                                    \
1342           "Allow JNIEnv proxies for jdbx")                                  \
1343                                                                             \
1344   product(bool, RestoreMXCSROnJNICalls, false,                              \
1345           "Restore MXCSR when returning from JNI calls")                    \
1346                                                                             \
1347   product(bool, CheckJNICalls, false,                                       \
1348           "Verify all arguments to JNI calls")                              \
1349                                                                             \
1350   product(bool, CheckEndorsedAndExtDirs, false,                             \
1351           "Verify the endorsed and extension directories are not used")     \
1352                                                                             \
1353   product(bool, UseFastJNIAccessors, true,                                  \
1354           "Use optimized versions of Get&lt;Primitive&gt;Field")                  \
1355                                                                             \
1356   product(intx, MaxJNILocalCapacity, 65536,                                 \
1357           "Maximum allowable local JNI handle capacity to "                 \
1358           "EnsureLocalCapacity() and PushLocalFrame(), "                    \
1359           "where &lt;= 0 is unlimited, default: 65536")                        \
1360           range(min_intx, max_intx)                                         \
1361                                                                             \
1362   product(bool, EagerXrunInit, false,                                       \
1363           "Eagerly initialize -Xrun libraries; allows startup profiling, "  \
1364           "but not all -Xrun libraries may support the state of the VM "    \
1365           "at this time")                                                   \
1366                                                                             \
1367   product(bool, PreserveAllAnnotations, false,                              \
1368           "Preserve RuntimeInvisibleAnnotations as well "                   \
1369           "as RuntimeVisibleAnnotations")                                   \
1370                                                                             \
1371   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
1372           "Number of OutOfMemoryErrors preallocated with backtrace")        \
1373                                                                             \
1374   product(bool, UseXMMForArrayCopy, false,                                  \
1375           "Use SSE2 MOVQ instruction for Arraycopy")                        \
1376                                                                             \
1377   product(intx, FieldsAllocationStyle, 1,                                   \
1378           "0 - type based with oops first, "                                \
1379           "1 - with oops last, "                                            \
1380           "2 - oops in super and sub classes are together")                 \
1381           range(0, 2)                                                       \
1382                                                                             \
1383   product(bool, CompactFields, true,                                        \
1384           "Allocate nonstatic fields in gaps between previous fields")      \
1385                                                                             \
1386   notproduct(bool, PrintFieldLayout, false,                                 \
1387           "Print field layout for each class")                              \
1388                                                                             \
1389   /* Need to limit the extent of the padding to reasonable size.          */\
1390   /* 8K is well beyond the reasonable HW cache line size, even with       */\
1391   /* aggressive prefetching, while still leaving the room for segregating */\
1392   /* among the distinct pages.                                            */\
1393   product(intx, ContendedPaddingWidth, 128,                                 \
1394           "How many bytes to pad the fields/classes marked @Contended with")\
1395           range(0, 8192)                                                    \
1396           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
1397                                                                             \
1398   product(bool, EnableContended, true,                                      \
1399           "Enable @Contended annotation support")                           \
1400                                                                             \
1401   product(bool, RestrictContended, true,                                    \
1402           "Restrict @Contended to trusted classes")                         \
1403                                                                             \
1404   product(bool, UseBiasedLocking, true,                                     \
1405           "Enable biased locking in JVM")                                   \
1406                                                                             \
1407   product(intx, BiasedLockingStartupDelay, 4000,                            \
1408           "Number of milliseconds to wait before enabling biased locking")  \
1409           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
1410           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
1411                                                                             \
1412   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
1413           "Print statistics of biased locking in JVM")                      \
1414                                                                             \
1415   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
1416           "Threshold of number of revocations per type to try to "          \
1417           "rebias all objects in the heap of that type")                    \
1418           range(0, max_intx)                                                \
1419           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
1420                                                                             \
1421   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
1422           "Threshold of number of revocations per type to permanently "     \
1423           "revoke biases of all objects in the heap of that type")          \
1424           range(0, max_intx)                                                \
1425           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
1426                                                                             \
1427   product(intx, BiasedLockingDecayTime, 25000,                              \
1428           "Decay time (in milliseconds) to re-enable bulk rebiasing of a "  \
1429           "type after previous bulk rebias")                                \
1430           range(500, max_intx)                                              \
1431           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
1432                                                                             \
1433   /* tracing */                                                             \
1434                                                                             \
1435   notproduct(bool, TraceRuntimeCalls, false,                                \
1436           "Trace run-time calls")                                           \
1437                                                                             \
1438   develop(bool, TraceJNICalls, false,                                       \
1439           "Trace JNI calls")                                                \
1440                                                                             \
1441   develop(bool, StressRewriter, false,                                      \
1442           "Stress linktime bytecode rewriting")                             \
1443                                                                             \
1444   notproduct(bool, TraceJVMCalls, false,                                    \
1445           "Trace JVM calls")                                                \
1446                                                                             \
1447   product(ccstr, TraceJVMTI, NULL,                                          \
1448           "Trace flags for JVMTI functions and events")                     \
1449                                                                             \
1450   /* This option can change an EMCP method into an obsolete method. */      \
1451   /* This can affect tests that except specific methods to be EMCP. */      \
1452   /* This option should be used with caution.                       */      \
1453   product(bool, StressLdcRewrite, false,                                    \
1454           "Force ldc -&gt; ldc_w rewrite during RedefineClasses")              \
1455                                                                             \
1456   product(uintx, TraceRedefineClasses, 0,                                   \
1457           "Trace level for JVMTI RedefineClasses")                          \
1458           range(0, 0xFFFFFFFF)                                              \
1459                                                                             \
1460   /* change to false by default sometime after Mustang */                   \
1461   product(bool, VerifyMergedCPBytecodes, true,                              \
1462           "Verify bytecodes after RedefineClasses constant pool merging")   \
1463                                                                             \
1464   develop(bool, TraceJNIHandleAllocation, false,                            \
1465           "Trace allocation/deallocation of JNI handle blocks")             \
1466                                                                             \
1467   develop(bool, TraceBytecodes, false,                                      \
1468           "Trace bytecode execution")                                       \
1469                                                                             \
1470   develop(bool, TraceClassInitialization, false,                            \
1471           "Trace class initialization")                                     \
1472                                                                             \
1473   product(bool, TraceExceptions, false,                                     \
1474           "Trace exceptions")                                               \
1475                                                                             \
1476   develop(bool, TraceICs, false,                                            \
1477           "Trace inline cache changes")                                     \
1478                                                                             \
1479   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
1480           "Trace method invocation counter overflow")                       \
1481                                                                             \
1482   develop(bool, TraceInlineCacheClearing, false,                            \
1483           "Trace clearing of inline caches in nmethods")                    \
1484                                                                             \
1485   develop(bool, TraceDependencies, false,                                   \
1486           "Trace dependencies")                                             \
1487                                                                             \
1488   develop(bool, VerifyDependencies, trueInDebug,                            \
1489           "Exercise and verify the compilation dependency mechanism")       \
1490                                                                             \
1491   develop(bool, TraceNewOopMapGeneration, false,                            \
1492           "Trace OopMapGeneration")                                         \
1493                                                                             \
1494   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
1495           "Trace OopMapGeneration: print detailed cell states")             \
1496                                                                             \
1497   develop(bool, TimeOopMap, false,                                          \
1498           "Time calls to GenerateOopMap::compute_map() in sum")             \
1499                                                                             \
1500   develop(bool, TimeOopMap2, false,                                         \
1501           "Time calls to GenerateOopMap::compute_map() individually")       \
1502                                                                             \
1503   develop(bool, TraceMonitorMismatch, false,                                \
1504           "Trace monitor matching failures during OopMapGeneration")        \
1505                                                                             \
1506   develop(bool, TraceOopMapRewrites, false,                                 \
1507           "Trace rewriting of method oops during oop map generation")       \
1508                                                                             \
1509   develop(bool, TraceICBuffer, false,                                       \
1510           "Trace usage of IC buffer")                                       \
1511                                                                             \
1512   develop(bool, TraceCompiledIC, false,                                     \
1513           "Trace changes of compiled IC")                                   \
1514                                                                             \
1515   develop(bool, TraceStartupTime, false,                                    \
1516           "Trace setup time")                                               \
1517                                                                             \
1518   develop(bool, TraceProtectionDomainVerification, false,                   \
1519           "Trace protection domain verification")                           \
1520                                                                             \
1521   develop(bool, TraceClearedExceptions, false,                              \
1522           "Print when an exception is forcibly cleared")                    \
1523                                                                             \
1524   product(bool, TraceClassResolution, false,                                \
1525           "Trace all constant pool resolutions (for debugging)")            \
1526                                                                             \
1527   product(bool, TraceBiasedLocking, false,                                  \
1528           "Trace biased locking in JVM")                                    \
1529                                                                             \
1530   product(bool, TraceMonitorInflation, false,                               \
1531           "Trace monitor inflation in JVM")                                 \
1532                                                                             \
1533   /* gc */                                                                  \
1534                                                                             \
1535   product(bool, UseSerialGC, false,                                         \
1536           "Use the Serial garbage collector")                               \
1537                                                                             \
1538   product(bool, UseG1GC, false,                                             \
1539           "Use the Garbage-First garbage collector")                        \
1540                                                                             \
1541   product(bool, UseParallelGC, false,                                       \
1542           "Use the Parallel Scavenge garbage collector")                    \
1543                                                                             \
1544   product(bool, UseParallelOldGC, false,                                    \
1545           "Use the Parallel Old garbage collector")                         \
1546                                                                             \
1547   product(uintx, HeapMaximumCompactionInterval, 20,                         \
1548           "How often should we maximally compact the heap (not allowing "   \
1549           "any dead space)")                                                \
1550                                                                             \
1551   product(uintx, HeapFirstMaximumCompactionCount, 3,                        \
1552           "The collection count for the first maximum compaction")          \
1553                                                                             \
1554   product(bool, UseMaximumCompactionOnSystemGC, true,                       \
1555           "Use maximum compaction in the Parallel Old garbage collector "   \
1556           "for a system GC")                                                \
1557                                                                             \
1558   product(uintx, ParallelOldDeadWoodLimiterMean, 50,                        \
1559           "The mean used by the parallel compact dead wood "                \
1560           "limiter (a number between 0-100)")                               \
1561           range(0, 100)                                                     \
1562                                                                             \
1563   product(uintx, ParallelOldDeadWoodLimiterStdDev, 80,                      \
1564           "The standard deviation used by the parallel compact dead wood "  \
1565           "limiter (a number between 0-100)")                               \
1566           range(0, 100)                                                     \
1567                                                                             \
1568   product(uint, ParallelGCThreads, 0,                                       \
1569           "Number of parallel threads parallel gc will use")                \
1570           constraint(ParallelGCThreadsConstraintFunc,AfterErgo)             \
1571                                                                             \
1572   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
1573             "Use semaphore synchronization for the GC Threads, "            \
1574             "instead of synchronization based on mutexes")                  \
1575                                                                             \
1576   product(bool, UseDynamicNumberOfGCThreads, false,                         \
1577           "Dynamically choose the number of parallel threads "              \
1578           "parallel gc will use")                                           \
1579                                                                             \
1580   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
1581           "Force dynamic selection of the number of "                       \
1582           "parallel threads parallel gc will use to aid debugging")         \
1583                                                                             \
1584   product(size_t, HeapSizePerGCThread, ScaleForWordSize(64*M),              \
1585           "Size of heap (bytes) per GC thread used in calculating the "     \
1586           "number of GC threads")                                           \
1587           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
1588                                                                             \
1589   product(bool, TraceDynamicGCThreads, false,                               \
1590           "Trace the dynamic GC thread usage")                              \
1591                                                                             \
1592   product(uint, ConcGCThreads, 0,                                           \
1593           "Number of threads concurrent gc will use")                       \
1594           constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \
1595                                                                             \
1596   product(uintx, GCTaskTimeStampEntries, 200,                               \
1597           "Number of time stamp entries per gc worker thread")              \
1598           range(1, max_uintx)                                               \
1599                                                                             \
1600   product(bool, AlwaysTenure, false,                                        \
1601           "Always tenure objects in eden (ParallelGC only)")                \
1602                                                                             \
1603   product(bool, NeverTenure, false,                                         \
1604           "Never tenure objects in eden, may tenure on overflow "           \
1605           "(ParallelGC only)")                                              \
1606                                                                             \
1607   product(bool, ScavengeBeforeFullGC, true,                                 \
1608           "Scavenge youngest generation before each full GC.")              \
1609                                                                             \
1610   product(bool, UseConcMarkSweepGC, false,                                  \
1611           "Use Concurrent Mark-Sweep GC in the old generation")             \
1612                                                                             \
1613   product(bool, ExplicitGCInvokesConcurrent, false,                         \
1614           "A System.gc() request invokes a concurrent collection; "         \
1615           "(effective only when using concurrent collectors)")              \
1616                                                                             \
1617   product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false,        \
1618           "A System.gc() request invokes a concurrent collection and "      \
1619           "also unloads classes during such a concurrent gc cycle "         \
1620           "(effective only when UseConcMarkSweepGC)")                       \
1621                                                                             \
1622   product(bool, GCLockerInvokesConcurrent, false,                           \
1623           "The exit of a JNI critical section necessitating a scavenge, "   \
1624           "also kicks off a background concurrent collection")              \
1625                                                                             \
1626   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
1627           "How much the GC can expand the eden by while the GC locker "     \
1628           "is active (as a percentage)")                                    \
1629           range(0, 100)                                                     \
1630                                                                             \
1631   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
1632           "Number of times to retry allocations when "                      \
1633           "blocked by the GC locker")                                       \
1634                                                                             \
1635   product(bool, UseCMSBestFit, true,                                        \
1636           "Use CMS best fit allocation strategy")                           \
1637                                                                             \
1638   product(bool, UseParNewGC, false,                                         \
1639           "Use parallel threads in the new generation")                     \
1640                                                                             \
1641   product(bool, PrintTaskqueue, false,                                      \
1642           "Print taskqueue statistics for parallel collectors")             \
1643                                                                             \
1644   product(bool, PrintTerminationStats, false,                               \
1645           "Print termination statistics for parallel collectors")           \
1646                                                                             \
1647   product(uintx, ParallelGCBufferWastePct, 10,                              \
1648           "Wasted fraction of parallel allocation buffer")                  \
1649           range(0, 100)                                                     \
1650                                                                             \
1651   product(uintx, TargetPLABWastePct, 10,                                    \
1652           "Target wasted space in last buffer as percent of overall "       \
1653           "allocation")                                                     \
1654           range(1, 100)                                                     \
1655                                                                             \
1656   product(uintx, PLABWeight, 75,                                            \
1657           "Percentage (0-100) used to weight the current sample when "      \
1658           "computing exponentially decaying average for ResizePLAB")        \
1659           range(0, 100)                                                     \
1660                                                                             \
1661   product(bool, ResizePLAB, true,                                           \
1662           "Dynamically resize (survivor space) promotion LAB's")            \
1663                                                                             \
1664   product(bool, PrintPLAB, false,                                           \
1665           "Print (survivor space) promotion LAB's sizing decisions")        \
1666                                                                             \
1667   product(intx, ParGCArrayScanChunk, 50,                                    \
1668           "Scan a subset of object array and push remainder, if array is "  \
1669           "bigger than this")                                               \
1670           range(1, max_intx)                                                \
1671                                                                             \
1672   product(bool, ParGCUseLocalOverflow, false,                               \
1673           "Instead of a global overflow list, use local overflow stacks")   \
1674                                                                             \
1675   product(bool, ParGCTrimOverflow, true,                                    \
1676           "Eagerly trim the local overflow lists "                          \
1677           "(when ParGCUseLocalOverflow)")                                   \
1678                                                                             \
1679   notproduct(bool, ParGCWorkQueueOverflowALot, false,                       \
1680           "Simulate work queue overflow in ParNew")                         \
1681                                                                             \
1682   notproduct(uintx, ParGCWorkQueueOverflowInterval, 1000,                   \
1683           "An `interval' counter that determines how frequently "           \
1684           "we simulate overflow; a smaller number increases frequency")     \
1685                                                                             \
1686   product(uintx, ParGCDesiredObjsFromOverflowList, 20,                      \
1687           "The desired number of objects to claim from the overflow list")  \
1688                                                                             \
1689   diagnostic(uintx, ParGCStridesPerThread, 2,                               \
1690           "The number of strides per worker thread that we divide up the "  \
1691           "card table scanning work into")                                  \
1692           range(1, max_uintx)                                               \
1693           constraint(ParGCStridesPerThreadConstraintFunc,AfterErgo)         \
1694                                                                             \
1695   diagnostic(intx, ParGCCardsPerStrideChunk, 256,                           \
1696           "The number of cards in each chunk of the parallel chunks used "  \
1697           "during card table scanning")                                     \
1698           range(1, max_intx)                                                \
1699                                                                             \
1700   product(uintx, OldPLABWeight, 50,                                         \
1701           "Percentage (0-100) used to weight the current sample when "      \
1702           "computing exponentially decaying average for resizing "          \
1703           "OldPLABSize")                                                    \
1704           range(0, 100)                                                     \
1705                                                                             \
1706   product(bool, ResizeOldPLAB, true,                                        \
1707           "Dynamically resize (old gen) promotion LAB's")                   \
1708                                                                             \
1709   product(bool, PrintOldPLAB, false,                                        \
1710           "Print (old gen) promotion LAB's sizing decisions")               \
1711                                                                             \
1712   product(size_t, CMSOldPLABMax, 1024,                                      \
1713           "Maximum size of CMS gen promotion LAB caches per worker "        \
1714           "per block size")                                                 \
1715           range(1, max_uintx)                                               \
1716           constraint(CMSOldPLABMaxConstraintFunc,AfterMemoryInit)           \
1717                                                                             \
1718   product(size_t, CMSOldPLABMin, 16,                                        \
1719           "Minimum size of CMS gen promotion LAB caches per worker "        \
1720           "per block size")                                                 \
1721           range(1, max_uintx)                                               \
1722           constraint(CMSOldPLABMinConstraintFunc,AfterMemoryInit)           \
1723                                                                             \
1724   product(uintx, CMSOldPLABNumRefills, 4,                                   \
1725           "Nominal number of refills of CMS gen promotion LAB cache "       \
1726           "per worker per block size")                                      \
1727           range(1, max_uintx)                                               \
1728                                                                             \
1729   product(bool, CMSOldPLABResizeQuicker, false,                             \
1730           "React on-the-fly during a scavenge to a sudden "                 \
1731           "change in block demand rate")                                    \
1732                                                                             \
1733   product(uintx, CMSOldPLABToleranceFactor, 4,                              \
1734           "The tolerance of the phase-change detector for on-the-fly "      \
1735           "PLAB resizing during a scavenge")                                \
1736           range(1, max_uintx)                                               \
1737                                                                             \
1738   product(uintx, CMSOldPLABReactivityFactor, 2,                             \
1739           "The gain in the feedback loop for on-the-fly PLAB resizing "     \
1740           "during a scavenge")                                              \
1741                                                                             \
1742   product(bool, AlwaysPreTouch, false,                                      \
1743           "Force all freshly committed pages to be pre-touched")            \
1744                                                                             \
1745   product_pd(size_t, CMSYoungGenPerWorker,                                  \
1746           "The maximum size of young gen chosen by default per GC worker "  \
1747           "thread available")                                               \
1748           range(1, max_uintx)                                               \
1749                                                                             \
1750   product(uintx, CMSIncrementalSafetyFactor, 10,                            \
1751           "Percentage (0-100) used to add conservatism when computing the " \
1752           "duty cycle")                                                     \
1753           range(0, 100)                                                     \
1754                                                                             \
1755   product(uintx, CMSExpAvgFactor, 50,                                       \
1756           "Percentage (0-100) used to weight the current sample when "      \
1757           "computing exponential averages for CMS statistics")              \
1758           range(0, 100)                                                     \
1759                                                                             \
1760   product(uintx, CMS_FLSWeight, 75,                                         \
1761           "Percentage (0-100) used to weight the current sample when "      \
1762           "computing exponentially decaying averages for CMS FLS "          \
1763           "statistics")                                                     \
1764           range(0, 100)                                                     \
1765                                                                             \
1766   product(uintx, CMS_FLSPadding, 1,                                         \
1767           "The multiple of deviation from mean to use for buffering "       \
1768           "against volatility in free list demand")                         \
1769                                                                             \
1770   product(uintx, FLSCoalescePolicy, 2,                                      \
1771           "CMS: aggressiveness level for coalescing, increasing "           \
1772           "from 0 to 4")                                                    \
1773           range(0, 4)                                                       \
1774                                                                             \
1775   product(bool, FLSAlwaysCoalesceLarge, false,                              \
1776           "CMS: larger free blocks are always available for coalescing")    \
1777                                                                             \
1778   product(double, FLSLargestBlockCoalesceProximity, 0.99,                   \
1779           "CMS: the smaller the percentage the greater the coalescing "     \
1780           "force")                                                          \
1781           range(0.0, 1.0)                                                   \
1782                                                                             \
1783   product(double, CMSSmallCoalSurplusPercent, 1.05,                         \
1784           "CMS: the factor by which to inflate estimated demand of small "  \
1785           "block sizes to prevent coalescing with an adjoining block")      \
1786           range(0.0, DBL_MAX)                                               \
1787                                                                             \
1788   product(double, CMSLargeCoalSurplusPercent, 0.95,                         \
1789           "CMS: the factor by which to inflate estimated demand of large "  \
1790           "block sizes to prevent coalescing with an adjoining block")      \
1791           range(0.0, DBL_MAX)                                               \
1792                                                                             \
1793   product(double, CMSSmallSplitSurplusPercent, 1.10,                        \
1794           "CMS: the factor by which to inflate estimated demand of small "  \
1795           "block sizes to prevent splitting to supply demand for smaller "  \
1796           "blocks")                                                         \
1797           range(0.0, DBL_MAX)                                               \
1798                                                                             \
1799   product(double, CMSLargeSplitSurplusPercent, 1.00,                        \
1800           "CMS: the factor by which to inflate estimated demand of large "  \
1801           "block sizes to prevent splitting to supply demand for smaller "  \
1802           "blocks")                                                         \
1803           range(0.0, DBL_MAX)                                               \
1804                                                                             \
1805   product(bool, CMSExtrapolateSweep, false,                                 \
1806           "CMS: cushion for block demand during sweep")                     \
1807                                                                             \
1808   product(uintx, CMS_SweepWeight, 75,                                       \
1809           "Percentage (0-100) used to weight the current sample when "      \
1810           "computing exponentially decaying average for inter-sweep "       \
1811           "duration")                                                       \
1812           range(0, 100)                                                     \
1813                                                                             \
1814   product(uintx, CMS_SweepPadding, 1,                                       \
1815           "The multiple of deviation from mean to use for buffering "       \
1816           "against volatility in inter-sweep duration")                     \
1817                                                                             \
1818   product(uintx, CMS_SweepTimerThresholdMillis, 10,                         \
1819           "Skip block flux-rate sampling for an epoch unless inter-sweep "  \
1820           "duration exceeds this threshold in milliseconds")                \
1821                                                                             \
1822   product(bool, CMSClassUnloadingEnabled, true,                             \
1823           "Whether class unloading enabled when using CMS GC")              \
1824                                                                             \
1825   product(uintx, CMSClassUnloadingMaxInterval, 0,                           \
1826           "When CMS class unloading is enabled, the maximum CMS cycle "     \
1827           "count for which classes may not be unloaded")                    \
1828                                                                             \
1829   product(uintx, CMSIndexedFreeListReplenish, 4,                            \
1830           "Replenish an indexed free list with this number of chunks")      \
1831           range(1, max_uintx)                                               \
1832                                                                             \
1833   product(bool, CMSReplenishIntermediate, true,                             \
1834           "Replenish all intermediate free-list caches")                    \
1835                                                                             \
1836   product(bool, CMSSplitIndexedFreeListBlocks, true,                        \
1837           "When satisfying batched demand, split blocks from the "          \
1838           "IndexedFreeList whose size is a multiple of requested size")     \
1839                                                                             \
1840   product(bool, CMSLoopWarn, false,                                         \
1841           "Warn in case of excessive CMS looping")                          \
1842                                                                             \
1843   /* where does the range max value of (max_jint - 1) come from? */         \
1844   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
1845           "Maximum size of marking stack")                                  \
1846           range(1, (max_jint - 1))                                          \
1847                                                                             \
1848   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
1849           "Size of marking stack")                                          \
1850           constraint(MarkStackSizeConstraintFunc,AfterErgo)                 \
1851                                                                             \
1852   notproduct(bool, CMSMarkStackOverflowALot, false,                         \
1853           "Simulate frequent marking stack / work queue overflow")          \
1854                                                                             \
1855   notproduct(uintx, CMSMarkStackOverflowInterval, 1000,                     \
1856           "An \"interval\" counter that determines how frequently "         \
1857           "to simulate overflow; a smaller number increases frequency")     \
1858                                                                             \
1859   product(uintx, CMSMaxAbortablePrecleanLoops, 0,                           \
1860           "Maximum number of abortable preclean iterations, if &gt; 0")        \
1861                                                                             \
1862   product(intx, CMSMaxAbortablePrecleanTime, 5000,                          \
1863           "Maximum time in abortable preclean (in milliseconds)")           \
1864           range(0, max_intx)                                                \
1865                                                                             \
1866   product(uintx, CMSAbortablePrecleanMinWorkPerIteration, 100,              \
1867           "Nominal minimum work per abortable preclean iteration")          \
1868                                                                             \
1869   manageable(intx, CMSAbortablePrecleanWaitMillis, 100,                     \
1870           "Time that we sleep between iterations when not given "           \
1871           "enough work per iteration")                                      \
1872           range(0, max_intx)                                                \
1873                                                                             \
1874   product(size_t, CMSRescanMultiple, 32,                                    \
1875           "Size (in cards) of CMS parallel rescan task")                    \
1876           range(1, max_uintx)                                               \
1877                                                                             \
1878   product(size_t, CMSConcMarkMultiple, 32,                                  \
1879           "Size (in cards) of CMS concurrent MT marking task")              \
1880           range(1, max_uintx)                                               \
1881                                                                             \
1882   product(bool, CMSAbortSemantics, false,                                   \
1883           "Whether abort-on-overflow semantics is implemented")             \
1884                                                                             \
1885   product(bool, CMSParallelInitialMarkEnabled, true,                        \
1886           "Use the parallel initial mark.")                                 \
1887                                                                             \
1888   product(bool, CMSParallelRemarkEnabled, true,                             \
1889           "Whether parallel remark enabled (only if ParNewGC)")             \
1890                                                                             \
1891   product(bool, CMSParallelSurvivorRemarkEnabled, true,                     \
1892           "Whether parallel remark of survivor space "                      \
1893           "enabled (effective only if CMSParallelRemarkEnabled)")           \
1894                                                                             \
1895   product(bool, CMSPLABRecordAlways, true,                                  \
1896           "Always record survivor space PLAB boundaries (effective only "   \
1897           "if CMSParallelSurvivorRemarkEnabled)")                           \
1898                                                                             \
1899   product(bool, CMSEdenChunksRecordAlways, true,                            \
1900           "Always record eden chunks used for the parallel initial mark "   \
1901           "or remark of eden")                                              \
1902                                                                             \
1903   product(bool, CMSPrintEdenSurvivorChunks, false,                          \
1904           "Print the eden and the survivor chunks used for the parallel "   \
1905           "initial mark or remark of the eden/survivor spaces")             \
1906                                                                             \
1907   product(bool, CMSConcurrentMTEnabled, true,                               \
1908           "Whether multi-threaded concurrent work enabled "                 \
1909           "(effective only if ParNewGC)")                                   \
1910                                                                             \
1911   product(bool, CMSPrecleaningEnabled, true,                                \
1912           "Whether concurrent precleaning enabled")                         \
1913                                                                             \
1914   product(uintx, CMSPrecleanIter, 3,                                        \
1915           "Maximum number of precleaning iteration passes")                 \
1916           range(0, 9)                                                       \
1917                                                                             \
1918   product(uintx, CMSPrecleanDenominator, 3,                                 \
1919           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1920           "ratio")                                                          \
1921           range(1, max_uintx)                                               \
1922           constraint(CMSPrecleanDenominatorConstraintFunc,AfterErgo)        \
1923                                                                             \
1924   product(uintx, CMSPrecleanNumerator, 2,                                   \
1925           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1926           "ratio")                                                          \
1927           range(0, max_uintx-1)                                             \
1928           constraint(CMSPrecleanNumeratorConstraintFunc,AfterErgo)          \
1929                                                                             \
1930   product(bool, CMSPrecleanRefLists1, true,                                 \
1931           "Preclean ref lists during (initial) preclean phase")             \
1932                                                                             \
1933   product(bool, CMSPrecleanRefLists2, false,                                \
1934           "Preclean ref lists during abortable preclean phase")             \
1935                                                                             \
1936   product(bool, CMSPrecleanSurvivors1, false,                               \
1937           "Preclean survivors during (initial) preclean phase")             \
1938                                                                             \
1939   product(bool, CMSPrecleanSurvivors2, true,                                \
1940           "Preclean survivors during abortable preclean phase")             \
1941                                                                             \
1942   product(uintx, CMSPrecleanThreshold, 1000,                                \
1943           "Do not iterate again if number of dirty cards is less than this")\
1944           range(100, max_uintx)                                             \
1945                                                                             \
1946   product(bool, CMSCleanOnEnter, true,                                      \
1947           "Clean-on-enter optimization for reducing number of dirty cards") \
1948                                                                             \
1949   product(uintx, CMSRemarkVerifyVariant, 1,                                 \
1950           "Choose variant (1,2) of verification following remark")          \
1951           range(1, 2)                                                       \
1952                                                                             \
1953   product(size_t, CMSScheduleRemarkEdenSizeThreshold, 2*M,                  \
1954           "If Eden size is below this, do not try to schedule remark")      \
1955                                                                             \
1956   product(uintx, CMSScheduleRemarkEdenPenetration, 50,                      \
1957           "The Eden occupancy percentage (0-100) at which "                 \
1958           "to try and schedule remark pause")                               \
1959           range(0, 100)                                                     \
1960                                                                             \
1961   product(uintx, CMSScheduleRemarkSamplingRatio, 5,                         \
1962           "Start sampling eden top at least before young gen "              \
1963           "occupancy reaches 1/&lt;ratio&gt; of the size at which "               \
1964           "we plan to schedule remark")                                     \
1965           range(1, max_uintx)                                               \
1966                                                                             \
1967   product(uintx, CMSSamplingGrain, 16*K,                                    \
1968           "The minimum distance between eden samples for CMS (see above)")  \
1969           range(1, max_uintx)                                               \
1970                                                                             \
1971   product(bool, CMSScavengeBeforeRemark, false,                             \
1972           "Attempt scavenge before the CMS remark step")                    \
1973                                                                             \
1974   develop(bool, CMSTraceSweeper, false,                                     \
1975           "Trace some actions of the CMS sweeper")                          \
1976                                                                             \
1977   product(uintx, CMSWorkQueueDrainThreshold, 10,                            \
1978           "Don't drain below this size per parallel worker/thief")          \
1979           range(1, max_juint)                                               \
1980           constraint(CMSWorkQueueDrainThresholdConstraintFunc,AfterErgo)    \
1981                                                                             \
1982   manageable(intx, CMSWaitDuration, 2000,                                   \
1983           "Time in milliseconds that CMS thread waits for young GC")        \
1984                                                                             \
1985   develop(uintx, CMSCheckInterval, 1000,                                    \
1986           "Interval in milliseconds that CMS thread checks if it "          \
1987           "should start a collection cycle")                                \
1988                                                                             \
1989   product(bool, CMSYield, true,                                             \
1990           "Yield between steps of CMS")                                     \
1991                                                                             \
1992   product(size_t, CMSBitMapYieldQuantum, 10*M,                              \
1993           "Bitmap operations should process at most this many bits "        \
1994           "between yields")                                                 \
1995           range(1, max_uintx)                                               \
1996                                                                             \
1997   product(bool, CMSDumpAtPromotionFailure, false,                           \
1998           "Dump useful information about the state of the CMS old "         \
1999           "generation upon a promotion failure")                            \
2000                                                                             \
2001   product(bool, CMSPrintChunksInDump, false,                                \
2002           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
2003           "more detailed information about the free chunks")                \
2004                                                                             \
2005   product(bool, CMSPrintObjectsInDump, false,                               \
2006           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
2007           "more detailed information about the allocated objects")          \
2008                                                                             \
2009   diagnostic(bool, FLSVerifyAllHeapReferences, false,                       \
2010           "Verify that all references across the FLS boundary "             \
2011           "are to valid objects")                                           \
2012                                                                             \
2013   diagnostic(bool, FLSVerifyLists, false,                                   \
2014           "Do lots of (expensive) FreeListSpace verification")              \
2015                                                                             \
2016   diagnostic(bool, FLSVerifyIndexTable, false,                              \
2017           "Do lots of (expensive) FLS index table verification")            \
2018                                                                             \
2019   develop(bool, FLSVerifyDictionary, false,                                 \
2020           "Do lots of (expensive) FLS dictionary verification")             \
2021                                                                             \
2022   develop(bool, VerifyBlockOffsetArray, false,                              \
2023           "Do (expensive) block offset array verification")                 \
2024                                                                             \
2025   diagnostic(bool, BlockOffsetArrayUseUnallocatedBlock, false,              \
2026           "Maintain _unallocated_block in BlockOffsetArray "                \
2027           "(currently applicable only to CMS collector)")                   \
2028                                                                             \
2029   develop(bool, TraceCMSState, false,                                       \
2030           "Trace the state of the CMS collection")                          \
2031                                                                             \
2032   product(intx, RefDiscoveryPolicy, 0,                                      \
2033           "Select type of reference discovery policy: "                     \
2034           "reference-based(0) or referent-based(1)")                        \
2035           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
2036                 ReferenceProcessor::DiscoveryPolicyMax)                     \
2037                                                                             \
2038   product(bool, ParallelRefProcEnabled, false,                              \
2039           "Enable parallel reference processing whenever possible")         \
2040                                                                             \
2041   product(bool, ParallelRefProcBalancingEnabled, true,                      \
2042           "Enable balancing of reference processing queues")                \
2043                                                                             \
2044   product(uintx, CMSTriggerRatio, 80,                                       \
2045           "Percentage of MinHeapFreeRatio in CMS generation that is "       \
2046           "allocated before a CMS collection cycle commences")              \
2047           range(0, 100)                                                     \
2048                                                                             \
2049   product(uintx, CMSBootstrapOccupancy, 50,                                 \
2050           "Percentage CMS generation occupancy at which to "                \
2051           "initiate CMS collection for bootstrapping collection stats")     \
2052           range(0, 100)                                                     \
2053                                                                             \
2054   product(intx, CMSInitiatingOccupancyFraction, -1,                         \
2055           "Percentage CMS generation occupancy to start a CMS collection "  \
2056           "cycle. A negative value means that CMSTriggerRatio is used")     \
2057           range(min_intx, 100)                                              \
2058                                                                             \
2059   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
2060           "Percentage of the (entire) heap occupancy to start a "           \
2061           "concurrent GC cycle. It is used by GCs that trigger a "          \
2062           "concurrent GC cycle based on the occupancy of the entire heap, " \
2063           "not just one of the generations (e.g., G1). A value of 0 "       \
2064           "denotes 'do constant GC cycles'.")                               \
2065           range(0, 100)                                                     \
2066                                                                             \
2067   manageable(intx, CMSTriggerInterval, -1,                                  \
2068           "Commence a CMS collection cycle (at least) every so many "       \
2069           "milliseconds (0 permanently, -1 disabled)")                      \
2070           range(-1, max_intx)                                               \
2071                                                                             \
2072   product(bool, UseCMSInitiatingOccupancyOnly, false,                       \
2073           "Only use occupancy as a criterion for starting a CMS collection")\
2074                                                                             \
2075   product(uintx, CMSIsTooFullPercentage, 98,                                \
2076           "An absolute ceiling above which CMS will always consider the "   \
2077           "unloading of classes when class unloading is enabled")           \
2078           range(0, 100)                                                     \
2079                                                                             \
2080   develop(bool, CMSTestInFreeList, false,                                   \
2081           "Check if the coalesced range is already in the "                 \
2082           "free lists as claimed")                                          \
2083                                                                             \
2084   notproduct(bool, CMSVerifyReturnedBytes, false,                           \
2085           "Check that all the garbage collected was returned to the "       \
2086           "free lists")                                                     \
2087                                                                             \
2088   notproduct(bool, ScavengeALot, false,                                     \
2089           "Force scavenge at every Nth exit from the runtime system "       \
2090           "(N=ScavengeALotInterval)")                                       \
2091                                                                             \
2092   develop(bool, FullGCALot, false,                                          \
2093           "Force full gc at every Nth exit from the runtime system "        \
2094           "(N=FullGCALotInterval)")                                         \
2095                                                                             \
2096   notproduct(bool, GCALotAtAllSafepoints, false,                            \
2097           "Enforce ScavengeALot/GCALot at all potential safepoints")        \
2098                                                                             \
2099   product(bool, PrintPromotionFailure, false,                               \
2100           "Print additional diagnostic information following "              \
2101           "promotion failure")                                              \
2102                                                                             \
2103   notproduct(bool, PromotionFailureALot, false,                             \
2104           "Use promotion failure handling on every youngest generation "    \
2105           "collection")                                                     \
2106                                                                             \
2107   develop(uintx, PromotionFailureALotCount, 1000,                           \
2108           "Number of promotion failures occurring at PLAB "                 \
2109           "refill attempts (ParNew) or promotion attempts "                 \
2110           "(other young collectors)")                                       \
2111                                                                             \
2112   develop(uintx, PromotionFailureALotInterval, 5,                           \
2113           "Total collections between promotion failures a lot")             \
2114                                                                             \
2115   experimental(uintx, WorkStealingSleepMillis, 1,                           \
2116           "Sleep time when sleep is used for yields")                       \
2117                                                                             \
2118   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
2119           "Number of yields before a sleep is done during work stealing")   \
2120                                                                             \
2121   experimental(uintx, WorkStealingHardSpins, 4096,                          \
2122           "Number of iterations in a spin loop between checks on "          \
2123           "time out of hard spin")                                          \
2124                                                                             \
2125   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
2126           "Ratio of hard spins to calls to yield")                          \
2127                                                                             \
2128   develop(uintx, ObjArrayMarkingStride, 512,                                \
2129           "Number of object array elements to push onto the marking stack " \
2130           "before pushing a continuation entry")                            \
2131                                                                             \
2132   develop(bool, MetadataAllocationFailALot, false,                          \
2133           "Fail metadata allocations at intervals controlled by "           \
2134           "MetadataAllocationFailALotInterval")                             \
2135                                                                             \
2136   develop(uintx, MetadataAllocationFailALotInterval, 1000,                  \
2137           "Metadata allocation failure a lot interval")                     \
2138                                                                             \
2139   develop(bool, TraceMetadataChunkAllocation, false,                        \
2140           "Trace chunk metadata allocations")                               \
2141                                                                             \
2142   product(bool, TraceMetadataHumongousAllocation, false,                    \
2143           "Trace humongous metadata allocations")                           \
2144                                                                             \
2145   develop(bool, TraceMetavirtualspaceAllocation, false,                     \
2146           "Trace virtual space metadata allocations")                       \
2147                                                                             \
2148   notproduct(bool, ExecuteInternalVMTests, false,                           \
2149           "Enable execution of internal VM tests")                          \
2150                                                                             \
2151   notproduct(bool, VerboseInternalVMTests, false,                           \
2152           "Turn on logging for internal VM tests.")                         \
2153                                                                             \
2154   product_pd(bool, UseTLAB, "Use thread-local object allocation")           \
2155                                                                             \
2156   product_pd(bool, ResizeTLAB,                                              \
2157           "Dynamically resize TLAB size for threads")                       \
2158                                                                             \
2159   product(bool, ZeroTLAB, false,                                            \
2160           "Zero out the newly created TLAB")                                \
2161                                                                             \
2162   product(bool, FastTLABRefill, true,                                       \
2163           "Use fast TLAB refill code")                                      \
2164                                                                             \
2165   product(bool, PrintTLAB, false,                                           \
2166           "Print various TLAB related information")                         \
2167                                                                             \
2168   product(bool, TLABStats, true,                                            \
2169           "Provide more detailed and expensive TLAB statistics "            \
2170           "(with PrintTLAB)")                                               \
2171                                                                             \
2172   product_pd(bool, NeverActAsServerClassMachine,                            \
2173           "Never act like a server-class machine")                          \
2174                                                                             \
2175   product(bool, AlwaysActAsServerClassMachine, false,                       \
2176           "Always act like a server-class machine")                         \
2177                                                                             \
2178   product_pd(uint64_t, MaxRAM,                                              \
2179           "Real memory size (in bytes) used to set maximum heap size")      \
2180           range(0, 0XFFFFFFFFFFFFFFFF)                                      \
2181                                                                             \
2182   product(size_t, ErgoHeapSizeLimit, 0,                                     \
2183           "Maximum ergonomically set heap size (in bytes); zero means use " \
2184           "MaxRAM / MaxRAMFraction")                                        \
2185                                                                             \
2186   product(uintx, MaxRAMFraction, 4,                                         \
2187           "Maximum fraction (1/n) of real memory used for maximum heap "    \
2188           "size")                                                           \
2189           range(1, max_uintx)                                               \
2190                                                                             \
2191   product(uintx, MinRAMFraction, 2,                                         \
2192           "Minimum fraction (1/n) of real memory used for maximum heap "    \
2193           "size on systems with small physical memory size")                \
2194           range(1, max_uintx)                                               \
2195                                                                             \
2196   product(uintx, InitialRAMFraction, 64,                                    \
2197           "Fraction (1/n) of real memory used for initial heap size")       \
2198           range(1, max_uintx)                                               \
2199                                                                             \
2200   develop(uintx, MaxVirtMemFraction, 2,                                     \
2201           "Maximum fraction (1/n) of virtual memory used for ergonomically "\
2202           "determining maximum heap size")                                  \
2203                                                                             \
2204   product(bool, UseAutoGCSelectPolicy, false,                               \
2205           "Use automatic collection selection policy")                      \
2206                                                                             \
2207   product(uintx, AutoGCSelectPauseMillis, 5000,                             \
2208           "Automatic GC selection pause threshold in milliseconds")         \
2209                                                                             \
2210   product(bool, UseAdaptiveSizePolicy, true,                                \
2211           "Use adaptive generation sizing policies")                        \
2212                                                                             \
2213   product(bool, UsePSAdaptiveSurvivorSizePolicy, true,                      \
2214           "Use adaptive survivor sizing policies")                          \
2215                                                                             \
2216   product(bool, UseAdaptiveGenerationSizePolicyAtMinorCollection, true,     \
2217           "Use adaptive young-old sizing policies at minor collections")    \
2218                                                                             \
2219   product(bool, UseAdaptiveGenerationSizePolicyAtMajorCollection, true,     \
2220           "Use adaptive young-old sizing policies at major collections")    \
2221                                                                             \
2222   product(bool, UseAdaptiveSizePolicyWithSystemGC, false,                   \
2223           "Include statistics from System.gc() for adaptive size policy")   \
2224                                                                             \
2225   product(bool, UseAdaptiveGCBoundary, false,                               \
2226           "Allow young-old boundary to move")                               \
2227                                                                             \
2228   develop(bool, TraceAdaptiveGCBoundary, false,                             \
2229           "Trace young-old boundary moves")                                 \
2230                                                                             \
2231   develop(intx, PSAdaptiveSizePolicyResizeVirtualSpaceAlot, -1,             \
2232           "Resize the virtual spaces of the young or old generations")      \
2233           range(-1, 1)                                                      \
2234                                                                             \
2235   product(uintx, AdaptiveSizeThroughPutPolicy, 0,                           \
2236           "Policy for changing generation size for throughput goals")       \
2237           range(0, 1)                                                       \
2238                                                                             \
2239   product(uintx, AdaptiveSizePolicyInitializingSteps, 20,                   \
2240           "Number of steps where heuristics is used before data is used")   \
2241                                                                             \
2242   develop(uintx, AdaptiveSizePolicyReadyThreshold, 5,                       \
2243           "Number of collections before the adaptive sizing is started")    \
2244                                                                             \
2245   product(uintx, AdaptiveSizePolicyOutputInterval, 0,                       \
2246           "Collection interval for printing information; zero means never") \
2247                                                                             \
2248   product(bool, UseAdaptiveSizePolicyFootprintGoal, true,                   \
2249           "Use adaptive minimum footprint as a goal")                       \
2250                                                                             \
2251   product(uintx, AdaptiveSizePolicyWeight, 10,                              \
2252           "Weight given to exponential resizing, between 0 and 100")        \
2253           range(0, 100)                                                     \
2254                                                                             \
2255   product(uintx, AdaptiveTimeWeight,       25,                              \
2256           "Weight given to time in adaptive policy, between 0 and 100")     \
2257           range(0, 100)                                                     \
2258                                                                             \
2259   product(uintx, PausePadding, 1,                                           \
2260           "How much buffer to keep for pause time")                         \
2261                                                                             \
2262   product(uintx, PromotedPadding, 3,                                        \
2263           "How much buffer to keep for promotion failure")                  \
2264                                                                             \
2265   product(uintx, SurvivorPadding, 3,                                        \
2266           "How much buffer to keep for survivor overflow")                  \
2267                                                                             \
2268   product(uintx, ThresholdTolerance, 10,                                    \
2269           "Allowed collection cost difference between generations")         \
2270           range(0, 100)                                                     \
2271                                                                             \
2272   product(uintx, AdaptiveSizePolicyCollectionCostMargin, 50,                \
2273           "If collection costs are within margin, reduce both by full "     \
2274           "delta")                                                          \
2275                                                                             \
2276   product(uintx, YoungGenerationSizeIncrement, 20,                          \
2277           "Adaptive size percentage change in young generation")            \
2278           range(0, 100)                                                     \
2279                                                                             \
2280   product(uintx, YoungGenerationSizeSupplement, 80,                         \
2281           "Supplement to YoungedGenerationSizeIncrement used at startup")   \
2282           range(0, 100)                                                     \
2283                                                                             \
2284   product(uintx, YoungGenerationSizeSupplementDecay, 8,                     \
2285           "Decay factor to YoungedGenerationSizeSupplement")                \
2286           range(1, max_uintx)                                               \
2287                                                                             \
2288   product(uintx, TenuredGenerationSizeIncrement, 20,                        \
2289           "Adaptive size percentage change in tenured generation")          \
2290           range(0, 100)                                                     \
2291                                                                             \
2292   product(uintx, TenuredGenerationSizeSupplement, 80,                       \
2293           "Supplement to TenuredGenerationSizeIncrement used at startup")   \
2294           range(0, 100)                                                     \
2295                                                                             \
2296   product(uintx, TenuredGenerationSizeSupplementDecay, 2,                   \
2297           "Decay factor to TenuredGenerationSizeIncrement")                 \
2298           range(1, max_uintx)                                               \
2299                                                                             \
2300   product(uintx, MaxGCPauseMillis, max_uintx,                               \
2301           "Adaptive size policy maximum GC pause time goal in millisecond, "\
2302           "or (G1 Only) the maximum GC time per MMU time slice")            \
2303           range(1, max_uintx)                                               \
2304           constraint(MaxGCPauseMillisConstraintFunc,AfterMemoryInit)        \
2305                                                                             \
2306   product(uintx, GCPauseIntervalMillis, 0,                                  \
2307           "Time slice for MMU specification")                               \
2308           constraint(GCPauseIntervalMillisConstraintFunc,AfterMemoryInit)   \
2309                                                                             \
2310   product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \
2311           "Adaptive size policy maximum GC minor pause time goal "          \
2312           "in millisecond")                                                 \
2313                                                                             \
2314   product(uintx, GCTimeRatio, 99,                                           \
2315           "Adaptive size policy application time to GC time ratio")         \
2316                                                                             \
2317   product(uintx, AdaptiveSizeDecrementScaleFactor, 4,                       \
2318           "Adaptive size scale down factor for shrinking")                  \
2319           range(1, max_uintx)                                               \
2320                                                                             \
2321   product(bool, UseAdaptiveSizeDecayMajorGCCost, true,                      \
2322           "Adaptive size decays the major cost for long major intervals")   \
2323                                                                             \
2324   product(uintx, AdaptiveSizeMajorGCDecayTimeScale, 10,                     \
2325           "Time scale over which major costs decay")                        \
2326                                                                             \
2327   product(uintx, MinSurvivorRatio, 3,                                       \
2328           "Minimum ratio of young generation/survivor space size")          \
2329           range(3, max_uintx)                                               \
2330                                                                             \
2331   product(uintx, InitialSurvivorRatio, 8,                                   \
2332           "Initial ratio of young generation/survivor space size")          \
2333                                                                             \
2334   product(size_t, BaseFootPrintEstimate, 256*M,                             \
2335           "Estimate of footprint other than Java Heap")                     \
2336                                                                             \
2337   product(bool, UseGCOverheadLimit, true,                                   \
2338           "Use policy to limit of proportion of time spent in GC "          \
2339           "before an OutOfMemory error is thrown")                          \
2340                                                                             \
2341   product(uintx, GCTimeLimit, 98,                                           \
2342           "Limit of the proportion of time spent in GC before "             \
2343           "an OutOfMemoryError is thrown (used with GCHeapFreeLimit)")      \
2344           range(0, 100)                                                     \
2345                                                                             \
2346   product(uintx, GCHeapFreeLimit, 2,                                        \
2347           "Minimum percentage of free space after a full GC before an "     \
2348           "OutOfMemoryError is thrown (used with GCTimeLimit)")             \
2349           range(0, 100)                                                     \
2350                                                                             \
2351   develop(uintx, AdaptiveSizePolicyGCTimeLimitThreshold, 5,                 \
2352           "Number of consecutive collections before gc time limit fires")   \
2353           range(1, max_uintx)                                               \
2354                                                                             \
2355   product(bool, PrintAdaptiveSizePolicy, false,                             \
2356           "Print information about AdaptiveSizePolicy")                     \
2357                                                                             \
2358   product(intx, PrefetchCopyIntervalInBytes, -1,                            \
2359           "How far ahead to prefetch destination area (&lt;= 0 means off)")    \
2360                                                                             \
2361   product(intx, PrefetchScanIntervalInBytes, -1,                            \
2362           "How far ahead to prefetch scan area (&lt;= 0 means off)")           \
2363                                                                             \
2364   product(intx, PrefetchFieldsAhead, -1,                                    \
2365           "How many fields ahead to prefetch in oop scan (&lt;= 0 means off)") \
2366                                                                             \
2367   diagnostic(bool, VerifySilently, false,                                   \
2368           "Do not print the verification progress")                         \
2369                                                                             \
2370   diagnostic(bool, VerifyDuringStartup, false,                              \
2371           "Verify memory system before executing any Java code "            \
2372           "during VM initialization")                                       \
2373                                                                             \
2374   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
2375           "Verify system before exiting")                                   \
2376                                                                             \
2377   diagnostic(bool, VerifyBeforeGC, false,                                   \
2378           "Verify memory system before GC")                                 \
2379                                                                             \
2380   diagnostic(bool, VerifyAfterGC, false,                                    \
2381           "Verify memory system after GC")                                  \
2382                                                                             \
2383   diagnostic(bool, VerifyDuringGC, false,                                   \
2384           "Verify memory system during GC (between phases)")                \
2385                                                                             \
2386   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
2387           "Enable parallel memory system verification")                     \
2388                                                                             \
2389   diagnostic(bool, DeferInitialCardMark, false,                             \
2390           "When +ReduceInitialCardMarks, explicitly defer any that "        \
2391           "may arise from new_pre_store_barrier")                           \
2392                                                                             \
2393   product(bool, UseCondCardMark, false,                                     \
2394           "Check for already marked card before updating card table")       \
2395                                                                             \
2396   diagnostic(bool, VerifyRememberedSets, false,                             \
2397           "Verify GC remembered sets")                                      \
2398                                                                             \
2399   diagnostic(bool, VerifyObjectStartArray, true,                            \
2400           "Verify GC object start array if verify before/after")            \
2401                                                                             \
2402   product(bool, DisableExplicitGC, false,                                   \
2403           "Ignore calls to System.gc()")                                    \
2404                                                                             \
2405   notproduct(bool, CheckMemoryInitialization, false,                        \
2406           "Check memory initialization")                                    \
2407                                                                             \
2408   diagnostic(bool, BindCMSThreadToCPU, false,                               \
2409           "Bind CMS Thread to CPU if possible")                             \
2410                                                                             \
2411   diagnostic(uintx, CPUForCMSThread, 0,                                     \
2412           "When BindCMSThreadToCPU is true, the CPU to bind CMS thread to") \
2413                                                                             \
2414   product(bool, BindGCTaskThreadsToCPUs, false,                             \
2415           "Bind GCTaskThreads to CPUs if possible")                         \
2416                                                                             \
2417   product(bool, UseGCTaskAffinity, false,                                   \
2418           "Use worker affinity when asking for GCTasks")                    \
2419                                                                             \
2420   product(uintx, ProcessDistributionStride, 4,                              \
2421           "Stride through processors when distributing processes")          \
2422                                                                             \
2423   product(uintx, CMSCoordinatorYieldSleepCount, 10,                         \
2424           "Number of times the coordinator GC thread will sleep while "     \
2425           "yielding before giving up and resuming GC")                      \
2426                                                                             \
2427   product(uintx, CMSYieldSleepCount, 0,                                     \
2428           "Number of times a GC thread (minus the coordinator) "            \
2429           "will sleep while yielding before giving up and resuming GC")     \
2430                                                                             \
2431   /* gc tracing */                                                          \
2432   manageable(bool, PrintGC, false,                                          \
2433           "Print message at garbage collection")                            \
2434                                                                             \
2435   manageable(bool, PrintGCDetails, false,                                   \
2436           "Print more details at garbage collection")                       \
2437                                                                             \
2438   manageable(bool, PrintGCDateStamps, false,                                \
2439           "Print date stamps at garbage collection")                        \
2440                                                                             \
2441   manageable(bool, PrintGCTimeStamps, false,                                \
2442           "Print timestamps at garbage collection")                         \
2443                                                                             \
2444   manageable(bool, PrintGCID, true,                                         \
2445           "Print an identifier for each garbage collection")                \
2446                                                                             \
2447   product(bool, PrintGCTaskTimeStamps, false,                               \
2448           "Print timestamps for individual gc worker thread tasks")         \
2449                                                                             \
2450   develop(intx, ConcGCYieldTimeout, 0,                                      \
2451           "If non-zero, assert that GC threads yield within this "          \
2452           "number of milliseconds")                                         \
2453           range(0, max_intx)                                                \
2454                                                                             \
2455   product(bool, PrintReferenceGC, false,                                    \
2456           "Print times spent handling reference objects during GC "         \
2457           "(enabled only when PrintGCDetails)")                             \
2458                                                                             \
2459   develop(bool, TraceReferenceGC, false,                                    \
2460           "Trace handling of soft/weak/final/phantom references")           \
2461                                                                             \
2462   develop(bool, TraceFinalizerRegistration, false,                          \
2463           "Trace registration of final references")                         \
2464                                                                             \
2465   notproduct(bool, TraceScavenge, false,                                    \
2466           "Trace scavenge")                                                 \
2467                                                                             \
2468   product(bool, IgnoreEmptyClassPaths, false,                               \
2469           "Ignore empty path elements in -classpath")                       \
2470                                                                             \
2471   product(bool, TraceClassPaths, false,                                     \
2472           "Trace processing of class paths")                                \
2473                                                                             \
2474   product_rw(bool, TraceClassLoading, false,                                \
2475           "Trace all classes loaded")                                       \
2476                                                                             \
2477   product(bool, TraceClassLoadingPreorder, false,                           \
2478           "Trace all classes loaded in order referenced (not loaded)")      \
2479                                                                             \
2480   product_rw(bool, TraceClassUnloading, false,                              \
2481           "Trace unloading of classes")                                     \
2482                                                                             \
2483   product_rw(bool, TraceLoaderConstraints, false,                           \
2484           "Trace loader constraints")                                       \
2485                                                                             \
2486   develop(bool, TraceClassLoaderData, false,                                \
2487           "Trace class loader loader_data lifetime")                        \
2488                                                                             \
2489   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
2490           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
2491           "Initial size of the boot class loader data metaspace")           \
2492           range(30*K, max_uintx/BytesPerWord)                               \
2493           constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\
2494                                                                             \
2495   product(bool, TraceYoungGenTime, false,                                   \
2496           "Trace accumulated time for young collection")                    \
2497                                                                             \
2498   product(bool, TraceOldGenTime, false,                                     \
2499           "Trace accumulated time for old collection")                      \
2500                                                                             \
2501   product(bool, PrintTenuringDistribution, false,                           \
2502           "Print tenuring age information")                                 \
2503                                                                             \
2504   product_rw(bool, PrintHeapAtGC, false,                                    \
2505           "Print heap layout before and after each GC")                     \
2506                                                                             \
2507   product_rw(bool, PrintHeapAtGCExtended, false,                            \
2508           "Print extended information about the layout of the heap "        \
2509           "when -XX:+PrintHeapAtGC is set")                                 \
2510                                                                             \
2511   product(bool, PrintHeapAtSIGBREAK, true,                                  \
2512           "Print heap layout in response to SIGBREAK")                      \
2513                                                                             \
2514   manageable(bool, PrintClassHistogramBeforeFullGC, false,                  \
2515           "Print a class histogram before any major stop-world GC")         \
2516                                                                             \
2517   manageable(bool, PrintClassHistogramAfterFullGC, false,                   \
2518           "Print a class histogram after any major stop-world GC")          \
2519                                                                             \
2520   manageable(bool, PrintClassHistogram, false,                              \
2521           "Print a histogram of class instances")                           \
2522                                                                             \
2523   develop(bool, TraceWorkGang, false,                                       \
2524           "Trace activities of work gangs")                                 \
2525                                                                             \
2526   product(bool, TraceParallelOldGCTasks, false,                             \
2527           "Trace multithreaded GC activity")                                \
2528                                                                             \
2529   develop(bool, TraceBlockOffsetTable, false,                               \
2530           "Print BlockOffsetTable maps")                                    \
2531                                                                             \
2532   develop(bool, TraceCardTableModRefBS, false,                              \
2533           "Print CardTableModRefBS maps")                                   \
2534                                                                             \
2535   develop(bool, TraceGCTaskManager, false,                                  \
2536           "Trace actions of the GC task manager")                           \
2537                                                                             \
2538   develop(bool, TraceGCTaskQueue, false,                                    \
2539           "Trace actions of the GC task queues")                            \
2540                                                                             \
2541   diagnostic(bool, TraceGCTaskThread, false,                                \
2542           "Trace actions of the GC task threads")                           \
2543                                                                             \
2544   product(bool, PrintParallelOldGCPhaseTimes, false,                        \
2545           "Print the time taken by each phase in ParallelOldGC "            \
2546           "(PrintGCDetails must also be enabled)")                          \
2547                                                                             \
2548   develop(bool, TraceParallelOldGCMarkingPhase, false,                      \
2549           "Trace marking phase in ParallelOldGC")                           \
2550                                                                             \
2551   develop(bool, TraceParallelOldGCSummaryPhase, false,                      \
2552           "Trace summary phase in ParallelOldGC")                           \
2553                                                                             \
2554   develop(bool, TraceParallelOldGCCompactionPhase, false,                   \
2555           "Trace compaction phase in ParallelOldGC")                        \
2556                                                                             \
2557   develop(bool, TraceParallelOldGCDensePrefix, false,                       \
2558           "Trace dense prefix computation for ParallelOldGC")               \
2559                                                                             \
2560   develop(bool, IgnoreLibthreadGPFault, false,                              \
2561           "Suppress workaround for libthread GP fault")                     \
2562                                                                             \
2563   product(bool, PrintJNIGCStalls, false,                                    \
2564           "Print diagnostic message when GC is stalled "                    \
2565           "by JNI critical section")                                        \
2566                                                                             \
2567   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
2568           "The percentage of the used heap that the instances of a class "  \
2569           "must occupy for the class to generate a trace event")            \
2570           range(0.0, 100.0)                                                 \
2571                                                                             \
2572   /* GC log rotation setting */                                             \
2573                                                                             \
2574   product(bool, UseGCLogFileRotation, false,                                \
2575           "Rotate gclog files (for long running applications). It requires "\
2576           "-Xloggc:&lt;filename&gt;")                                             \
2577                                                                             \
2578   product(uintx, NumberOfGCLogFiles, 0,                                     \
2579           "Number of gclog files in rotation "                              \
2580           "(default: 0, no rotation)")                                      \
2581                                                                             \
2582   product(size_t, GCLogFileSize, 8*K,                                       \
2583           "GC log file size, requires UseGCLogFileRotation. "               \
2584           "Set to 0 to only trigger rotation via jcmd")                     \
2585                                                                             \
2586   /* JVMTI heap profiling */                                                \
2587                                                                             \
2588   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
2589           "Trace JVMTI object tagging calls")                               \
2590                                                                             \
2591   diagnostic(bool, VerifyBeforeIteration, false,                            \
2592           "Verify memory system before JVMTI iteration")                    \
2593                                                                             \
2594   /* compiler interface */                                                  \
2595                                                                             \
2596   develop(bool, CIPrintCompilerName, false,                                 \
2597           "when CIPrint is active, print the name of the active compiler")  \
2598                                                                             \
2599   diagnostic(bool, CIPrintCompileQueue, false,                              \
2600           "display the contents of the compile queue whenever a "           \
2601           "compilation is enqueued")                                        \
2602                                                                             \
2603   develop(bool, CIPrintRequests, false,                                     \
2604           "display every request for compilation")                          \
2605                                                                             \
2606   product(bool, CITime, false,                                              \
2607           "collect timing information for compilation")                     \
2608                                                                             \
2609   develop(bool, CITimeVerbose, false,                                       \
2610           "be more verbose in compilation timings")                         \
2611                                                                             \
2612   develop(bool, CITimeEach, false,                                          \
2613           "display timing information after each successful compilation")   \
2614                                                                             \
2615   develop(bool, CICountOSR, false,                                          \
2616           "use a separate counter when assigning ids to osr compilations")  \
2617                                                                             \
2618   develop(bool, CICompileNatives, true,                                     \
2619           "compile native methods if supported by the compiler")            \
2620                                                                             \
2621   develop_pd(bool, CICompileOSR,                                            \
2622           "compile on stack replacement methods if supported by the "       \
2623           "compiler")                                                       \
2624                                                                             \
2625   develop(bool, CIPrintMethodCodes, false,                                  \
2626           "print method bytecodes of the compiled code")                    \
2627                                                                             \
2628   develop(bool, CIPrintTypeFlow, false,                                     \
2629           "print the results of ciTypeFlow analysis")                       \
2630                                                                             \
2631   develop(bool, CITraceTypeFlow, false,                                     \
2632           "detailed per-bytecode tracing of ciTypeFlow analysis")           \
2633                                                                             \
2634   develop(intx, OSROnlyBCI, -1,                                             \
2635           "OSR only at this bci.  Negative values mean exclude that bci")   \
2636                                                                             \
2637   /* compiler */                                                            \
2638                                                                             \
2639   /* notice: the max range value here is max_jint, not max_intx  */         \
2640   /* because of overflow issue                                   */         \
2641   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
2642           "Number of compiler threads to run")                              \
2643           range(0, max_jint)                                                \
2644           constraint(CICompilerCountConstraintFunc, AtParse)                \
2645                                                                             \
2646   product(intx, CompilationPolicyChoice, 0,                                 \
2647           "which compilation policy (0-3)")                                 \
2648           range(0, 3)                                                       \
2649                                                                             \
2650   develop(bool, UseStackBanging, true,                                      \
2651           "use stack banging for stack overflow checks (required for "      \
2652           "proper StackOverflow handling; disable only to measure cost "    \
2653           "of stackbanging)")                                               \
2654                                                                             \
2655   develop(bool, UseStrictFP, true,                                          \
2656           "use strict fp if modifier strictfp is set")                      \
2657                                                                             \
2658   develop(bool, GenerateSynchronizationCode, true,                          \
2659           "generate locking/unlocking code for synchronized methods and "   \
2660           "monitors")                                                       \
2661                                                                             \
2662   develop(bool, GenerateCompilerNullChecks, true,                           \
2663           "Generate explicit null checks for loads/stores/calls")           \
2664                                                                             \
2665   develop(bool, GenerateRangeChecks, true,                                  \
2666           "Generate range checks for array accesses")                       \
2667                                                                             \
2668   develop_pd(bool, ImplicitNullChecks,                                      \
2669           "Generate code for implicit null checks")                         \
2670                                                                             \
2671   product_pd(bool, TrapBasedNullChecks,                                     \
2672           "Generate code for null checks that uses a cmp and trap "         \
2673           "instruction raising SIGTRAP.  This is only used if an access to" \
2674           "null (+offset) will not raise a SIGSEGV, i.e.,"                  \
2675           "ImplicitNullChecks don't work (PPC64).")                         \
2676                                                                             \
2677   product(bool, PrintSafepointStatistics, false,                            \
2678           "Print statistics about safepoint synchronization")               \
2679                                                                             \
2680   product(intx, PrintSafepointStatisticsCount, 300,                         \
2681           "Total number of safepoint statistics collected "                 \
2682           "before printing them out")                                       \
2683           range(1, max_intx)                                                \
2684                                                                             \
2685   product(intx, PrintSafepointStatisticsTimeout,  -1,                       \
2686           "Print safepoint statistics only when safepoint takes "           \
2687           "more than PrintSafepointSatisticsTimeout in millis")             \
2688   LP64_ONLY(range(-1, max_intx/MICROUNITS))                                 \
2689   NOT_LP64(range(-1, max_intx))                                             \
2690                                                                             \
2691   product(bool, TraceSafepointCleanupTime, false,                           \
2692           "Print the break down of clean up tasks performed during "        \
2693           "safepoint")                                                      \
2694                                                                             \
2695   product(bool, Inline, true,                                               \
2696           "Enable inlining")                                                \
2697                                                                             \
2698   product(bool, ClipInlining, true,                                         \
2699           "Clip inlining if aggregate method exceeds DesiredMethodLimit")   \
2700                                                                             \
2701   develop(bool, UseCHA, true,                                               \
2702           "Enable CHA")                                                     \
2703                                                                             \
2704   product(bool, UseTypeProfile, true,                                       \
2705           "Check interpreter profile for historically monomorphic calls")   \
2706                                                                             \
2707   diagnostic(bool, PrintInlining, false,                                    \
2708           "Print inlining optimizations")                                   \
2709                                                                             \
2710   product(bool, UsePopCountInstruction, false,                              \
2711           "Use population count instruction")                               \
2712                                                                             \
2713   develop(bool, EagerInitialization, false,                                 \
2714           "Eagerly initialize classes if possible")                         \
2715                                                                             \
2716   diagnostic(bool, LogTouchedMethods, false,                                \
2717           "Log methods which have been ever touched in runtime")            \
2718                                                                             \
2719   diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \
2720           "Print all methods that have been ever touched in runtime")       \
2721                                                                             \
2722   develop(bool, TraceMethodReplacement, false,                              \
2723           "Print when methods are replaced do to recompilation")            \
2724                                                                             \
2725   develop(bool, PrintMethodFlushing, false,                                 \
2726           "Print the nmethods being flushed")                               \
2727                                                                             \
2728   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
2729           "print statistics about method flushing")                         \
2730                                                                             \
2731   diagnostic(intx, HotMethodDetectionLimit, 100000,                         \
2732           "Number of compiled code invocations after which "                \
2733           "the method is considered as hot by the flusher")                 \
2734           range(1, max_jint)                                                \
2735                                                                             \
2736   diagnostic(intx, MinPassesBeforeFlush, 10,                                \
2737           "Minimum number of sweeper passes before an nmethod "             \
2738           "can be flushed")                                                 \
2739           range(0, max_intx)                                                \
2740                                                                             \
2741   product(bool, UseCodeAging, true,                                         \
2742           "Insert counter to detect warm methods")                          \
2743                                                                             \
2744   diagnostic(bool, StressCodeAging, false,                                  \
2745           "Start with counters compiled in")                                \
2746                                                                             \
2747   develop(bool, UseRelocIndex, false,                                       \
2748           "Use an index to speed random access to relocations")             \
2749                                                                             \
2750   develop(bool, StressCodeBuffers, false,                                   \
2751           "Exercise code buffer expansion and other rare state changes")    \
2752                                                                             \
2753   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
2754           "Generate extra debugging information for non-safepoints in "     \
2755           "nmethods")                                                       \
2756                                                                             \
2757   product(bool, PrintVMOptions, false,                                      \
2758           "Print flags that appeared on the command line")                  \
2759                                                                             \
2760   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
2761           "Ignore unrecognized VM options")                                 \
2762                                                                             \
2763   product(bool, PrintCommandLineFlags, false,                               \
2764           "Print flags specified on command line or set by ergonomics")     \
2765                                                                             \
2766   product(bool, PrintFlagsInitial, false,                                   \
2767           "Print all VM flags before argument processing and exit VM")      \
2768                                                                             \
2769   product(bool, PrintFlagsFinal, false,                                     \
2770           "Print all VM flags after argument and ergonomic processing")     \
2771                                                                             \
2772   notproduct(bool, PrintFlagsWithComments, false,                           \
2773           "Print all VM flags with default values and descriptions and "    \
2774           "exit")                                                           \
2775                                                                             \
2776   product(bool, PrintFlagsRanges, false,                                    \
2777           "Print VM flags and their ranges and exit VM")                    \
2778                                                                             \
2779   diagnostic(bool, SerializeVMOutput, true,                                 \
2780           "Use a mutex to serialize output to tty and LogFile")             \
2781                                                                             \
2782   diagnostic(bool, DisplayVMOutput, true,                                   \
2783           "Display all VM output on the tty, independently of LogVMOutput") \
2784                                                                             \
2785   diagnostic(bool, LogVMOutput, false,                                      \
2786           "Save VM output to LogFile")                                      \
2787                                                                             \
2788   diagnostic(ccstr, LogFile, NULL,                                          \
2789           "If LogVMOutput or LogCompilation is on, save VM output to "      \
2790           "this file [default: ./hotspot_pid%p.log] (%p replaced with pid)")\
2791                                                                             \
2792   product(ccstr, ErrorFile, NULL,                                           \
2793           "If an error occurs, save the error data to this file "           \
2794           "[default: ./hs_err_pid%p.log] (%p replaced with pid)")           \
2795                                                                             \
2796   product(bool, DisplayVMOutputToStderr, false,                             \
2797           "If DisplayVMOutput is true, display all VM output to stderr")    \
2798                                                                             \
2799   product(bool, DisplayVMOutputToStdout, false,                             \
2800           "If DisplayVMOutput is true, display all VM output to stdout")    \
2801                                                                             \
2802   product(bool, UseHeavyMonitors, false,                                    \
2803           "use heavyweight instead of lightweight Java monitors")           \
2804                                                                             \
2805   product(bool, PrintStringTableStatistics, false,                          \
2806           "print statistics about the StringTable and SymbolTable")         \
2807                                                                             \
2808   diagnostic(bool, VerifyStringTableAtExit, false,                          \
2809           "verify StringTable contents at exit")                            \
2810                                                                             \
2811   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
2812           "print histogram of the symbol table")                            \
2813                                                                             \
2814   notproduct(bool, ExitVMOnVerifyError, false,                              \
2815           "standard exit from VM if bytecode verify error "                 \
2816           "(only in debug mode)")                                           \
2817                                                                             \
2818   diagnostic(ccstr, AbortVMOnException, NULL,                               \
2819           "Call fatal if this exception is thrown.  Example: "              \
2820           "java -XX:AbortVMOnException=java.lang.NullPointerException Foo") \
2821                                                                             \
2822   diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \
2823           "Call fatal if the exception pointed by AbortVMOnException "      \
2824           "has this message")                                               \
2825                                                                             \
2826   develop(bool, DebugVtables, false,                                        \
2827           "add debugging code to vtable dispatch")                          \
2828                                                                             \
2829   develop(bool, PrintVtables, false,                                        \
2830           "print vtables when printing klass")                              \
2831                                                                             \
2832   notproduct(bool, PrintVtableStats, false,                                 \
2833           "print vtables stats at end of run")                              \
2834                                                                             \
2835   develop(bool, TraceCreateZombies, false,                                  \
2836           "trace creation of zombie nmethods")                              \
2837                                                                             \
2838   notproduct(bool, IgnoreLockingAssertions, false,                          \
2839           "disable locking assertions (for speed)")                         \
2840                                                                             \
2841   product(bool, RangeCheckElimination, true,                                \
2842           "Eliminate range checks")                                         \
2843                                                                             \
2844   develop_pd(bool, UncommonNullCast,                                        \
2845           "track occurrences of null in casts; adjust compiler tactics")    \
2846                                                                             \
2847   develop(bool, TypeProfileCasts,  true,                                    \
2848           "treat casts like calls for purposes of type profiling")          \
2849                                                                             \
2850   develop(bool, DelayCompilationDuringStartup, true,                        \
2851           "Delay invoking the compiler until main application class is "    \
2852           "loaded")                                                         \
2853                                                                             \
2854   develop(bool, CompileTheWorld, false,                                     \
2855           "Compile all methods in all classes in bootstrap class path "     \
2856             "(stress test)")                                                \
2857                                                                             \
2858   develop(bool, CompileTheWorldPreloadClasses, true,                        \
2859           "Preload all classes used by a class before start loading")       \
2860                                                                             \
2861   notproduct(intx, CompileTheWorldSafepointInterval, 100,                   \
2862           "Force a safepoint every n compiles so sweeper can keep up")      \
2863                                                                             \
2864   develop(bool, FillDelaySlots, true,                                       \
2865           "Fill delay slots (on SPARC only)")                               \
2866                                                                             \
2867   develop(bool, TimeLivenessAnalysis, false,                                \
2868           "Time computation of bytecode liveness analysis")                 \
2869                                                                             \
2870   develop(bool, TraceLivenessGen, false,                                    \
2871           "Trace the generation of liveness analysis information")          \
2872                                                                             \
2873   notproduct(bool, TraceLivenessQuery, false,                               \
2874           "Trace queries of liveness analysis information")                 \
2875                                                                             \
2876   notproduct(bool, CollectIndexSetStatistics, false,                        \
2877           "Collect information about IndexSets")                            \
2878                                                                             \
2879   develop(bool, UseLoopSafepoints, true,                                    \
2880           "Generate Safepoint nodes in every loop")                         \
2881                                                                             \
2882   develop(intx, FastAllocateSizeLimit, 128*K,                               \
2883           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
2884           "Inline allocations larger than this in doublewords must go slow")\
2885                                                                             \
2886   product(bool, AggressiveOpts, false,                                      \
2887           "Enable aggressive optimizations - see arguments.cpp")            \
2888                                                                             \
2889   product_pd(bool, CompactStrings,                                          \
2890           "Enable Strings to use single byte chars in backing store")       \
2891                                                                             \
2892   product_pd(uintx, TypeProfileLevel,                                       \
2893           "=XYZ, with Z: Type profiling of arguments at call; "             \
2894                      "Y: Type profiling of return value at call; "          \
2895                      "X: Type profiling of parameters to methods; "         \
2896           "X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods")             \
2897           constraint(TypeProfileLevelConstraintFunc, AfterErgo)             \
2898                                                                             \
2899   product(intx, TypeProfileArgsLimit,     2,                                \
2900           "max number of call arguments to consider for type profiling")    \
2901           range(0, 16)                                                      \
2902                                                                             \
2903   product(intx, TypeProfileParmsLimit,    2,                                \
2904           "max number of incoming parameters to consider for type profiling"\
2905           ", -1 for all")                                                   \
2906           range(-1, 64)                                                     \
2907                                                                             \
2908   /* statistics */                                                          \
2909   develop(bool, CountCompiledCalls, false,                                  \
2910           "Count method invocations")                                       \
2911                                                                             \
2912   notproduct(bool, CountRuntimeCalls, false,                                \
2913           "Count VM runtime calls")                                         \
2914                                                                             \
2915   develop(bool, CountJNICalls, false,                                       \
2916           "Count jni method invocations")                                   \
2917                                                                             \
2918   notproduct(bool, CountJVMCalls, false,                                    \
2919           "Count jvm method invocations")                                   \
2920                                                                             \
2921   notproduct(bool, CountRemovableExceptions, false,                         \
2922           "Count exceptions that could be replaced by branches due to "     \
2923           "inlining")                                                       \
2924                                                                             \
2925   notproduct(bool, ICMissHistogram, false,                                  \
2926           "Produce histogram of IC misses")                                 \
2927                                                                             \
2928   /* interpreter */                                                         \
2929   develop(bool, ClearInterpreterLocals, false,                              \
2930           "Always clear local variables of interpreter activations upon "   \
2931           "entry")                                                          \
2932                                                                             \
2933   product_pd(bool, RewriteBytecodes,                                        \
2934           "Allow rewriting of bytecodes (bytecodes are not immutable)")     \
2935                                                                             \
2936   product_pd(bool, RewriteFrequentPairs,                                    \
2937           "Rewrite frequently used bytecode pairs into a single bytecode")  \
2938                                                                             \
2939   diagnostic(bool, PrintInterpreter, false,                                 \
2940           "Print the generated interpreter code")                           \
2941                                                                             \
2942   product(bool, UseInterpreter, true,                                       \
2943           "Use interpreter for non-compiled methods")                       \
2944                                                                             \
2945   develop(bool, UseFastSignatureHandlers, true,                             \
2946           "Use fast signature handlers for native calls")                   \
2947                                                                             \
2948   product(bool, UseLoopCounter, true,                                       \
2949           "Increment invocation counter on backward branch")                \
2950                                                                             \
2951   product_pd(bool, UseOnStackReplacement,                                   \
2952           "Use on stack replacement, calls runtime if invoc. counter "      \
2953           "overflows in loop")                                              \
2954                                                                             \
2955   notproduct(bool, TraceOnStackReplacement, false,                          \
2956           "Trace on stack replacement")                                     \
2957                                                                             \
2958   product_pd(bool, PreferInterpreterNativeStubs,                            \
2959           "Use always interpreter stubs for native methods invoked via "    \
2960           "interpreter")                                                    \
2961                                                                             \
2962   develop(bool, CountBytecodes, false,                                      \
2963           "Count number of bytecodes executed")                             \
2964                                                                             \
2965   develop(bool, PrintBytecodeHistogram, false,                              \
2966           "Print histogram of the executed bytecodes")                      \
2967                                                                             \
2968   develop(bool, PrintBytecodePairHistogram, false,                          \
2969           "Print histogram of the executed bytecode pairs")                 \
2970                                                                             \
2971   diagnostic(bool, PrintSignatureHandlers, false,                           \
2972           "Print code generated for native method signature handlers")      \
2973                                                                             \
2974   develop(bool, VerifyOops, false,                                          \
2975           "Do plausibility checks for oops")                                \
2976                                                                             \
2977   develop(bool, CheckUnhandledOops, false,                                  \
2978           "Check for unhandled oops in VM code")                            \
2979                                                                             \
2980   develop(bool, VerifyJNIFields, trueInDebug,                               \
2981           "Verify jfieldIDs for instance fields")                           \
2982                                                                             \
2983   notproduct(bool, VerifyJNIEnvThread, false,                               \
2984           "Verify JNIEnv.thread == Thread::current() when entering VM "     \
2985           "from JNI")                                                       \
2986                                                                             \
2987   develop(bool, VerifyFPU, false,                                           \
2988           "Verify FPU state (check for NaN's, etc.)")                       \
2989                                                                             \
2990   develop(bool, VerifyThread, false,                                        \
2991           "Watch the thread register for corruption (SPARC only)")          \
2992                                                                             \
2993   develop(bool, VerifyActivationFrameSize, false,                           \
2994           "Verify that activation frame didn't become smaller than its "    \
2995           "minimal size")                                                   \
2996                                                                             \
2997   develop(bool, TraceFrequencyInlining, false,                              \
2998           "Trace frequency based inlining")                                 \
2999                                                                             \
3000   develop_pd(bool, InlineIntrinsics,                                        \
3001           "Inline intrinsics that can be statically resolved")              \
3002                                                                             \
3003   product_pd(bool, ProfileInterpreter,                                      \
3004           "Profile at the bytecode level during interpretation")            \
3005                                                                             \
3006   develop(bool, TraceProfileInterpreter, false,                             \
3007           "Trace profiling at the bytecode level during interpretation. "   \
3008           "This outputs the profiling information collected to improve "    \
3009           "jit compilation.")                                               \
3010                                                                             \
3011   develop_pd(bool, ProfileTraps,                                            \
3012           "Profile deoptimization traps at the bytecode level")             \
3013                                                                             \
3014   product(intx, ProfileMaturityPercentage, 20,                              \
3015           "number of method invocations/branches (expressed as % of "       \
3016           "CompileThreshold) before using the method's profile")            \
3017           range(0, 100)                                                     \
3018                                                                             \
3019   diagnostic(bool, PrintMethodData, false,                                  \
3020           "Print the results of +ProfileInterpreter at end of run")         \
3021                                                                             \
3022   develop(bool, VerifyDataPointer, trueInDebug,                             \
3023           "Verify the method data pointer during interpreter profiling")    \
3024                                                                             \
3025   develop(bool, VerifyCompiledCode, false,                                  \
3026           "Include miscellaneous runtime verifications in nmethod code; "   \
3027           "default off because it disturbs nmethod size heuristics")        \
3028                                                                             \
3029   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
3030           "Manually make GC thread crash then dump java stack trace;  "     \
3031           "Test only")                                                      \
3032                                                                             \
3033   /* compilation */                                                         \
3034   product(bool, UseCompiler, true,                                          \
3035           "Use Just-In-Time compilation")                                   \
3036                                                                             \
3037   develop(bool, TraceCompilationPolicy, false,                              \
3038           "Trace compilation policy")                                       \
3039                                                                             \
3040   develop(bool, TimeCompilationPolicy, false,                               \
3041           "Time the compilation policy")                                    \
3042                                                                             \
3043   product(bool, UseCounterDecay, true,                                      \
3044           "Adjust recompilation counters")                                  \
3045                                                                             \
3046   develop(intx, CounterHalfLifeTime,    30,                                 \
3047           "Half-life time of invocation counters (in seconds)")             \
3048                                                                             \
3049   develop(intx, CounterDecayMinIntervalLength,   500,                       \
3050           "The minimum interval (in milliseconds) between invocation of "   \
3051           "CounterDecay")                                                   \
3052                                                                             \
3053   product(bool, AlwaysCompileLoopMethods, false,                            \
3054           "When using recompilation, never interpret methods "              \
3055           "containing loops")                                               \
3056                                                                             \
3057   product(bool, DontCompileHugeMethods, true,                               \
3058           "Do not compile methods &gt; HugeMethodLimit")                       \
3059                                                                             \
3060   /* Bytecode escape analysis estimation. */                                \
3061   product(bool, EstimateArgEscape, true,                                    \
3062           "Analyze bytecodes to estimate escape state of arguments")        \
3063                                                                             \
3064   product(intx, BCEATraceLevel, 0,                                          \
3065           "How much tracing to do of bytecode escape analysis estimates "   \
3066           "(0-3)")                                                          \
3067           range(0, 3)                                                       \
3068                                                                             \
3069   product(intx, MaxBCEAEstimateLevel, 5,                                    \
3070           "Maximum number of nested calls that are analyzed by BC EA")      \
3071           range(0, max_jint)                                                \
3072                                                                             \
3073   product(intx, MaxBCEAEstimateSize, 150,                                   \
3074           "Maximum bytecode size of a method to be analyzed by BC EA")      \
3075           range(0, max_jint)                                                \
3076                                                                             \
3077   product(intx,  AllocatePrefetchStyle, 1,                                  \
3078           "0 = no prefetch, "                                               \
3079           "1 = prefetch instructions for each allocation, "                 \
3080           "2 = use TLAB watermark to gate allocation prefetch, "            \
3081           "3 = use BIS instruction on Sparc for allocation prefetch")       \
3082           range(0, 3)                                                       \
3083                                                                             \
3084   product(intx,  AllocatePrefetchDistance, -1,                              \
3085           "Distance to prefetch ahead of allocation pointer. "              \
3086           "-1: use system-specific value (automatically determined")        \
3087           constraint(AllocatePrefetchDistanceConstraintFunc, AfterMemoryInit)\
3088                                                                             \
3089   product(intx,  AllocatePrefetchLines, 3,                                  \
3090           "Number of lines to prefetch ahead of array allocation pointer")  \
3091           range(1, max_jint / 2)                                            \
3092                                                                             \
3093   product(intx,  AllocateInstancePrefetchLines, 1,                          \
3094           "Number of lines to prefetch ahead of instance allocation "       \
3095           "pointer")                                                        \
3096           range(1, max_jint / 2)                                            \
3097                                                                             \
3098   product(intx,  AllocatePrefetchStepSize, 16,                              \
3099           "Step size in bytes of sequential prefetch instructions")         \
3100           range(1, max_jint)                                                \
3101           constraint(AllocatePrefetchStepSizeConstraintFunc,AfterMemoryInit)\
3102                                                                             \
3103   product(intx,  AllocatePrefetchInstr, 0,                                  \
3104           "Prefetch instruction to prefetch ahead of allocation pointer")   \
3105           constraint(AllocatePrefetchInstrConstraintFunc, AfterErgo)        \
3106                                                                             \
3107   /* deoptimization */                                                      \
3108   develop(bool, TraceDeoptimization, false,                                 \
3109           "Trace deoptimization")                                           \
3110                                                                             \
3111   develop(bool, PrintDeoptimizationDetails, false,                          \
3112           "Print more information about deoptimization")                    \
3113                                                                             \
3114   develop(bool, DebugDeoptimization, false,                                 \
3115           "Tracing various information while debugging deoptimization")     \
3116                                                                             \
3117   product(intx, SelfDestructTimer, 0,                                       \
3118           "Will cause VM to terminate after a given time (in minutes) "     \
3119           "(0 means off)")                                                  \
3120           range(0, max_intx)                                                \
3121                                                                             \
3122   product(intx, MaxJavaStackTraceDepth, 1024,                               \
3123           "The maximum number of lines in the stack trace for Java "        \
3124           "exceptions (0 means all)")                                       \
3125           range(0, max_jint/2)                                              \
3126                                                                             \
3127   /* notice: the max range value here is max_jint, not max_intx  */         \
3128   /* because of overflow issue                                   */         \
3129   NOT_EMBEDDED(diagnostic(intx, GuaranteedSafepointInterval, 1000,          \
3130           "Guarantee a safepoint (at least) every so many milliseconds "    \
3131           "(0 means none)"))                                                \
3132   NOT_EMBEDDED(range(0, max_jint))                                          \
3133                                                                             \
3134   EMBEDDED_ONLY(product(intx, GuaranteedSafepointInterval, 0,               \
3135           "Guarantee a safepoint (at least) every so many milliseconds "    \
3136           "(0 means none)"))                                                \
3137   EMBEDDED_ONLY(range(0, max_jint))                                         \
3138                                                                             \
3139   product(intx, SafepointTimeoutDelay, 10000,                               \
3140           "Delay in milliseconds for option SafepointTimeout")              \
3141   LP64_ONLY(range(0, max_intx/MICROUNITS))                                  \
3142   NOT_LP64(range(0, max_intx))                                              \
3143                                                                             \
3144   product(intx, NmethodSweepActivity, 10,                                   \
3145           "Removes cold nmethods from code cache if &gt; 0. Higher values "    \
3146           "result in more aggressive sweeping")                             \
3147           range(0, 2000)                                                    \
3148                                                                             \
3149   notproduct(bool, LogSweeper, false,                                       \
3150           "Keep a ring buffer of sweeper activity")                         \
3151                                                                             \
3152   notproduct(intx, SweeperLogEntries, 1024,                                 \
3153           "Number of records in the ring buffer of sweeper activity")       \
3154                                                                             \
3155   notproduct(intx, MemProfilingInterval, 500,                               \
3156           "Time between each invocation of the MemProfiler")                \
3157                                                                             \
3158   develop(intx, MallocCatchPtr, -1,                                         \
3159           "Hit breakpoint when mallocing/freeing this pointer")             \
3160                                                                             \
3161   notproduct(ccstrlist, SuppressErrorAt, "",                                \
3162           "List of assertions (file:line) to muzzle")                       \
3163                                                                             \
3164   notproduct(size_t, HandleAllocationLimit, 1024,                           \
3165           "Threshold for HandleMark allocation when +TraceHandleAllocation "\
3166           "is used")                                                        \
3167                                                                             \
3168   develop(size_t, TotalHandleAllocationLimit, 1024,                         \
3169           "Threshold for total handle allocation when "                     \
3170           "+TraceHandleAllocation is used")                                 \
3171                                                                             \
3172   develop(intx, StackPrintLimit, 100,                                       \
3173           "number of stack frames to print in VM-level stack dump")         \
3174                                                                             \
3175   notproduct(intx, MaxElementPrintSize, 256,                                \
3176           "maximum number of elements to print")                            \
3177                                                                             \
3178   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
3179           "maximum number of subklasses to print when printing klass")      \
3180                                                                             \
3181   product(intx, MaxInlineLevel, 9,                                          \
3182           "maximum number of nested calls that are inlined")                \
3183           range(0, max_jint)                                                \
3184                                                                             \
3185   product(intx, MaxRecursiveInlineLevel, 1,                                 \
3186           "maximum number of nested recursive calls that are inlined")      \
3187           range(0, max_jint)                                                \
3188                                                                             \
3189   develop(intx, MaxForceInlineLevel, 100,                                   \
3190           "maximum number of nested calls that are forced for inlining "    \
3191           "(using CompileCommand or marked w/ @ForceInline)")               \
3192           range(0, max_jint)                                                \
3193                                                                             \
3194   product_pd(intx, InlineSmallCode,                                         \
3195           "Only inline already compiled methods if their code size is "     \
3196           "less than this")                                                 \
3197           range(0, max_jint)                                                \
3198                                                                             \
3199   product(intx, MaxInlineSize, 35,                                          \
3200           "The maximum bytecode size of a method to be inlined")            \
3201           range(0, max_jint)                                                \
3202                                                                             \
3203   product_pd(intx, FreqInlineSize,                                          \
3204           "The maximum bytecode size of a frequent method to be inlined")   \
3205           range(0, max_jint)                                                \
3206                                                                             \
3207   product(intx, MaxTrivialSize, 6,                                          \
3208           "The maximum bytecode size of a trivial method to be inlined")    \
3209           range(0, max_jint)                                                \
3210                                                                             \
3211   product(intx, MinInliningThreshold, 250,                                  \
3212           "The minimum invocation count a method needs to have to be "      \
3213           "inlined")                                                        \
3214           range(0, max_jint)                                                \
3215                                                                             \
3216   develop(intx, MethodHistogramCutoff, 100,                                 \
3217           "The cutoff value for method invocation histogram (+CountCalls)") \
3218                                                                             \
3219   develop(intx, ProfilerNumberOfInterpretedMethods, 25,                     \
3220           "Number of interpreted methods to show in profile")               \
3221                                                                             \
3222   develop(intx, ProfilerNumberOfCompiledMethods, 25,                        \
3223           "Number of compiled methods to show in profile")                  \
3224                                                                             \
3225   develop(intx, ProfilerNumberOfStubMethods, 25,                            \
3226           "Number of stub methods to show in profile")                      \
3227                                                                             \
3228   develop(intx, ProfilerNumberOfRuntimeStubNodes, 25,                       \
3229           "Number of runtime stub nodes to show in profile")                \
3230                                                                             \
3231   product(intx, ProfileIntervalsTicks, 100,                                 \
3232           "Number of ticks between printing of interval profile "           \
3233           "(+ProfileIntervals)")                                            \
3234           range(0, max_intx)                                                \
3235                                                                             \
3236   notproduct(intx, ScavengeALotInterval,     1,                             \
3237           "Interval between which scavenge will occur with +ScavengeALot")  \
3238                                                                             \
3239   notproduct(intx, FullGCALotInterval,     1,                               \
3240           "Interval between which full gc will occur with +FullGCALot")     \
3241                                                                             \
3242   notproduct(intx, FullGCALotStart,     0,                                  \
3243           "For which invocation to start FullGCAlot")                       \
3244                                                                             \
3245   notproduct(intx, FullGCALotDummies,  32*K,                                \
3246           "Dummy object allocated with +FullGCALot, forcing all objects "   \
3247           "to move")                                                        \
3248                                                                             \
3249   develop(intx, DontYieldALotInterval,    10,                               \
3250           "Interval between which yields will be dropped (milliseconds)")   \
3251                                                                             \
3252   develop(intx, MinSleepInterval,     1,                                    \
3253           "Minimum sleep() interval (milliseconds) when "                   \
3254           "ConvertSleepToYield is off (used for Solaris)")                  \
3255                                                                             \
3256   develop(intx, ProfilerPCTickThreshold,    15,                             \
3257           "Number of ticks in a PC buckets to be a hotspot")                \
3258                                                                             \
3259   notproduct(intx, DeoptimizeALotInterval,     5,                           \
3260           "Number of exits until DeoptimizeALot kicks in")                  \
3261                                                                             \
3262   notproduct(intx, ZombieALotInterval,     5,                               \
3263           "Number of exits until ZombieALot kicks in")                      \
3264                                                                             \
3265   diagnostic(intx, MallocVerifyInterval,     0,                             \
3266           "If non-zero, verify C heap after every N calls to "              \
3267           "malloc/realloc/free")                                            \
3268           range(0, max_intx)                                                \
3269                                                                             \
3270   diagnostic(intx, MallocVerifyStart,     0,                                \
3271           "If non-zero, start verifying C heap after Nth call to "          \
3272           "malloc/realloc/free")                                            \
3273           range(0, max_intx)                                                \
3274                                                                             \
3275   diagnostic(uintx, MallocMaxTestWords,     0,                              \
3276           "If non-zero, maximum number of words that malloc/realloc can "   \
3277           "allocate (for testing only)")                                    \
3278           range(0, max_uintx)                                               \
3279                                                                             \
3280   product(intx, TypeProfileWidth, 2,                                        \
3281           "Number of receiver types to record in call/cast profile")        \
3282           range(0, 8)                                                       \
3283                                                                             \
3284   experimental(intx, MethodProfileWidth, 0,                                 \
3285           "Number of methods to record in call profile")                    \
3286                                                                             \
3287   develop(intx, BciProfileWidth,      2,                                    \
3288           "Number of return bci's to record in ret profile")                \
3289                                                                             \
3290   product(intx, PerMethodRecompilationCutoff, 400,                          \
3291           "After recompiling N times, stay in the interpreter (-1=&gt;'Inf')") \
3292           range(-1, max_intx)                                               \
3293                                                                             \
3294   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
3295           "Per-BCI limit on repeated recompilation (-1=&gt;'Inf')")            \
3296           range(-1, max_intx)                                               \
3297                                                                             \
3298   product(intx, PerMethodTrapLimit,  100,                                   \
3299           "Limit on traps (of one kind) in a method (includes inlines)")    \
3300           range(0, max_jint)                                                \
3301                                                                             \
3302   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
3303           "Limit on speculative traps (of one kind) in a method "           \
3304           "(includes inlines)")                                             \
3305           range(0, max_jint)                                                \
3306                                                                             \
3307   product(intx, PerBytecodeTrapLimit,  4,                                   \
3308           "Limit on traps (of one kind) at a particular BCI")               \
3309           range(0, max_jint)                                                \
3310                                                                             \
3311   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
3312           "Extra method data trap entries for speculation")                 \
3313                                                                             \
3314   develop(intx, InlineFrequencyRatio,    20,                                \
3315           "Ratio of call site execution to caller method invocation")       \
3316           range(0, max_jint)                                                \
3317                                                                             \
3318   develop_pd(intx, InlineFrequencyCount,                                    \
3319           "Count of call site execution necessary to trigger frequent "     \
3320           "inlining")                                                       \
3321           range(0, max_jint)                                                \
3322                                                                             \
3323   develop(intx, InlineThrowCount,    50,                                    \
3324           "Force inlining of interpreted methods that throw this often")    \
3325           range(0, max_jint)                                                \
3326                                                                             \
3327   develop(intx, InlineThrowMaxSize,   200,                                  \
3328           "Force inlining of throwing methods smaller than this")           \
3329           range(0, max_jint)                                                \
3330                                                                             \
3331   develop(intx, ProfilerNodeSize,  1024,                                    \
3332           "Size in K to allocate for the Profile Nodes of each thread")     \
3333           range(0, 1024)                                                    \
3334                                                                             \
3335   /* gc parameters */                                                       \
3336   product(size_t, InitialHeapSize, 0,                                       \
3337           "Initial heap size (in bytes); zero means use ergonomics")        \
3338           constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \
3339                                                                             \
3340   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
3341           "Maximum heap size (in bytes)")                                   \
3342           constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \
3343                                                                             \
3344   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
3345           "Initial tenured generation size (in bytes)")                     \
3346                                                                             \
3347   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
3348           "Initial new generation size (in bytes)")                         \
3349           constraint(NewSizeConstraintFunc,AfterErgo)                       \
3350                                                                             \
3351   product(size_t, MaxNewSize, max_uintx,                                    \
3352           "Maximum new generation size (in bytes), max_uintx means set "    \
3353           "ergonomically")                                                  \
3354                                                                             \
3355   product(size_t, PretenureSizeThreshold, 0,                                \
3356           "Maximum size in bytes of objects allocated in DefNew "           \
3357           "generation; zero means no maximum")                              \
3358                                                                             \
3359   product(size_t, MinTLABSize, 2*K,                                         \
3360           "Minimum allowed TLAB size (in bytes)")                           \
3361           range(1, max_uintx)                                               \
3362           constraint(MinTLABSizeConstraintFunc,AfterMemoryInit)             \
3363                                                                             \
3364   product(size_t, TLABSize, 0,                                              \
3365           "Starting TLAB size (in bytes); zero means set ergonomically")    \
3366           constraint(TLABSizeConstraintFunc,AfterMemoryInit)                \
3367                                                                             \
3368   product(size_t, YoungPLABSize, 4096,                                      \
3369           "Size of young gen promotion LAB's (in HeapWords)")               \
3370           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
3371                                                                             \
3372   product(size_t, OldPLABSize, 1024,                                        \
3373           "Size of old gen promotion LAB's (in HeapWords), or Number "      \
3374           "of blocks to attempt to claim when refilling CMS LAB's")         \
3375           constraint(OldPLABSizeConstraintFunc,AfterMemoryInit)             \
3376                                                                             \
3377   product(uintx, TLABAllocationWeight, 35,                                  \
3378           "Allocation averaging weight")                                    \
3379           range(0, 100)                                                     \
3380                                                                             \
3381   /* Limit the lower bound of this flag to 1 as it is used  */              \
3382   /* in a division expression.                              */              \
3383   product(uintx, TLABWasteTargetPercent, 1,                                 \
3384           "Percentage of Eden that can be wasted")                          \
3385           range(1, 100)                                                     \
3386                                                                             \
3387   product(uintx, TLABRefillWasteFraction,    64,                            \
3388           "Maximum TLAB waste at a refill (internal fragmentation)")        \
3389           range(1, max_uintx)                                               \
3390                                                                             \
3391   product(uintx, TLABWasteIncrement,    4,                                  \
3392           "Increment allowed waste at slow allocation")                     \
3393                                                                             \
3394   product(uintx, SurvivorRatio, 8,                                          \
3395           "Ratio of eden/survivor space size")                              \
3396           range(1, max_uintx-2)                                             \
3397           constraint(SurvivorRatioConstraintFunc,AfterMemoryInit)           \
3398                                                                             \
3399   product(uintx, NewRatio, 2,                                               \
3400           "Ratio of old/new generation sizes")                              \
3401           range(0, max_uintx-1)                                             \
3402                                                                             \
3403   product_pd(size_t, NewSizeThreadIncrease,                                 \
3404           "Additional size added to desired new generation size per "       \
3405           "non-daemon thread (in bytes)")                                   \
3406                                                                             \
3407   product_pd(size_t, MetaspaceSize,                                         \
3408           "Initial size of Metaspaces (in bytes)")                          \
3409           constraint(MetaspaceSizeConstraintFunc,AfterErgo)                 \
3410                                                                             \
3411   product(size_t, MaxMetaspaceSize, max_uintx,                              \
3412           "Maximum size of Metaspaces (in bytes)")                          \
3413           constraint(MaxMetaspaceSizeConstraintFunc,AfterErgo)              \
3414                                                                             \
3415   product(size_t, CompressedClassSpaceSize, 1*G,                            \
3416           "Maximum size of class area in Metaspace when compressed "        \
3417           "class pointers are used")                                        \
3418           range(1*M, 3*G)                                                   \
3419                                                                             \
3420   manageable(uintx, MinHeapFreeRatio, 40,                                   \
3421           "The minimum percentage of heap free after GC to avoid expansion."\
3422           " For most GCs this applies to the old generation. In G1 and"     \
3423           " ParallelGC it applies to the whole heap.")                      \
3424           range(0, 100)                                                     \
3425           constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \
3426                                                                             \
3427   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
3428           "The maximum percentage of heap free after GC to avoid shrinking."\
3429           " For most GCs this applies to the old generation. In G1 and"     \
3430           " ParallelGC it applies to the whole heap.")                      \
3431           range(0, 100)                                                     \
3432           constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \
3433                                                                             \
3434   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
3435           "Number of milliseconds per MB of free space in the heap")        \
3436           range(0, max_intx)                                                \
3437           constraint(SoftRefLRUPolicyMSPerMBConstraintFunc,AfterMemoryInit) \
3438                                                                             \
3439   product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),               \
3440           "The minimum change in heap space due to GC (in bytes)")          \
3441                                                                             \
3442   product(size_t, MinMetaspaceExpansion, ScaleForWordSize(256*K),           \
3443           "The minimum expansion of Metaspace (in bytes)")                  \
3444                                                                             \
3445   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
3446           "The maximum percentage of Metaspace free after GC to avoid "     \
3447           "shrinking")                                                      \
3448           range(0, 100)                                                     \
3449           constraint(MaxMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3450                                                                             \
3451   product(uintx, MinMetaspaceFreeRatio,    40,                              \
3452           "The minimum percentage of Metaspace free after GC to avoid "     \
3453           "expansion")                                                      \
3454           range(0, 99)                                                      \
3455           constraint(MinMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3456                                                                             \
3457   product(size_t, MaxMetaspaceExpansion, ScaleForWordSize(4*M),             \
3458           "The maximum expansion of Metaspace without full GC (in bytes)")  \
3459                                                                             \
3460   product(uintx, QueuedAllocationWarningCount, 0,                           \
3461           "Number of times an allocation that queues behind a GC "          \
3462           "will retry before printing a warning")                           \
3463                                                                             \
3464   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
3465           "GC invoke count where +VerifyBefore/AfterGC kicks in")           \
3466                                                                             \
3467   diagnostic(intx, VerifyGCLevel,     0,                                    \
3468           "Generation level at which to start +VerifyBefore/AfterGC")       \
3469           range(0, 1)                                                       \
3470                                                                             \
3471   product(uintx, MaxTenuringThreshold,    15,                               \
3472           "Maximum value for tenuring threshold")                           \
3473           range(0, markOopDesc::max_age + 1)                                \
3474           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
3475                                                                             \
3476   product(uintx, InitialTenuringThreshold,    7,                            \
3477           "Initial value for tenuring threshold")                           \
3478           range(0, markOopDesc::max_age + 1)                                \
3479           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
3480                                                                             \
3481   product(uintx, TargetSurvivorRatio,    50,                                \
3482           "Desired percentage of survivor space used after scavenge")       \
3483           range(0, 100)                                                     \
3484                                                                             \
3485   product(uintx, MarkSweepDeadRatio,     5,                                 \
3486           "Percentage (0-100) of the old gen allowed as dead wood. "        \
3487           "Serial mark sweep treats this as both the minimum and maximum "  \
3488           "value. "                                                         \
3489           "CMS uses this value only if it falls back to mark sweep. "       \
3490           "Par compact uses a variable scale based on the density of the "  \
3491           "generation and treats this as the maximum value when the heap "  \
3492           "is either completely full or completely empty.  Par compact "    \
3493           "also has a smaller default value; see arguments.cpp.")           \
3494           range(0, 100)                                                     \
3495                                                                             \
3496   product(uintx, MarkSweepAlwaysCompactCount,     4,                        \
3497           "How often should we fully compact the heap (ignoring the dead "  \
3498           "space parameters)")                                              \
3499           range(1, max_uintx)                                               \
3500                                                                             \
3501   product(intx, PrintCMSStatistics, 0,                                      \
3502           "Statistics for CMS")                                             \
3503                                                                             \
3504   product(bool, PrintCMSInitiationStatistics, false,                        \
3505           "Statistics for initiating a CMS collection")                     \
3506                                                                             \
3507   product(intx, PrintFLSStatistics, 0,                                      \
3508           "Statistics for CMS' FreeListSpace")                              \
3509                                                                             \
3510   product(intx, PrintFLSCensus, 0,                                          \
3511           "Census for CMS' FreeListSpace")                                  \
3512                                                                             \
3513   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
3514           "Delay between expansion and allocation (in milliseconds)")       \
3515                                                                             \
3516   develop(uintx, GCWorkerDelayMillis, 0,                                    \
3517           "Delay in scheduling GC workers (in milliseconds)")               \
3518                                                                             \
3519   product(intx, DeferThrSuspendLoopCount,     4000,                         \
3520           "(Unstable) Number of times to iterate in safepoint loop "        \
3521           "before blocking VM threads ")                                    \
3522           range(-1, max_jint-1)                                             \
3523                                                                             \
3524   product(intx, DeferPollingPageLoopCount,     -1,                          \
3525           "(Unsafe,Unstable) Number of iterations in safepoint loop "       \
3526           "before changing safepoint polling page to RO ")                  \
3527           range(-1, max_jint-1)                                             \
3528                                                                             \
3529   product(intx, SafepointSpinBeforeYield, 2000, "(Unstable)")               \
3530           range(0, max_intx)                                                \
3531                                                                             \
3532   product(bool, PSChunkLargeArrays, true,                                   \
3533           "Process large arrays in chunks")                                 \
3534                                                                             \
3535   product(uintx, GCDrainStackTargetSize, 64,                                \
3536           "Number of entries we will try to leave on the stack "            \
3537           "during parallel gc")                                             \
3538                                                                             \
3539   /* stack parameters */                                                    \
3540   product_pd(intx, StackYellowPages,                                        \
3541           "Number of yellow zone (recoverable overflows) pages")            \
3542           range(MIN_STACK_YELLOW_PAGES, (DEFAULT_STACK_YELLOW_PAGES+5))     \
3543                                                                             \
3544   product_pd(intx, StackRedPages,                                           \
3545           "Number of red zone (unrecoverable overflows) pages")             \
3546           range(MIN_STACK_RED_PAGES, (DEFAULT_STACK_RED_PAGES+2))           \
3547                                                                             \
3548   /* greater stack shadow pages can't generate instruction to bang stack */ \
3549   product_pd(intx, StackShadowPages,                                        \
3550           "Number of shadow zone (for overflow checking) pages "            \
3551           "this should exceed the depth of the VM and native call stack")   \
3552           range(MIN_STACK_SHADOW_PAGES, (DEFAULT_STACK_SHADOW_PAGES+30))    \
3553                                                                             \
3554   product_pd(intx, ThreadStackSize,                                         \
3555           "Thread Stack Size (in Kbytes)")                                  \
3556           range(0, max_intx-os::vm_page_size())                             \
3557                                                                             \
3558   product_pd(intx, VMThreadStackSize,                                       \
3559           "Non-Java Thread Stack Size (in Kbytes)")                         \
3560           range(0, max_intx/(1 * K))                                        \
3561                                                                             \
3562   product_pd(intx, CompilerThreadStackSize,                                 \
3563           "Compiler Thread Stack Size (in Kbytes)")                         \
3564           range(0, max_intx)                                                \
3565                                                                             \
3566   develop_pd(size_t, JVMInvokeMethodSlack,                                  \
3567           "Stack space (bytes) required for JVM_InvokeMethod to complete")  \
3568                                                                             \
3569   /* code cache parameters                                    */            \
3570   /* ppc64/tiered compilation has large code-entry alignment. */            \
3571   develop(uintx, CodeCacheSegmentSize,                                      \
3572           64 PPC64_ONLY(+64) NOT_PPC64(TIERED_ONLY(+64)),                   \
3573           "Code cache segment size (in bytes) - smallest unit of "          \
3574           "allocation")                                                     \
3575           range(1, 1024)                                                    \
3576           constraint(CodeCacheSegmentSizeConstraintFunc, AfterErgo)         \
3577                                                                             \
3578   develop_pd(intx, CodeEntryAlignment,                                      \
3579           "Code entry alignment for generated code (in bytes)")             \
3580           constraint(CodeEntryAlignmentConstraintFunc, AfterErgo)           \
3581                                                                             \
3582   product_pd(intx, OptoLoopAlignment,                                       \
3583           "Align inner loops to zero relative to this modulus")             \
3584           range(1, 16)                                                      \
3585           constraint(OptoLoopAlignmentConstraintFunc, AfterErgo)            \
3586                                                                             \
3587   product_pd(uintx, InitialCodeCacheSize,                                   \
3588           "Initial code cache size (in bytes)")                             \
3589           range(0, max_uintx)                                               \
3590                                                                             \
3591   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
3592           "Minimum code cache size (in bytes) required to start VM.")       \
3593           range(0, max_uintx)                                               \
3594                                                                             \
3595   product(bool, SegmentedCodeCache, false,                                  \
3596           "Use a segmented code cache")                                     \
3597                                                                             \
3598   product_pd(uintx, ReservedCodeCacheSize,                                  \
3599           "Reserved code cache size (in bytes) - maximum code cache size")  \
3600           range(0, max_uintx)                                               \
3601                                                                             \
3602   product_pd(uintx, NonProfiledCodeHeapSize,                                \
3603           "Size of code heap with non-profiled methods (in bytes)")         \
3604           range(0, max_uintx)                                               \
3605                                                                             \
3606   product_pd(uintx, ProfiledCodeHeapSize,                                   \
3607           "Size of code heap with profiled methods (in bytes)")             \
3608           range(0, max_uintx)                                               \
3609                                                                             \
3610   product_pd(uintx, NonNMethodCodeHeapSize,                                 \
3611           "Size of code heap with non-nmethods (in bytes)")                 \
3612           range(0, max_uintx)                                               \
3613                                                                             \
3614   product_pd(uintx, CodeCacheExpansionSize,                                 \
3615           "Code cache expansion size (in bytes)")                           \
3616           range(0, max_uintx)                                               \
3617                                                                             \
3618   develop_pd(uintx, CodeCacheMinBlockLength,                                \
3619           "Minimum number of segments in a code cache block")               \
3620           range(1, 100)                                                     \
3621                                                                             \
3622   notproduct(bool, ExitOnFullCodeCache, false,                              \
3623           "Exit the VM if we fill the code cache")                          \
3624                                                                             \
3625   product(bool, UseCodeCacheFlushing, true,                                 \
3626           "Remove cold/old nmethods from the code cache")                   \
3627                                                                             \
3628   product(uintx, StartAggressiveSweepingAt, 10,                             \
3629           "Start aggressive sweeping if X[%] of the code cache is free."    \
3630           "Segmented code cache: X[%] of the non-profiled heap."            \
3631           "Non-segmented code cache: X[%] of the total code cache")         \
3632           range(0, 100)                                                     \
3633                                                                             \
3634   /* interpreter debugging */                                               \
3635   develop(intx, BinarySwitchThreshold, 5,                                   \
3636           "Minimal number of lookupswitch entries for rewriting to binary " \
3637           "switch")                                                         \
3638                                                                             \
3639   develop(intx, StopInterpreterAt, 0,                                       \
3640           "Stop interpreter execution at specified bytecode number")        \
3641                                                                             \
3642   develop(intx, TraceBytecodesAt, 0,                                        \
3643           "Trace bytecodes starting with specified bytecode number")        \
3644                                                                             \
3645   /* compiler interface */                                                  \
3646   develop(intx, CIStart, 0,                                                 \
3647           "The id of the first compilation to permit")                      \
3648                                                                             \
3649   develop(intx, CIStop, max_jint,                                           \
3650           "The id of the last compilation to permit")                       \
3651                                                                             \
3652   develop(intx, CIStartOSR, 0,                                              \
3653           "The id of the first osr compilation to permit "                  \
3654           "(CICountOSR must be on)")                                        \
3655                                                                             \
3656   develop(intx, CIStopOSR, max_jint,                                        \
3657           "The id of the last osr compilation to permit "                   \
3658           "(CICountOSR must be on)")                                        \
3659                                                                             \
3660   develop(intx, CIBreakAtOSR, -1,                                           \
3661           "The id of osr compilation to break at")                          \
3662                                                                             \
3663   develop(intx, CIBreakAt, -1,                                              \
3664           "The id of compilation to break at")                              \
3665                                                                             \
3666   product(ccstrlist, CompileOnly, "",                                       \
3667           "List of methods (pkg/class.name) to restrict compilation to")    \
3668                                                                             \
3669   product(ccstr, CompileCommandFile, NULL,                                  \
3670           "Read compiler commands from this file [.hotspot_compiler]")      \
3671                                                                             \
3672   diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \
3673           "Read compiler directives from this file")                        \
3674                                                                             \
3675   product(ccstrlist, CompileCommand, "",                                    \
3676           "Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;") \
3677                                                                             \
3678   develop(bool, ReplayCompiles, false,                                      \
3679           "Enable replay of compilations from ReplayDataFile")              \
3680                                                                             \
3681   product(ccstr, ReplayDataFile, NULL,                                      \
3682           "File containing compilation replay information"                  \
3683           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
3684                                                                             \
3685    product(ccstr, InlineDataFile, NULL,                                     \
3686           "File containing inlining replay information"                     \
3687           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
3688                                                                             \
3689   develop(intx, ReplaySuppressInitializers, 2,                              \
3690           "Control handling of class initialization during replay: "        \
3691           "0 - don't do anything special; "                                 \
3692           "1 - treat all class initializers as empty; "                     \
3693           "2 - treat class initializers for application classes as empty; " \
3694           "3 - allow all class initializers to run during bootstrap but "   \
3695           "    pretend they are empty after starting replay")               \
3696           range(0, 3)                                                       \
3697                                                                             \
3698   develop(bool, ReplayIgnoreInitErrors, false,                              \
3699           "Ignore exceptions thrown during initialization for replay")      \
3700                                                                             \
3701   product(bool, DumpReplayDataOnError, true,                                \
3702           "Record replay data for crashing compiler threads")               \
3703                                                                             \
3704   product(bool, CICompilerCountPerCPU, false,                               \
3705           "1 compiler thread for log(N CPUs)")                              \
3706                                                                             \
3707   develop(intx, CIFireOOMAt,    -1,                                         \
3708           "Fire OutOfMemoryErrors throughout CI for testing the compiler "  \
3709           "(non-negative value throws OOM after this many CI accesses "     \
3710           "in each compile)")                                               \
3711   notproduct(intx, CICrashAt, -1,                                           \
3712           "id of compilation to trigger assert in compiler thread for "     \
3713           "the purpose of testing, e.g. generation of replay data")         \
3714   notproduct(bool, CIObjectFactoryVerify, false,                            \
3715           "enable potentially expensive verification in ciObjectFactory")   \
3716                                                                             \
3717   /* Priorities */                                                          \
3718   product_pd(bool, UseThreadPriorities,  "Use native thread priorities")    \
3719                                                                             \
3720   product(intx, ThreadPriorityPolicy, 0,                                    \
3721           "0 : Normal.                                                     "\
3722           "    VM chooses priorities that are appropriate for normal       "\
3723           "    applications. On Solaris NORM_PRIORITY and above are mapped "\
3724           "    to normal native priority. Java priorities below "           \
3725           "    NORM_PRIORITY map to lower native priority values. On       "\
3726           "    Windows applications are allowed to use higher native       "\
3727           "    priorities. However, with ThreadPriorityPolicy=0, VM will   "\
3728           "    not use the highest possible native priority,               "\
3729           "    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     "\
3730           "    system threads. On Linux thread priorities are ignored      "\
3731           "    because the OS does not support static priority in          "\
3732           "    SCHED_OTHER scheduling class which is the only choice for   "\
3733           "    non-root, non-realtime applications.                        "\
3734           "1 : Aggressive.                                                 "\
3735           "    Java thread priorities map over to the entire range of      "\
3736           "    native thread priorities. Higher Java thread priorities map "\
3737           "    to higher native thread priorities. This policy should be   "\
3738           "    used with care, as sometimes it can cause performance       "\
3739           "    degradation in the application and/or the entire system. On "\
3740           "    Linux this policy requires root privilege.")                 \
3741           range(0, 1)                                                       \
3742                                                                             \
3743   product(bool, ThreadPriorityVerbose, false,                               \
3744           "Print priority changes")                                         \
3745                                                                             \
3746   product(intx, CompilerThreadPriority, -1,                                 \
3747           "The native priority at which compiler threads should run "       \
3748           "(-1 means no change)")                                           \
3749           range(min_jint, max_jint)                                         \
3750           constraint(CompilerThreadPriorityConstraintFunc, AfterErgo)       \
3751                                                                             \
3752   product(intx, VMThreadPriority, -1,                                       \
3753           "The native priority at which the VM thread should run "          \
3754           "(-1 means no change)")                                           \
3755           range(-1, 127)                                                    \
3756                                                                             \
3757   product(bool, CompilerThreadHintNoPreempt, true,                          \
3758           "(Solaris only) Give compiler threads an extra quanta")           \
3759                                                                             \
3760   product(bool, VMThreadHintNoPreempt, false,                               \
3761           "(Solaris only) Give VM thread an extra quanta")                  \
3762                                                                             \
3763   product(intx, JavaPriority1_To_OSPriority, -1,                            \
3764           "Map Java priorities to OS priorities")                           \
3765           range(-1, 127)                                                    \
3766                                                                             \
3767   product(intx, JavaPriority2_To_OSPriority, -1,                            \
3768           "Map Java priorities to OS priorities")                           \
3769           range(-1, 127)                                                    \
3770                                                                             \
3771   product(intx, JavaPriority3_To_OSPriority, -1,                            \
3772           "Map Java priorities to OS priorities")                           \
3773           range(-1, 127)                                                    \
3774                                                                             \
3775   product(intx, JavaPriority4_To_OSPriority, -1,                            \
3776           "Map Java priorities to OS priorities")                           \
3777           range(-1, 127)                                                    \
3778                                                                             \
3779   product(intx, JavaPriority5_To_OSPriority, -1,                            \
3780           "Map Java priorities to OS priorities")                           \
3781           range(-1, 127)                                                    \
3782                                                                             \
3783   product(intx, JavaPriority6_To_OSPriority, -1,                            \
3784           "Map Java priorities to OS priorities")                           \
3785           range(-1, 127)                                                    \
3786                                                                             \
3787   product(intx, JavaPriority7_To_OSPriority, -1,                            \
3788           "Map Java priorities to OS priorities")                           \
3789           range(-1, 127)                                                    \
3790                                                                             \
3791   product(intx, JavaPriority8_To_OSPriority, -1,                            \
3792           "Map Java priorities to OS priorities")                           \
3793           range(-1, 127)                                                    \
3794                                                                             \
3795   product(intx, JavaPriority9_To_OSPriority, -1,                            \
3796           "Map Java priorities to OS priorities")                           \
3797           range(-1, 127)                                                    \
3798                                                                             \
3799   product(intx, JavaPriority10_To_OSPriority,-1,                            \
3800           "Map Java priorities to OS priorities")                           \
3801           range(-1, 127)                                                    \
3802                                                                             \
3803   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
3804           "Java thread priority 10 maps to critical scheduling priority")   \
3805                                                                             \
3806   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
3807           "Compiler thread(s) run at critical scheduling priority")         \
3808                                                                             \
3809   experimental(bool, UseCriticalCMSThreadPriority, false,                   \
3810           "ConcurrentMarkSweep thread runs at critical scheduling priority")\
3811                                                                             \
3812   /* compiler debugging */                                                  \
3813   notproduct(intx, CompileTheWorldStartAt,     1,                           \
3814           "First class to consider when using +CompileTheWorld")            \
3815                                                                             \
3816   notproduct(intx, CompileTheWorldStopAt, max_jint,                         \
3817           "Last class to consider when using +CompileTheWorld")             \
3818                                                                             \
3819   develop(intx, NewCodeParameter,      0,                                   \
3820           "Testing Only: Create a dedicated integer parameter before "      \
3821           "putback")                                                        \
3822                                                                             \
3823   /* new oopmap storage allocation */                                       \
3824   develop(intx, MinOopMapAllocation,     8,                                 \
3825           "Minimum number of OopMap entries in an OopMapSet")               \
3826                                                                             \
3827   /* Background Compilation */                                              \
3828   develop(intx, LongCompileThreshold,     50,                               \
3829           "Used with +TraceLongCompiles")                                   \
3830                                                                             \
3831   /* recompilation */                                                       \
3832   product_pd(intx, CompileThreshold,                                        \
3833           "number of interpreted method invocations before (re-)compiling") \
3834           constraint(CompileThresholdConstraintFunc, AfterErgo)             \
3835                                                                             \
3836   product(double, CompileThresholdScaling, 1.0,                             \
3837           "Factor to control when first compilation happens "               \
3838           "(both with and without tiered compilation): "                    \
3839           "values greater than 1.0 delay counter overflow, "                \
3840           "values between 0 and 1.0 rush counter overflow, "                \
3841           "value of 1.0 leaves compilation thresholds unchanged "           \
3842           "value of 0.0 is equivalent to -Xint. "                           \
3843           ""                                                                \
3844           "Flag can be set as per-method option. "                          \
3845           "If a value is specified for a method, compilation thresholds "   \
3846           "for that method are scaled by both the value of the global flag "\
3847           "and the value of the per-method flag.")                          \
3848           range(0.0, DBL_MAX)                                               \
3849                                                                             \
3850   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
3851           "Interpreter (tier 0) invocation notification frequency")         \
3852           range(0, 30)                                                      \
3853                                                                             \
3854   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
3855           "C1 without MDO (tier 2) invocation notification frequency")      \
3856           range(0, 30)                                                      \
3857                                                                             \
3858   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
3859           "C1 with MDO profiling (tier 3) invocation notification "         \
3860           "frequency")                                                      \
3861           range(0, 30)                                                      \
3862                                                                             \
3863   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
3864           "Inlinee invocation (tiers 2 and 3) notification frequency")      \
3865           range(0, 30)                                                      \
3866                                                                             \
3867   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
3868           "Interpreter (tier 0) invocation notification frequency")         \
3869           range(0, 30)                                                      \
3870                                                                             \
3871   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
3872           "C1 without MDO (tier 2) invocation notification frequency")      \
3873           range(0, 30)                                                      \
3874                                                                             \
3875   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
3876           "C1 with MDO profiling (tier 3) invocation notification "         \
3877           "frequency")                                                      \
3878           range(0, 30)                                                      \
3879                                                                             \
3880   product(intx, Tier2CompileThreshold, 0,                                   \
3881           "threshold at which tier 2 compilation is invoked")               \
3882           range(0, max_jint)                                                \
3883                                                                             \
3884   product(intx, Tier2BackEdgeThreshold, 0,                                  \
3885           "Back edge threshold at which tier 2 compilation is invoked")     \
3886           range(0, max_jint)                                                \
3887                                                                             \
3888   product(intx, Tier3InvocationThreshold, 200,                              \
3889           "Compile if number of method invocations crosses this "           \
3890           "threshold")                                                      \
3891           range(0, max_jint)                                                \
3892                                                                             \
3893   product(intx, Tier3MinInvocationThreshold, 100,                           \
3894           "Minimum invocation to compile at tier 3")                        \
3895           range(0, max_jint)                                                \
3896                                                                             \
3897   product(intx, Tier3CompileThreshold, 2000,                                \
3898           "Threshold at which tier 3 compilation is invoked (invocation "   \
3899           "minimum must be satisfied)")                                     \
3900           range(0, max_jint)                                                \
3901                                                                             \
3902   product(intx, Tier3BackEdgeThreshold,  60000,                             \
3903           "Back edge threshold at which tier 3 OSR compilation is invoked") \
3904           range(0, max_jint)                                                \
3905                                                                             \
3906   product(intx, Tier4InvocationThreshold, 5000,                             \
3907           "Compile if number of method invocations crosses this "           \
3908           "threshold")                                                      \
3909           range(0, max_jint)                                                \
3910                                                                             \
3911   product(intx, Tier4MinInvocationThreshold, 600,                           \
3912           "Minimum invocation to compile at tier 4")                        \
3913           range(0, max_jint)                                                \
3914                                                                             \
3915   product(intx, Tier4CompileThreshold, 15000,                               \
3916           "Threshold at which tier 4 compilation is invoked (invocation "   \
3917           "minimum must be satisfied")                                      \
3918           range(0, max_jint)                                                \
3919                                                                             \
3920   product(intx, Tier4BackEdgeThreshold, 40000,                              \
3921           "Back edge threshold at which tier 4 OSR compilation is invoked") \
3922           range(0, max_jint)                                                \
3923                                                                             \
3924   product(intx, Tier3DelayOn, 5,                                            \
3925           "If C2 queue size grows over this amount per compiler thread "    \
3926           "stop compiling at tier 3 and start compiling at tier 2")         \
3927           range(0, max_jint)                                                \
3928                                                                             \
3929   product(intx, Tier3DelayOff, 2,                                           \
3930           "If C2 queue size is less than this amount per compiler thread "  \
3931           "allow methods compiled at tier 2 transition to tier 3")          \
3932           range(0, max_jint)                                                \
3933                                                                             \
3934   product(intx, Tier3LoadFeedback, 5,                                       \
3935           "Tier 3 thresholds will increase twofold when C1 queue size "     \
3936           "reaches this amount per compiler thread")                        \
3937           range(0, max_jint)                                                \
3938                                                                             \
3939   product(intx, Tier4LoadFeedback, 3,                                       \
3940           "Tier 4 thresholds will increase twofold when C2 queue size "     \
3941           "reaches this amount per compiler thread")                        \
3942           range(0, max_jint)                                                \
3943                                                                             \
3944   product(intx, TieredCompileTaskTimeout, 50,                               \
3945           "Kill compile task if method was not used within "                \
3946           "given timeout in milliseconds")                                  \
3947           range(0, max_intx)                                                \
3948                                                                             \
3949   product(intx, TieredStopAtLevel, 4,                                       \
3950           "Stop at given compilation level")                                \
3951           range(0, 4)                                                       \
3952                                                                             \
3953   product(intx, Tier0ProfilingStartPercentage, 200,                         \
3954           "Start profiling in interpreter if the counters exceed tier 3 "   \
3955           "thresholds by the specified percentage")                         \
3956           range(0, max_jint)                                                \
3957                                                                             \
3958   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
3959           "Increase the compile threshold for C1 compilation if the code "  \
3960           "cache is filled by the specified percentage")                    \
3961           range(0, 99)                                                      \
3962                                                                             \
3963   product(intx, TieredRateUpdateMinTime, 1,                                 \
3964           "Minimum rate sampling interval (in milliseconds)")               \
3965           range(0, max_intx)                                                \
3966                                                                             \
3967   product(intx, TieredRateUpdateMaxTime, 25,                                \
3968           "Maximum rate sampling interval (in milliseconds)")               \
3969           range(0, max_intx)                                                \
3970                                                                             \
3971   product_pd(bool, TieredCompilation,                                       \
3972           "Enable tiered compilation")                                      \
3973                                                                             \
3974   product(bool, PrintTieredEvents, false,                                   \
3975           "Print tiered events notifications")                              \
3976                                                                             \
3977   product_pd(intx, OnStackReplacePercentage,                                \
3978           "NON_TIERED number of method invocations/branches (expressed as " \
3979           "% of CompileThreshold) before (re-)compiling OSR code")          \
3980           constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \
3981                                                                             \
3982   product(intx, InterpreterProfilePercentage, 33,                           \
3983           "NON_TIERED number of method invocations/branches (expressed as " \
3984           "% of CompileThreshold) before profiling in the interpreter")     \
3985           range(0, 100)                                                     \
3986                                                                             \
3987   develop(intx, MaxRecompilationSearchLength,    10,                        \
3988           "The maximum number of frames to inspect when searching for "     \
3989           "recompilee")                                                     \
3990                                                                             \
3991   develop(intx, MaxInterpretedSearchLength,     3,                          \
3992           "The maximum number of interpreted frames to skip when searching "\
3993           "for recompilee")                                                 \
3994                                                                             \
3995   develop(intx, DesiredMethodLimit,  8000,                                  \
3996           "The desired maximum method size (in bytecodes) after inlining")  \
3997                                                                             \
3998   develop(intx, HugeMethodLimit,  8000,                                     \
3999           "Don't compile methods larger than this if "                      \
4000           "+DontCompileHugeMethods")                                        \
4001                                                                             \
4002   /* New JDK 1.4 reflection implementation */                               \
4003                                                                             \
4004   develop(intx, FastSuperclassLimit, 8,                                     \
4005           "Depth of hardwired instanceof accelerator array")                \
4006                                                                             \
4007   /* Properties for Java libraries  */                                      \
4008                                                                             \
4009   product(size_t, MaxDirectMemorySize, 0,                                   \
4010           "Maximum total size of NIO direct-buffer allocations")            \
4011           range(0, (size_t)SIZE_MAX)                                        \
4012                                                                             \
4013   /* Flags used for temporary code during development  */                   \
4014                                                                             \
4015   diagnostic(bool, UseNewCode, false,                                       \
4016           "Testing Only: Use the new version while testing")                \
4017                                                                             \
4018   diagnostic(bool, UseNewCode2, false,                                      \
4019           "Testing Only: Use the new version while testing")                \
4020                                                                             \
4021   diagnostic(bool, UseNewCode3, false,                                      \
4022           "Testing Only: Use the new version while testing")                \
4023                                                                             \
4024   /* flags for performance data collection */                               \
4025                                                                             \
4026   product(bool, UsePerfData, falseInEmbedded,                               \
4027           "Flag to disable jvmstat instrumentation for performance testing "\
4028           "and problem isolation purposes")                                 \
4029                                                                             \
4030   product(bool, PerfDataSaveToFile, false,                                  \
4031           "Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit")          \
4032                                                                             \
4033   product(ccstr, PerfDataSaveFile, NULL,                                    \
4034           "Save PerfData memory to the specified absolute pathname. "       \
4035           "The string %p in the file name (if present) "                    \
4036           "will be replaced by pid")                                        \
4037                                                                             \
4038   product(intx, PerfDataSamplingInterval, 50,                               \
4039           "Data sampling interval (in milliseconds)")                       \
4040           range(PeriodicTask::min_interval, max_jint)                       \
4041           constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \
4042                                                                             \
4043   develop(bool, PerfTraceDataCreation, false,                               \
4044           "Trace creation of Performance Data Entries")                     \
4045                                                                             \
4046   develop(bool, PerfTraceMemOps, false,                                     \
4047           "Trace PerfMemory create/attach/detach calls")                    \
4048                                                                             \
4049   product(bool, PerfDisableSharedMem, false,                                \
4050           "Store performance data in standard memory")                      \
4051                                                                             \
4052   product(intx, PerfDataMemorySize, 64*K,                                   \
4053           "Size of performance data memory region. Will be rounded "        \
4054           "up to a multiple of the native os page size.")                   \
4055           range(128, 32*64*K)                                               \
4056                                                                             \
4057   product(intx, PerfMaxStringConstLength, 1024,                             \
4058           "Maximum PerfStringConstant string length before truncation")     \
4059           range(32, 32*K)                                                   \
4060                                                                             \
4061   product(bool, PerfAllowAtExitRegistration, false,                         \
4062           "Allow registration of atexit() methods")                         \
4063                                                                             \
4064   product(bool, PerfBypassFileSystemCheck, false,                           \
4065           "Bypass Win32 file system criteria checks (Windows Only)")        \
4066                                                                             \
4067   product(intx, UnguardOnExecutionViolation, 0,                             \
4068           "Unguard page and retry on no-execute fault (Win32 only) "        \
4069           "0=off, 1=conservative, 2=aggressive")                            \
4070           range(0, 2)                                                       \
4071                                                                             \
4072   /* Serviceability Support */                                              \
4073                                                                             \
4074   product(bool, ManagementServer, false,                                    \
4075           "Create JMX Management Server")                                   \
4076                                                                             \
4077   product(bool, DisableAttachMechanism, false,                              \
4078           "Disable mechanism that allows tools to attach to this VM")       \
4079                                                                             \
4080   product(bool, StartAttachListener, false,                                 \
4081           "Always start Attach Listener at VM startup")                     \
4082                                                                             \
4083   manageable(bool, PrintConcurrentLocks, false,                             \
4084           "Print java.util.concurrent locks in thread dump")                \
4085                                                                             \
4086   product(bool, TransmitErrorReport, false,                                 \
4087           "Enable error report transmission on erroneous termination")      \
4088                                                                             \
4089   product(ccstr, ErrorReportServer, NULL,                                   \
4090           "Override built-in error report server address")                  \
4091                                                                             \
4092   /* Shared spaces */                                                       \
4093                                                                             \
4094   product(bool, UseSharedSpaces, true,                                      \
4095           "Use shared spaces for metadata")                                 \
4096                                                                             \
4097   product(bool, VerifySharedSpaces, false,                                  \
4098           "Verify shared spaces (false for default archive, true for "      \
4099           "archive specified by -XX:SharedArchiveFile)")                    \
4100                                                                             \
4101   product(bool, RequireSharedSpaces, false,                                 \
4102           "Require shared spaces for metadata")                             \
4103                                                                             \
4104   product(bool, DumpSharedSpaces, false,                                    \
4105           "Special mode: JVM reads a class list, loads classes, builds "    \
4106           "shared spaces, and dumps the shared spaces to a file to be "     \
4107           "used in future JVM runs")                                        \
4108                                                                             \
4109   product(bool, PrintSharedSpaces, false,                                   \
4110           "Print usage of shared spaces")                                   \
4111                                                                             \
4112   product(bool, PrintSharedArchiveAndExit, false,                           \
4113           "Print shared archive file contents")                             \
4114                                                                             \
4115   product(bool, PrintSharedDictionary, false,                               \
4116           "If PrintSharedArchiveAndExit is true, also print the shared "    \
4117           "dictionary")                                                     \
4118                                                                             \
4119   product(size_t, SharedReadWriteSize, NOT_LP64(12*M) LP64_ONLY(16*M),      \
4120           "Size of read-write space for metadata (in bytes)")               \
4121                                                                             \
4122   product(size_t, SharedReadOnlySize, NOT_LP64(12*M) LP64_ONLY(16*M),       \
4123           "Size of read-only space for metadata (in bytes)")                \
4124                                                                             \
4125   product(uintx, SharedMiscDataSize,    NOT_LP64(2*M) LP64_ONLY(4*M),       \
4126           "Size of the shared miscellaneous data area (in bytes)")          \
4127                                                                             \
4128   product(uintx, SharedMiscCodeSize,    120*K,                              \
4129           "Size of the shared miscellaneous code area (in bytes)")          \
4130                                                                             \
4131   product(uintx, SharedBaseAddress, LP64_ONLY(32*G)                         \
4132           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
4133           "Address to allocate shared memory region for class data")        \
4134                                                                             \
4135   product(uintx, SharedSymbolTableBucketSize, 4,                            \
4136           "Average number of symbols per bucket in shared table")           \
4137           range(2, 246)                                                     \
4138                                                                             \
4139   diagnostic(bool, IgnoreUnverifiableClassesDuringDump, false,              \
4140           "Do not quit -Xshare:dump even if we encounter unverifiable "     \
4141           "classes. Just exclude them from the shared dictionary.")         \
4142                                                                             \
4143   diagnostic(bool, PrintMethodHandleStubs, false,                           \
4144           "Print generated stub code for method handles")                   \
4145                                                                             \
4146   develop(bool, TraceMethodHandles, false,                                  \
4147           "trace internal method handle operations")                        \
4148                                                                             \
4149   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
4150           "perform extra checks when constructing method handles")          \
4151                                                                             \
4152   diagnostic(bool, ShowHiddenFrames, false,                                 \
4153           "show method handle implementation frames (usually hidden)")      \
4154                                                                             \
4155   experimental(bool, TrustFinalNonStaticFields, false,                      \
4156           "trust final non-static declarations for constant folding")       \
4157                                                                             \
4158   diagnostic(bool, FoldStableValues, true,                                  \
4159           "Optimize loads from stable fields (marked w/ @Stable)")          \
4160                                                                             \
4161   develop(bool, TraceInvokeDynamic, false,                                  \
4162           "trace internal invoke dynamic operations")                       \
4163                                                                             \
4164   diagnostic(bool, PauseAtStartup,      false,                              \
4165           "Causes the VM to pause at startup time and wait for the pause "  \
4166           "file to be removed (default: ./vm.paused.&lt;pid&gt;)")                \
4167                                                                             \
4168   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
4169           "The file to create and for whose removal to await when pausing " \
4170           "at startup. (default: ./vm.paused.&lt;pid&gt;)")                       \
4171                                                                             \
4172   diagnostic(bool, PauseAtExit, false,                                      \
4173           "Pause and wait for keypress on exit if a debugger is attached")  \
4174                                                                             \
4175   product(bool, ExtendedDTraceProbes,    false,                             \
4176           "Enable performance-impacting dtrace probes")                     \
4177                                                                             \
4178   product(bool, DTraceMethodProbes, false,                                  \
4179           "Enable dtrace probes for method-entry and method-exit")          \
4180                                                                             \
4181   product(bool, DTraceAllocProbes, false,                                   \
4182           "Enable dtrace probes for object allocation")                     \
4183                                                                             \
4184   product(bool, DTraceMonitorProbes, false,                                 \
4185           "Enable dtrace probes for monitor events")                        \
4186                                                                             \
4187   product(bool, RelaxAccessControlCheck, false,                             \
4188           "Relax the access control checks in the verifier")                \
4189                                                                             \
4190   product(uintx, StringTableSize, defaultStringTableSize,                   \
4191           "Number of buckets in the interned String table")                 \
4192           range(minimumStringTableSize, 111*defaultStringTableSize)         \
4193                                                                             \
4194   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
4195           "Number of buckets in the JVM internal Symbol table")             \
4196           range(minimumSymbolTableSize, 111*defaultSymbolTableSize)         \
4197                                                                             \
4198   product(bool, UseStringDeduplication, false,                              \
4199           "Use string deduplication")                                       \
4200                                                                             \
4201   product(bool, PrintStringDeduplicationStatistics, false,                  \
4202           "Print string deduplication statistics")                          \
4203                                                                             \
4204   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
4205           "A string must reach this age (or be promoted to an old region) " \
4206           "to be considered for deduplication")                             \
4207           range(1, markOopDesc::max_age)                                    \
4208                                                                             \
4209   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
4210           "Force table resize every time the table is scanned")             \
4211                                                                             \
4212   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
4213           "Force table rehash every time the table is scanned")             \
4214                                                                             \
4215   diagnostic(bool, WhiteBoxAPI, false,                                      \
4216           "Enable internal testing APIs")                                   \
4217                                                                             \
4218   product(bool, PrintGCCause, true,                                         \
4219           "Include GC cause in GC logging")                                 \
4220                                                                             \
4221   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
4222            "Default survivor space alignment in bytes")                     \
4223            constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \
4224                                                                             \
4225   product(bool , AllowNonVirtualCalls, false,                               \
4226           "Obey the ACC_SUPER flag and allow invokenonvirtual calls")       \
4227                                                                             \
4228   product(ccstr, DumpLoadedClassList, NULL,                                 \
4229           "Dump the names all loaded classes, that could be stored into "   \
4230           "the CDS archive, in the specified file")                         \
4231                                                                             \
4232   product(ccstr, SharedClassListFile, NULL,                                 \
4233           "Override the default CDS class list")                            \
4234                                                                             \
4235   diagnostic(ccstr, SharedArchiveFile, NULL,                                \
4236           "Override the default location of the CDS archive file")          \
4237                                                                             \
4238   product(ccstr, ExtraSharedClassListFile, NULL,                            \
4239           "Extra classlist for building the CDS archive file")              \
4240                                                                             \
4241   experimental(size_t, ArrayAllocatorMallocLimit,                           \
4242           SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \
4243           "Allocation less than this value will be allocated "              \
4244           "using malloc. Larger allocations will use mmap.")                \
4245                                                                             \
4246   experimental(bool, AlwaysAtomicAccesses, false,                           \
4247           "Accesses to all variables should always be atomic")              \
4248                                                                             \
4249   product(bool, EnableTracing, false,                                       \
4250           "Enable event-based tracing")                                     \
4251                                                                             \
4252   product(bool, UseLockedTracing, false,                                    \
4253           "Use locked-tracing when doing event-based tracing")              \
4254                                                                             \
4255   diagnostic(bool, UseUnalignedAccesses, false,                             \
4256           "Use unaligned memory accesses in Unsafe")                        \
4257                                                                             \
4258   product_pd(bool, PreserveFramePointer,                                    \
4259              "Use the FP register for holding the frame pointer "           \
4260              "and not as a general purpose register.")                      \
4261                                                                             \
4262   diagnostic(bool, CheckIntrinsics, true,                                   \
4263              "When a class C is loaded, check that "                        \
4264              "(1) all intrinsics defined by the VM for class C are present "\
4265              "in the loaded class file and are marked with the "            \
4266              "@HotSpotIntrinsicCandidate annotation, that "                 \
4267              "(2) there is an intrinsic registered for all loaded methods " \
4268              "that are annotated with the @HotSpotIntrinsicCandidate "      \
4269              "annotation, and that "                                        \
4270              "(3) no orphan methods exist for class C (i.e., methods for "  \
4271              "which the VM declares an intrinsic but that are not declared "\
4272              "in the loaded class C. "                                      \
4273              "Check (3) is available only in debug builds.")                \
4274                                                                             \
4275   diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \
4276              "Disable backwards compatibility for compile commands.")       \
4277                                                                             \
4278   diagnostic(bool, PrintCompilerDirectives, false,                          \
4279              "Print compiler directives on installation.")
4280 
4281 /*
4282  *  Macros for factoring of globals
4283  */
4284 
4285 // Interface macros
4286 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern "C" type name;
4287 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern "C" type name;
4288 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern "C" type name;
4289 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern "C" type name;
4290 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern "C" type name;
4291 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern "C" type name;
4292 #ifdef PRODUCT
4293 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type CONST_##name; const type name = value;
4294 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type CONST_##name; const type name = pd_##name;
4295 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type CONST_##name;
4296 #else
4297 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type name;
4298 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type name;
4299 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type name;
4300 #endif // PRODUCT
4301 // Special LP64 flags, product only needed for now.
4302 #ifdef _LP64
4303 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern "C" type name;
4304 #else
4305 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
4306 #endif // _LP64
4307 
4308 // Implementation macros
4309 #define MATERIALIZE_PRODUCT_FLAG(type, name, value, doc)      type name = value;
4310 #define MATERIALIZE_PD_PRODUCT_FLAG(type, name, doc)          type name = pd_##name;
4311 #define MATERIALIZE_DIAGNOSTIC_FLAG(type, name, value, doc)   type name = value;
4312 #define MATERIALIZE_EXPERIMENTAL_FLAG(type, name, value, doc) type name = value;
4313 #define MATERIALIZE_MANAGEABLE_FLAG(type, name, value, doc)   type name = value;
4314 #define MATERIALIZE_PRODUCT_RW_FLAG(type, name, value, doc)   type name = value;
4315 #ifdef PRODUCT
4316 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type CONST_##name = value;
4317 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type CONST_##name = pd_##name;
4318 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type CONST_##name = value;
4319 #else
4320 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type name = value;
4321 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type name = pd_##name;
4322 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type name = value;
4323 #endif // PRODUCT
4324 #ifdef _LP64
4325 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) type name = value;
4326 #else
4327 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) /* flag is constant */
4328 #endif // _LP64
4329 
4330 // Only materialize src code for range checking when required, ignore otherwise
4331 #define IGNORE_RANGE(a, b)
4332 // Only materialize src code for contraint checking when required, ignore otherwise
4333 #define IGNORE_CONSTRAINT(func,type)
4334 
4335 RUNTIME_FLAGS(DECLARE_DEVELOPER_FLAG, \
4336               DECLARE_PD_DEVELOPER_FLAG, \
4337               DECLARE_PRODUCT_FLAG, \
4338               DECLARE_PD_PRODUCT_FLAG, \
4339               DECLARE_DIAGNOSTIC_FLAG, \
4340               DECLARE_EXPERIMENTAL_FLAG, \
4341               DECLARE_NOTPRODUCT_FLAG, \
4342               DECLARE_MANAGEABLE_FLAG, \
4343               DECLARE_PRODUCT_RW_FLAG, \
4344               DECLARE_LP64_PRODUCT_FLAG, \
4345               IGNORE_RANGE, \
4346               IGNORE_CONSTRAINT)
4347 
4348 RUNTIME_OS_FLAGS(DECLARE_DEVELOPER_FLAG, \
4349                  DECLARE_PD_DEVELOPER_FLAG, \
4350                  DECLARE_PRODUCT_FLAG, \
4351                  DECLARE_PD_PRODUCT_FLAG, \
4352                  DECLARE_DIAGNOSTIC_FLAG, \
4353                  DECLARE_NOTPRODUCT_FLAG, \
4354                  IGNORE_RANGE, \
4355                  IGNORE_CONSTRAINT)
4356 
4357 ARCH_FLAGS(DECLARE_DEVELOPER_FLAG, \
4358            DECLARE_PRODUCT_FLAG, \
4359            DECLARE_DIAGNOSTIC_FLAG, \
4360            DECLARE_EXPERIMENTAL_FLAG, \
4361            DECLARE_NOTPRODUCT_FLAG, \
4362            IGNORE_RANGE, \
4363            IGNORE_CONSTRAINT)
4364 
4365 // Extensions
4366 
4367 #include "runtime/globals_ext.hpp"
4368 
4369 #endif // SHARE_VM_RUNTIME_GLOBALS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
