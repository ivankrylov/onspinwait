<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1994, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.WeakReference;
  31 import java.security.AccessController;
  32 import java.security.AccessControlContext;
  33 import java.security.PrivilegedAction;
  34 import java.util.Map;
  35 import java.util.HashMap;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 import java.util.concurrent.ConcurrentMap;
  38 import java.util.concurrent.locks.LockSupport;
  39 import sun.nio.ch.Interruptible;
  40 import sun.reflect.CallerSensitive;
  41 import sun.reflect.Reflection;
  42 import sun.security.util.SecurityConstants;
  43 import jdk.internal.HotSpotIntrinsicCandidate;
  44 
  45 /**
  46  * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
  47  * Virtual Machine allows an application to have multiple threads of
  48  * execution running concurrently.
  49  * &lt;p&gt;
  50  * Every thread has a priority. Threads with higher priority are
  51  * executed in preference to threads with lower priority. Each thread
  52  * may or may not also be marked as a daemon. When code running in
  53  * some thread creates a new &lt;code&gt;Thread&lt;/code&gt; object, the new
  54  * thread has its priority initially set equal to the priority of the
  55  * creating thread, and is a daemon thread if and only if the
  56  * creating thread is a daemon.
  57  * &lt;p&gt;
  58  * When a Java Virtual Machine starts up, there is usually a single
  59  * non-daemon thread (which typically calls the method named
  60  * &lt;code&gt;main&lt;/code&gt; of some designated class). The Java Virtual
  61  * Machine continues to execute threads until either of the following
  62  * occurs:
  63  * &lt;ul&gt;
  64  * &lt;li&gt;The &lt;code&gt;exit&lt;/code&gt; method of class &lt;code&gt;Runtime&lt;/code&gt; has been
  65  *     called and the security manager has permitted the exit operation
  66  *     to take place.
  67  * &lt;li&gt;All threads that are not daemon threads have died, either by
  68  *     returning from the call to the &lt;code&gt;run&lt;/code&gt; method or by
  69  *     throwing an exception that propagates beyond the &lt;code&gt;run&lt;/code&gt;
  70  *     method.
  71  * &lt;/ul&gt;
  72  * &lt;p&gt;
  73  * There are two ways to create a new thread of execution. One is to
  74  * declare a class to be a subclass of &lt;code&gt;Thread&lt;/code&gt;. This
  75  * subclass should override the &lt;code&gt;run&lt;/code&gt; method of class
  76  * &lt;code&gt;Thread&lt;/code&gt;. An instance of the subclass can then be
  77  * allocated and started. For example, a thread that computes primes
  78  * larger than a stated value could be written as follows:
  79  * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
  80  *     class PrimeThread extends Thread {
  81  *         long minPrime;
  82  *         PrimeThread(long minPrime) {
  83  *             this.minPrime = minPrime;
  84  *         }
  85  *
  86  *         public void run() {
  87  *             // compute primes larger than minPrime
  88  *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
  89  *         }
  90  *     }
  91  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
  92  * &lt;p&gt;
  93  * The following code would then create a thread and start it running:
  94  * &lt;blockquote&gt;&lt;pre&gt;
  95  *     PrimeThread p = new PrimeThread(143);
  96  *     p.start();
  97  * &lt;/pre&gt;&lt;/blockquote&gt;
  98  * &lt;p&gt;
  99  * The other way to create a thread is to declare a class that
 100  * implements the &lt;code&gt;Runnable&lt;/code&gt; interface. That class then
 101  * implements the &lt;code&gt;run&lt;/code&gt; method. An instance of the class can
 102  * then be allocated, passed as an argument when creating
 103  * &lt;code&gt;Thread&lt;/code&gt;, and started. The same example in this other
 104  * style looks like the following:
 105  * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
 106  *     class PrimeRun implements Runnable {
 107  *         long minPrime;
 108  *         PrimeRun(long minPrime) {
 109  *             this.minPrime = minPrime;
 110  *         }
 111  *
 112  *         public void run() {
 113  *             // compute primes larger than minPrime
 114  *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 115  *         }
 116  *     }
 117  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
 118  * &lt;p&gt;
 119  * The following code would then create a thread and start it running:
 120  * &lt;blockquote&gt;&lt;pre&gt;
 121  *     PrimeRun p = new PrimeRun(143);
 122  *     new Thread(p).start();
 123  * &lt;/pre&gt;&lt;/blockquote&gt;
 124  * &lt;p&gt;
 125  * Every thread has a name for identification purposes. More than
 126  * one thread may have the same name. If a name is not specified when
 127  * a thread is created, a new name is generated for it.
 128  * &lt;p&gt;
 129  * Unless otherwise noted, passing a {@code null} argument to a constructor
 130  * or method in this class will cause a {@link NullPointerException} to be
 131  * thrown.
 132  *
 133  * @author  unascribed
 134  * @see     Runnable
 135  * @see     Runtime#exit(int)
 136  * @see     #run()
 137  * @see     #stop()
 138  * @since   1.0
 139  */
 140 public
 141 class Thread implements Runnable {
 142     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 143     private static native void registerNatives();
 144     static {
 145         registerNatives();
 146     }
 147 
 148     private volatile String name;
 149     private int            priority;
 150     private Thread         threadQ;
 151     private long           eetop;
 152 
 153     /* Whether or not to single_step this thread. */
 154     private boolean     single_step;
 155 
 156     /* Whether or not the thread is a daemon thread. */
 157     private boolean     daemon = false;
 158 
 159     /* JVM state */
 160     private boolean     stillborn = false;
 161 
 162     /* What will be run. */
 163     private Runnable target;
 164 
 165     /* The group of this thread */
 166     private ThreadGroup group;
 167 
 168     /* The context ClassLoader for this thread */
 169     private ClassLoader contextClassLoader;
 170 
 171     /* The inherited AccessControlContext of this thread */
 172     private AccessControlContext inheritedAccessControlContext;
 173 
 174     /* For autonumbering anonymous threads. */
 175     private static int threadInitNumber;
 176     private static synchronized int nextThreadNum() {
 177         return threadInitNumber++;
 178     }
 179 
 180     /* ThreadLocal values pertaining to this thread. This map is maintained
 181      * by the ThreadLocal class. */
 182     ThreadLocal.ThreadLocalMap threadLocals = null;
 183 
 184     /*
 185      * InheritableThreadLocal values pertaining to this thread. This map is
 186      * maintained by the InheritableThreadLocal class.
 187      */
 188     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 189 
 190     /*
 191      * The requested stack size for this thread, or 0 if the creator did
 192      * not specify a stack size.  It is up to the VM to do whatever it
 193      * likes with this number; some VMs will ignore it.
 194      */
 195     private long stackSize;
 196 
 197     /*
 198      * JVM-private state that persists after native thread termination.
 199      */
 200     private long nativeParkEventPointer;
 201 
 202     /*
 203      * Thread ID
 204      */
 205     private long tid;
 206 
 207     /* For generating thread ID */
 208     private static long threadSeqNumber;
 209 
 210     /* Java thread status for tools,
 211      * initialized to indicate thread 'not yet started'
 212      */
 213 
 214     private volatile int threadStatus = 0;
 215 
 216 
 217     private static synchronized long nextThreadID() {
 218         return ++threadSeqNumber;
 219     }
 220 
 221     /**
 222      * The argument supplied to the current call to
 223      * java.util.concurrent.locks.LockSupport.park.
 224      * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
 225      * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
 226      */
 227     volatile Object parkBlocker;
 228 
 229     /* The object in which this thread is blocked in an interruptible I/O
 230      * operation, if any.  The blocker's interrupt method should be invoked
 231      * after setting this thread's interrupt status.
 232      */
 233     private volatile Interruptible blocker;
 234     private final Object blockerLock = new Object();
 235 
 236     /* Set the blocker field; invoked via jdk.internal.misc.SharedSecrets
 237      * from java.nio code
 238      */
 239     void blockedOn(Interruptible b) {
 240         synchronized (blockerLock) {
 241             blocker = b;
 242         }
 243     }
 244 
 245     /**
 246      * The minimum priority that a thread can have.
 247      */
 248     public static final int MIN_PRIORITY = 1;
 249 
 250    /**
 251      * The default priority that is assigned to a thread.
 252      */
 253     public static final int NORM_PRIORITY = 5;
 254 
 255     /**
 256      * The maximum priority that a thread can have.
 257      */
 258     public static final int MAX_PRIORITY = 10;
 259 
 260     /**
 261      * Returns a reference to the currently executing thread object.
 262      *
 263      * @return  the currently executing thread.
 264      */
 265     @HotSpotIntrinsicCandidate
 266     public static native Thread currentThread();
 267 
 268     /**
 269      * A hint to the scheduler that the current thread is willing to yield
 270      * its current use of a processor. The scheduler is free to ignore this
 271      * hint.
 272      *
 273      * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 274      * between threads that would otherwise over-utilise a CPU. Its use
 275      * should be combined with detailed profiling and benchmarking to
 276      * ensure that it actually has the desired effect.
 277      *
 278      * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 279      * for debugging or testing purposes, where it may help to reproduce
 280      * bugs due to race conditions. It may also be useful when designing
 281      * concurrency control constructs such as the ones in the
 282      * {@link java.util.concurrent.locks} package.
 283      */
 284     public static native void yield();
 285 
 286     /**
 287      * Causes the currently executing thread to sleep (temporarily cease
 288      * execution) for the specified number of milliseconds, subject to
 289      * the precision and accuracy of system timers and schedulers. The thread
 290      * does not lose ownership of any monitors.
 291      *
 292      * @param  millis
 293      *         the length of time to sleep in milliseconds
 294      *
 295      * @throws  IllegalArgumentException
 296      *          if the value of {@code millis} is negative
 297      *
 298      * @throws  InterruptedException
 299      *          if any thread has interrupted the current thread. The
 300      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 301      *          cleared when this exception is thrown.
 302      */
 303     public static native void sleep(long millis) throws InterruptedException;
 304 
 305     /**
 306      * Causes the currently executing thread to sleep (temporarily cease
 307      * execution) for the specified number of milliseconds plus the specified
 308      * number of nanoseconds, subject to the precision and accuracy of system
 309      * timers and schedulers. The thread does not lose ownership of any
 310      * monitors.
 311      *
 312      * @param  millis
 313      *         the length of time to sleep in milliseconds
 314      *
 315      * @param  nanos
 316      *         {@code 0-999999} additional nanoseconds to sleep
 317      *
 318      * @throws  IllegalArgumentException
 319      *          if the value of {@code millis} is negative, or the value of
 320      *          {@code nanos} is not in the range {@code 0-999999}
 321      *
 322      * @throws  InterruptedException
 323      *          if any thread has interrupted the current thread. The
 324      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 325      *          cleared when this exception is thrown.
 326      */
 327     public static void sleep(long millis, int nanos)
 328     throws InterruptedException {
 329         if (millis &lt; 0) {
 330             throw new IllegalArgumentException("timeout value is negative");
 331         }
 332 
 333         if (nanos &lt; 0 || nanos &gt; 999999) {
 334             throw new IllegalArgumentException(
 335                                 "nanosecond timeout value out of range");
 336         }
 337 
 338         if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
 339             millis++;
 340         }
 341 
 342         sleep(millis);
 343     }
 344 
 345     /**
<a name="1" id="anc1"></a><span class="new"> 346      * Provide the JVM with a hint that this call is made from within a spinning</span>
<span class="new"> 347      * loop. The JVM may assume that the speed of executing the loop (e.g. in</span>
<span class="new"> 348      * terms of number of loop executions per second) is less important than the</span>
<span class="new"> 349      * reaction time to events that would cause the loop to terminate, or than</span>
<span class="new"> 350      * potential power savings that may be derived from possible execution</span>
<span class="new"> 351      * choices. The JVM will not slow down the loop execution to a point where</span>
<span class="new"> 352      * execution will be delayed indefinitely, but other choices of loop execution</span>
<span class="new"> 353      * speed are system-specific.</span>
<span class="new"> 354      */</span>
<span class="new"> 355     @HotSpotIntrinsicCandidate</span>
<span class="new"> 356     public static void spinLoopHint() {};</span>
<span class="new"> 357 </span>
<span class="new"> 358     /**</span>
 359      * Initializes a Thread with the current AccessControlContext.
 360      * @see #init(ThreadGroup,Runnable,String,long,AccessControlContext)
 361      */
 362     private void init(ThreadGroup g, Runnable target, String name,
 363                       long stackSize) {
 364         init(g, target, name, stackSize, null);
 365     }
 366 
 367     /**
 368      * Initializes a Thread.
 369      *
 370      * @param g the Thread group
 371      * @param target the object whose run() method gets called
 372      * @param name the name of the new Thread
 373      * @param stackSize the desired stack size for the new thread, or
 374      *        zero to indicate that this parameter is to be ignored.
 375      * @param acc the AccessControlContext to inherit, or
 376      *            AccessController.getContext() if null
 377      */
 378     private void init(ThreadGroup g, Runnable target, String name,
 379                       long stackSize, AccessControlContext acc) {
 380         if (name == null) {
 381             throw new NullPointerException("name cannot be null");
 382         }
 383 
 384         this.name = name;
 385 
 386         Thread parent = currentThread();
 387         SecurityManager security = System.getSecurityManager();
 388         if (g == null) {
 389             /* Determine if it's an applet or not */
 390 
 391             /* If there is a security manager, ask the security manager
 392                what to do. */
 393             if (security != null) {
 394                 g = security.getThreadGroup();
 395             }
 396 
 397             /* If the security doesn't have a strong opinion of the matter
 398                use the parent thread group. */
 399             if (g == null) {
 400                 g = parent.getThreadGroup();
 401             }
 402         }
 403 
 404         /* checkAccess regardless of whether or not threadgroup is
 405            explicitly passed in. */
 406         g.checkAccess();
 407 
 408         /*
 409          * Do we have the required permissions?
 410          */
 411         if (security != null) {
 412             if (isCCLOverridden(getClass())) {
 413                 security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
 414             }
 415         }
 416 
 417         g.addUnstarted();
 418 
 419         this.group = g;
 420         this.daemon = parent.isDaemon();
 421         this.priority = parent.getPriority();
 422         if (security == null || isCCLOverridden(parent.getClass()))
 423             this.contextClassLoader = parent.getContextClassLoader();
 424         else
 425             this.contextClassLoader = parent.contextClassLoader;
 426         this.inheritedAccessControlContext =
 427                 acc != null ? acc : AccessController.getContext();
 428         this.target = target;
 429         setPriority(priority);
 430         if (parent.inheritableThreadLocals != null)
 431             this.inheritableThreadLocals =
 432                 ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
 433         /* Stash the specified stack size in case the VM cares */
 434         this.stackSize = stackSize;
 435 
 436         /* Set thread ID */
 437         tid = nextThreadID();
 438     }
 439 
 440     /**
 441      * Throws CloneNotSupportedException as a Thread can not be meaningfully
 442      * cloned. Construct a new Thread instead.
 443      *
 444      * @throws  CloneNotSupportedException
 445      *          always
 446      */
 447     @Override
 448     protected Object clone() throws CloneNotSupportedException {
 449         throw new CloneNotSupportedException();
 450     }
 451 
 452     /**
 453      * Allocates a new {@code Thread} object. This constructor has the same
 454      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 455      * {@code (null, null, gname)}, where {@code gname} is a newly generated
 456      * name. Automatically generated names are of the form
 457      * {@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
 458      */
 459     public Thread() {
 460         init(null, null, "Thread-" + nextThreadNum(), 0);
 461     }
 462 
 463     /**
 464      * Allocates a new {@code Thread} object. This constructor has the same
 465      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 466      * {@code (null, target, gname)}, where {@code gname} is a newly generated
 467      * name. Automatically generated names are of the form
 468      * {@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
 469      *
 470      * @param  target
 471      *         the object whose {@code run} method is invoked when this thread
 472      *         is started. If {@code null}, this classes {@code run} method does
 473      *         nothing.
 474      */
 475     public Thread(Runnable target) {
 476         init(null, target, "Thread-" + nextThreadNum(), 0);
 477     }
 478 
 479     /**
 480      * Creates a new Thread that inherits the given AccessControlContext.
 481      * This is not a public constructor.
 482      */
 483     Thread(Runnable target, AccessControlContext acc) {
 484         init(null, target, "Thread-" + nextThreadNum(), 0, acc);
 485     }
 486 
 487     /**
 488      * Allocates a new {@code Thread} object. This constructor has the same
 489      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 490      * {@code (group, target, gname)} ,where {@code gname} is a newly generated
 491      * name. Automatically generated names are of the form
 492      * {@code "Thread-"+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
 493      *
 494      * @param  group
 495      *         the thread group. If {@code null} and there is a security
 496      *         manager, the group is determined by {@linkplain
 497      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 498      *         If there is not a security manager or {@code
 499      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 500      *         is set to the current thread's thread group.
 501      *
 502      * @param  target
 503      *         the object whose {@code run} method is invoked when this thread
 504      *         is started. If {@code null}, this thread's run method is invoked.
 505      *
 506      * @throws  SecurityException
 507      *          if the current thread cannot create a thread in the specified
 508      *          thread group
 509      */
 510     public Thread(ThreadGroup group, Runnable target) {
 511         init(group, target, "Thread-" + nextThreadNum(), 0);
 512     }
 513 
 514     /**
 515      * Allocates a new {@code Thread} object. This constructor has the same
 516      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 517      * {@code (null, null, name)}.
 518      *
 519      * @param   name
 520      *          the name of the new thread
 521      */
 522     public Thread(String name) {
 523         init(null, null, name, 0);
 524     }
 525 
 526     /**
 527      * Allocates a new {@code Thread} object. This constructor has the same
 528      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 529      * {@code (group, null, name)}.
 530      *
 531      * @param  group
 532      *         the thread group. If {@code null} and there is a security
 533      *         manager, the group is determined by {@linkplain
 534      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 535      *         If there is not a security manager or {@code
 536      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 537      *         is set to the current thread's thread group.
 538      *
 539      * @param  name
 540      *         the name of the new thread
 541      *
 542      * @throws  SecurityException
 543      *          if the current thread cannot create a thread in the specified
 544      *          thread group
 545      */
 546     public Thread(ThreadGroup group, String name) {
 547         init(group, null, name, 0);
 548     }
 549 
 550     /**
 551      * Allocates a new {@code Thread} object. This constructor has the same
 552      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 553      * {@code (null, target, name)}.
 554      *
 555      * @param  target
 556      *         the object whose {@code run} method is invoked when this thread
 557      *         is started. If {@code null}, this thread's run method is invoked.
 558      *
 559      * @param  name
 560      *         the name of the new thread
 561      */
 562     public Thread(Runnable target, String name) {
 563         init(null, target, name, 0);
 564     }
 565 
 566     /**
 567      * Allocates a new {@code Thread} object so that it has {@code target}
 568      * as its run object, has the specified {@code name} as its name,
 569      * and belongs to the thread group referred to by {@code group}.
 570      *
 571      * &lt;p&gt;If there is a security manager, its
 572      * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
 573      * method is invoked with the ThreadGroup as its argument.
 574      *
 575      * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
 576      * the {@code RuntimePermission("enableContextClassLoaderOverride")}
 577      * permission when invoked directly or indirectly by the constructor
 578      * of a subclass which overrides the {@code getContextClassLoader}
 579      * or {@code setContextClassLoader} methods.
 580      *
 581      * &lt;p&gt;The priority of the newly created thread is set equal to the
 582      * priority of the thread creating it, that is, the currently running
 583      * thread. The method {@linkplain #setPriority setPriority} may be
 584      * used to change the priority to a new value.
 585      *
 586      * &lt;p&gt;The newly created thread is initially marked as being a daemon
 587      * thread if and only if the thread creating it is currently marked
 588      * as a daemon thread. The method {@linkplain #setDaemon setDaemon}
 589      * may be used to change whether or not a thread is a daemon.
 590      *
 591      * @param  group
 592      *         the thread group. If {@code null} and there is a security
 593      *         manager, the group is determined by {@linkplain
 594      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 595      *         If there is not a security manager or {@code
 596      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 597      *         is set to the current thread's thread group.
 598      *
 599      * @param  target
 600      *         the object whose {@code run} method is invoked when this thread
 601      *         is started. If {@code null}, this thread's run method is invoked.
 602      *
 603      * @param  name
 604      *         the name of the new thread
 605      *
 606      * @throws  SecurityException
 607      *          if the current thread cannot create a thread in the specified
 608      *          thread group or cannot override the context class loader methods.
 609      */
 610     public Thread(ThreadGroup group, Runnable target, String name) {
 611         init(group, target, name, 0);
 612     }
 613 
 614     /**
 615      * Allocates a new {@code Thread} object so that it has {@code target}
 616      * as its run object, has the specified {@code name} as its name,
 617      * and belongs to the thread group referred to by {@code group}, and has
 618      * the specified &lt;i&gt;stack size&lt;/i&gt;.
 619      *
 620      * &lt;p&gt;This constructor is identical to {@link
 621      * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
 622      * that it allows the thread stack size to be specified.  The stack size
 623      * is the approximate number of bytes of address space that the virtual
 624      * machine is to allocate for this thread's stack.  &lt;b&gt;The effect of the
 625      * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
 626      *
 627      * &lt;p&gt;On some platforms, specifying a higher value for the
 628      * {@code stackSize} parameter may allow a thread to achieve greater
 629      * recursion depth before throwing a {@link StackOverflowError}.
 630      * Similarly, specifying a lower value may allow a greater number of
 631      * threads to exist concurrently without throwing an {@link
 632      * OutOfMemoryError} (or other internal error).  The details of
 633      * the relationship between the value of the {@code stackSize} parameter
 634      * and the maximum recursion depth and concurrency level are
 635      * platform-dependent.  &lt;b&gt;On some platforms, the value of the
 636      * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
 637      *
 638      * &lt;p&gt;The virtual machine is free to treat the {@code stackSize}
 639      * parameter as a suggestion.  If the specified value is unreasonably low
 640      * for the platform, the virtual machine may instead use some
 641      * platform-specific minimum value; if the specified value is unreasonably
 642      * high, the virtual machine may instead use some platform-specific
 643      * maximum.  Likewise, the virtual machine is free to round the specified
 644      * value up or down as it sees fit (or to ignore it completely).
 645      *
 646      * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
 647      * cause this constructor to behave exactly like the
 648      * {@code Thread(ThreadGroup, Runnable, String)} constructor.
 649      *
 650      * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
 651      * constructor, extreme care should be exercised in its use.
 652      * The thread stack size necessary to perform a given computation will
 653      * likely vary from one JRE implementation to another.  In light of this
 654      * variation, careful tuning of the stack size parameter may be required,
 655      * and the tuning may need to be repeated for each JRE implementation on
 656      * which an application is to run.&lt;/i&gt;
 657      *
 658      * &lt;p&gt;Implementation note: Java platform implementers are encouraged to
 659      * document their implementation's behavior with respect to the
 660      * {@code stackSize} parameter.
 661      *
 662      *
 663      * @param  group
 664      *         the thread group. If {@code null} and there is a security
 665      *         manager, the group is determined by {@linkplain
 666      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 667      *         If there is not a security manager or {@code
 668      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 669      *         is set to the current thread's thread group.
 670      *
 671      * @param  target
 672      *         the object whose {@code run} method is invoked when this thread
 673      *         is started. If {@code null}, this thread's run method is invoked.
 674      *
 675      * @param  name
 676      *         the name of the new thread
 677      *
 678      * @param  stackSize
 679      *         the desired stack size for the new thread, or zero to indicate
 680      *         that this parameter is to be ignored.
 681      *
 682      * @throws  SecurityException
 683      *          if the current thread cannot create a thread in the specified
 684      *          thread group
 685      *
 686      * @since 1.4
 687      */
 688     public Thread(ThreadGroup group, Runnable target, String name,
 689                   long stackSize) {
 690         init(group, target, name, stackSize);
 691     }
 692 
 693     /**
 694      * Causes this thread to begin execution; the Java Virtual Machine
 695      * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.
 696      * &lt;p&gt;
 697      * The result is that two threads are running concurrently: the
 698      * current thread (which returns from the call to the
 699      * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its
 700      * &lt;code&gt;run&lt;/code&gt; method).
 701      * &lt;p&gt;
 702      * It is never legal to start a thread more than once.
 703      * In particular, a thread may not be restarted once it has completed
 704      * execution.
 705      *
 706      * @exception  IllegalThreadStateException  if the thread was already
 707      *               started.
 708      * @see        #run()
 709      * @see        #stop()
 710      */
 711     public synchronized void start() {
 712         /**
 713          * This method is not invoked for the main method thread or "system"
 714          * group threads created/set up by the VM. Any new functionality added
 715          * to this method in the future may have to also be added to the VM.
 716          *
 717          * A zero status value corresponds to state "NEW".
 718          */
 719         if (threadStatus != 0)
 720             throw new IllegalThreadStateException();
 721 
 722         /* Notify the group that this thread is about to be started
 723          * so that it can be added to the group's list of threads
 724          * and the group's unstarted count can be decremented. */
 725         group.add(this);
 726 
 727         boolean started = false;
 728         try {
 729             start0();
 730             started = true;
 731         } finally {
 732             try {
 733                 if (!started) {
 734                     group.threadStartFailed(this);
 735                 }
 736             } catch (Throwable ignore) {
 737                 /* do nothing. If start0 threw a Throwable then
 738                   it will be passed up the call stack */
 739             }
 740         }
 741     }
 742 
 743     private native void start0();
 744 
 745     /**
 746      * If this thread was constructed using a separate
 747      * &lt;code&gt;Runnable&lt;/code&gt; run object, then that
 748      * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called;
 749      * otherwise, this method does nothing and returns.
 750      * &lt;p&gt;
 751      * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.
 752      *
 753      * @see     #start()
 754      * @see     #stop()
 755      * @see     #Thread(ThreadGroup, Runnable, String)
 756      */
 757     @Override
 758     public void run() {
 759         if (target != null) {
 760             target.run();
 761         }
 762     }
 763 
 764     /**
 765      * This method is called by the system to give a Thread
 766      * a chance to clean up before it actually exits.
 767      */
 768     private void exit() {
 769         if (group != null) {
 770             group.threadTerminated(this);
 771             group = null;
 772         }
 773         /* Aggressively null out all reference fields: see bug 4006245 */
 774         target = null;
 775         /* Speed the release of some of these resources */
 776         threadLocals = null;
 777         inheritableThreadLocals = null;
 778         inheritedAccessControlContext = null;
 779         blocker = null;
 780         uncaughtExceptionHandler = null;
 781     }
 782 
 783     /**
 784      * Forces the thread to stop executing.
 785      * &lt;p&gt;
 786      * If there is a security manager installed, its &lt;code&gt;checkAccess&lt;/code&gt;
 787      * method is called with &lt;code&gt;this&lt;/code&gt;
 788      * as its argument. This may result in a
 789      * &lt;code&gt;SecurityException&lt;/code&gt; being raised (in the current thread).
 790      * &lt;p&gt;
 791      * If this thread is different from the current thread (that is, the current
 792      * thread is trying to stop a thread other than itself), the
 793      * security manager's &lt;code&gt;checkPermission&lt;/code&gt; method (with a
 794      * &lt;code&gt;RuntimePermission("stopThread")&lt;/code&gt; argument) is called in
 795      * addition.
 796      * Again, this may result in throwing a
 797      * &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).
 798      * &lt;p&gt;
 799      * The thread represented by this thread is forced to stop whatever
 800      * it is doing abnormally and to throw a newly created
 801      * &lt;code&gt;ThreadDeath&lt;/code&gt; object as an exception.
 802      * &lt;p&gt;
 803      * It is permitted to stop a thread that has not yet been started.
 804      * If the thread is eventually started, it immediately terminates.
 805      * &lt;p&gt;
 806      * An application should not normally try to catch
 807      * &lt;code&gt;ThreadDeath&lt;/code&gt; unless it must do some extraordinary
 808      * cleanup operation (note that the throwing of
 809      * &lt;code&gt;ThreadDeath&lt;/code&gt; causes &lt;code&gt;finally&lt;/code&gt; clauses of
 810      * &lt;code&gt;try&lt;/code&gt; statements to be executed before the thread
 811      * officially dies).  If a &lt;code&gt;catch&lt;/code&gt; clause catches a
 812      * &lt;code&gt;ThreadDeath&lt;/code&gt; object, it is important to rethrow the
 813      * object so that the thread actually dies.
 814      * &lt;p&gt;
 815      * The top-level error handler that reacts to otherwise uncaught
 816      * exceptions does not print out a message or otherwise notify the
 817      * application if the uncaught exception is an instance of
 818      * &lt;code&gt;ThreadDeath&lt;/code&gt;.
 819      *
 820      * @exception  SecurityException  if the current thread cannot
 821      *               modify this thread.
 822      * @see        #interrupt()
 823      * @see        #checkAccess()
 824      * @see        #run()
 825      * @see        #start()
 826      * @see        ThreadDeath
 827      * @see        ThreadGroup#uncaughtException(Thread,Throwable)
 828      * @see        SecurityManager#checkAccess(Thread)
 829      * @see        SecurityManager#checkPermission
 830      * @deprecated This method is inherently unsafe.  Stopping a thread with
 831      *       Thread.stop causes it to unlock all of the monitors that it
 832      *       has locked (as a natural consequence of the unchecked
 833      *       &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack).  If
 834      *       any of the objects previously protected by these monitors were in
 835      *       an inconsistent state, the damaged objects become visible to
 836      *       other threads, potentially resulting in arbitrary behavior.  Many
 837      *       uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply
 838      *       modifies some variable to indicate that the target thread should
 839      *       stop running.  The target thread should check this variable
 840      *       regularly, and return from its run method in an orderly fashion
 841      *       if the variable indicates that it is to stop running.  If the
 842      *       target thread waits for long periods (on a condition variable,
 843      *       for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to
 844      *       interrupt the wait.
 845      *       For more information, see
 846      *       &lt;a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html"&gt;Why
 847      *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
 848      */
 849     @Deprecated
 850     public final void stop() {
 851         SecurityManager security = System.getSecurityManager();
 852         if (security != null) {
 853             checkAccess();
 854             if (this != Thread.currentThread()) {
 855                 security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
 856             }
 857         }
 858         // A zero status value corresponds to "NEW", it can't change to
 859         // not-NEW because we hold the lock.
 860         if (threadStatus != 0) {
 861             resume(); // Wake up thread if it was suspended; no-op otherwise
 862         }
 863 
 864         // The VM can handle all thread states
 865         stop0(new ThreadDeath());
 866     }
 867 
 868     /**
 869      * Throws {@code UnsupportedOperationException}.
 870      *
 871      * @param obj ignored
 872      *
 873      * @deprecated This method was originally designed to force a thread to stop
 874      *        and throw a given {@code Throwable} as an exception. It was
 875      *        inherently unsafe (see {@link #stop()} for details), and furthermore
 876      *        could be used to generate exceptions that the target thread was
 877      *        not prepared to handle.
 878      *        For more information, see
 879      *        &lt;a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html"&gt;Why
 880      *        are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
 881      */
 882     @Deprecated
 883     public final synchronized void stop(Throwable obj) {
 884         throw new UnsupportedOperationException();
 885     }
 886 
 887     /**
 888      * Interrupts this thread.
 889      *
 890      * &lt;p&gt; Unless the current thread is interrupting itself, which is
 891      * always permitted, the {@link #checkAccess() checkAccess} method
 892      * of this thread is invoked, which may cause a {@link
 893      * SecurityException} to be thrown.
 894      *
 895      * &lt;p&gt; If this thread is blocked in an invocation of the {@link
 896      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
 897      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
 898      * class, or of the {@link #join()}, {@link #join(long)}, {@link
 899      * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
 900      * methods of this class, then its interrupt status will be cleared and it
 901      * will receive an {@link InterruptedException}.
 902      *
 903      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
 904      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
 905      * then the channel will be closed, the thread's interrupt
 906      * status will be set, and the thread will receive a {@link
 907      * java.nio.channels.ClosedByInterruptException}.
 908      *
 909      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
 910      * then the thread's interrupt status will be set and it will return
 911      * immediately from the selection operation, possibly with a non-zero
 912      * value, just as if the selector's {@link
 913      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
 914      *
 915      * &lt;p&gt; If none of the previous conditions hold then this thread's interrupt
 916      * status will be set. &lt;/p&gt;
 917      *
 918      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
 919      *
 920      * @throws  SecurityException
 921      *          if the current thread cannot modify this thread
 922      *
 923      * @revised 6.0
 924      * @spec JSR-51
 925      */
 926     public void interrupt() {
 927         if (this != Thread.currentThread())
 928             checkAccess();
 929 
 930         synchronized (blockerLock) {
 931             Interruptible b = blocker;
 932             if (b != null) {
 933                 interrupt0();           // Just to set the interrupt flag
 934                 b.interrupt(this);
 935                 return;
 936             }
 937         }
 938         interrupt0();
 939     }
 940 
 941     /**
 942      * Tests whether the current thread has been interrupted.  The
 943      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
 944      * other words, if this method were to be called twice in succession, the
 945      * second call would return false (unless the current thread were
 946      * interrupted again, after the first call had cleared its interrupted
 947      * status and before the second call had examined it).
 948      *
 949      * &lt;p&gt;A thread interruption ignored because a thread was not alive
 950      * at the time of the interrupt will be reflected by this method
 951      * returning false.
 952      *
 953      * @return  &lt;code&gt;true&lt;/code&gt; if the current thread has been interrupted;
 954      *          &lt;code&gt;false&lt;/code&gt; otherwise.
 955      * @see #isInterrupted()
 956      * @revised 6.0
 957      */
 958     public static boolean interrupted() {
 959         return currentThread().isInterrupted(true);
 960     }
 961 
 962     /**
 963      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
 964      * status&lt;/i&gt; of the thread is unaffected by this method.
 965      *
 966      * &lt;p&gt;A thread interruption ignored because a thread was not alive
 967      * at the time of the interrupt will be reflected by this method
 968      * returning false.
 969      *
 970      * @return  &lt;code&gt;true&lt;/code&gt; if this thread has been interrupted;
 971      *          &lt;code&gt;false&lt;/code&gt; otherwise.
 972      * @see     #interrupted()
 973      * @revised 6.0
 974      */
 975     public boolean isInterrupted() {
 976         return isInterrupted(false);
 977     }
 978 
 979     /**
 980      * Tests if some Thread has been interrupted.  The interrupted state
 981      * is reset or not based on the value of ClearInterrupted that is
 982      * passed.
 983      */
 984     @HotSpotIntrinsicCandidate
 985     private native boolean isInterrupted(boolean ClearInterrupted);
 986 
 987     /**
 988      * Throws {@link NoSuchMethodError}.
 989      *
 990      * @deprecated This method was originally designed to destroy this
 991      *     thread without any cleanup. Any monitors it held would have
 992      *     remained locked. However, the method was never implemented.
 993      *     If it were to be implemented, it would be deadlock-prone in
 994      *     much the manner of {@link #suspend}. If the target thread held
 995      *     a lock protecting a critical system resource when it was
 996      *     destroyed, no thread could ever access this resource again.
 997      *     If another thread ever attempted to lock this resource, deadlock
 998      *     would result. Such deadlocks typically manifest themselves as
 999      *     "frozen" processes. For more information, see
1000      *     &lt;a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html"&gt;
1001      *     Why are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1002      * @throws NoSuchMethodError always
1003      */
1004     @Deprecated
1005     public void destroy() {
1006         throw new NoSuchMethodError();
1007     }
1008 
1009     /**
1010      * Tests if this thread is alive. A thread is alive if it has
1011      * been started and has not yet died.
1012      *
1013      * @return  &lt;code&gt;true&lt;/code&gt; if this thread is alive;
1014      *          &lt;code&gt;false&lt;/code&gt; otherwise.
1015      */
1016     public final native boolean isAlive();
1017 
1018     /**
1019      * Suspends this thread.
1020      * &lt;p&gt;
1021      * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
1022      * with no arguments. This may result in throwing a
1023      * &lt;code&gt;SecurityException &lt;/code&gt;(in the current thread).
1024      * &lt;p&gt;
1025      * If the thread is alive, it is suspended and makes no further
1026      * progress unless and until it is resumed.
1027      *
1028      * @exception  SecurityException  if the current thread cannot modify
1029      *               this thread.
1030      * @see #checkAccess
1031      * @deprecated   This method has been deprecated, as it is
1032      *   inherently deadlock-prone.  If the target thread holds a lock on the
1033      *   monitor protecting a critical system resource when it is suspended, no
1034      *   thread can access this resource until the target thread is resumed. If
1035      *   the thread that would resume the target thread attempts to lock this
1036      *   monitor prior to calling &lt;code&gt;resume&lt;/code&gt;, deadlock results.  Such
1037      *   deadlocks typically manifest themselves as "frozen" processes.
1038      *   For more information, see
1039      *   &lt;a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html"&gt;Why
1040      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1041      */
1042     @Deprecated
1043     public final void suspend() {
1044         checkAccess();
1045         suspend0();
1046     }
1047 
1048     /**
1049      * Resumes a suspended thread.
1050      * &lt;p&gt;
1051      * First, the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
1052      * with no arguments. This may result in throwing a
1053      * &lt;code&gt;SecurityException&lt;/code&gt; (in the current thread).
1054      * &lt;p&gt;
1055      * If the thread is alive but suspended, it is resumed and is
1056      * permitted to make progress in its execution.
1057      *
1058      * @exception  SecurityException  if the current thread cannot modify this
1059      *               thread.
1060      * @see        #checkAccess
1061      * @see        #suspend()
1062      * @deprecated This method exists solely for use with {@link #suspend},
1063      *     which has been deprecated because it is deadlock-prone.
1064      *     For more information, see
1065      *     &lt;a href="{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html"&gt;Why
1066      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1067      */
1068     @Deprecated
1069     public final void resume() {
1070         checkAccess();
1071         resume0();
1072     }
1073 
1074     /**
1075      * Changes the priority of this thread.
1076      * &lt;p&gt;
1077      * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
1078      * with no arguments. This may result in throwing a
1079      * &lt;code&gt;SecurityException&lt;/code&gt;.
1080      * &lt;p&gt;
1081      * Otherwise, the priority of this thread is set to the smaller of
1082      * the specified &lt;code&gt;newPriority&lt;/code&gt; and the maximum permitted
1083      * priority of the thread's thread group.
1084      *
1085      * @param newPriority priority to set this thread to
1086      * @exception  IllegalArgumentException  If the priority is not in the
1087      *               range &lt;code&gt;MIN_PRIORITY&lt;/code&gt; to
1088      *               &lt;code&gt;MAX_PRIORITY&lt;/code&gt;.
1089      * @exception  SecurityException  if the current thread cannot modify
1090      *               this thread.
1091      * @see        #getPriority
1092      * @see        #checkAccess()
1093      * @see        #getThreadGroup()
1094      * @see        #MAX_PRIORITY
1095      * @see        #MIN_PRIORITY
1096      * @see        ThreadGroup#getMaxPriority()
1097      */
1098     public final void setPriority(int newPriority) {
1099         ThreadGroup g;
1100         checkAccess();
1101         if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
1102             throw new IllegalArgumentException();
1103         }
1104         if((g = getThreadGroup()) != null) {
1105             if (newPriority &gt; g.getMaxPriority()) {
1106                 newPriority = g.getMaxPriority();
1107             }
1108             setPriority0(priority = newPriority);
1109         }
1110     }
1111 
1112     /**
1113      * Returns this thread's priority.
1114      *
1115      * @return  this thread's priority.
1116      * @see     #setPriority
1117      */
1118     public final int getPriority() {
1119         return priority;
1120     }
1121 
1122     /**
1123      * Changes the name of this thread to be equal to the argument
1124      * &lt;code&gt;name&lt;/code&gt;.
1125      * &lt;p&gt;
1126      * First the &lt;code&gt;checkAccess&lt;/code&gt; method of this thread is called
1127      * with no arguments. This may result in throwing a
1128      * &lt;code&gt;SecurityException&lt;/code&gt;.
1129      *
1130      * @param      name   the new name for this thread.
1131      * @exception  SecurityException  if the current thread cannot modify this
1132      *               thread.
1133      * @see        #getName
1134      * @see        #checkAccess()
1135      */
1136     public final synchronized void setName(String name) {
1137         checkAccess();
1138         if (name == null) {
1139             throw new NullPointerException("name cannot be null");
1140         }
1141 
1142         this.name = name;
1143         if (threadStatus != 0) {
1144             setNativeName(name);
1145         }
1146     }
1147 
1148     /**
1149      * Returns this thread's name.
1150      *
1151      * @return  this thread's name.
1152      * @see     #setName(String)
1153      */
1154     public final String getName() {
1155         return name;
1156     }
1157 
1158     /**
1159      * Returns the thread group to which this thread belongs.
1160      * This method returns null if this thread has died
1161      * (been stopped).
1162      *
1163      * @return  this thread's thread group.
1164      */
1165     public final ThreadGroup getThreadGroup() {
1166         return group;
1167     }
1168 
1169     /**
1170      * Returns an estimate of the number of active threads in the current
1171      * thread's {@linkplain java.lang.ThreadGroup thread group} and its
1172      * subgroups. Recursively iterates over all subgroups in the current
1173      * thread's thread group.
1174      *
1175      * &lt;p&gt; The value returned is only an estimate because the number of
1176      * threads may change dynamically while this method traverses internal
1177      * data structures, and might be affected by the presence of certain
1178      * system threads. This method is intended primarily for debugging
1179      * and monitoring purposes.
1180      *
1181      * @return  an estimate of the number of active threads in the current
1182      *          thread's thread group and in any other thread group that
1183      *          has the current thread's thread group as an ancestor
1184      */
1185     public static int activeCount() {
1186         return currentThread().getThreadGroup().activeCount();
1187     }
1188 
1189     /**
1190      * Copies into the specified array every active thread in the current
1191      * thread's thread group and its subgroups. This method simply
1192      * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
1193      * method of the current thread's thread group.
1194      *
1195      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
1196      * method to get an estimate of how big the array should be, however
1197      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
1198      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
1199      * thread in the current thread's thread group and its subgroups, the
1200      * invoker should verify that the returned int value is strictly less
1201      * than the length of {@code tarray}.
1202      *
1203      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
1204      * that the method only be used for debugging and monitoring purposes.
1205      *
1206      * @param  tarray
1207      *         an array into which to put the list of threads
1208      *
1209      * @return  the number of threads put into the array
1210      *
1211      * @throws  SecurityException
1212      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
1213      *          the current thread cannot access its thread group
1214      */
1215     public static int enumerate(Thread tarray[]) {
1216         return currentThread().getThreadGroup().enumerate(tarray);
1217     }
1218 
1219     /**
1220      * Counts the number of stack frames in this thread. The thread must
1221      * be suspended.
1222      *
1223      * @return     the number of stack frames in this thread.
1224      * @exception  IllegalThreadStateException  if this thread is not
1225      *             suspended.
1226      * @deprecated The definition of this call depends on {@link #suspend},
1227      *             which is deprecated.  Further, the results of this call
1228      *             were never well-defined.
1229      */
1230     @Deprecated
1231     public native int countStackFrames();
1232 
1233     /**
1234      * Waits at most {@code millis} milliseconds for this thread to
1235      * die. A timeout of {@code 0} means to wait forever.
1236      *
1237      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
1238      * conditioned on {@code this.isAlive}. As a thread terminates the
1239      * {@code this.notifyAll} method is invoked. It is recommended that
1240      * applications not use {@code wait}, {@code notify}, or
1241      * {@code notifyAll} on {@code Thread} instances.
1242      *
1243      * @param  millis
1244      *         the time to wait in milliseconds
1245      *
1246      * @throws  IllegalArgumentException
1247      *          if the value of {@code millis} is negative
1248      *
1249      * @throws  InterruptedException
1250      *          if any thread has interrupted the current thread. The
1251      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
1252      *          cleared when this exception is thrown.
1253      */
1254     public final synchronized void join(long millis)
1255     throws InterruptedException {
1256         long base = System.currentTimeMillis();
1257         long now = 0;
1258 
1259         if (millis &lt; 0) {
1260             throw new IllegalArgumentException("timeout value is negative");
1261         }
1262 
1263         if (millis == 0) {
1264             while (isAlive()) {
1265                 wait(0);
1266             }
1267         } else {
1268             while (isAlive()) {
1269                 long delay = millis - now;
1270                 if (delay &lt;= 0) {
1271                     break;
1272                 }
1273                 wait(delay);
1274                 now = System.currentTimeMillis() - base;
1275             }
1276         }
1277     }
1278 
1279     /**
1280      * Waits at most {@code millis} milliseconds plus
1281      * {@code nanos} nanoseconds for this thread to die.
1282      *
1283      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
1284      * conditioned on {@code this.isAlive}. As a thread terminates the
1285      * {@code this.notifyAll} method is invoked. It is recommended that
1286      * applications not use {@code wait}, {@code notify}, or
1287      * {@code notifyAll} on {@code Thread} instances.
1288      *
1289      * @param  millis
1290      *         the time to wait in milliseconds
1291      *
1292      * @param  nanos
1293      *         {@code 0-999999} additional nanoseconds to wait
1294      *
1295      * @throws  IllegalArgumentException
1296      *          if the value of {@code millis} is negative, or the value
1297      *          of {@code nanos} is not in the range {@code 0-999999}
1298      *
1299      * @throws  InterruptedException
1300      *          if any thread has interrupted the current thread. The
1301      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
1302      *          cleared when this exception is thrown.
1303      */
1304     public final synchronized void join(long millis, int nanos)
1305     throws InterruptedException {
1306 
1307         if (millis &lt; 0) {
1308             throw new IllegalArgumentException("timeout value is negative");
1309         }
1310 
1311         if (nanos &lt; 0 || nanos &gt; 999999) {
1312             throw new IllegalArgumentException(
1313                                 "nanosecond timeout value out of range");
1314         }
1315 
1316         if (nanos &gt;= 500000 || (nanos != 0 &amp;&amp; millis == 0)) {
1317             millis++;
1318         }
1319 
1320         join(millis);
1321     }
1322 
1323     /**
1324      * Waits for this thread to die.
1325      *
1326      * &lt;p&gt; An invocation of this method behaves in exactly the same
1327      * way as the invocation
1328      *
1329      * &lt;blockquote&gt;
1330      * {@linkplain #join(long) join}{@code (0)}
1331      * &lt;/blockquote&gt;
1332      *
1333      * @throws  InterruptedException
1334      *          if any thread has interrupted the current thread. The
1335      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
1336      *          cleared when this exception is thrown.
1337      */
1338     public final void join() throws InterruptedException {
1339         join(0);
1340     }
1341 
1342     /**
1343      * Prints a stack trace of the current thread to the standard error stream.
1344      * This method is used only for debugging.
1345      *
1346      * @see     Throwable#printStackTrace()
1347      */
1348     public static void dumpStack() {
1349         new Exception("Stack trace").printStackTrace();
1350     }
1351 
1352     /**
1353      * Marks this thread as either a {@linkplain #isDaemon daemon} thread
1354      * or a user thread. The Java Virtual Machine exits when the only
1355      * threads running are all daemon threads.
1356      *
1357      * &lt;p&gt; This method must be invoked before the thread is started.
1358      *
1359      * @param  on
1360      *         if {@code true}, marks this thread as a daemon thread
1361      *
1362      * @throws  IllegalThreadStateException
1363      *          if this thread is {@linkplain #isAlive alive}
1364      *
1365      * @throws  SecurityException
1366      *          if {@link #checkAccess} determines that the current
1367      *          thread cannot modify this thread
1368      */
1369     public final void setDaemon(boolean on) {
1370         checkAccess();
1371         if (isAlive()) {
1372             throw new IllegalThreadStateException();
1373         }
1374         daemon = on;
1375     }
1376 
1377     /**
1378      * Tests if this thread is a daemon thread.
1379      *
1380      * @return  &lt;code&gt;true&lt;/code&gt; if this thread is a daemon thread;
1381      *          &lt;code&gt;false&lt;/code&gt; otherwise.
1382      * @see     #setDaemon(boolean)
1383      */
1384     public final boolean isDaemon() {
1385         return daemon;
1386     }
1387 
1388     /**
1389      * Determines if the currently running thread has permission to
1390      * modify this thread.
1391      * &lt;p&gt;
1392      * If there is a security manager, its &lt;code&gt;checkAccess&lt;/code&gt; method
1393      * is called with this thread as its argument. This may result in
1394      * throwing a &lt;code&gt;SecurityException&lt;/code&gt;.
1395      *
1396      * @exception  SecurityException  if the current thread is not allowed to
1397      *               access this thread.
1398      * @see        SecurityManager#checkAccess(Thread)
1399      */
1400     public final void checkAccess() {
1401         SecurityManager security = System.getSecurityManager();
1402         if (security != null) {
1403             security.checkAccess(this);
1404         }
1405     }
1406 
1407     /**
1408      * Returns a string representation of this thread, including the
1409      * thread's name, priority, and thread group.
1410      *
1411      * @return  a string representation of this thread.
1412      */
1413     public String toString() {
1414         ThreadGroup group = getThreadGroup();
1415         if (group != null) {
1416             return "Thread[" + getName() + "," + getPriority() + "," +
1417                            group.getName() + "]";
1418         } else {
1419             return "Thread[" + getName() + "," + getPriority() + "," +
1420                             "" + "]";
1421         }
1422     }
1423 
1424     /**
1425      * Returns the context ClassLoader for this Thread. The context
1426      * ClassLoader is provided by the creator of the thread for use
1427      * by code running in this thread when loading classes and resources.
1428      * If not {@linkplain #setContextClassLoader set}, the default is the
1429      * ClassLoader context of the parent Thread. The context ClassLoader of the
1430      * primordial thread is typically set to the class loader used to load the
1431      * application.
1432      *
1433      * &lt;p&gt;If a security manager is present, and the invoker's class loader is not
1434      * {@code null} and is not the same as or an ancestor of the context class
1435      * loader, then this method invokes the security manager's {@link
1436      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
1437      * method with a {@link RuntimePermission RuntimePermission}{@code
1438      * ("getClassLoader")} permission to verify that retrieval of the context
1439      * class loader is permitted.
1440      *
1441      * @return  the context ClassLoader for this Thread, or {@code null}
1442      *          indicating the system class loader (or, failing that, the
1443      *          bootstrap class loader)
1444      *
1445      * @throws  SecurityException
1446      *          if the current thread cannot get the context ClassLoader
1447      *
1448      * @since 1.2
1449      */
1450     @CallerSensitive
1451     public ClassLoader getContextClassLoader() {
1452         if (contextClassLoader == null)
1453             return null;
1454         SecurityManager sm = System.getSecurityManager();
1455         if (sm != null) {
1456             ClassLoader.checkClassLoaderPermission(contextClassLoader,
1457                                                    Reflection.getCallerClass());
1458         }
1459         return contextClassLoader;
1460     }
1461 
1462     /**
1463      * Sets the context ClassLoader for this Thread. The context
1464      * ClassLoader can be set when a thread is created, and allows
1465      * the creator of the thread to provide the appropriate class loader,
1466      * through {@code getContextClassLoader}, to code running in the thread
1467      * when loading classes and resources.
1468      *
1469      * &lt;p&gt;If a security manager is present, its {@link
1470      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
1471      * method is invoked with a {@link RuntimePermission RuntimePermission}{@code
1472      * ("setContextClassLoader")} permission to see if setting the context
1473      * ClassLoader is permitted.
1474      *
1475      * @param  cl
1476      *         the context ClassLoader for this Thread, or null  indicating the
1477      *         system class loader (or, failing that, the bootstrap class loader)
1478      *
1479      * @throws  SecurityException
1480      *          if the current thread cannot set the context ClassLoader
1481      *
1482      * @since 1.2
1483      */
1484     public void setContextClassLoader(ClassLoader cl) {
1485         SecurityManager sm = System.getSecurityManager();
1486         if (sm != null) {
1487             sm.checkPermission(new RuntimePermission("setContextClassLoader"));
1488         }
1489         contextClassLoader = cl;
1490     }
1491 
1492     /**
1493      * Returns {@code true} if and only if the current thread holds the
1494      * monitor lock on the specified object.
1495      *
1496      * &lt;p&gt;This method is designed to allow a program to assert that
1497      * the current thread already holds a specified lock:
1498      * &lt;pre&gt;
1499      *     assert Thread.holdsLock(obj);
1500      * &lt;/pre&gt;
1501      *
1502      * @param  obj the object on which to test lock ownership
1503      * @throws NullPointerException if obj is {@code null}
1504      * @return {@code true} if the current thread holds the monitor lock on
1505      *         the specified object.
1506      * @since 1.4
1507      */
1508     public static native boolean holdsLock(Object obj);
1509 
1510     private static final StackTraceElement[] EMPTY_STACK_TRACE
1511         = new StackTraceElement[0];
1512 
1513     /**
1514      * Returns an array of stack trace elements representing the stack dump
1515      * of this thread.  This method will return a zero-length array if
1516      * this thread has not started, has started but has not yet been
1517      * scheduled to run by the system, or has terminated.
1518      * If the returned array is of non-zero length then the first element of
1519      * the array represents the top of the stack, which is the most recent
1520      * method invocation in the sequence.  The last element of the array
1521      * represents the bottom of the stack, which is the least recent method
1522      * invocation in the sequence.
1523      *
1524      * &lt;p&gt;If there is a security manager, and this thread is not
1525      * the current thread, then the security manager's
1526      * {@code checkPermission} method is called with a
1527      * {@code RuntimePermission("getStackTrace")} permission
1528      * to see if it's ok to get the stack trace.
1529      *
1530      * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
1531      * or more stack frames from the stack trace.  In the extreme case,
1532      * a virtual machine that has no stack trace information concerning
1533      * this thread is permitted to return a zero-length array from this
1534      * method.
1535      *
1536      * @return an array of {@code StackTraceElement},
1537      * each represents one stack frame.
1538      *
1539      * @throws SecurityException
1540      *        if a security manager exists and its
1541      *        {@code checkPermission} method doesn't allow
1542      *        getting the stack trace of thread.
1543      * @see SecurityManager#checkPermission
1544      * @see RuntimePermission
1545      * @see Throwable#getStackTrace
1546      *
1547      * @since 1.5
1548      */
1549     public StackTraceElement[] getStackTrace() {
1550         if (this != Thread.currentThread()) {
1551             // check for getStackTrace permission
1552             SecurityManager security = System.getSecurityManager();
1553             if (security != null) {
1554                 security.checkPermission(
1555                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
1556             }
1557             // optimization so we do not call into the vm for threads that
1558             // have not yet started or have terminated
1559             if (!isAlive()) {
1560                 return EMPTY_STACK_TRACE;
1561             }
1562             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
1563             StackTraceElement[] stackTrace = stackTraceArray[0];
1564             // a thread that was alive during the previous isAlive call may have
1565             // since terminated, therefore not having a stacktrace.
1566             if (stackTrace == null) {
1567                 stackTrace = EMPTY_STACK_TRACE;
1568             }
1569             return stackTrace;
1570         } else {
1571             // Don't need JVM help for current thread
1572             return (new Exception()).getStackTrace();
1573         }
1574     }
1575 
1576     /**
1577      * Returns a map of stack traces for all live threads.
1578      * The map keys are threads and each map value is an array of
1579      * {@code StackTraceElement} that represents the stack dump
1580      * of the corresponding {@code Thread}.
1581      * The returned stack traces are in the format specified for
1582      * the {@link #getStackTrace getStackTrace} method.
1583      *
1584      * &lt;p&gt;The threads may be executing while this method is called.
1585      * The stack trace of each thread only represents a snapshot and
1586      * each stack trace may be obtained at different time.  A zero-length
1587      * array will be returned in the map value if the virtual machine has
1588      * no stack trace information about a thread.
1589      *
1590      * &lt;p&gt;If there is a security manager, then the security manager's
1591      * {@code checkPermission} method is called with a
1592      * {@code RuntimePermission("getStackTrace")} permission as well as
1593      * {@code RuntimePermission("modifyThreadGroup")} permission
1594      * to see if it is ok to get the stack trace of all threads.
1595      *
1596      * @return a {@code Map} from {@code Thread} to an array of
1597      * {@code StackTraceElement} that represents the stack trace of
1598      * the corresponding thread.
1599      *
1600      * @throws SecurityException
1601      *        if a security manager exists and its
1602      *        {@code checkPermission} method doesn't allow
1603      *        getting the stack trace of thread.
1604      * @see #getStackTrace
1605      * @see SecurityManager#checkPermission
1606      * @see RuntimePermission
1607      * @see Throwable#getStackTrace
1608      *
1609      * @since 1.5
1610      */
1611     public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() {
1612         // check for getStackTrace permission
1613         SecurityManager security = System.getSecurityManager();
1614         if (security != null) {
1615             security.checkPermission(
1616                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
1617             security.checkPermission(
1618                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
1619         }
1620 
1621         // Get a snapshot of the list of all threads
1622         Thread[] threads = getThreads();
1623         StackTraceElement[][] traces = dumpThreads(threads);
1624         Map&lt;Thread, StackTraceElement[]&gt; m = new HashMap&lt;&gt;(threads.length);
1625         for (int i = 0; i &lt; threads.length; i++) {
1626             StackTraceElement[] stackTrace = traces[i];
1627             if (stackTrace != null) {
1628                 m.put(threads[i], stackTrace);
1629             }
1630             // else terminated so we don't put it in the map
1631         }
1632         return m;
1633     }
1634 
1635 
1636     private static final RuntimePermission SUBCLASS_IMPLEMENTATION_PERMISSION =
1637                     new RuntimePermission("enableContextClassLoaderOverride");
1638 
1639     /** cache of subclass security audit results */
1640     /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
1641      * release */
1642     private static class Caches {
1643         /** cache of subclass security audit results */
1644         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
1645             new ConcurrentHashMap&lt;&gt;();
1646 
1647         /** queue for WeakReferences to audited subclasses */
1648         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
1649             new ReferenceQueue&lt;&gt;();
1650     }
1651 
1652     /**
1653      * Verifies that this (possibly subclass) instance can be constructed
1654      * without violating security constraints: the subclass must not override
1655      * security-sensitive non-final methods, or else the
1656      * "enableContextClassLoaderOverride" RuntimePermission is checked.
1657      */
1658     private static boolean isCCLOverridden(Class&lt;?&gt; cl) {
1659         if (cl == Thread.class)
1660             return false;
1661 
1662         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1663         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1664         Boolean result = Caches.subclassAudits.get(key);
1665         if (result == null) {
1666             result = Boolean.valueOf(auditSubclass(cl));
1667             Caches.subclassAudits.putIfAbsent(key, result);
1668         }
1669 
1670         return result.booleanValue();
1671     }
1672 
1673     /**
1674      * Performs reflective checks on given subclass to verify that it doesn't
1675      * override security-sensitive non-final methods.  Returns true if the
1676      * subclass overrides any of the methods, false otherwise.
1677      */
1678     private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
1679         Boolean result = AccessController.doPrivileged(
1680             new PrivilegedAction&lt;&gt;() {
1681                 public Boolean run() {
1682                     for (Class&lt;?&gt; cl = subcl;
1683                          cl != Thread.class;
1684                          cl = cl.getSuperclass())
1685                     {
1686                         try {
1687                             cl.getDeclaredMethod("getContextClassLoader", new Class&lt;?&gt;[0]);
1688                             return Boolean.TRUE;
1689                         } catch (NoSuchMethodException ex) {
1690                         }
1691                         try {
1692                             Class&lt;?&gt;[] params = {ClassLoader.class};
1693                             cl.getDeclaredMethod("setContextClassLoader", params);
1694                             return Boolean.TRUE;
1695                         } catch (NoSuchMethodException ex) {
1696                         }
1697                     }
1698                     return Boolean.FALSE;
1699                 }
1700             }
1701         );
1702         return result.booleanValue();
1703     }
1704 
1705     private static native StackTraceElement[][] dumpThreads(Thread[] threads);
1706     private static native Thread[] getThreads();
1707 
1708     /**
1709      * Returns the identifier of this Thread.  The thread ID is a positive
1710      * {@code long} number generated when this thread was created.
1711      * The thread ID is unique and remains unchanged during its lifetime.
1712      * When a thread is terminated, this thread ID may be reused.
1713      *
1714      * @return this thread's ID.
1715      * @since 1.5
1716      */
1717     public long getId() {
1718         return tid;
1719     }
1720 
1721     /**
1722      * A thread state.  A thread can be in one of the following states:
1723      * &lt;ul&gt;
1724      * &lt;li&gt;{@link #NEW}&lt;br&gt;
1725      *     A thread that has not yet started is in this state.
1726      *     &lt;/li&gt;
1727      * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
1728      *     A thread executing in the Java virtual machine is in this state.
1729      *     &lt;/li&gt;
1730      * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
1731      *     A thread that is blocked waiting for a monitor lock
1732      *     is in this state.
1733      *     &lt;/li&gt;
1734      * &lt;li&gt;{@link #WAITING}&lt;br&gt;
1735      *     A thread that is waiting indefinitely for another thread to
1736      *     perform a particular action is in this state.
1737      *     &lt;/li&gt;
1738      * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
1739      *     A thread that is waiting for another thread to perform an action
1740      *     for up to a specified waiting time is in this state.
1741      *     &lt;/li&gt;
1742      * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
1743      *     A thread that has exited is in this state.
1744      *     &lt;/li&gt;
1745      * &lt;/ul&gt;
1746      *
1747      * &lt;p&gt;
1748      * A thread can be in only one state at a given point in time.
1749      * These states are virtual machine states which do not reflect
1750      * any operating system thread states.
1751      *
1752      * @since   1.5
1753      * @see #getState
1754      */
1755     public enum State {
1756         /**
1757          * Thread state for a thread which has not yet started.
1758          */
1759         NEW,
1760 
1761         /**
1762          * Thread state for a runnable thread.  A thread in the runnable
1763          * state is executing in the Java virtual machine but it may
1764          * be waiting for other resources from the operating system
1765          * such as processor.
1766          */
1767         RUNNABLE,
1768 
1769         /**
1770          * Thread state for a thread blocked waiting for a monitor lock.
1771          * A thread in the blocked state is waiting for a monitor lock
1772          * to enter a synchronized block/method or
1773          * reenter a synchronized block/method after calling
1774          * {@link Object#wait() Object.wait}.
1775          */
1776         BLOCKED,
1777 
1778         /**
1779          * Thread state for a waiting thread.
1780          * A thread is in the waiting state due to calling one of the
1781          * following methods:
1782          * &lt;ul&gt;
1783          *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
1784          *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
1785          *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
1786          * &lt;/ul&gt;
1787          *
1788          * &lt;p&gt;A thread in the waiting state is waiting for another thread to
1789          * perform a particular action.
1790          *
1791          * For example, a thread that has called {@code Object.wait()}
1792          * on an object is waiting for another thread to call
1793          * {@code Object.notify()} or {@code Object.notifyAll()} on
1794          * that object. A thread that has called {@code Thread.join()}
1795          * is waiting for a specified thread to terminate.
1796          */
1797         WAITING,
1798 
1799         /**
1800          * Thread state for a waiting thread with a specified waiting time.
1801          * A thread is in the timed waiting state due to calling one of
1802          * the following methods with a specified positive waiting time:
1803          * &lt;ul&gt;
1804          *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
1805          *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
1806          *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
1807          *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
1808          *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
1809          * &lt;/ul&gt;
1810          */
1811         TIMED_WAITING,
1812 
1813         /**
1814          * Thread state for a terminated thread.
1815          * The thread has completed execution.
1816          */
1817         TERMINATED;
1818     }
1819 
1820     /**
1821      * Returns the state of this thread.
1822      * This method is designed for use in monitoring of the system state,
1823      * not for synchronization control.
1824      *
1825      * @return this thread's state.
1826      * @since 1.5
1827      */
1828     public State getState() {
1829         // get current thread state
1830         return sun.misc.VM.toThreadState(threadStatus);
1831     }
1832 
1833     // Added in JSR-166
1834 
1835     /**
1836      * Interface for handlers invoked when a {@code Thread} abruptly
1837      * terminates due to an uncaught exception.
1838      * &lt;p&gt;When a thread is about to terminate due to an uncaught exception
1839      * the Java Virtual Machine will query the thread for its
1840      * {@code UncaughtExceptionHandler} using
1841      * {@link #getUncaughtExceptionHandler} and will invoke the handler's
1842      * {@code uncaughtException} method, passing the thread and the
1843      * exception as arguments.
1844      * If a thread has not had its {@code UncaughtExceptionHandler}
1845      * explicitly set, then its {@code ThreadGroup} object acts as its
1846      * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object
1847      * has no
1848      * special requirements for dealing with the exception, it can forward
1849      * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler
1850      * default uncaught exception handler}.
1851      *
1852      * @see #setDefaultUncaughtExceptionHandler
1853      * @see #setUncaughtExceptionHandler
1854      * @see ThreadGroup#uncaughtException
1855      * @since 1.5
1856      */
1857     @FunctionalInterface
1858     public interface UncaughtExceptionHandler {
1859         /**
1860          * Method invoked when the given thread terminates due to the
1861          * given uncaught exception.
1862          * &lt;p&gt;Any exception thrown by this method will be ignored by the
1863          * Java Virtual Machine.
1864          * @param t the thread
1865          * @param e the exception
1866          */
1867         void uncaughtException(Thread t, Throwable e);
1868     }
1869 
1870     // null unless explicitly set
1871     private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
1872 
1873     // null unless explicitly set
1874     private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
1875 
1876     /**
1877      * Set the default handler invoked when a thread abruptly terminates
1878      * due to an uncaught exception, and no other handler has been defined
1879      * for that thread.
1880      *
1881      * &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
1882      * by the thread's {@link ThreadGroup} object and finally by the default
1883      * uncaught exception handler. If the thread does not have an explicit
1884      * uncaught exception handler set, and the thread's thread group
1885      * (including parent thread groups)  does not specialize its
1886      * {@code uncaughtException} method, then the default handler's
1887      * {@code uncaughtException} method will be invoked.
1888      * &lt;p&gt;By setting the default uncaught exception handler, an application
1889      * can change the way in which uncaught exceptions are handled (such as
1890      * logging to a specific device, or file) for those threads that would
1891      * already accept whatever &amp;quot;default&amp;quot; behavior the system
1892      * provided.
1893      *
1894      * &lt;p&gt;Note that the default uncaught exception handler should not usually
1895      * defer to the thread's {@code ThreadGroup} object, as that could cause
1896      * infinite recursion.
1897      *
1898      * @param eh the object to use as the default uncaught exception handler.
1899      * If {@code null} then there is no default handler.
1900      *
1901      * @throws SecurityException if a security manager is present and it denies
1902      *         {@link RuntimePermission}{@code ("setDefaultUncaughtExceptionHandler")}
1903      *
1904      * @see #setUncaughtExceptionHandler
1905      * @see #getUncaughtExceptionHandler
1906      * @see ThreadGroup#uncaughtException
1907      * @since 1.5
1908      */
1909     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
1910         SecurityManager sm = System.getSecurityManager();
1911         if (sm != null) {
1912             sm.checkPermission(
1913                 new RuntimePermission("setDefaultUncaughtExceptionHandler")
1914                     );
1915         }
1916 
1917          defaultUncaughtExceptionHandler = eh;
1918      }
1919 
1920     /**
1921      * Returns the default handler invoked when a thread abruptly terminates
1922      * due to an uncaught exception. If the returned value is {@code null},
1923      * there is no default.
1924      * @since 1.5
1925      * @see #setDefaultUncaughtExceptionHandler
1926      * @return the default uncaught exception handler for all threads
1927      */
1928     public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
1929         return defaultUncaughtExceptionHandler;
1930     }
1931 
1932     /**
1933      * Returns the handler invoked when this thread abruptly terminates
1934      * due to an uncaught exception. If this thread has not had an
1935      * uncaught exception handler explicitly set then this thread's
1936      * {@code ThreadGroup} object is returned, unless this thread
1937      * has terminated, in which case {@code null} is returned.
1938      * @since 1.5
1939      * @return the uncaught exception handler for this thread
1940      */
1941     public UncaughtExceptionHandler getUncaughtExceptionHandler() {
1942         return uncaughtExceptionHandler != null ?
1943             uncaughtExceptionHandler : group;
1944     }
1945 
1946     /**
1947      * Set the handler invoked when this thread abruptly terminates
1948      * due to an uncaught exception.
1949      * &lt;p&gt;A thread can take full control of how it responds to uncaught
1950      * exceptions by having its uncaught exception handler explicitly set.
1951      * If no such handler is set then the thread's {@code ThreadGroup}
1952      * object acts as its handler.
1953      * @param eh the object to use as this thread's uncaught exception
1954      * handler. If {@code null} then this thread has no explicit handler.
1955      * @throws  SecurityException  if the current thread is not allowed to
1956      *          modify this thread.
1957      * @see #setDefaultUncaughtExceptionHandler
1958      * @see ThreadGroup#uncaughtException
1959      * @since 1.5
1960      */
1961     public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
1962         checkAccess();
1963         uncaughtExceptionHandler = eh;
1964     }
1965 
1966     /**
1967      * Dispatch an uncaught exception to the handler. This method is
1968      * intended to be called only by the JVM.
1969      */
1970     private void dispatchUncaughtException(Throwable e) {
1971         getUncaughtExceptionHandler().uncaughtException(this, e);
1972     }
1973 
1974     /**
1975      * Removes from the specified map any keys that have been enqueued
1976      * on the specified reference queue.
1977      */
1978     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
1979                              ConcurrentMap&lt;? extends
1980                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
1981     {
1982         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
1983         while((ref = queue.poll()) != null) {
1984             map.remove(ref);
1985         }
1986     }
1987 
1988     /**
1989      *  Weak key for Class objects.
1990      **/
1991     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
1992         /**
1993          * saved value of the referent's identity hash code, to maintain
1994          * a consistent hash code after the referent has been cleared
1995          */
1996         private final int hash;
1997 
1998         /**
1999          * Create a new WeakClassKey to the given object, registered
2000          * with a queue.
2001          */
2002         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2003             super(cl, refQueue);
2004             hash = System.identityHashCode(cl);
2005         }
2006 
2007         /**
2008          * Returns the identity hash code of the original referent.
2009          */
2010         @Override
2011         public int hashCode() {
2012             return hash;
2013         }
2014 
2015         /**
2016          * Returns true if the given object is this identical
2017          * WeakClassKey instance, or, if this object's referent has not
2018          * been cleared, if the given object is another WeakClassKey
2019          * instance with the identical non-null referent as this one.
2020          */
2021         @Override
2022         public boolean equals(Object obj) {
2023             if (obj == this)
2024                 return true;
2025 
2026             if (obj instanceof WeakClassKey) {
2027                 Object referent = get();
2028                 return (referent != null) &amp;&amp;
2029                        (referent == ((WeakClassKey) obj).get());
2030             } else {
2031                 return false;
2032             }
2033         }
2034     }
2035 
2036 
2037     // The following three initially uninitialized fields are exclusively
2038     // managed by class java.util.concurrent.ThreadLocalRandom. These
2039     // fields are used to build the high-performance PRNGs in the
2040     // concurrent code, and we can not risk accidental false sharing.
2041     // Hence, the fields are isolated with @Contended.
2042 
2043     /** The current seed for a ThreadLocalRandom */
2044     @sun.misc.Contended("tlr")
2045     long threadLocalRandomSeed;
2046 
2047     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2048     @sun.misc.Contended("tlr")
2049     int threadLocalRandomProbe;
2050 
2051     /** Secondary seed isolated from public ThreadLocalRandom sequence */
2052     @sun.misc.Contended("tlr")
2053     int threadLocalRandomSecondarySeed;
2054 
2055     /* Some private helper methods */
2056     private native void setPriority0(int newPriority);
2057     private native void stop0(Object o);
2058     private native void suspend0();
2059     private native void resume0();
2060     private native void interrupt0();
2061     private native void setNativeName(String name);
2062 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
