--- old/src/cpu/ppc/vm/vm_version_ppc.cpp	2015-10-14 14:23:22.000000000 +0300
+++ new/src/cpu/ppc/vm/vm_version_ppc.cpp	2015-10-14 14:23:22.000000000 +0300
@@ -173,6 +173,12 @@
     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
   }
 
+  if (UseSpinLoopHintIntrinsic) {
+    if (!FLAG_IS_DEFAULT(UseSpinLoopHintIntrinsic))
+      warning("spinLoopHint intrinsic is not available on this CPU");
+    FLAG_SET_DEFAULT(UseSpinLoopHintIntrinsic, false);
+  }
+
   // The AES intrinsic stubs require AES instruction support.
   if (UseAES) {
     warning("AES instructions are not available on this CPU");
--- old/src/cpu/sparc/vm/vm_version_sparc.cpp	2015-10-14 14:23:22.000000000 +0300
+++ new/src/cpu/sparc/vm/vm_version_sparc.cpp	2015-10-14 14:23:22.000000000 +0300
@@ -365,6 +365,12 @@
     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
   }
 
+  if (UseSpinLoopHintIntrinsic) {
+    if (!FLAG_IS_DEFAULT(UseSpinLoopHintIntrinsic))
+      warning("spinLoopHint intrinsic is not available on this CPU");
+    FLAG_SET_DEFAULT(UseSpinLoopHintIntrinsic, false);
+  }
+
   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &&
     (cache_line_size > ContendedPaddingWidth))
     ContendedPaddingWidth = cache_line_size;
--- old/src/cpu/x86/vm/x86_64.ad	2015-10-14 14:23:23.000000000 +0300
+++ new/src/cpu/x86/vm/x86_64.ad	2015-10-14 14:23:23.000000000 +0300
@@ -6308,6 +6308,25 @@
   ins_pipe(empty);
 %}
 
+instruct spinloophint()
+%{
+  match(SpinLoopHint);
+  ins_cost(200);
+
+  format %{
+    $$template
+    if (os::is_MP()) {
+      $$emit$$"pause\t! membar_spinloophint"
+    } else {
+      $$emit$$"MEMBAR-spinloophint ! (empty encoding)"
+    }
+  %}
+  ins_encode %{
+    __ pause();
+  %}
+  ins_pipe(pipe_slow);
+%}
+
 instruct membar_volatile(rFlagsReg cr) %{
   match(MemBarVolatile);
   effect(KILL cr);
--- old/src/share/vm/classfile/vmSymbols.cpp	2015-10-14 14:23:23.000000000 +0300
+++ new/src/share/vm/classfile/vmSymbols.cpp	2015-10-14 14:23:23.000000000 +0300
@@ -678,6 +678,9 @@
   case vmIntrinsics::_montgomerySquare:
     if (!UseMontgomerySquareIntrinsic) return true;
     break;
+  case vmIntrinsics::_spinLoopHint:
+    if (!UseSpinLoopHintIntrinsic) return true;
+    break;
   case vmIntrinsics::_addExactI:
   case vmIntrinsics::_addExactL:
   case vmIntrinsics::_decrementExactI:
--- old/src/share/vm/classfile/vmSymbols.hpp	2015-10-14 14:23:24.000000000 +0300
+++ new/src/share/vm/classfile/vmSymbols.hpp	2015-10-14 14:23:24.000000000 +0300
@@ -787,6 +787,9 @@
   do_intrinsic(_currentThread,            java_lang_Thread,       currentThread_name, currentThread_signature,   F_S)   \
    do_name(     currentThread_name,                              "currentThread")                                       \
    do_signature(currentThread_signature,                         "()Ljava/lang/Thread;")                                \
+  do_intrinsic(_spinLoopHint,             java_lang_Thread,       spinLoopHint_name, spinLoopHint_signature,     F_S)   \
+   do_name(     spinLoopHint_name,                               "spinLoopHint")                                        \
+   do_alias(    spinLoopHint_signature,                           void_method_signature)                                \
                                                                                                                         \
   /* reflective intrinsics, for java/lang/Class, etc. */                                                                \
   do_intrinsic(_isAssignableFrom,         java_lang_Class,        isAssignableFrom_name, class_boolean_signature, F_RN) \
--- old/src/share/vm/opto/c2compiler.cpp	2015-10-14 14:23:24.000000000 +0300
+++ new/src/share/vm/opto/c2compiler.cpp	2015-10-14 14:23:24.000000000 +0300
@@ -371,6 +371,7 @@
   case vmIntrinsics::_fullFence:
   case vmIntrinsics::_currentThread:
   case vmIntrinsics::_isInterrupted:
+  case vmIntrinsics::_spinLoopHint:
 #ifdef TRACE_HAVE_INTRINSICS
   case vmIntrinsics::_classID:
   case vmIntrinsics::_threadID:
--- old/src/share/vm/opto/classes.hpp	2015-10-14 14:23:25.000000000 +0300
+++ new/src/share/vm/opto/classes.hpp	2015-10-14 14:23:24.000000000 +0300
@@ -169,6 +169,7 @@
 macro(Mach)
 macro(MachProj)
 macro(MaxI)
+macro(SpinLoopHint)
 macro(MemBarAcquire)
 macro(LoadFence)
 macro(MemBarAcquireLock)
--- old/src/share/vm/opto/library_call.cpp	2015-10-14 14:23:25.000000000 +0300
+++ new/src/share/vm/opto/library_call.cpp	2015-10-14 14:23:25.000000000 +0300
@@ -271,6 +271,7 @@
   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind);
   bool inline_unsafe_ordered_store(BasicType type);
   bool inline_unsafe_fence(vmIntrinsics::ID id);
+  bool inline_spinloophint();
   bool inline_fp_conversions(vmIntrinsics::ID id);
   bool inline_number_methods(vmIntrinsics::ID id);
   bool inline_reference_get();
@@ -601,6 +602,8 @@
   case vmIntrinsics::_storeFence:
   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 
+  case vmIntrinsics::_spinLoopHint:             return inline_spinloophint();
+
   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
   case vmIntrinsics::_isInterrupted:            return inline_native_isInterrupted();
 
@@ -2874,6 +2877,11 @@
   }
 }
 
+bool LibraryCallKit::inline_spinloophint() {
+  insert_mem_bar(Op_SpinLoopHint);
+  return true;
+}
+
 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
   if (!kls->is_Con()) {
     return true;
@@ -3256,6 +3264,9 @@
     // nothing is an instance of a primitive type
     query_value = gen_instanceof(obj, kls, safe_for_replace);
     break;
+  
+  case vmIntrinsics::_spinLoopHint:
+    break;
 
   case vmIntrinsics::_getModifiers:
     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
--- old/src/share/vm/opto/matcher.cpp	2015-10-14 14:23:26.000000000 +0300
+++ new/src/share/vm/opto/matcher.cpp	2015-10-14 14:23:25.000000000 +0300
@@ -939,6 +939,7 @@
     case Op_AryEq:
     case Op_MemBarVolatile:
     case Op_MemBarCPUOrder: // %%% these ideals should have narrower adr_type?
+    case Op_SpinLoopHint:
     case Op_EncodeISOArray:
       nidx = Compile::AliasIdxTop;
       nat = NULL;
--- old/src/share/vm/opto/memnode.cpp	2015-10-14 14:23:26.000000000 +0300
+++ new/src/share/vm/opto/memnode.cpp	2015-10-14 14:23:26.000000000 +0300
@@ -2891,6 +2891,7 @@
   case Op_MemBarReleaseLock: return new MemBarReleaseLockNode(C, atp, pn);
   case Op_MemBarVolatile:    return new MemBarVolatileNode(C, atp, pn);
   case Op_MemBarCPUOrder:    return new MemBarCPUOrderNode(C, atp, pn);
+  case Op_SpinLoopHint:      return new SpinLoopHintNode(C, atp, pn);
   case Op_Initialize:        return new InitializeNode(C, atp, pn);
   case Op_MemBarStoreStore:  return new MemBarStoreStoreNode(C, atp, pn);
   default: ShouldNotReachHere(); return NULL;
--- old/src/share/vm/opto/memnode.hpp	2015-10-14 14:23:27.000000000 +0300
+++ new/src/share/vm/opto/memnode.hpp	2015-10-14 14:23:26.000000000 +0300
@@ -1075,6 +1075,13 @@
   virtual uint ideal_reg() const { return 0; } // not matched in the AD file
 };
 
+class SpinLoopHintNode: public MemBarNode {
+public:
+  SpinLoopHintNode(Compile* C, int alias_idx, Node* precedent)
+    : MemBarNode(C, alias_idx, precedent) {}
+  virtual int Opcode() const;
+};
+
 // Isolation of object setup after an AllocateNode and before next safepoint.
 // (See comment in memnode.cpp near InitializeNode::InitializeNode for semantics.)
 class InitializeNode: public MemBarNode {
--- old/src/share/vm/runtime/globals.hpp	2015-10-14 14:23:27.000000000 +0300
+++ new/src/share/vm/runtime/globals.hpp	2015-10-14 14:23:27.000000000 +0300
@@ -838,6 +838,9 @@
   diagnostic(ccstrlist, DisableIntrinsic, "",                               \
          "do not expand intrinsics whose (internal) names appear here")     \
                                                                             \
+  product(bool, UseSpinLoopHintIntrinsic, false,                            \
+          "Use intrinsics for spinLoopHint")                                \
+                                                                            \
   develop(bool, TraceCallFixup, false,                                      \
           "Trace all call fixups")                                          \
                                                                             \
--- old/src/share/vm/runtime/vmStructs.cpp	2015-10-14 14:23:28.000000000 +0300
+++ new/src/share/vm/runtime/vmStructs.cpp	2015-10-14 14:23:27.000000000 +0300
@@ -1857,6 +1857,7 @@
   declare_c2_type(StoreFenceNode, MemBarNode)                             \
   declare_c2_type(MemBarVolatileNode, MemBarNode)                         \
   declare_c2_type(MemBarCPUOrderNode, MemBarNode)                         \
+  declare_c2_type(SpinLoopHintNode, MemBarNode)                           \
   declare_c2_type(InitializeNode, MemBarNode)                             \
   declare_c2_type(ThreadLocalNode, Node)                                  \
   declare_c2_type(Opaque1Node, Node)                                      \
