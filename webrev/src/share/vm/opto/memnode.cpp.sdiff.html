<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/share/vm/opto </title>
</head><body id="SUNWwebrev">
<h2>src/share/vm/opto/memnode.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
2920     init_req(TypeFunc::Parms, precedent);
2921 }
2922 
2923 //------------------------------cmp--------------------------------------------
2924 uint MemBarNode::hash() const { return NO_HASH; }
2925 uint MemBarNode::cmp( const Node &amp;n ) const {
2926   return (&amp;n == this);          // Always fail except on self
2927 }
2928 
2929 //------------------------------make-------------------------------------------
2930 MemBarNode* MemBarNode::make(Compile* C, int opcode, int atp, Node* pn) {
2931   switch (opcode) {
2932   case Op_MemBarAcquire:     return new MemBarAcquireNode(C, atp, pn);
2933   case Op_LoadFence:         return new LoadFenceNode(C, atp, pn);
2934   case Op_MemBarRelease:     return new MemBarReleaseNode(C, atp, pn);
2935   case Op_StoreFence:        return new StoreFenceNode(C, atp, pn);
2936   case Op_MemBarAcquireLock: return new MemBarAcquireLockNode(C, atp, pn);
2937   case Op_MemBarReleaseLock: return new MemBarReleaseLockNode(C, atp, pn);
2938   case Op_MemBarVolatile:    return new MemBarVolatileNode(C, atp, pn);
2939   case Op_MemBarCPUOrder:    return new MemBarCPUOrderNode(C, atp, pn);

2940   case Op_Initialize:        return new InitializeNode(C, atp, pn);
2941   case Op_MemBarStoreStore:  return new MemBarStoreStoreNode(C, atp, pn);
2942   default: ShouldNotReachHere(); return NULL;
2943   }
2944 }
2945 
2946 //------------------------------Ideal------------------------------------------
2947 // Return a node which is more "ideal" than the current node.  Strip out
2948 // control copies
2949 Node *MemBarNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2950   if (remove_dead_region(phase, can_reshape)) return this;
2951   // Don't bother trying to transform a dead node
2952   if (in(0) &amp;&amp; in(0)-&gt;is_top()) {
2953     return NULL;
2954   }
2955 
2956   bool progress = false;
2957   // Eliminate volatile MemBars for scalar replaced objects.
2958   if (can_reshape &amp;&amp; req() == (Precedent+1)) {
2959     bool eliminate = false;

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
2920     init_req(TypeFunc::Parms, precedent);
2921 }
2922 
2923 //------------------------------cmp--------------------------------------------
2924 uint MemBarNode::hash() const { return NO_HASH; }
2925 uint MemBarNode::cmp( const Node &amp;n ) const {
2926   return (&amp;n == this);          // Always fail except on self
2927 }
2928 
2929 //------------------------------make-------------------------------------------
2930 MemBarNode* MemBarNode::make(Compile* C, int opcode, int atp, Node* pn) {
2931   switch (opcode) {
2932   case Op_MemBarAcquire:     return new MemBarAcquireNode(C, atp, pn);
2933   case Op_LoadFence:         return new LoadFenceNode(C, atp, pn);
2934   case Op_MemBarRelease:     return new MemBarReleaseNode(C, atp, pn);
2935   case Op_StoreFence:        return new StoreFenceNode(C, atp, pn);
2936   case Op_MemBarAcquireLock: return new MemBarAcquireLockNode(C, atp, pn);
2937   case Op_MemBarReleaseLock: return new MemBarReleaseLockNode(C, atp, pn);
2938   case Op_MemBarVolatile:    return new MemBarVolatileNode(C, atp, pn);
2939   case Op_MemBarCPUOrder:    return new MemBarCPUOrderNode(C, atp, pn);
<span class="new">2940   case Op_SpinLoopHint:      return new SpinLoopHintNode(C, atp, pn);</span>
2941   case Op_Initialize:        return new InitializeNode(C, atp, pn);
2942   case Op_MemBarStoreStore:  return new MemBarStoreStoreNode(C, atp, pn);
2943   default: ShouldNotReachHere(); return NULL;
2944   }
2945 }
2946 
2947 //------------------------------Ideal------------------------------------------
2948 // Return a node which is more "ideal" than the current node.  Strip out
2949 // control copies
2950 Node *MemBarNode::Ideal(PhaseGVN *phase, bool can_reshape) {
2951   if (remove_dead_region(phase, can_reshape)) return this;
2952   // Don't bother trying to transform a dead node
2953   if (in(0) &amp;&amp; in(0)-&gt;is_top()) {
2954     return NULL;
2955   }
2956 
2957   bool progress = false;
2958   // Eliminate volatile MemBars for scalar replaced objects.
2959   if (can_reshape &amp;&amp; req() == (Precedent+1)) {
2960     bool eliminate = false;

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
