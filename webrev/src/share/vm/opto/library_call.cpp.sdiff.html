<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/share/vm/opto </title>
</head><body id="SUNWwebrev">
<h2>src/share/vm/opto/library_call.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 254   bool inline_array_copyOf(bool is_copyOfRange);
 255   bool inline_array_equals();
 256   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array, bool card_mark);
 257   bool inline_native_clone(bool is_virtual);
 258   bool inline_native_Reflection_getCallerClass();
 259   // Helper function for inlining native object hash method
 260   bool inline_native_hashcode(bool is_virtual, bool is_static);
 261   bool inline_native_getClass();
 262 
 263   // Helper functions for inlining arraycopy
 264   bool inline_arraycopy();
 265   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 266                                                 RegionNode* slow_region);
 267   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 268   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp);
 269 
 270   typedef enum { LS_xadd, LS_xchg, LS_cmpxchg } LoadStoreKind;
 271   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind);
 272   bool inline_unsafe_ordered_store(BasicType type);
 273   bool inline_unsafe_fence(vmIntrinsics::ID id);

 274   bool inline_fp_conversions(vmIntrinsics::ID id);
 275   bool inline_number_methods(vmIntrinsics::ID id);
 276   bool inline_reference_get();
 277   bool inline_Class_cast();
 278   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 279   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
 280   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
 281   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 282   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 283   bool inline_ghash_processBlocks();
 284   bool inline_sha_implCompress(vmIntrinsics::ID id);
 285   bool inline_digestBase_implCompressMB(int predicate);
 286   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 287                                  bool long_state, address stubAddr, const char *stubName,
 288                                  Node* src_start, Node* ofs, Node* limit);
 289   Node* get_state_from_sha_object(Node *sha_object);
 290   Node* get_state_from_sha5_object(Node *sha_object);
 291   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 292   bool inline_encodeISOArray();
 293   bool inline_updateCRC32();

</pre><hr></hr><pre>
 584   case vmIntrinsics::_putLongUnaligned:         return inline_unsafe_access(!is_native_ptr,  is_store, T_LONG,    !is_volatile);
 585 
 586   case vmIntrinsics::_compareAndSwapObject:     return inline_unsafe_load_store(T_OBJECT, LS_cmpxchg);
 587   case vmIntrinsics::_compareAndSwapInt:        return inline_unsafe_load_store(T_INT,    LS_cmpxchg);
 588   case vmIntrinsics::_compareAndSwapLong:       return inline_unsafe_load_store(T_LONG,   LS_cmpxchg);
 589 
 590   case vmIntrinsics::_putOrderedObject:         return inline_unsafe_ordered_store(T_OBJECT);
 591   case vmIntrinsics::_putOrderedInt:            return inline_unsafe_ordered_store(T_INT);
 592   case vmIntrinsics::_putOrderedLong:           return inline_unsafe_ordered_store(T_LONG);
 593 
 594   case vmIntrinsics::_getAndAddInt:             return inline_unsafe_load_store(T_INT,    LS_xadd);
 595   case vmIntrinsics::_getAndAddLong:            return inline_unsafe_load_store(T_LONG,   LS_xadd);
 596   case vmIntrinsics::_getAndSetInt:             return inline_unsafe_load_store(T_INT,    LS_xchg);
 597   case vmIntrinsics::_getAndSetLong:            return inline_unsafe_load_store(T_LONG,   LS_xchg);
 598   case vmIntrinsics::_getAndSetObject:          return inline_unsafe_load_store(T_OBJECT, LS_xchg);
 599 
 600   case vmIntrinsics::_loadFence:
 601   case vmIntrinsics::_storeFence:
 602   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 603 


 604   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
 605   case vmIntrinsics::_isInterrupted:            return inline_native_isInterrupted();
 606 
 607 #ifdef TRACE_HAVE_INTRINSICS
 608   case vmIntrinsics::_classID:                  return inline_native_classID();
 609   case vmIntrinsics::_threadID:                 return inline_native_threadID();
 610   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, TRACE_TIME_METHOD), "counterTime");
 611 #endif
 612   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), "currentTimeMillis");
 613   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), "nanoTime");
 614   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 615   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 616   case vmIntrinsics::_newArray:                 return inline_native_newArray();
 617   case vmIntrinsics::_getLength:                return inline_native_getLength();
 618   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 619   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 620   case vmIntrinsics::_equalsC:                  return inline_array_equals();
 621   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 622 
 623   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();

</pre><hr></hr><pre>
2857 bool LibraryCallKit::inline_unsafe_fence(vmIntrinsics::ID id) {
2858   // Regardless of form, don't allow previous ld/st to move down,
2859   // then issue acquire, release, or volatile mem_bar.
2860   insert_mem_bar(Op_MemBarCPUOrder);
2861   switch(id) {
2862     case vmIntrinsics::_loadFence:
2863       insert_mem_bar(Op_LoadFence);
2864       return true;
2865     case vmIntrinsics::_storeFence:
2866       insert_mem_bar(Op_StoreFence);
2867       return true;
2868     case vmIntrinsics::_fullFence:
2869       insert_mem_bar(Op_MemBarVolatile);
2870       return true;
2871     default:
2872       fatal_unexpected_iid(id);
2873       return false;
2874   }
2875 }
2876 





2877 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2878   if (!kls-&gt;is_Con()) {
2879     return true;
2880   }
2881   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2882   if (klsptr == NULL) {
2883     return true;
2884   }
2885   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2886   // don't need a guard for a klass that is already initialized
2887   return !ik-&gt;is_initialized();
2888 }
2889 
2890 //----------------------------inline_unsafe_allocate---------------------------
2891 // public native Object sun.misc.Unsafe.allocateInstance(Class&lt;?&gt; cls);
2892 bool LibraryCallKit::inline_unsafe_allocate() {
2893   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2894 
2895   null_check_receiver();  // null-check, then ignore
2896   Node* cls = null_check(argument(1));

</pre><hr></hr><pre>
3240   // Now load the mirror's klass metaobject, and null-check it.
3241   // Side-effects region with the control path if the klass is null.
3242   Node* kls = load_klass_from_mirror(mirror, never_see_null, region, _prim_path);
3243   // If kls is null, we have a primitive mirror.
3244   phi-&gt;init_req(_prim_path, prim_return_value);
3245   if (stopped()) { set_result(region, phi); return true; }
3246   bool safe_for_replace = (region-&gt;in(_prim_path) == top());
3247 
3248   Node* p;  // handy temp
3249   Node* null_ctl;
3250 
3251   // Now that we have the non-null klass, we can perform the real query.
3252   // For constant classes, the query will constant-fold in LoadNode::Value.
3253   Node* query_value = top();
3254   switch (id) {
3255   case vmIntrinsics::_isInstance:
3256     // nothing is an instance of a primitive type
3257     query_value = gen_instanceof(obj, kls, safe_for_replace);
3258     break;
3259 



3260   case vmIntrinsics::_getModifiers:
3261     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
3262     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3263     break;
3264 
3265   case vmIntrinsics::_isInterface:
3266     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3267     if (generate_interface_guard(kls, region) != NULL)
3268       // A guard was added.  If the guard is taken, it was an interface.
3269       phi-&gt;add_req(intcon(1));
3270     // If we fall through, it's a plain class.
3271     query_value = intcon(0);
3272     break;
3273 
3274   case vmIntrinsics::_isArray:
3275     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3276     if (generate_array_guard(kls, region) != NULL)
3277       // A guard was added.  If the guard is taken, it was an array.
3278       phi-&gt;add_req(intcon(1));
3279     // If we fall through, it's a plain class.

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 254   bool inline_array_copyOf(bool is_copyOfRange);
 255   bool inline_array_equals();
 256   void copy_to_clone(Node* obj, Node* alloc_obj, Node* obj_size, bool is_array, bool card_mark);
 257   bool inline_native_clone(bool is_virtual);
 258   bool inline_native_Reflection_getCallerClass();
 259   // Helper function for inlining native object hash method
 260   bool inline_native_hashcode(bool is_virtual, bool is_static);
 261   bool inline_native_getClass();
 262 
 263   // Helper functions for inlining arraycopy
 264   bool inline_arraycopy();
 265   AllocateArrayNode* tightly_coupled_allocation(Node* ptr,
 266                                                 RegionNode* slow_region);
 267   JVMState* arraycopy_restore_alloc_state(AllocateArrayNode* alloc, int&amp; saved_reexecute_sp);
 268   void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp);
 269 
 270   typedef enum { LS_xadd, LS_xchg, LS_cmpxchg } LoadStoreKind;
 271   bool inline_unsafe_load_store(BasicType type,  LoadStoreKind kind);
 272   bool inline_unsafe_ordered_store(BasicType type);
 273   bool inline_unsafe_fence(vmIntrinsics::ID id);
<span class="new"> 274   bool inline_spinloophint();</span>
 275   bool inline_fp_conversions(vmIntrinsics::ID id);
 276   bool inline_number_methods(vmIntrinsics::ID id);
 277   bool inline_reference_get();
 278   bool inline_Class_cast();
 279   bool inline_aescrypt_Block(vmIntrinsics::ID id);
 280   bool inline_cipherBlockChaining_AESCrypt(vmIntrinsics::ID id);
 281   Node* inline_cipherBlockChaining_AESCrypt_predicate(bool decrypting);
 282   Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);
 283   Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);
 284   bool inline_ghash_processBlocks();
 285   bool inline_sha_implCompress(vmIntrinsics::ID id);
 286   bool inline_digestBase_implCompressMB(int predicate);
 287   bool inline_sha_implCompressMB(Node* digestBaseObj, ciInstanceKlass* instklass_SHA,
 288                                  bool long_state, address stubAddr, const char *stubName,
 289                                  Node* src_start, Node* ofs, Node* limit);
 290   Node* get_state_from_sha_object(Node *sha_object);
 291   Node* get_state_from_sha5_object(Node *sha_object);
 292   Node* inline_digestBase_implCompressMB_predicate(int predicate);
 293   bool inline_encodeISOArray();
 294   bool inline_updateCRC32();

</pre><hr></hr><pre>
 585   case vmIntrinsics::_putLongUnaligned:         return inline_unsafe_access(!is_native_ptr,  is_store, T_LONG,    !is_volatile);
 586 
 587   case vmIntrinsics::_compareAndSwapObject:     return inline_unsafe_load_store(T_OBJECT, LS_cmpxchg);
 588   case vmIntrinsics::_compareAndSwapInt:        return inline_unsafe_load_store(T_INT,    LS_cmpxchg);
 589   case vmIntrinsics::_compareAndSwapLong:       return inline_unsafe_load_store(T_LONG,   LS_cmpxchg);
 590 
 591   case vmIntrinsics::_putOrderedObject:         return inline_unsafe_ordered_store(T_OBJECT);
 592   case vmIntrinsics::_putOrderedInt:            return inline_unsafe_ordered_store(T_INT);
 593   case vmIntrinsics::_putOrderedLong:           return inline_unsafe_ordered_store(T_LONG);
 594 
 595   case vmIntrinsics::_getAndAddInt:             return inline_unsafe_load_store(T_INT,    LS_xadd);
 596   case vmIntrinsics::_getAndAddLong:            return inline_unsafe_load_store(T_LONG,   LS_xadd);
 597   case vmIntrinsics::_getAndSetInt:             return inline_unsafe_load_store(T_INT,    LS_xchg);
 598   case vmIntrinsics::_getAndSetLong:            return inline_unsafe_load_store(T_LONG,   LS_xchg);
 599   case vmIntrinsics::_getAndSetObject:          return inline_unsafe_load_store(T_OBJECT, LS_xchg);
 600 
 601   case vmIntrinsics::_loadFence:
 602   case vmIntrinsics::_storeFence:
 603   case vmIntrinsics::_fullFence:                return inline_unsafe_fence(intrinsic_id());
 604 
<span class="new"> 605   case vmIntrinsics::_spinLoopHint:             return inline_spinloophint();</span>
<span class="new"> 606 </span>
 607   case vmIntrinsics::_currentThread:            return inline_native_currentThread();
 608   case vmIntrinsics::_isInterrupted:            return inline_native_isInterrupted();
 609 
 610 #ifdef TRACE_HAVE_INTRINSICS
 611   case vmIntrinsics::_classID:                  return inline_native_classID();
 612   case vmIntrinsics::_threadID:                 return inline_native_threadID();
 613   case vmIntrinsics::_counterTime:              return inline_native_time_funcs(CAST_FROM_FN_PTR(address, TRACE_TIME_METHOD), "counterTime");
 614 #endif
 615   case vmIntrinsics::_currentTimeMillis:        return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeMillis), "currentTimeMillis");
 616   case vmIntrinsics::_nanoTime:                 return inline_native_time_funcs(CAST_FROM_FN_PTR(address, os::javaTimeNanos), "nanoTime");
 617   case vmIntrinsics::_allocateInstance:         return inline_unsafe_allocate();
 618   case vmIntrinsics::_copyMemory:               return inline_unsafe_copyMemory();
 619   case vmIntrinsics::_newArray:                 return inline_native_newArray();
 620   case vmIntrinsics::_getLength:                return inline_native_getLength();
 621   case vmIntrinsics::_copyOf:                   return inline_array_copyOf(false);
 622   case vmIntrinsics::_copyOfRange:              return inline_array_copyOf(true);
 623   case vmIntrinsics::_equalsC:                  return inline_array_equals();
 624   case vmIntrinsics::_clone:                    return inline_native_clone(intrinsic()-&gt;is_virtual());
 625 
 626   case vmIntrinsics::_isAssignableFrom:         return inline_native_subtype_check();

</pre><hr></hr><pre>
2860 bool LibraryCallKit::inline_unsafe_fence(vmIntrinsics::ID id) {
2861   // Regardless of form, don't allow previous ld/st to move down,
2862   // then issue acquire, release, or volatile mem_bar.
2863   insert_mem_bar(Op_MemBarCPUOrder);
2864   switch(id) {
2865     case vmIntrinsics::_loadFence:
2866       insert_mem_bar(Op_LoadFence);
2867       return true;
2868     case vmIntrinsics::_storeFence:
2869       insert_mem_bar(Op_StoreFence);
2870       return true;
2871     case vmIntrinsics::_fullFence:
2872       insert_mem_bar(Op_MemBarVolatile);
2873       return true;
2874     default:
2875       fatal_unexpected_iid(id);
2876       return false;
2877   }
2878 }
2879 
<span class="new">2880 bool LibraryCallKit::inline_spinloophint() {</span>
<span class="new">2881   insert_mem_bar(Op_SpinLoopHint);</span>
<span class="new">2882   return true;</span>
<span class="new">2883 }</span>
<span class="new">2884 </span>
2885 bool LibraryCallKit::klass_needs_init_guard(Node* kls) {
2886   if (!kls-&gt;is_Con()) {
2887     return true;
2888   }
2889   const TypeKlassPtr* klsptr = kls-&gt;bottom_type()-&gt;isa_klassptr();
2890   if (klsptr == NULL) {
2891     return true;
2892   }
2893   ciInstanceKlass* ik = klsptr-&gt;klass()-&gt;as_instance_klass();
2894   // don't need a guard for a klass that is already initialized
2895   return !ik-&gt;is_initialized();
2896 }
2897 
2898 //----------------------------inline_unsafe_allocate---------------------------
2899 // public native Object sun.misc.Unsafe.allocateInstance(Class&lt;?&gt; cls);
2900 bool LibraryCallKit::inline_unsafe_allocate() {
2901   if (callee()-&gt;is_static())  return false;  // caller must have the capability!
2902 
2903   null_check_receiver();  // null-check, then ignore
2904   Node* cls = null_check(argument(1));

</pre><hr></hr><pre>
3248   // Now load the mirror's klass metaobject, and null-check it.
3249   // Side-effects region with the control path if the klass is null.
3250   Node* kls = load_klass_from_mirror(mirror, never_see_null, region, _prim_path);
3251   // If kls is null, we have a primitive mirror.
3252   phi-&gt;init_req(_prim_path, prim_return_value);
3253   if (stopped()) { set_result(region, phi); return true; }
3254   bool safe_for_replace = (region-&gt;in(_prim_path) == top());
3255 
3256   Node* p;  // handy temp
3257   Node* null_ctl;
3258 
3259   // Now that we have the non-null klass, we can perform the real query.
3260   // For constant classes, the query will constant-fold in LoadNode::Value.
3261   Node* query_value = top();
3262   switch (id) {
3263   case vmIntrinsics::_isInstance:
3264     // nothing is an instance of a primitive type
3265     query_value = gen_instanceof(obj, kls, safe_for_replace);
3266     break;
3267   
<span class="new">3268   case vmIntrinsics::_spinLoopHint:</span>
<span class="new">3269     break;</span>
<span class="new">3270 </span>
3271   case vmIntrinsics::_getModifiers:
3272     p = basic_plus_adr(kls, in_bytes(Klass::modifier_flags_offset()));
3273     query_value = make_load(NULL, p, TypeInt::INT, T_INT, MemNode::unordered);
3274     break;
3275 
3276   case vmIntrinsics::_isInterface:
3277     // (To verify this code sequence, check the asserts in JVM_IsInterface.)
3278     if (generate_interface_guard(kls, region) != NULL)
3279       // A guard was added.  If the guard is taken, it was an interface.
3280       phi-&gt;add_req(intcon(1));
3281     // If we fall through, it's a plain class.
3282     query_value = intcon(0);
3283     break;
3284 
3285   case vmIntrinsics::_isArray:
3286     // (To verify this code sequence, check the asserts in JVM_IsArrayClass.)
3287     if (generate_array_guard(kls, region) != NULL)
3288       // A guard was added.  If the guard is taken, it was an array.
3289       phi-&gt;add_req(intcon(1));
3290     // If we fall through, it's a plain class.

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
