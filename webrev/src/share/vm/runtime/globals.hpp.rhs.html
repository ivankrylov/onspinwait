<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_RUNTIME_GLOBALS_HPP
  26 #define SHARE_VM_RUNTIME_GLOBALS_HPP
  27 
  28 #include "utilities/debug.hpp"
  29 
  30 // use this for flags that are true per default in the tiered build
  31 // but false in non-tiered builds, and vice versa
  32 #ifdef TIERED
  33 #define  trueInTiered true
  34 #define falseInTiered false
  35 #else
  36 #define  trueInTiered false
  37 #define falseInTiered true
  38 #endif
  39 
  40 #ifdef TARGET_ARCH_x86
  41 # include "globals_x86.hpp"
  42 #endif
  43 #ifdef TARGET_ARCH_sparc
  44 # include "globals_sparc.hpp"
  45 #endif
  46 #ifdef TARGET_ARCH_zero
  47 # include "globals_zero.hpp"
  48 #endif
  49 #ifdef TARGET_ARCH_arm
  50 # include "globals_arm.hpp"
  51 #endif
  52 #ifdef TARGET_ARCH_ppc
  53 # include "globals_ppc.hpp"
  54 #endif
  55 #ifdef TARGET_ARCH_aarch64
  56 # include "globals_aarch64.hpp"
  57 #endif
  58 #ifdef TARGET_OS_FAMILY_linux
  59 # include "globals_linux.hpp"
  60 #endif
  61 #ifdef TARGET_OS_FAMILY_solaris
  62 # include "globals_solaris.hpp"
  63 #endif
  64 #ifdef TARGET_OS_FAMILY_windows
  65 # include "globals_windows.hpp"
  66 #endif
  67 #ifdef TARGET_OS_FAMILY_aix
  68 # include "globals_aix.hpp"
  69 #endif
  70 #ifdef TARGET_OS_FAMILY_bsd
  71 # include "globals_bsd.hpp"
  72 #endif
  73 #ifdef TARGET_OS_ARCH_linux_x86
  74 # include "globals_linux_x86.hpp"
  75 #endif
  76 #ifdef TARGET_OS_ARCH_linux_sparc
  77 # include "globals_linux_sparc.hpp"
  78 #endif
  79 #ifdef TARGET_OS_ARCH_linux_zero
  80 # include "globals_linux_zero.hpp"
  81 #endif
  82 #ifdef TARGET_OS_ARCH_solaris_x86
  83 # include "globals_solaris_x86.hpp"
  84 #endif
  85 #ifdef TARGET_OS_ARCH_solaris_sparc
  86 # include "globals_solaris_sparc.hpp"
  87 #endif
  88 #ifdef TARGET_OS_ARCH_windows_x86
  89 # include "globals_windows_x86.hpp"
  90 #endif
  91 #ifdef TARGET_OS_ARCH_linux_arm
  92 # include "globals_linux_arm.hpp"
  93 #endif
  94 #ifdef TARGET_OS_ARCH_linux_ppc
  95 # include "globals_linux_ppc.hpp"
  96 #endif
  97 #ifdef TARGET_OS_ARCH_linux_aarch64
  98 # include "globals_linux_aarch64.hpp"
  99 #endif
 100 #ifdef TARGET_OS_ARCH_aix_ppc
 101 # include "globals_aix_ppc.hpp"
 102 #endif
 103 #ifdef TARGET_OS_ARCH_bsd_x86
 104 # include "globals_bsd_x86.hpp"
 105 #endif
 106 #ifdef TARGET_OS_ARCH_bsd_zero
 107 # include "globals_bsd_zero.hpp"
 108 #endif
 109 #ifdef COMPILER1
 110 #ifdef TARGET_ARCH_x86
 111 # include "c1_globals_x86.hpp"
 112 #endif
 113 #ifdef TARGET_ARCH_sparc
 114 # include "c1_globals_sparc.hpp"
 115 #endif
 116 #ifdef TARGET_ARCH_arm
 117 # include "c1_globals_arm.hpp"
 118 #endif
 119 #ifdef TARGET_ARCH_aarch64
 120 # include "c1_globals_aarch64.hpp"
 121 #endif
 122 #ifdef TARGET_OS_FAMILY_linux
 123 # include "c1_globals_linux.hpp"
 124 #endif
 125 #ifdef TARGET_OS_FAMILY_solaris
 126 # include "c1_globals_solaris.hpp"
 127 #endif
 128 #ifdef TARGET_OS_FAMILY_windows
 129 # include "c1_globals_windows.hpp"
 130 #endif
 131 #ifdef TARGET_OS_FAMILY_aix
 132 # include "c1_globals_aix.hpp"
 133 #endif
 134 #ifdef TARGET_OS_FAMILY_bsd
 135 # include "c1_globals_bsd.hpp"
 136 #endif
 137 #ifdef TARGET_ARCH_ppc
 138 # include "c1_globals_ppc.hpp"
 139 #endif
 140 #endif
 141 #ifdef COMPILER2
 142 #ifdef TARGET_ARCH_x86
 143 # include "c2_globals_x86.hpp"
 144 #endif
 145 #ifdef TARGET_ARCH_sparc
 146 # include "c2_globals_sparc.hpp"
 147 #endif
 148 #ifdef TARGET_ARCH_arm
 149 # include "c2_globals_arm.hpp"
 150 #endif
 151 #ifdef TARGET_ARCH_ppc
 152 # include "c2_globals_ppc.hpp"
 153 #endif
 154 #ifdef TARGET_ARCH_aarch64
 155 # include "c2_globals_aarch64.hpp"
 156 #endif
 157 #ifdef TARGET_OS_FAMILY_linux
 158 # include "c2_globals_linux.hpp"
 159 #endif
 160 #ifdef TARGET_OS_FAMILY_solaris
 161 # include "c2_globals_solaris.hpp"
 162 #endif
 163 #ifdef TARGET_OS_FAMILY_windows
 164 # include "c2_globals_windows.hpp"
 165 #endif
 166 #ifdef TARGET_OS_FAMILY_aix
 167 # include "c2_globals_aix.hpp"
 168 #endif
 169 #ifdef TARGET_OS_FAMILY_bsd
 170 # include "c2_globals_bsd.hpp"
 171 #endif
 172 #endif
 173 #ifdef SHARK
 174 #ifdef TARGET_ARCH_zero
 175 # include "shark_globals_zero.hpp"
 176 #endif
 177 #endif
 178 
 179 #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !defined(SHARK)
 180 define_pd_global(bool, BackgroundCompilation,        false);
 181 define_pd_global(bool, UseTLAB,                      false);
 182 define_pd_global(bool, CICompileOSR,                 false);
 183 define_pd_global(bool, UseTypeProfile,               false);
 184 define_pd_global(bool, UseOnStackReplacement,        false);
 185 define_pd_global(bool, InlineIntrinsics,             false);
 186 define_pd_global(bool, PreferInterpreterNativeStubs, true);
 187 define_pd_global(bool, ProfileInterpreter,           false);
 188 define_pd_global(bool, ProfileTraps,                 false);
 189 define_pd_global(bool, TieredCompilation,            false);
 190 
 191 define_pd_global(intx, CompileThreshold,             0);
 192 
 193 define_pd_global(intx, OnStackReplacePercentage,     0);
 194 define_pd_global(bool, ResizeTLAB,                   false);
 195 define_pd_global(intx, FreqInlineSize,               0);
 196 define_pd_global(size_t, NewSizeThreadIncrease,      4*K);
 197 define_pd_global(intx, InlineClassNatives,           true);
 198 define_pd_global(intx, InlineUnsafeOps,              true);
 199 define_pd_global(intx, InitialCodeCacheSize,         160*K);
 200 define_pd_global(intx, ReservedCodeCacheSize,        32*M);
 201 define_pd_global(intx, NonProfiledCodeHeapSize,      0);
 202 define_pd_global(intx, ProfiledCodeHeapSize,         0);
 203 define_pd_global(intx, NonNMethodCodeHeapSize,       32*M);
 204 
 205 define_pd_global(intx, CodeCacheExpansionSize,       32*K);
 206 define_pd_global(intx, CodeCacheMinBlockLength,      1);
 207 define_pd_global(intx, CodeCacheMinimumUseSpace,     200*K);
 208 define_pd_global(size_t, MetaspaceSize,              ScaleForWordSize(4*M));
 209 define_pd_global(bool, NeverActAsServerClassMachine, true);
 210 define_pd_global(uint64_t,MaxRAM,                    1ULL*G);
 211 #define CI_COMPILER_COUNT 0
 212 #else
 213 
 214 #ifdef COMPILER2
 215 #define CI_COMPILER_COUNT 2
 216 #else
 217 #define CI_COMPILER_COUNT 1
 218 #endif // COMPILER2
 219 
 220 #endif // no compilers
 221 
 222 // string type aliases used only in this file
 223 typedef const char* ccstr;
 224 typedef const char* ccstrlist;   // represents string arguments which accumulate
 225 
 226 struct Flag {
 227   enum Flags {
 228     // value origin
 229     DEFAULT          = 0,
 230     COMMAND_LINE     = 1,
 231     ENVIRON_VAR      = 2,
 232     CONFIG_FILE      = 3,
 233     MANAGEMENT       = 4,
 234     ERGONOMIC        = 5,
 235     ATTACH_ON_DEMAND = 6,
 236     INTERNAL         = 7,
 237 
 238     LAST_VALUE_ORIGIN = INTERNAL,
 239     VALUE_ORIGIN_BITS = 4,
 240     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 241 
 242     // flag kind
 243     KIND_PRODUCT            = 1 &lt;&lt; 4,
 244     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 245     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 246     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 247     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 248     KIND_DEVELOP            = 1 &lt;&lt; 9,
 249     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 250     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 251     KIND_C1                 = 1 &lt;&lt; 12,
 252     KIND_C2                 = 1 &lt;&lt; 13,
 253     KIND_ARCH               = 1 &lt;&lt; 14,
 254     KIND_SHARK              = 1 &lt;&lt; 15,
 255     KIND_LP64_PRODUCT       = 1 &lt;&lt; 16,
 256     KIND_COMMERCIAL         = 1 &lt;&lt; 17,
 257 
 258     KIND_MASK = ~VALUE_ORIGIN_MASK
 259   };
 260 
 261   enum Error {
 262     // no error
 263     SUCCESS = 0,
 264     // flag name is missing
 265     MISSING_NAME,
 266     // flag value is missing
 267     MISSING_VALUE,
 268     // error parsing the textual form of the value
 269     WRONG_FORMAT,
 270     // flag is not writeable
 271     NON_WRITABLE,
 272     // flag value is outside of its bounds
 273     OUT_OF_BOUNDS,
 274     // flag value violates its constraint
 275     VIOLATES_CONSTRAINT,
 276     // there is no flag with the given name
 277     INVALID_FLAG,
 278     // other, unspecified error related to setting the flag
 279     ERR_OTHER
 280   };
 281 
 282   const char* _type;
 283   const char* _name;
 284   void* _addr;
 285   NOT_PRODUCT(const char* _doc;)
 286   Flags _flags;
 287 
 288   // points to all Flags static array
 289   static Flag* flags;
 290 
 291   // number of flags
 292   static size_t numFlags;
 293 
 294   static Flag* find_flag(const char* name) { return find_flag(name, strlen(name), true, true); };
 295   static Flag* find_flag(const char* name, size_t length, bool allow_locked = false, bool return_flag = false);
 296   static Flag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
 297 
 298   void check_writable();
 299 
 300   bool is_bool() const;
 301   bool get_bool() const;
 302   void set_bool(bool value);
 303 
 304   bool is_int() const;
 305   int get_int() const;
 306   void set_int(int value);
 307 
 308   bool is_uint() const;
 309   uint get_uint() const;
 310   void set_uint(uint value);
 311 
 312   bool is_intx() const;
 313   intx get_intx() const;
 314   void set_intx(intx value);
 315 
 316   bool is_uintx() const;
 317   uintx get_uintx() const;
 318   void set_uintx(uintx value);
 319 
 320   bool is_uint64_t() const;
 321   uint64_t get_uint64_t() const;
 322   void set_uint64_t(uint64_t value);
 323 
 324   bool is_size_t() const;
 325   size_t get_size_t() const;
 326   void set_size_t(size_t value);
 327 
 328   bool is_double() const;
 329   double get_double() const;
 330   void set_double(double value);
 331 
 332   bool is_ccstr() const;
 333   bool ccstr_accumulates() const;
 334   ccstr get_ccstr() const;
 335   void set_ccstr(ccstr value);
 336 
 337   Flags get_origin();
 338   void set_origin(Flags origin);
 339 
 340   bool is_default();
 341   bool is_ergonomic();
 342   bool is_command_line();
 343 
 344   bool is_product() const;
 345   bool is_manageable() const;
 346   bool is_diagnostic() const;
 347   bool is_experimental() const;
 348   bool is_notproduct() const;
 349   bool is_develop() const;
 350   bool is_read_write() const;
 351   bool is_commercial() const;
 352 
 353   bool is_constant_in_binary() const;
 354 
 355   bool is_unlocker() const;
 356   bool is_unlocked() const;
 357   bool is_writeable() const;
 358   bool is_external() const;
 359 
 360   bool is_unlocker_ext() const;
 361   bool is_unlocked_ext() const;
 362   bool is_writeable_ext() const;
 363   bool is_external_ext() const;
 364 
 365   void unlock_diagnostic();
 366 
 367   void get_locked_message(char*, int) const;
 368   void get_locked_message_ext(char*, int) const;
 369 
 370   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 371   void print_on(outputStream* st, bool withComments = false, bool printRanges = false);
 372   void print_kind(outputStream* st);
 373   void print_as_flag(outputStream* st);
 374 
 375   static const char* flag_error_str(Flag::Error error);
 376 };
 377 
 378 // debug flags control various aspects of the VM and are global accessible
 379 
 380 // use FlagSetting to temporarily change some debug flag
 381 // e.g. FlagSetting fs(DebugThisAndThat, true);
 382 // restored to previous value upon leaving scope
 383 class FlagSetting {
 384   bool val;
 385   bool* flag;
 386  public:
 387   FlagSetting(bool&amp; fl, bool newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 388   ~FlagSetting()                       { *flag = val; }
 389 };
 390 
 391 
 392 class CounterSetting {
 393   intx* counter;
 394  public:
 395   CounterSetting(intx* cnt) { counter = cnt; (*counter)++; }
 396   ~CounterSetting()         { (*counter)--; }
 397 };
 398 
 399 class IntFlagSetting {
 400   int val;
 401   int* flag;
 402  public:
 403   IntFlagSetting(int&amp; fl, int newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 404   ~IntFlagSetting()                     { *flag = val; }
 405 };
 406 
 407 class UIntFlagSetting {
 408   uint val;
 409   uint* flag;
 410  public:
 411   UIntFlagSetting(uint&amp; fl, uint newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 412   ~UIntFlagSetting()                       { *flag = val; }
 413 };
 414 
 415 class UIntXFlagSetting {
 416   uintx val;
 417   uintx* flag;
 418  public:
 419   UIntXFlagSetting(uintx&amp; fl, uintx newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 420   ~UIntXFlagSetting()                         { *flag = val; }
 421 };
 422 
 423 class DoubleFlagSetting {
 424   double val;
 425   double* flag;
 426  public:
 427   DoubleFlagSetting(double&amp; fl, double newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 428   ~DoubleFlagSetting()                           { *flag = val; }
 429 };
 430 
 431 class SizeTFlagSetting {
 432   size_t val;
 433   size_t* flag;
 434  public:
 435   SizeTFlagSetting(size_t&amp; fl, size_t newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 436   ~SizeTFlagSetting()                           { *flag = val; }
 437 };
 438 
 439 
 440 class CommandLineFlags {
 441 public:
 442   static Flag::Error boolAt(const char* name, size_t len, bool* value, bool allow_locked = false, bool return_flag = false);
 443   static Flag::Error boolAt(const char* name, bool* value, bool allow_locked = false, bool return_flag = false)      { return boolAt(name, strlen(name), value, allow_locked, return_flag); }
 444   static Flag::Error boolAtPut(const char* name, size_t len, bool* value, Flag::Flags origin);
 445   static Flag::Error boolAtPut(const char* name, bool* value, Flag::Flags origin)   { return boolAtPut(name, strlen(name), value, origin); }
 446 
 447   static Flag::Error intAt(const char* name, size_t len, int* value, bool allow_locked = false, bool return_flag = false);
 448   static Flag::Error intAt(const char* name, int* value, bool allow_locked = false, bool return_flag = false)      { return intAt(name, strlen(name), value, allow_locked, return_flag); }
 449   static Flag::Error intAtPut(const char* name, size_t len, int* value, Flag::Flags origin);
 450   static Flag::Error intAtPut(const char* name, int* value, Flag::Flags origin)   { return intAtPut(name, strlen(name), value, origin); }
 451 
 452   static Flag::Error uintAt(const char* name, size_t len, uint* value, bool allow_locked = false, bool return_flag = false);
 453   static Flag::Error uintAt(const char* name, uint* value, bool allow_locked = false, bool return_flag = false)      { return uintAt(name, strlen(name), value, allow_locked, return_flag); }
 454   static Flag::Error uintAtPut(const char* name, size_t len, uint* value, Flag::Flags origin);
 455   static Flag::Error uintAtPut(const char* name, uint* value, Flag::Flags origin)   { return uintAtPut(name, strlen(name), value, origin); }
 456 
 457   static Flag::Error intxAt(const char* name, size_t len, intx* value, bool allow_locked = false, bool return_flag = false);
 458   static Flag::Error intxAt(const char* name, intx* value, bool allow_locked = false, bool return_flag = false)      { return intxAt(name, strlen(name), value, allow_locked, return_flag); }
 459   static Flag::Error intxAtPut(const char* name, size_t len, intx* value, Flag::Flags origin);
 460   static Flag::Error intxAtPut(const char* name, intx* value, Flag::Flags origin)   { return intxAtPut(name, strlen(name), value, origin); }
 461 
 462   static Flag::Error uintxAt(const char* name, size_t len, uintx* value, bool allow_locked = false, bool return_flag = false);
 463   static Flag::Error uintxAt(const char* name, uintx* value, bool allow_locked = false, bool return_flag = false)    { return uintxAt(name, strlen(name), value, allow_locked, return_flag); }
 464   static Flag::Error uintxAtPut(const char* name, size_t len, uintx* value, Flag::Flags origin);
 465   static Flag::Error uintxAtPut(const char* name, uintx* value, Flag::Flags origin) { return uintxAtPut(name, strlen(name), value, origin); }
 466 
 467   static Flag::Error size_tAt(const char* name, size_t len, size_t* value, bool allow_locked = false, bool return_flag = false);
 468   static Flag::Error size_tAt(const char* name, size_t* value, bool allow_locked = false, bool return_flag = false)    { return size_tAt(name, strlen(name), value, allow_locked, return_flag); }
 469   static Flag::Error size_tAtPut(const char* name, size_t len, size_t* value, Flag::Flags origin);
 470   static Flag::Error size_tAtPut(const char* name, size_t* value, Flag::Flags origin) { return size_tAtPut(name, strlen(name), value, origin); }
 471 
 472   static Flag::Error uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked = false, bool return_flag = false);
 473   static Flag::Error uint64_tAt(const char* name, uint64_t* value, bool allow_locked = false, bool return_flag = false) { return uint64_tAt(name, strlen(name), value, allow_locked, return_flag); }
 474   static Flag::Error uint64_tAtPut(const char* name, size_t len, uint64_t* value, Flag::Flags origin);
 475   static Flag::Error uint64_tAtPut(const char* name, uint64_t* value, Flag::Flags origin) { return uint64_tAtPut(name, strlen(name), value, origin); }
 476 
 477   static Flag::Error doubleAt(const char* name, size_t len, double* value, bool allow_locked = false, bool return_flag = false);
 478   static Flag::Error doubleAt(const char* name, double* value, bool allow_locked = false, bool return_flag = false)    { return doubleAt(name, strlen(name), value, allow_locked, return_flag); }
 479   static Flag::Error doubleAtPut(const char* name, size_t len, double* value, Flag::Flags origin);
 480   static Flag::Error doubleAtPut(const char* name, double* value, Flag::Flags origin) { return doubleAtPut(name, strlen(name), value, origin); }
 481 
 482   static Flag::Error ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked = false, bool return_flag = false);
 483   static Flag::Error ccstrAt(const char* name, ccstr* value, bool allow_locked = false, bool return_flag = false)    { return ccstrAt(name, strlen(name), value, allow_locked, return_flag); }
 484   // Contract:  Flag will make private copy of the incoming value.
 485   // Outgoing value is always malloc-ed, and caller MUST call free.
 486   static Flag::Error ccstrAtPut(const char* name, size_t len, ccstr* value, Flag::Flags origin);
 487   static Flag::Error ccstrAtPut(const char* name, ccstr* value, Flag::Flags origin) { return ccstrAtPut(name, strlen(name), value, origin); }
 488 
 489   // Returns false if name is not a command line flag.
 490   static bool wasSetOnCmdline(const char* name, bool* value);
 491   static void printSetFlags(outputStream* out);
 492 
 493   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 494   static void printFlags(outputStream* out, bool withComments, bool printRanges = false);
 495 
 496   static void verify() PRODUCT_RETURN;
 497 };
 498 
 499 // use this for flags that are true by default in the debug version but
 500 // false in the optimized version, and vice versa
 501 #ifdef ASSERT
 502 #define trueInDebug  true
 503 #define falseInDebug false
 504 #else
 505 #define trueInDebug  false
 506 #define falseInDebug true
 507 #endif
 508 
 509 // use this for flags that are true per default in the product build
 510 // but false in development builds, and vice versa
 511 #ifdef PRODUCT
 512 #define trueInProduct  true
 513 #define falseInProduct false
 514 #else
 515 #define trueInProduct  false
 516 #define falseInProduct true
 517 #endif
 518 
 519 #ifdef JAVASE_EMBEDDED
 520 #define falseInEmbedded false
 521 #else
 522 #define falseInEmbedded true
 523 #endif
 524 
 525 // develop flags are settable / visible only during development and are constant in the PRODUCT version
 526 // product flags are always settable / visible
 527 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
 528 
 529 // A flag must be declared with one of the following types:
 530 // bool, intx, uintx, size_t, ccstr, double, or uint64_t.
 531 // The type "ccstr" is an alias for "const char*" and is used
 532 // only in this file, because the macrology requires single-token type names.
 533 
 534 // Note: Diagnostic options not meant for VM tuning or for product modes.
 535 // They are to be used for VM quality assurance or field diagnosis
 536 // of VM bugs.  They are hidden so that users will not be encouraged to
 537 // try them as if they were VM ordinary execution options.  However, they
 538 // are available in the product version of the VM.  Under instruction
 539 // from support engineers, VM customers can turn them on to collect
 540 // diagnostic information about VM problems.  To use a VM diagnostic
 541 // option, you must first specify +UnlockDiagnosticVMOptions.
 542 // (This master switch also affects the behavior of -Xprintflags.)
 543 //
 544 // experimental flags are in support of features that are not
 545 //    part of the officially supported product, but are available
 546 //    for experimenting with. They could, for example, be performance
 547 //    features that may not have undergone full or rigorous QA, but which may
 548 //    help performance in some cases and released for experimentation
 549 //    by the community of users and developers. This flag also allows one to
 550 //    be able to build a fully supported product that nonetheless also
 551 //    ships with some unsupported, lightly tested, experimental features.
 552 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
 553 //    UnlockExperimentalVMOptions flag, which allows the control and
 554 //    modification of the experimental flags.
 555 //
 556 // Nota bene: neither diagnostic nor experimental options should be used casually,
 557 //    and they are not supported on production loads, except under explicit
 558 //    direction from support engineers.
 559 //
 560 // manageable flags are writeable external product flags.
 561 //    They are dynamically writeable through the JDK management interface
 562 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
 563 //    These flags are external exported interface (see CCC).  The list of
 564 //    manageable flags can be queried programmatically through the management
 565 //    interface.
 566 //
 567 //    A flag can be made as "manageable" only if
 568 //    - the flag is defined in a CCC as an external exported interface.
 569 //    - the VM implementation supports dynamic setting of the flag.
 570 //      This implies that the VM must *always* query the flag variable
 571 //      and not reuse state related to the flag state at any given time.
 572 //    - you want the flag to be queried programmatically by the customers.
 573 //
 574 // product_rw flags are writeable internal product flags.
 575 //    They are like "manageable" flags but for internal/private use.
 576 //    The list of product_rw flags are internal/private flags which
 577 //    may be changed/removed in a future release.  It can be set
 578 //    through the management interface to get/set value
 579 //    when the name of flag is supplied.
 580 //
 581 //    A flag can be made as "product_rw" only if
 582 //    - the VM implementation supports dynamic setting of the flag.
 583 //      This implies that the VM must *always* query the flag variable
 584 //      and not reuse state related to the flag state at any given time.
 585 //
 586 // Note that when there is a need to support develop flags to be writeable,
 587 // it can be done in the same way as product_rw.
 588 //
 589 // range is a macro that will expand to min and max arguments for range
 590 //    checking code if provided - see commandLineFlagRangeList.hpp
 591 //
 592 // constraint is a macro that will expand to custom function call
 593 //    for constraint checking if provided - see commandLineFlagConstraintList.hpp
 594 //
 595 
 596 #define RUNTIME_FLAGS(develop, develop_pd, product, product_pd, diagnostic, experimental, notproduct, manageable, product_rw, lp64_product, range, constraint) \
 597                                                                             \
 598   lp64_product(bool, UseCompressedOops, false,                              \
 599           "Use 32-bit object references in 64-bit VM. "                     \
 600           "lp64_product means flag is always constant in 32 bit VM")        \
 601                                                                             \
 602   lp64_product(bool, UseCompressedClassPointers, false,                     \
 603           "Use 32-bit class pointers in 64-bit VM. "                        \
 604           "lp64_product means flag is always constant in 32 bit VM")        \
 605                                                                             \
 606   notproduct(bool, CheckCompressedOops, true,                               \
 607           "Generate checks in encoding/decoding code in debug VM")          \
 608                                                                             \
 609   product_pd(size_t, HeapBaseMinAddress,                                    \
 610           "OS specific low limit for heap base address")                    \
 611                                                                             \
 612   product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
 613           "Heap allocation steps through preferred address regions to find" \
 614           " where it can allocate the heap. Number of steps to take per "   \
 615           "region.")                                                        \
 616           range(1, max_uintx)                                               \
 617                                                                             \
 618   diagnostic(bool, PrintCompressedOopsMode, false,                          \
 619           "Print compressed oops base address and encoding mode")           \
 620                                                                             \
 621   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 622           "Default object alignment in bytes, 8 is minimum")                \
 623           range(8, 256)                                                     \
 624           constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
 625                                                                             \
 626   product(bool, AssumeMP, false,                                            \
 627           "Instruct the VM to assume multiple processors are available")    \
 628                                                                             \
 629   /* UseMembar is theoretically a temp flag used for memory barrier      */ \
 630   /* removal testing.  It was supposed to be removed before FCS but has  */ \
 631   /* been re-added (see 6401008)                                         */ \
 632   product_pd(bool, UseMembar,                                               \
 633           "(Unstable) Issues membars on thread state transitions")          \
 634                                                                             \
 635   develop(bool, CleanChunkPoolAsync, falseInEmbedded,                       \
 636           "Clean the chunk pool asynchronously")                            \
 637                                                                             \
 638   experimental(bool, AlwaysSafeConstructors, false,                         \
 639           "Force safe construction, as if all fields are final.")           \
 640                                                                             \
 641   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 642           "Enable normal processing of flags relating to field diagnostics")\
 643                                                                             \
 644   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 645           "Enable normal processing of flags relating to experimental "     \
 646           "features")                                                       \
 647                                                                             \
 648   product(bool, JavaMonitorsInStackTrace, true,                             \
 649           "Print information about Java monitor locks when the stacks are"  \
 650           "dumped")                                                         \
 651                                                                             \
 652   product_pd(bool, UseLargePages,                                           \
 653           "Use large page memory")                                          \
 654                                                                             \
 655   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 656           "Allocate large pages individually for better affinity")          \
 657                                                                             \
 658   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 659           "Fail large pages individual allocation")                         \
 660                                                                             \
 661   product(bool, UseLargePagesInMetaspace, false,                            \
 662           "Use large page memory in metaspace. "                            \
 663           "Only used if UseLargePages is enabled.")                         \
 664                                                                             \
 665   develop(bool, TracePageSizes, false,                                      \
 666           "Trace page size selection and usage")                            \
 667                                                                             \
 668   product(bool, UseNUMA, false,                                             \
 669           "Use NUMA if available")                                          \
 670                                                                             \
 671   product(bool, UseNUMAInterleaving, false,                                 \
 672           "Interleave memory across NUMA nodes if available")               \
 673                                                                             \
 674   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 675           "Granularity to use for NUMA interleaving on Windows OS")         \
 676                                                                             \
 677   product(bool, ForceNUMA, false,                                           \
 678           "Force NUMA optimizations on single-node/UMA systems")            \
 679                                                                             \
 680   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 681           "Percentage (0-100) used to weight the current sample when "      \
 682           "computing exponentially decaying average for "                   \
 683           "AdaptiveNUMAChunkSizing")                                        \
 684           range(0, 100)                                                     \
 685                                                                             \
 686   product(size_t, NUMASpaceResizeRate, 1*G,                                 \
 687           "Do not reallocate more than this amount per collection")         \
 688                                                                             \
 689   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 690           "Enable adaptive chunk sizing for NUMA")                          \
 691                                                                             \
 692   product(bool, NUMAStats, false,                                           \
 693           "Print NUMA stats in detailed heap information")                  \
 694                                                                             \
 695   product(uintx, NUMAPageScanRate, 256,                                     \
 696           "Maximum number of pages to include in the page scan procedure")  \
 697                                                                             \
 698   product_pd(bool, NeedsDeoptSuspend,                                       \
 699           "True for register window machines (sparc/ia64)")                 \
 700                                                                             \
 701   product(intx, UseSSE, 99,                                                 \
 702           "Highest supported SSE instructions set on x86/x64")              \
 703                                                                             \
 704   product(bool, UseAES, false,                                              \
 705           "Control whether AES instructions can be used on x86/x64")        \
 706                                                                             \
 707   product(bool, UseSHA, false,                                              \
 708           "Control whether SHA instructions can be used "                   \
 709           "on SPARC and on ARM")                                            \
 710                                                                             \
 711   product(bool, UseGHASHIntrinsics, false,                                  \
 712           "Use intrinsics for GHASH versions of crypto")                    \
 713                                                                             \
 714   product(size_t, LargePageSizeInBytes, 0,                                  \
 715           "Large page size (0 to let VM choose the page size)")             \
 716                                                                             \
 717   product(size_t, LargePageHeapSizeThreshold, 128*M,                        \
 718           "Use large pages if maximum heap is at least this big")           \
 719                                                                             \
 720   product(bool, ForceTimeHighResolution, false,                             \
 721           "Using high time resolution (for Win32 only)")                    \
 722                                                                             \
 723   develop(bool, TraceItables, false,                                        \
 724           "Trace initialization and use of itables")                        \
 725                                                                             \
 726   develop(bool, TracePcPatching, false,                                     \
 727           "Trace usage of frame::patch_pc")                                 \
 728                                                                             \
 729   develop(bool, TraceJumps, false,                                          \
 730           "Trace assembly jumps in thread ring buffer")                     \
 731                                                                             \
 732   develop(bool, TraceRelocator, false,                                      \
 733           "Trace the bytecode relocator")                                   \
 734                                                                             \
 735   develop(bool, TraceLongCompiles, false,                                   \
 736           "Print out every time compilation is longer than "                \
 737           "a given threshold")                                              \
 738                                                                             \
 739   develop(bool, SafepointALot, false,                                       \
 740           "Generate a lot of safepoints. This works with "                  \
 741           "GuaranteedSafepointInterval")                                    \
 742                                                                             \
 743   product_pd(bool, BackgroundCompilation,                                   \
 744           "A thread requesting compilation is not blocked during "          \
 745           "compilation")                                                    \
 746                                                                             \
 747   product(bool, PrintVMQWaitTime, false,                                    \
 748           "Print out the waiting time in VM operation queue")               \
 749                                                                             \
 750   develop(bool, TraceOopMapGeneration, false,                               \
 751           "Show OopMapGeneration")                                          \
 752                                                                             \
 753   product(bool, MethodFlushing, true,                                       \
 754           "Reclamation of zombie and not-entrant methods")                  \
 755                                                                             \
 756   develop(bool, VerifyStack, false,                                         \
 757           "Verify stack of each thread when it is entering a runtime call") \
 758                                                                             \
 759   diagnostic(bool, ForceUnreachable, false,                                 \
 760           "Make all non code cache addresses to be unreachable by "         \
 761           "forcing use of 64bit literal fixups")                            \
 762                                                                             \
 763   notproduct(bool, StressDerivedPointers, false,                            \
 764           "Force scavenge when a derived pointer is detected on stack "     \
 765           "after rtm call")                                                 \
 766                                                                             \
 767   develop(bool, TraceDerivedPointers, false,                                \
 768           "Trace traversal of derived pointers on stack")                   \
 769                                                                             \
 770   notproduct(bool, TraceCodeBlobStacks, false,                              \
 771           "Trace stack-walk of codeblobs")                                  \
 772                                                                             \
 773   product(bool, PrintJNIResolving, false,                                   \
 774           "Used to implement -v:jni")                                       \
 775                                                                             \
 776   notproduct(bool, PrintRewrites, false,                                    \
 777           "Print methods that are being rewritten")                         \
 778                                                                             \
 779   product(bool, UseInlineCaches, true,                                      \
 780           "Use Inline Caches for virtual calls ")                           \
 781                                                                             \
 782   develop(bool, InlineArrayCopy, true,                                      \
 783           "Inline arraycopy native that is known to be part of "            \
 784           "base library DLL")                                               \
 785                                                                             \
 786   develop(bool, InlineObjectHash, true,                                     \
 787           "Inline Object::hashCode() native that is known to be part "      \
 788           "of base library DLL")                                            \
 789                                                                             \
 790   develop(bool, InlineNatives, true,                                        \
 791           "Inline natives that are known to be part of base library DLL")   \
 792                                                                             \
 793   develop(bool, InlineMathNatives, true,                                    \
 794           "Inline SinD, CosD, etc.")                                        \
 795                                                                             \
 796   develop(bool, InlineClassNatives, true,                                   \
 797           "Inline Class.isInstance, etc")                                   \
 798                                                                             \
 799   develop(bool, InlineThreadNatives, true,                                  \
 800           "Inline Thread.currentThread, etc")                               \
 801                                                                             \
 802   develop(bool, InlineUnsafeOps, true,                                      \
 803           "Inline memory ops (native methods) from sun.misc.Unsafe")        \
 804                                                                             \
 805   product(bool, CriticalJNINatives, true,                                   \
 806           "Check for critical JNI entry points")                            \
 807                                                                             \
 808   notproduct(bool, StressCriticalJNINatives, false,                         \
 809           "Exercise register saving code in critical natives")              \
 810                                                                             \
 811   product(bool, UseSSE42Intrinsics, false,                                  \
 812           "SSE4.2 versions of intrinsics")                                  \
 813                                                                             \
 814   product(bool, UseAESIntrinsics, false,                                    \
 815           "Use intrinsics for AES versions of crypto")                      \
 816                                                                             \
 817   product(bool, UseSHA1Intrinsics, false,                                   \
 818           "Use intrinsics for SHA-1 crypto hash function. "                 \
 819           "Requires that UseSHA is enabled.")                               \
 820                                                                             \
 821   product(bool, UseSHA256Intrinsics, false,                                 \
 822           "Use intrinsics for SHA-224 and SHA-256 crypto hash functions. "  \
 823           "Requires that UseSHA is enabled.")                               \
 824                                                                             \
 825   product(bool, UseSHA512Intrinsics, false,                                 \
 826           "Use intrinsics for SHA-384 and SHA-512 crypto hash functions. "  \
 827           "Requires that UseSHA is enabled.")                               \
 828                                                                             \
 829   product(bool, UseCRC32Intrinsics, false,                                  \
 830           "use intrinsics for java.util.zip.CRC32")                         \
 831                                                                             \
 832   product(bool, UseCRC32CIntrinsics, false,                                 \
 833           "use intrinsics for java.util.zip.CRC32C")                        \
 834                                                                             \
 835   product(bool, UseAdler32Intrinsics, false,                                \
 836           "use intrinsics for java.util.zip.Adler32")                       \
 837                                                                             \
 838   diagnostic(ccstrlist, DisableIntrinsic, "",                               \
 839          "do not expand intrinsics whose (internal) names appear here")     \
 840                                                                             \
<a name="1" id="anc1"></a><span class="new"> 841   product(bool, UseSpinLoopHintIntrinsic, false,                            \</span>
<span class="new"> 842           "Use intrinsics for spinLoopHint")                                \</span>
<span class="new"> 843                                                                             \</span>
 844   develop(bool, TraceCallFixup, false,                                      \
 845           "Trace all call fixups")                                          \
 846                                                                             \
 847   develop(bool, DeoptimizeALot, false,                                      \
 848           "Deoptimize at every exit from the runtime system")               \
 849                                                                             \
 850   notproduct(ccstrlist, DeoptimizeOnlyAt, "",                               \
 851           "A comma separated list of bcis to deoptimize at")                \
 852                                                                             \
 853   product(bool, DeoptimizeRandom, false,                                    \
 854           "Deoptimize random frames on random exit from the runtime system")\
 855                                                                             \
 856   notproduct(bool, ZombieALot, false,                                       \
 857           "Create zombies (non-entrant) at exit from the runtime system")   \
 858                                                                             \
 859   product(bool, UnlinkSymbolsALot, false,                                   \
 860           "Unlink unreferenced symbols from the symbol table at safepoints")\
 861                                                                             \
 862   notproduct(bool, WalkStackALot, false,                                    \
 863           "Trace stack (no print) at every exit from the runtime system")   \
 864                                                                             \
 865   product(bool, Debugging, false,                                           \
 866           "Set when executing debug methods in debug.cpp "                  \
 867           "(to prevent triggering assertions)")                             \
 868                                                                             \
 869   notproduct(bool, StrictSafepointChecks, trueInDebug,                      \
 870           "Enable strict checks that safepoints cannot happen for threads " \
 871           "that use No_Safepoint_Verifier")                                 \
 872                                                                             \
 873   notproduct(bool, VerifyLastFrame, false,                                  \
 874           "Verify oops on last frame on entry to VM")                       \
 875                                                                             \
 876   develop(bool, TraceHandleAllocation, false,                               \
 877           "Print out warnings when suspiciously many handles are allocated")\
 878                                                                             \
 879   product(bool, FailOverToOldVerifier, true,                                \
 880           "Fail over to old verifier when split verifier fails")            \
 881                                                                             \
 882   develop(bool, ShowSafepointMsgs, false,                                   \
 883           "Show message about safepoint synchronization")                   \
 884                                                                             \
 885   product(bool, SafepointTimeout, false,                                    \
 886           "Time out and warn or fail after SafepointTimeoutDelay "          \
 887           "milliseconds if failed to reach safepoint")                      \
 888                                                                             \
 889   develop(bool, DieOnSafepointTimeout, false,                               \
 890           "Die upon failure to reach safepoint (see SafepointTimeout)")     \
 891                                                                             \
 892   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 893   /* typically, at most a few retries are needed                    */      \
 894   product(intx, SuspendRetryCount, 50,                                      \
 895           "Maximum retry count for an external suspend request")            \
 896                                                                             \
 897   product(intx, SuspendRetryDelay, 5,                                       \
 898           "Milliseconds to delay per retry (* current_retry_count)")        \
 899                                                                             \
 900   product(bool, AssertOnSuspendWaitFailure, false,                          \
 901           "Assert/Guarantee on external suspend wait failure")              \
 902                                                                             \
 903   product(bool, TraceSuspendWaitFailures, false,                            \
 904           "Trace external suspend wait failures")                           \
 905                                                                             \
 906   product(bool, MaxFDLimit, true,                                           \
 907           "Bump the number of file descriptors to maximum in Solaris")      \
 908                                                                             \
 909   diagnostic(bool, LogEvents, true,                                         \
 910           "Enable the various ring buffer event logs")                      \
 911                                                                             \
 912   diagnostic(uintx, LogEventsBufferEntries, 10,                             \
 913           "Number of ring buffer event logs")                               \
 914           range(1, NOT_LP64(1*K) LP64_ONLY(1*M))                            \
 915                                                                             \
 916   product(bool, BytecodeVerificationRemote, true,                           \
 917           "Enable the Java bytecode verifier for remote classes")           \
 918                                                                             \
 919   product(bool, BytecodeVerificationLocal, false,                           \
 920           "Enable the Java bytecode verifier for local classes")            \
 921                                                                             \
 922   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 923           "Force exceptions on FP stack under/overflow")                    \
 924                                                                             \
 925   develop(bool, VerifyStackAtCalls, false,                                  \
 926           "Verify that the stack pointer is unchanged after calls")         \
 927                                                                             \
 928   develop(bool, TraceJavaAssertions, false,                                 \
 929           "Trace java language assertions")                                 \
 930                                                                             \
 931   notproduct(bool, CheckAssertionStatusDirectives, false,                   \
 932           "Temporary - see javaClasses.cpp")                                \
 933                                                                             \
 934   notproduct(bool, PrintMallocFree, false,                                  \
 935           "Trace calls to C heap malloc/free allocation")                   \
 936                                                                             \
 937   product(bool, PrintOopAddress, false,                                     \
 938           "Always print the location of the oop")                           \
 939                                                                             \
 940   notproduct(bool, VerifyCodeCache, false,                                  \
 941           "Verify code cache on memory allocation/deallocation")            \
 942                                                                             \
 943   develop(bool, ZapDeadCompiledLocals, false,                               \
 944           "Zap dead locals in compiler frames")                             \
 945                                                                             \
 946   notproduct(bool, ZapDeadLocalsOld, false,                                 \
 947           "Zap dead locals (old version, zaps all frames when "             \
 948           "entering the VM")                                                \
 949                                                                             \
 950   notproduct(bool, CheckOopishValues, false,                                \
 951           "Warn if value contains oop (requires ZapDeadLocals)")            \
 952                                                                             \
 953   develop(bool, UseMallocOnly, false,                                       \
 954           "Use only malloc/free for allocation (no resource area/arena)")   \
 955                                                                             \
 956   develop(bool, PrintMalloc, false,                                         \
 957           "Print all malloc/free calls")                                    \
 958                                                                             \
 959   develop(bool, PrintMallocStatistics, false,                               \
 960           "Print malloc/free statistics")                                   \
 961                                                                             \
 962   develop(bool, ZapResourceArea, trueInDebug,                               \
 963           "Zap freed resource/arena space with 0xABABABAB")                 \
 964                                                                             \
 965   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 966           "Zap freed VM handle space with 0xBCBCBCBC")                      \
 967                                                                             \
 968   develop(bool, ZapJNIHandleArea, trueInDebug,                              \
 969           "Zap freed JNI handle space with 0xFEFEFEFE")                     \
 970                                                                             \
 971   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 972           "Zap allocated/freed stack segments with 0xFADFADED")             \
 973                                                                             \
 974   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 975           "Zap unused heap space with 0xBAADBABE")                          \
 976                                                                             \
 977   develop(bool, TraceZapUnusedHeapArea, false,                              \
 978           "Trace zapping of unused heap space")                             \
 979                                                                             \
 980   develop(bool, CheckZapUnusedHeapArea, false,                              \
 981           "Check zapping of unused heap space")                             \
 982                                                                             \
 983   develop(bool, ZapFillerObjects, trueInDebug,                              \
 984           "Zap filler objects with 0xDEAFBABE")                             \
 985                                                                             \
 986   develop(bool, PrintVMMessages, true,                                      \
 987           "Print VM messages on console")                                   \
 988                                                                             \
 989   product(bool, PrintGCApplicationConcurrentTime, false,                    \
 990           "Print the time the application has been running")                \
 991                                                                             \
 992   product(bool, PrintGCApplicationStoppedTime, false,                       \
 993           "Print the time the application has been stopped")                \
 994                                                                             \
 995   diagnostic(bool, VerboseVerification, false,                              \
 996           "Display detailed verification details")                          \
 997                                                                             \
 998   notproduct(uintx, ErrorHandlerTest, 0,                                    \
 999           "If &gt; 0, provokes an error after VM initialization; the value "   \
1000           "determines which error to provoke. See test_error_handler() "    \
1001           "in debug.cpp.")                                                  \
1002                                                                             \
1003   notproduct(uintx, TestCrashInErrorHandler, 0,                             \
1004           "If &gt; 0, provokes an error inside VM error handler (a secondary " \
1005           "crash). see test_error_handler() in debug.cpp.")                 \
1006                                                                             \
1007   notproduct(bool, TestSafeFetchInErrorHandler, false,                      \
1008           "If true, tests SafeFetch inside error handler.")                 \
1009                                                                             \
1010   develop(bool, Verbose, false,                                             \
1011           "Print additional debugging information from other modes")        \
1012                                                                             \
1013   develop(bool, PrintMiscellaneous, false,                                  \
1014           "Print uncategorized debugging information (requires +Verbose)")  \
1015                                                                             \
1016   develop(bool, WizardMode, false,                                          \
1017           "Print much more debugging information")                          \
1018                                                                             \
1019   product(bool, ShowMessageBoxOnError, false,                               \
1020           "Keep process alive on VM fatal error")                           \
1021                                                                             \
1022   product(bool, CreateCoredumpOnCrash, true,                                \
1023           "Create core/mini dump on VM fatal error")                        \
1024                                                                             \
1025   product(uintx, ErrorLogTimeout, 2 * 60,                                   \
1026           "Timeout, in seconds, to limit the time spent on writing an "     \
1027           "error log in case of a crash.")                                  \
1028                                                                             \
1029   product_pd(bool, UseOSErrorReporting,                                     \
1030           "Let VM fatal error propagate to the OS (ie. WER on Windows)")    \
1031                                                                             \
1032   product(bool, SuppressFatalErrorMessage, false,                           \
1033           "Report NO fatal error message (avoid deadlock)")                 \
1034                                                                             \
1035   product(ccstrlist, OnError, "",                                           \
1036           "Run user-defined commands on fatal error; see VMError.cpp "      \
1037           "for examples")                                                   \
1038                                                                             \
1039   product(ccstrlist, OnOutOfMemoryError, "",                                \
1040           "Run user-defined commands on first java.lang.OutOfMemoryError")  \
1041                                                                             \
1042   manageable(bool, HeapDumpBeforeFullGC, false,                             \
1043           "Dump heap to file before any major stop-the-world GC")           \
1044                                                                             \
1045   manageable(bool, HeapDumpAfterFullGC, false,                              \
1046           "Dump heap to file after any major stop-the-world GC")            \
1047                                                                             \
1048   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
1049           "Dump heap to file when java.lang.OutOfMemoryError is thrown")    \
1050                                                                             \
1051   manageable(ccstr, HeapDumpPath, NULL,                                     \
1052           "When HeapDumpOnOutOfMemoryError is on, the path (filename or "   \
1053           "directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof "   \
1054           "in the working directory)")                                      \
1055                                                                             \
1056   develop(size_t, SegmentedHeapDumpThreshold, 2*G,                          \
1057           "Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) "     \
1058           "when the heap usage is larger than this")                        \
1059                                                                             \
1060   develop(size_t, HeapDumpSegmentSize, 1*G,                                 \
1061           "Approximate segment size when generating a segmented heap dump") \
1062                                                                             \
1063   develop(bool, BreakAtWarning, false,                                      \
1064           "Execute breakpoint upon encountering VM warning")                \
1065                                                                             \
1066   develop(bool, TraceVMOperation, false,                                    \
1067           "Trace VM operations")                                            \
1068                                                                             \
1069   develop(bool, UseFakeTimers, false,                                       \
1070           "Tell whether the VM should use system time or a fake timer")     \
1071                                                                             \
1072   product(ccstr, NativeMemoryTracking, "off",                               \
1073           "Native memory tracking options")                                 \
1074                                                                             \
1075   diagnostic(bool, PrintNMTStatistics, false,                               \
1076           "Print native memory tracking summary data if it is on")          \
1077                                                                             \
1078   diagnostic(bool, LogCompilation, false,                                   \
1079           "Log compilation activity in detail to LogFile")                  \
1080                                                                             \
1081   product(bool, PrintCompilation, false,                                    \
1082           "Print compilations")                                             \
1083                                                                             \
1084   diagnostic(bool, TraceNMethodInstalls, false,                             \
1085           "Trace nmethod installation")                                     \
1086                                                                             \
1087   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
1088           "0: do not allow scavengable oops in the code cache; "            \
1089           "1: allow scavenging from the code cache; "                       \
1090           "2: emit as many constants as the compiler can see")              \
1091           range(0, 2)                                                       \
1092                                                                             \
1093   product(bool, AlwaysRestoreFPU, false,                                    \
1094           "Restore the FPU control word after every JNI call (expensive)")  \
1095                                                                             \
1096   diagnostic(bool, PrintCompilation2, false,                                \
1097           "Print additional statistics per compilation")                    \
1098                                                                             \
1099   diagnostic(bool, PrintAdapterHandlers, false,                             \
1100           "Print code generated for i2c/c2i adapters")                      \
1101                                                                             \
1102   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
1103           "Verify that i2c/c2i adapters are called properly")               \
1104                                                                             \
1105   develop(bool, VerifyAdapterSharing, false,                                \
1106           "Verify that the code for shared adapters is the equivalent")     \
1107                                                                             \
1108   diagnostic(bool, PrintAssembly, false,                                    \
1109           "Print assembly code (using external disassembler.so)")           \
1110                                                                             \
1111   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
1112           "Print options string passed to disassembler.so")                 \
1113                                                                             \
1114   diagnostic(bool, PrintNMethods, false,                                    \
1115           "Print assembly code for nmethods when generated")                \
1116                                                                             \
1117   diagnostic(bool, PrintNativeNMethods, false,                              \
1118           "Print assembly code for native nmethods when generated")         \
1119                                                                             \
1120   develop(bool, PrintDebugInfo, false,                                      \
1121           "Print debug information for all nmethods when generated")        \
1122                                                                             \
1123   develop(bool, PrintRelocations, false,                                    \
1124           "Print relocation information for all nmethods when generated")   \
1125                                                                             \
1126   develop(bool, PrintDependencies, false,                                   \
1127           "Print dependency information for all nmethods when generated")   \
1128                                                                             \
1129   develop(bool, PrintExceptionHandlers, false,                              \
1130           "Print exception handler tables for all nmethods when generated") \
1131                                                                             \
1132   develop(bool, StressCompiledExceptionHandlers, false,                     \
1133           "Exercise compiled exception handlers")                           \
1134                                                                             \
1135   develop(bool, InterceptOSException, false,                                \
1136           "Start debugger when an implicit OS (e.g. NULL) "                 \
1137           "exception happens")                                              \
1138                                                                             \
1139   product(bool, PrintCodeCache, false,                                      \
1140           "Print the code cache memory usage when exiting")                 \
1141                                                                             \
1142   develop(bool, PrintCodeCache2, false,                                     \
1143           "Print detailed usage information on the code cache when exiting")\
1144                                                                             \
1145   product(bool, PrintCodeCacheOnCompilation, false,                         \
1146           "Print the code cache memory usage each time a method is "        \
1147           "compiled")                                                       \
1148                                                                             \
1149   diagnostic(bool, PrintStubCode, false,                                    \
1150           "Print generated stub code")                                      \
1151                                                                             \
1152   product(bool, StackTraceInThrowable, true,                                \
1153           "Collect backtrace in throwable when exception happens")          \
1154                                                                             \
1155   product(bool, OmitStackTraceInFastThrow, true,                            \
1156           "Omit backtraces for some 'hot' exceptions in optimized code")    \
1157                                                                             \
1158   product(bool, ProfilerPrintByteCodeStatistics, false,                     \
1159           "Print bytecode statistics when dumping profiler output")         \
1160                                                                             \
1161   product(bool, ProfilerRecordPC, false,                                    \
1162           "Collect ticks for each 16 byte interval of compiled code")       \
1163                                                                             \
1164   product(bool, ProfileVM, false,                                           \
1165           "Profile ticks that fall within VM (either in the VM Thread "     \
1166           "or VM code called through stubs)")                               \
1167                                                                             \
1168   product(bool, ProfileIntervals, false,                                    \
1169           "Print profiles for each interval (see ProfileIntervalsTicks)")   \
1170                                                                             \
1171   notproduct(bool, ProfilerCheckIntervals, false,                           \
1172           "Collect and print information on spacing of profiler ticks")     \
1173                                                                             \
1174   product(bool, PrintWarnings, true,                                        \
1175           "Print JVM warnings to output stream")                            \
1176                                                                             \
1177   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
1178           "Print warnings for stalled SpinLocks")                           \
1179                                                                             \
1180   product(bool, RegisterFinalizersAtInit, true,                             \
1181           "Register finalizable objects at end of Object.&lt;init&gt; or "        \
1182           "after allocation")                                               \
1183                                                                             \
1184   develop(bool, RegisterReferences, true,                                   \
1185           "Tell whether the VM should register soft/weak/final/phantom "    \
1186           "references")                                                     \
1187                                                                             \
1188   develop(bool, IgnoreRewrites, false,                                      \
1189           "Suppress rewrites of bytecodes in the oopmap generator. "        \
1190           "This is unsafe!")                                                \
1191                                                                             \
1192   develop(bool, PrintCodeCacheExtension, false,                             \
1193           "Print extension of code cache")                                  \
1194                                                                             \
1195   develop(bool, UsePrivilegedStack, true,                                   \
1196           "Enable the security JVM functions")                              \
1197                                                                             \
1198   develop(bool, ProtectionDomainVerification, true,                         \
1199           "Verify protection domain before resolution in system dictionary")\
1200                                                                             \
1201   product(bool, ClassUnloading, true,                                       \
1202           "Do unloading of classes")                                        \
1203                                                                             \
1204   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
1205           "Do unloading of classes with a concurrent marking cycle")        \
1206                                                                             \
1207   develop(bool, DisableStartThread, false,                                  \
1208           "Disable starting of additional Java threads "                    \
1209           "(for debugging only)")                                           \
1210                                                                             \
1211   develop(bool, MemProfiling, false,                                        \
1212           "Write memory usage profiling to log file")                       \
1213                                                                             \
1214   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
1215           "Print the system dictionary at exit")                            \
1216                                                                             \
1217   experimental(intx, PredictedLoadedClassCount, 0,                          \
1218           "Experimental: Tune loaded class cache starting size")            \
1219                                                                             \
1220   diagnostic(bool, UnsyncloadClass, false,                                  \
1221           "Unstable: VM calls loadClass unsynchronized. Custom "            \
1222           "class loader must call VM synchronized for findClass "           \
1223           "and defineClass.")                                               \
1224                                                                             \
1225   product(bool, AlwaysLockClassLoader, false,                               \
1226           "Require the VM to acquire the class loader lock before calling " \
1227           "loadClass() even for class loaders registering "                 \
1228           "as parallel capable")                                            \
1229                                                                             \
1230   product(bool, AllowParallelDefineClass, false,                            \
1231           "Allow parallel defineClass requests for class loaders "          \
1232           "registering as parallel capable")                                \
1233                                                                             \
1234   product(bool, MustCallLoadClassInternal, false,                           \
1235           "Call loadClassInternal() rather than loadClass()")               \
1236                                                                             \
1237   product_pd(bool, DontYieldALot,                                           \
1238           "Throw away obvious excess yield calls")                          \
1239                                                                             \
1240   product_pd(bool, ConvertSleepToYield,                                     \
1241           "Convert sleep(0) to thread yield "                               \
1242           "(may be off for Solaris to improve GUI)")                        \
1243                                                                             \
1244   product(bool, ConvertYieldToSleep, false,                                 \
1245           "Convert yield to a sleep of MinSleepInterval to simulate Win32 " \
1246           "behavior")                                                       \
1247                                                                             \
1248   develop(bool, UseDetachedThreads, true,                                   \
1249           "Use detached threads that are recycled upon termination "        \
1250           "(for Solaris only)")                                             \
1251                                                                             \
1252   product(bool, UseLWPSynchronization, true,                                \
1253           "Use LWP-based instead of libthread-based synchronization "       \
1254           "(SPARC only)")                                                   \
1255                                                                             \
1256   experimental(ccstr, SyncKnobs, NULL,                                      \
1257                "(Unstable) Various monitor synchronization tunables")       \
1258                                                                             \
1259   experimental(intx, EmitSync, 0,                                           \
1260                "(Unsafe, Unstable) "                                        \
1261                "Control emission of inline sync fast-path code")            \
1262                                                                             \
1263   product(intx, MonitorBound, 0, "Bound Monitor population")                \
1264                                                                             \
1265   product(bool, MonitorInUseLists, false, "Track Monitors for Deflation")   \
1266                                                                             \
1267   experimental(intx, SyncFlags, 0, "(Unsafe, Unstable) "                    \
1268                "Experimental Sync flags")                                   \
1269                                                                             \
1270   experimental(intx, SyncVerbose, 0, "(Unstable)")                          \
1271                                                                             \
1272   diagnostic(bool, InlineNotify, true, "intrinsify subset of notify")       \
1273                                                                             \
1274   experimental(intx, ClearFPUAtPark, 0, "(Unsafe, Unstable)")               \
1275                                                                             \
1276   experimental(intx, hashCode, 5,                                           \
1277                "(Unstable) select hashCode generation algorithm")           \
1278                                                                             \
1279   experimental(intx, WorkAroundNPTLTimedWaitHang, 0,                        \
1280                "(Unstable, Linux-specific) "                                \
1281                "avoid NPTL-FUTEX hang pthread_cond_timedwait")              \
1282                                                                             \
1283   product(bool, FilterSpuriousWakeups, true,                                \
1284           "When true prevents OS-level spurious, or premature, wakeups "    \
1285           "from Object.wait (Ignored for Windows)")                         \
1286                                                                             \
1287   experimental(intx, NativeMonitorTimeout, -1, "(Unstable)")                \
1288                                                                             \
1289   experimental(intx, NativeMonitorFlags, 0, "(Unstable)")                   \
1290                                                                             \
1291   experimental(intx, NativeMonitorSpinLimit, 20, "(Unstable)")              \
1292                                                                             \
1293   develop(bool, UsePthreads, false,                                         \
1294           "Use pthread-based instead of libthread-based synchronization "   \
1295           "(SPARC only)")                                                   \
1296                                                                             \
1297   product(bool, ReduceSignalUsage, false,                                   \
1298           "Reduce the use of OS signals in Java and/or the VM")             \
1299                                                                             \
1300   develop_pd(bool, ShareVtableStubs,                                        \
1301           "Share vtable stubs (smaller code but worse branch prediction")   \
1302                                                                             \
1303   develop(bool, LoadLineNumberTables, true,                                 \
1304           "Tell whether the class file parser loads line number tables")    \
1305                                                                             \
1306   develop(bool, LoadLocalVariableTables, true,                              \
1307           "Tell whether the class file parser loads local variable tables") \
1308                                                                             \
1309   develop(bool, LoadLocalVariableTypeTables, true,                          \
1310           "Tell whether the class file parser loads local variable type"    \
1311           "tables")                                                         \
1312                                                                             \
1313   product(bool, AllowUserSignalHandlers, false,                             \
1314           "Do not complain if the application installs signal handlers "    \
1315           "(Solaris &amp; Linux only)")                                         \
1316                                                                             \
1317   product(bool, UseSignalChaining, true,                                    \
1318           "Use signal-chaining to invoke signal handlers installed "        \
1319           "by the application (Solaris &amp; Linux only)")                      \
1320                                                                             \
1321   product(bool, UseAltSigs, false,                                          \
1322           "Use alternate signals instead of SIGUSR1 &amp; SIGUSR2 for VM "      \
1323           "internal signals (Solaris only)")                                \
1324                                                                             \
1325   product(bool, AllowJNIEnvProxy, false,                                    \
1326           "Allow JNIEnv proxies for jdbx")                                  \
1327                                                                             \
1328   product(bool, JNIDetachReleasesMonitors, true,                            \
1329           "JNI DetachCurrentThread releases monitors owned by thread")      \
1330                                                                             \
1331   product(bool, RestoreMXCSROnJNICalls, false,                              \
1332           "Restore MXCSR when returning from JNI calls")                    \
1333                                                                             \
1334   product(bool, CheckJNICalls, false,                                       \
1335           "Verify all arguments to JNI calls")                              \
1336                                                                             \
1337   product(bool, CheckEndorsedAndExtDirs, false,                             \
1338           "Verify the endorsed and extension directories are not used")     \
1339                                                                             \
1340   product(bool, UseFastJNIAccessors, true,                                  \
1341           "Use optimized versions of Get&lt;Primitive&gt;Field")                  \
1342                                                                             \
1343   product(intx, MaxJNILocalCapacity, 65536,                                 \
1344           "Maximum allowable local JNI handle capacity to "                 \
1345           "EnsureLocalCapacity() and PushLocalFrame(), "                    \
1346           "where &lt;= 0 is unlimited, default: 65536")                        \
1347                                                                             \
1348   product(bool, EagerXrunInit, false,                                       \
1349           "Eagerly initialize -Xrun libraries; allows startup profiling, "  \
1350           "but not all -Xrun libraries may support the state of the VM "    \
1351           "at this time")                                                   \
1352                                                                             \
1353   product(bool, PreserveAllAnnotations, false,                              \
1354           "Preserve RuntimeInvisibleAnnotations as well "                   \
1355           "as RuntimeVisibleAnnotations")                                   \
1356                                                                             \
1357   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
1358           "Number of OutOfMemoryErrors preallocated with backtrace")        \
1359                                                                             \
1360   product(bool, UseXMMForArrayCopy, false,                                  \
1361           "Use SSE2 MOVQ instruction for Arraycopy")                        \
1362                                                                             \
1363   product(intx, FieldsAllocationStyle, 1,                                   \
1364           "0 - type based with oops first, "                                \
1365           "1 - with oops last, "                                            \
1366           "2 - oops in super and sub classes are together")                 \
1367           range(0, 2)                                                       \
1368                                                                             \
1369   product(bool, CompactFields, true,                                        \
1370           "Allocate nonstatic fields in gaps between previous fields")      \
1371                                                                             \
1372   notproduct(bool, PrintFieldLayout, false,                                 \
1373           "Print field layout for each class")                              \
1374                                                                             \
1375   /* Need to limit the extent of the padding to reasonable size.          */\
1376   /* 8K is well beyond the reasonable HW cache line size, even with       */\
1377   /* aggressive prefetching, while still leaving the room for segregating */\
1378   /* among the distinct pages.                                            */\
1379   product(intx, ContendedPaddingWidth, 128,                                 \
1380           "How many bytes to pad the fields/classes marked @Contended with")\
1381           range(0, 8192)                                                    \
1382           constraint(ContendedPaddingWidthConstraintFunc,AtParse)           \
1383                                                                             \
1384   product(bool, EnableContended, true,                                      \
1385           "Enable @Contended annotation support")                           \
1386                                                                             \
1387   product(bool, RestrictContended, true,                                    \
1388           "Restrict @Contended to trusted classes")                         \
1389                                                                             \
1390   product(bool, UseBiasedLocking, true,                                     \
1391           "Enable biased locking in JVM")                                   \
1392                                                                             \
1393   product(intx, BiasedLockingStartupDelay, 4000,                            \
1394           "Number of milliseconds to wait before enabling biased locking")  \
1395                                                                             \
1396   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
1397           "Print statistics of biased locking in JVM")                      \
1398                                                                             \
1399   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
1400           "Threshold of number of revocations per type to try to "          \
1401           "rebias all objects in the heap of that type")                    \
1402                                                                             \
1403   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
1404           "Threshold of number of revocations per type to permanently "     \
1405           "revoke biases of all objects in the heap of that type")          \
1406                                                                             \
1407   product(intx, BiasedLockingDecayTime, 25000,                              \
1408           "Decay time (in milliseconds) to re-enable bulk rebiasing of a "  \
1409           "type after previous bulk rebias")                                \
1410                                                                             \
1411   /* tracing */                                                             \
1412                                                                             \
1413   notproduct(bool, TraceRuntimeCalls, false,                                \
1414           "Trace run-time calls")                                           \
1415                                                                             \
1416   develop(bool, TraceJNICalls, false,                                       \
1417           "Trace JNI calls")                                                \
1418                                                                             \
1419   develop(bool, StressRewriter, false,                                      \
1420           "Stress linktime bytecode rewriting")                             \
1421                                                                             \
1422   notproduct(bool, TraceJVMCalls, false,                                    \
1423           "Trace JVM calls")                                                \
1424                                                                             \
1425   product(ccstr, TraceJVMTI, NULL,                                          \
1426           "Trace flags for JVMTI functions and events")                     \
1427                                                                             \
1428   /* This option can change an EMCP method into an obsolete method. */      \
1429   /* This can affect tests that except specific methods to be EMCP. */      \
1430   /* This option should be used with caution.                       */      \
1431   product(bool, StressLdcRewrite, false,                                    \
1432           "Force ldc -&gt; ldc_w rewrite during RedefineClasses")              \
1433                                                                             \
1434   product(intx, TraceRedefineClasses, 0,                                    \
1435           "Trace level for JVMTI RedefineClasses")                          \
1436                                                                             \
1437   /* change to false by default sometime after Mustang */                   \
1438   product(bool, VerifyMergedCPBytecodes, true,                              \
1439           "Verify bytecodes after RedefineClasses constant pool merging")   \
1440                                                                             \
1441   develop(bool, TraceJNIHandleAllocation, false,                            \
1442           "Trace allocation/deallocation of JNI handle blocks")             \
1443                                                                             \
1444   develop(bool, TraceBytecodes, false,                                      \
1445           "Trace bytecode execution")                                       \
1446                                                                             \
1447   develop(bool, TraceClassInitialization, false,                            \
1448           "Trace class initialization")                                     \
1449                                                                             \
1450   product(bool, TraceExceptions, false,                                     \
1451           "Trace exceptions")                                               \
1452                                                                             \
1453   develop(bool, TraceICs, false,                                            \
1454           "Trace inline cache changes")                                     \
1455                                                                             \
1456   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
1457           "Trace method invocation counter overflow")                       \
1458                                                                             \
1459   develop(bool, TraceInlineCacheClearing, false,                            \
1460           "Trace clearing of inline caches in nmethods")                    \
1461                                                                             \
1462   develop(bool, TraceDependencies, false,                                   \
1463           "Trace dependencies")                                             \
1464                                                                             \
1465   develop(bool, VerifyDependencies, trueInDebug,                            \
1466           "Exercise and verify the compilation dependency mechanism")       \
1467                                                                             \
1468   develop(bool, TraceNewOopMapGeneration, false,                            \
1469           "Trace OopMapGeneration")                                         \
1470                                                                             \
1471   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
1472           "Trace OopMapGeneration: print detailed cell states")             \
1473                                                                             \
1474   develop(bool, TimeOopMap, false,                                          \
1475           "Time calls to GenerateOopMap::compute_map() in sum")             \
1476                                                                             \
1477   develop(bool, TimeOopMap2, false,                                         \
1478           "Time calls to GenerateOopMap::compute_map() individually")       \
1479                                                                             \
1480   develop(bool, TraceMonitorMismatch, false,                                \
1481           "Trace monitor matching failures during OopMapGeneration")        \
1482                                                                             \
1483   develop(bool, TraceOopMapRewrites, false,                                 \
1484           "Trace rewriting of method oops during oop map generation")       \
1485                                                                             \
1486   develop(bool, TraceSafepoint, false,                                      \
1487           "Trace safepoint operations")                                     \
1488                                                                             \
1489   develop(bool, TraceICBuffer, false,                                       \
1490           "Trace usage of IC buffer")                                       \
1491                                                                             \
1492   develop(bool, TraceCompiledIC, false,                                     \
1493           "Trace changes of compiled IC")                                   \
1494                                                                             \
1495   notproduct(bool, TraceZapDeadLocals, false,                               \
1496           "Trace zapping dead locals")                                      \
1497                                                                             \
1498   develop(bool, TraceStartupTime, false,                                    \
1499           "Trace setup time")                                               \
1500                                                                             \
1501   develop(bool, TraceProtectionDomainVerification, false,                   \
1502           "Trace protection domain verification")                           \
1503                                                                             \
1504   develop(bool, TraceClearedExceptions, false,                              \
1505           "Print when an exception is forcibly cleared")                    \
1506                                                                             \
1507   product(bool, TraceClassResolution, false,                                \
1508           "Trace all constant pool resolutions (for debugging)")            \
1509                                                                             \
1510   product(bool, TraceBiasedLocking, false,                                  \
1511           "Trace biased locking in JVM")                                    \
1512                                                                             \
1513   product(bool, TraceMonitorInflation, false,                               \
1514           "Trace monitor inflation in JVM")                                 \
1515                                                                             \
1516   /* gc */                                                                  \
1517                                                                             \
1518   product(bool, UseSerialGC, false,                                         \
1519           "Use the Serial garbage collector")                               \
1520                                                                             \
1521   product(bool, UseG1GC, false,                                             \
1522           "Use the Garbage-First garbage collector")                        \
1523                                                                             \
1524   product(bool, UseParallelGC, false,                                       \
1525           "Use the Parallel Scavenge garbage collector")                    \
1526                                                                             \
1527   product(bool, UseParallelOldGC, false,                                    \
1528           "Use the Parallel Old garbage collector")                         \
1529                                                                             \
1530   product(uintx, HeapMaximumCompactionInterval, 20,                         \
1531           "How often should we maximally compact the heap (not allowing "   \
1532           "any dead space)")                                                \
1533                                                                             \
1534   product(uintx, HeapFirstMaximumCompactionCount, 3,                        \
1535           "The collection count for the first maximum compaction")          \
1536                                                                             \
1537   product(bool, UseMaximumCompactionOnSystemGC, true,                       \
1538           "Use maximum compaction in the Parallel Old garbage collector "   \
1539           "for a system GC")                                                \
1540                                                                             \
1541   product(uintx, ParallelOldDeadWoodLimiterMean, 50,                        \
1542           "The mean used by the parallel compact dead wood "                \
1543           "limiter (a number between 0-100)")                               \
1544           range(0, 100)                                                     \
1545                                                                             \
1546   product(uintx, ParallelOldDeadWoodLimiterStdDev, 80,                      \
1547           "The standard deviation used by the parallel compact dead wood "  \
1548           "limiter (a number between 0-100)")                               \
1549           range(0, 100)                                                     \
1550                                                                             \
1551   product(uint, ParallelGCThreads, 0,                                       \
1552           "Number of parallel threads parallel gc will use")                \
1553                                                                             \
1554   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
1555             "Use semaphore synchronization for the GC Threads, "            \
1556             "instead of synchronization based on mutexes")                  \
1557                                                                             \
1558   product(bool, UseDynamicNumberOfGCThreads, false,                         \
1559           "Dynamically choose the number of parallel threads "              \
1560           "parallel gc will use")                                           \
1561                                                                             \
1562   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
1563           "Force dynamic selection of the number of "                       \
1564           "parallel threads parallel gc will use to aid debugging")         \
1565                                                                             \
1566   product(size_t, HeapSizePerGCThread, ScaleForWordSize(64*M),              \
1567           "Size of heap (bytes) per GC thread used in calculating the "     \
1568           "number of GC threads")                                           \
1569           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
1570                                                                             \
1571   product(bool, TraceDynamicGCThreads, false,                               \
1572           "Trace the dynamic GC thread usage")                              \
1573                                                                             \
1574   develop(bool, ParallelOldGCSplitALot, false,                              \
1575           "Provoke splitting (copying data from a young gen space to "      \
1576           "multiple destination spaces)")                                   \
1577                                                                             \
1578   develop(uintx, ParallelOldGCSplitInterval, 3,                             \
1579           "How often to provoke splitting a young gen space")               \
1580           range(0, max_uintx)                                               \
1581                                                                             \
1582   product(uint, ConcGCThreads, 0,                                           \
1583           "Number of threads concurrent gc will use")                       \
1584                                                                             \
1585   product(size_t, YoungPLABSize, 4096,                                      \
1586           "Size of young gen promotion LAB's (in HeapWords)")               \
1587           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
1588                                                                             \
1589   product(size_t, OldPLABSize, 1024,                                        \
1590           "Size of old gen promotion LAB's (in HeapWords), or Number        \
1591           of blocks to attempt to claim when refilling CMS LAB's")          \
1592                                                                             \
1593   product(uintx, GCTaskTimeStampEntries, 200,                               \
1594           "Number of time stamp entries per gc worker thread")              \
1595           range(1, max_uintx)                                               \
1596                                                                             \
1597   product(bool, AlwaysTenure, false,                                        \
1598           "Always tenure objects in eden (ParallelGC only)")                \
1599                                                                             \
1600   product(bool, NeverTenure, false,                                         \
1601           "Never tenure objects in eden, may tenure on overflow "           \
1602           "(ParallelGC only)")                                              \
1603                                                                             \
1604   product(bool, ScavengeBeforeFullGC, true,                                 \
1605           "Scavenge youngest generation before each full GC.")              \
1606                                                                             \
1607   develop(bool, ScavengeWithObjectsInToSpace, false,                        \
1608           "Allow scavenges to occur when to-space contains objects")        \
1609                                                                             \
1610   product(bool, UseConcMarkSweepGC, false,                                  \
1611           "Use Concurrent Mark-Sweep GC in the old generation")             \
1612                                                                             \
1613   product(bool, ExplicitGCInvokesConcurrent, false,                         \
1614           "A System.gc() request invokes a concurrent collection; "         \
1615           "(effective only when using concurrent collectors)")              \
1616                                                                             \
1617   product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false,        \
1618           "A System.gc() request invokes a concurrent collection and "      \
1619           "also unloads classes during such a concurrent gc cycle "         \
1620           "(effective only when UseConcMarkSweepGC)")                       \
1621                                                                             \
1622   product(bool, GCLockerInvokesConcurrent, false,                           \
1623           "The exit of a JNI critical section necessitating a scavenge, "   \
1624           "also kicks off a background concurrent collection")              \
1625                                                                             \
1626   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
1627           "How much the GC can expand the eden by while the GC locker "     \
1628           "is active (as a percentage)")                                    \
1629           range(0, 100)                                                     \
1630                                                                             \
1631   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
1632           "Number of times to retry allocations when "                      \
1633           "blocked by the GC locker")                                       \
1634                                                                             \
1635   develop(bool, UseCMSAdaptiveFreeLists, true,                              \
1636           "Use adaptive free lists in the CMS generation")                  \
1637                                                                             \
1638   develop(bool, UseAsyncConcMarkSweepGC, true,                              \
1639           "Use Asynchronous Concurrent Mark-Sweep GC in the old generation")\
1640                                                                             \
1641   product(bool, UseCMSBestFit, true,                                        \
1642           "Use CMS best fit allocation strategy")                           \
1643                                                                             \
1644   product(bool, UseParNewGC, false,                                         \
1645           "Use parallel threads in the new generation")                     \
1646                                                                             \
1647   product(bool, PrintTaskqueue, false,                                      \
1648           "Print taskqueue statistics for parallel collectors")             \
1649                                                                             \
1650   product(bool, PrintTerminationStats, false,                               \
1651           "Print termination statistics for parallel collectors")           \
1652                                                                             \
1653   product(uintx, ParallelGCBufferWastePct, 10,                              \
1654           "Wasted fraction of parallel allocation buffer")                  \
1655           range(0, 100)                                                     \
1656                                                                             \
1657   product(uintx, TargetPLABWastePct, 10,                                    \
1658           "Target wasted space in last buffer as percent of overall "       \
1659           "allocation")                                                     \
1660           range(1, 100)                                                     \
1661                                                                             \
1662   product(uintx, PLABWeight, 75,                                            \
1663           "Percentage (0-100) used to weight the current sample when "      \
1664           "computing exponentially decaying average for ResizePLAB")        \
1665           range(0, 100)                                                     \
1666                                                                             \
1667   product(bool, ResizePLAB, true,                                           \
1668           "Dynamically resize (survivor space) promotion LAB's")            \
1669                                                                             \
1670   product(bool, PrintPLAB, false,                                           \
1671           "Print (survivor space) promotion LAB's sizing decisions")        \
1672                                                                             \
1673   product(intx, ParGCArrayScanChunk, 50,                                    \
1674           "Scan a subset of object array and push remainder, if array is "  \
1675           "bigger than this")                                               \
1676           range(1, max_intx)                                                \
1677                                                                             \
1678   product(bool, ParGCUseLocalOverflow, false,                               \
1679           "Instead of a global overflow list, use local overflow stacks")   \
1680                                                                             \
1681   product(bool, ParGCTrimOverflow, true,                                    \
1682           "Eagerly trim the local overflow lists "                          \
1683           "(when ParGCUseLocalOverflow)")                                   \
1684                                                                             \
1685   notproduct(bool, ParGCWorkQueueOverflowALot, false,                       \
1686           "Simulate work queue overflow in ParNew")                         \
1687                                                                             \
1688   notproduct(uintx, ParGCWorkQueueOverflowInterval, 1000,                   \
1689           "An `interval' counter that determines how frequently "           \
1690           "we simulate overflow; a smaller number increases frequency")     \
1691                                                                             \
1692   product(uintx, ParGCDesiredObjsFromOverflowList, 20,                      \
1693           "The desired number of objects to claim from the overflow list")  \
1694                                                                             \
1695   diagnostic(uintx, ParGCStridesPerThread, 2,                               \
1696           "The number of strides per worker thread that we divide up the "  \
1697           "card table scanning work into")                                  \
1698           range(1, max_uintx)                                               \
1699                                                                             \
1700   diagnostic(intx, ParGCCardsPerStrideChunk, 256,                           \
1701           "The number of cards in each chunk of the parallel chunks used "  \
1702           "during card table scanning")                                     \
1703           range(1, max_intx)                                                \
1704                                                                             \
1705   product(uintx, OldPLABWeight, 50,                                         \
1706           "Percentage (0-100) used to weight the current sample when "      \
1707           "computing exponentially decaying average for resizing "          \
1708           "OldPLABSize")                                                    \
1709           range(0, 100)                                                     \
1710                                                                             \
1711   product(bool, ResizeOldPLAB, true,                                        \
1712           "Dynamically resize (old gen) promotion LAB's")                   \
1713                                                                             \
1714   product(bool, PrintOldPLAB, false,                                        \
1715           "Print (old gen) promotion LAB's sizing decisions")               \
1716                                                                             \
1717   product(size_t, CMSOldPLABMax, 1024,                                      \
1718           "Maximum size of CMS gen promotion LAB caches per worker "        \
1719           "per block size")                                                 \
1720           range(1, max_uintx)                                               \
1721                                                                             \
1722   product(size_t, CMSOldPLABMin, 16,                                        \
1723           "Minimum size of CMS gen promotion LAB caches per worker "        \
1724           "per block size")                                                 \
1725           range(1, max_uintx)                                               \
1726           constraint(CMSOldPLABMinConstraintFunc,AfterErgo)                 \
1727                                                                             \
1728   product(uintx, CMSOldPLABNumRefills, 4,                                   \
1729           "Nominal number of refills of CMS gen promotion LAB cache "       \
1730           "per worker per block size")                                      \
1731           range(1, max_uintx)                                               \
1732                                                                             \
1733   product(bool, CMSOldPLABResizeQuicker, false,                             \
1734           "React on-the-fly during a scavenge to a sudden "                 \
1735           "change in block demand rate")                                    \
1736                                                                             \
1737   product(uintx, CMSOldPLABToleranceFactor, 4,                              \
1738           "The tolerance of the phase-change detector for on-the-fly "      \
1739           "PLAB resizing during a scavenge")                                \
1740           range(1, max_uintx)                                               \
1741                                                                             \
1742   product(uintx, CMSOldPLABReactivityFactor, 2,                             \
1743           "The gain in the feedback loop for on-the-fly PLAB resizing "     \
1744           "during a scavenge")                                              \
1745                                                                             \
1746   product(bool, AlwaysPreTouch, false,                                      \
1747           "Force all freshly committed pages to be pre-touched")            \
1748                                                                             \
1749   product_pd(size_t, CMSYoungGenPerWorker,                                  \
1750           "The maximum size of young gen chosen by default per GC worker "  \
1751           "thread available")                                               \
1752           range(1, max_uintx)                                               \
1753                                                                             \
1754   product(uintx, CMSIncrementalSafetyFactor, 10,                            \
1755           "Percentage (0-100) used to add conservatism when computing the " \
1756           "duty cycle")                                                     \
1757           range(0, 100)                                                     \
1758                                                                             \
1759   product(uintx, CMSExpAvgFactor, 50,                                       \
1760           "Percentage (0-100) used to weight the current sample when "      \
1761           "computing exponential averages for CMS statistics")              \
1762           range(0, 100)                                                     \
1763                                                                             \
1764   product(uintx, CMS_FLSWeight, 75,                                         \
1765           "Percentage (0-100) used to weight the current sample when "      \
1766           "computing exponentially decaying averages for CMS FLS "          \
1767           "statistics")                                                     \
1768           range(0, 100)                                                     \
1769                                                                             \
1770   product(uintx, CMS_FLSPadding, 1,                                         \
1771           "The multiple of deviation from mean to use for buffering "       \
1772           "against volatility in free list demand")                         \
1773                                                                             \
1774   product(uintx, FLSCoalescePolicy, 2,                                      \
1775           "CMS: aggressiveness level for coalescing, increasing "           \
1776           "from 0 to 4")                                                    \
1777           range(0, 4)                                                       \
1778                                                                             \
1779   product(bool, FLSAlwaysCoalesceLarge, false,                              \
1780           "CMS: larger free blocks are always available for coalescing")    \
1781                                                                             \
1782   product(double, FLSLargestBlockCoalesceProximity, 0.99,                   \
1783           "CMS: the smaller the percentage the greater the coalescing "     \
1784           "force")                                                          \
1785                                                                             \
1786   product(double, CMSSmallCoalSurplusPercent, 1.05,                         \
1787           "CMS: the factor by which to inflate estimated demand of small "  \
1788           "block sizes to prevent coalescing with an adjoining block")      \
1789                                                                             \
1790   product(double, CMSLargeCoalSurplusPercent, 0.95,                         \
1791           "CMS: the factor by which to inflate estimated demand of large "  \
1792           "block sizes to prevent coalescing with an adjoining block")      \
1793                                                                             \
1794   product(double, CMSSmallSplitSurplusPercent, 1.10,                        \
1795           "CMS: the factor by which to inflate estimated demand of small "  \
1796           "block sizes to prevent splitting to supply demand for smaller "  \
1797           "blocks")                                                         \
1798                                                                             \
1799   product(double, CMSLargeSplitSurplusPercent, 1.00,                        \
1800           "CMS: the factor by which to inflate estimated demand of large "  \
1801           "block sizes to prevent splitting to supply demand for smaller "  \
1802           "blocks")                                                         \
1803                                                                             \
1804   product(bool, CMSExtrapolateSweep, false,                                 \
1805           "CMS: cushion for block demand during sweep")                     \
1806                                                                             \
1807   product(uintx, CMS_SweepWeight, 75,                                       \
1808           "Percentage (0-100) used to weight the current sample when "      \
1809           "computing exponentially decaying average for inter-sweep "       \
1810           "duration")                                                       \
1811           range(0, 100)                                                     \
1812                                                                             \
1813   product(uintx, CMS_SweepPadding, 1,                                       \
1814           "The multiple of deviation from mean to use for buffering "       \
1815           "against volatility in inter-sweep duration")                     \
1816                                                                             \
1817   product(uintx, CMS_SweepTimerThresholdMillis, 10,                         \
1818           "Skip block flux-rate sampling for an epoch unless inter-sweep "  \
1819           "duration exceeds this threshold in milliseconds")                \
1820                                                                             \
1821   product(bool, CMSClassUnloadingEnabled, true,                             \
1822           "Whether class unloading enabled when using CMS GC")              \
1823                                                                             \
1824   product(uintx, CMSClassUnloadingMaxInterval, 0,                           \
1825           "When CMS class unloading is enabled, the maximum CMS cycle "     \
1826           "count for which classes may not be unloaded")                    \
1827                                                                             \
1828   develop(intx, CMSDictionaryChoice, 0,                                     \
1829           "Use BinaryTreeDictionary as default in the CMS generation")      \
1830                                                                             \
1831   product(uintx, CMSIndexedFreeListReplenish, 4,                            \
1832           "Replenish an indexed free list with this number of chunks")      \
1833                                                                             \
1834   product(bool, CMSReplenishIntermediate, true,                             \
1835           "Replenish all intermediate free-list caches")                    \
1836                                                                             \
1837   product(bool, CMSSplitIndexedFreeListBlocks, true,                        \
1838           "When satisfying batched demand, split blocks from the "          \
1839           "IndexedFreeList whose size is a multiple of requested size")     \
1840                                                                             \
1841   product(bool, CMSLoopWarn, false,                                         \
1842           "Warn in case of excessive CMS looping")                          \
1843                                                                             \
1844   develop(bool, CMSOverflowEarlyRestoration, false,                         \
1845           "Restore preserved marks early")                                  \
1846                                                                             \
1847   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
1848           "Size of marking stack")                                          \
1849                                                                             \
1850   /* where does the range max value of (max_jint - 1) come from? */         \
1851   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
1852           "Maximum size of marking stack")                                  \
1853           range(1, (max_jint - 1))                                          \
1854                                                                             \
1855   notproduct(bool, CMSMarkStackOverflowALot, false,                         \
1856           "Simulate frequent marking stack / work queue overflow")          \
1857                                                                             \
1858   notproduct(uintx, CMSMarkStackOverflowInterval, 1000,                     \
1859           "An \"interval\" counter that determines how frequently "         \
1860           "to simulate overflow; a smaller number increases frequency")     \
1861                                                                             \
1862   product(uintx, CMSMaxAbortablePrecleanLoops, 0,                           \
1863           "Maximum number of abortable preclean iterations, if &gt; 0")        \
1864                                                                             \
1865   product(intx, CMSMaxAbortablePrecleanTime, 5000,                          \
1866           "Maximum time in abortable preclean (in milliseconds)")           \
1867                                                                             \
1868   product(uintx, CMSAbortablePrecleanMinWorkPerIteration, 100,              \
1869           "Nominal minimum work per abortable preclean iteration")          \
1870                                                                             \
1871   manageable(intx, CMSAbortablePrecleanWaitMillis, 100,                     \
1872           "Time that we sleep between iterations when not given "           \
1873           "enough work per iteration")                                      \
1874                                                                             \
1875   product(size_t, CMSRescanMultiple, 32,                                    \
1876           "Size (in cards) of CMS parallel rescan task")                    \
1877           range(1, max_uintx)                                               \
1878                                                                             \
1879   product(size_t, CMSConcMarkMultiple, 32,                                  \
1880           "Size (in cards) of CMS concurrent MT marking task")              \
1881           range(1, max_uintx)                                               \
1882                                                                             \
1883   product(bool, CMSAbortSemantics, false,                                   \
1884           "Whether abort-on-overflow semantics is implemented")             \
1885                                                                             \
1886   product(bool, CMSParallelInitialMarkEnabled, true,                        \
1887           "Use the parallel initial mark.")                                 \
1888                                                                             \
1889   product(bool, CMSParallelRemarkEnabled, true,                             \
1890           "Whether parallel remark enabled (only if ParNewGC)")             \
1891                                                                             \
1892   product(bool, CMSParallelSurvivorRemarkEnabled, true,                     \
1893           "Whether parallel remark of survivor space "                      \
1894           "enabled (effective only if CMSParallelRemarkEnabled)")           \
1895                                                                             \
1896   product(bool, CMSPLABRecordAlways, true,                                  \
1897           "Always record survivor space PLAB boundaries (effective only "   \
1898           "if CMSParallelSurvivorRemarkEnabled)")                           \
1899                                                                             \
1900   product(bool, CMSEdenChunksRecordAlways, true,                            \
1901           "Always record eden chunks used for the parallel initial mark "   \
1902           "or remark of eden")                                              \
1903                                                                             \
1904   product(bool, CMSPrintEdenSurvivorChunks, false,                          \
1905           "Print the eden and the survivor chunks used for the parallel "   \
1906           "initial mark or remark of the eden/survivor spaces")             \
1907                                                                             \
1908   product(bool, CMSConcurrentMTEnabled, true,                               \
1909           "Whether multi-threaded concurrent work enabled "                 \
1910           "(effective only if ParNewGC)")                                   \
1911                                                                             \
1912   product(bool, CMSPrecleaningEnabled, true,                                \
1913           "Whether concurrent precleaning enabled")                         \
1914                                                                             \
1915   product(uintx, CMSPrecleanIter, 3,                                        \
1916           "Maximum number of precleaning iteration passes")                 \
1917           range(0, 9)                                                       \
1918                                                                             \
1919   product(uintx, CMSPrecleanDenominator, 3,                                 \
1920           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1921           "ratio")                                                          \
1922           range(1, max_uintx)                                               \
1923           constraint(CMSPrecleanDenominatorConstraintFunc,AfterErgo)        \
1924                                                                             \
1925   product(uintx, CMSPrecleanNumerator, 2,                                   \
1926           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1927           "ratio")                                                          \
1928           range(0, max_uintx-1)                                             \
1929           constraint(CMSPrecleanNumeratorConstraintFunc,AfterErgo)          \
1930                                                                             \
1931   product(bool, CMSPrecleanRefLists1, true,                                 \
1932           "Preclean ref lists during (initial) preclean phase")             \
1933                                                                             \
1934   product(bool, CMSPrecleanRefLists2, false,                                \
1935           "Preclean ref lists during abortable preclean phase")             \
1936                                                                             \
1937   product(bool, CMSPrecleanSurvivors1, false,                               \
1938           "Preclean survivors during (initial) preclean phase")             \
1939                                                                             \
1940   product(bool, CMSPrecleanSurvivors2, true,                                \
1941           "Preclean survivors during abortable preclean phase")             \
1942                                                                             \
1943   product(uintx, CMSPrecleanThreshold, 1000,                                \
1944           "Do not iterate again if number of dirty cards is less than this")\
1945           range(100, max_uintx)                                             \
1946                                                                             \
1947   product(bool, CMSCleanOnEnter, true,                                      \
1948           "Clean-on-enter optimization for reducing number of dirty cards") \
1949                                                                             \
1950   product(uintx, CMSRemarkVerifyVariant, 1,                                 \
1951           "Choose variant (1,2) of verification following remark")          \
1952           range(1, 2)                                                       \
1953                                                                             \
1954   product(size_t, CMSScheduleRemarkEdenSizeThreshold, 2*M,                  \
1955           "If Eden size is below this, do not try to schedule remark")      \
1956                                                                             \
1957   product(uintx, CMSScheduleRemarkEdenPenetration, 50,                      \
1958           "The Eden occupancy percentage (0-100) at which "                 \
1959           "to try and schedule remark pause")                               \
1960           range(0, 100)                                                     \
1961                                                                             \
1962   product(uintx, CMSScheduleRemarkSamplingRatio, 5,                         \
1963           "Start sampling eden top at least before young gen "              \
1964           "occupancy reaches 1/&lt;ratio&gt; of the size at which "               \
1965           "we plan to schedule remark")                                     \
1966           range(1, max_uintx)                                               \
1967                                                                             \
1968   product(uintx, CMSSamplingGrain, 16*K,                                    \
1969           "The minimum distance between eden samples for CMS (see above)")  \
1970           range(1, max_uintx)                                               \
1971                                                                             \
1972   product(bool, CMSScavengeBeforeRemark, false,                             \
1973           "Attempt scavenge before the CMS remark step")                    \
1974                                                                             \
1975   develop(bool, CMSTraceSweeper, false,                                     \
1976           "Trace some actions of the CMS sweeper")                          \
1977                                                                             \
1978   product(uintx, CMSWorkQueueDrainThreshold, 10,                            \
1979           "Don't drain below this size per parallel worker/thief")          \
1980                                                                             \
1981   manageable(intx, CMSWaitDuration, 2000,                                   \
1982           "Time in milliseconds that CMS thread waits for young GC")        \
1983                                                                             \
1984   develop(uintx, CMSCheckInterval, 1000,                                    \
1985           "Interval in milliseconds that CMS thread checks if it "          \
1986           "should start a collection cycle")                                \
1987                                                                             \
1988   product(bool, CMSYield, true,                                             \
1989           "Yield between steps of CMS")                                     \
1990                                                                             \
1991   product(size_t, CMSBitMapYieldQuantum, 10*M,                              \
1992           "Bitmap operations should process at most this many bits "        \
1993           "between yields")                                                 \
1994           range(1, max_uintx)                                               \
1995                                                                             \
1996   product(bool, CMSDumpAtPromotionFailure, false,                           \
1997           "Dump useful information about the state of the CMS old "         \
1998           "generation upon a promotion failure")                            \
1999                                                                             \
2000   product(bool, CMSPrintChunksInDump, false,                                \
2001           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
2002           "more detailed information about the free chunks")                \
2003                                                                             \
2004   product(bool, CMSPrintObjectsInDump, false,                               \
2005           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
2006           "more detailed information about the allocated objects")          \
2007                                                                             \
2008   diagnostic(bool, FLSVerifyAllHeapReferences, false,                       \
2009           "Verify that all references across the FLS boundary "             \
2010           "are to valid objects")                                           \
2011                                                                             \
2012   diagnostic(bool, FLSVerifyLists, false,                                   \
2013           "Do lots of (expensive) FreeListSpace verification")              \
2014                                                                             \
2015   diagnostic(bool, FLSVerifyIndexTable, false,                              \
2016           "Do lots of (expensive) FLS index table verification")            \
2017                                                                             \
2018   develop(bool, FLSVerifyDictionary, false,                                 \
2019           "Do lots of (expensive) FLS dictionary verification")             \
2020                                                                             \
2021   develop(bool, VerifyBlockOffsetArray, false,                              \
2022           "Do (expensive) block offset array verification")                 \
2023                                                                             \
2024   diagnostic(bool, BlockOffsetArrayUseUnallocatedBlock, false,              \
2025           "Maintain _unallocated_block in BlockOffsetArray "                \
2026           "(currently applicable only to CMS collector)")                   \
2027                                                                             \
2028   develop(bool, TraceCMSState, false,                                       \
2029           "Trace the state of the CMS collection")                          \
2030                                                                             \
2031   product(intx, RefDiscoveryPolicy, 0,                                      \
2032           "Select type of reference discovery policy: "                     \
2033           "reference-based(0) or referent-based(1)")                        \
2034           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
2035                 ReferenceProcessor::DiscoveryPolicyMax)                     \
2036                                                                             \
2037   product(bool, ParallelRefProcEnabled, false,                              \
2038           "Enable parallel reference processing whenever possible")         \
2039                                                                             \
2040   product(bool, ParallelRefProcBalancingEnabled, true,                      \
2041           "Enable balancing of reference processing queues")                \
2042                                                                             \
2043   product(uintx, CMSTriggerRatio, 80,                                       \
2044           "Percentage of MinHeapFreeRatio in CMS generation that is "       \
2045           "allocated before a CMS collection cycle commences")              \
2046           range(0, 100)                                                     \
2047                                                                             \
2048   product(uintx, CMSBootstrapOccupancy, 50,                                 \
2049           "Percentage CMS generation occupancy at which to "                \
2050           "initiate CMS collection for bootstrapping collection stats")     \
2051           range(0, 100)                                                     \
2052                                                                             \
2053   product(intx, CMSInitiatingOccupancyFraction, -1,                         \
2054           "Percentage CMS generation occupancy to start a CMS collection "  \
2055           "cycle. A negative value means that CMSTriggerRatio is used")     \
2056           range(min_intx, 100)                                              \
2057                                                                             \
2058   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
2059           "Percentage of the (entire) heap occupancy to start a "           \
2060           "concurrent GC cycle. It is used by GCs that trigger a "          \
2061           "concurrent GC cycle based on the occupancy of the entire heap, " \
2062           "not just one of the generations (e.g., G1). A value of 0 "       \
2063           "denotes 'do constant GC cycles'.")                               \
2064           range(0, 100)                                                     \
2065                                                                             \
2066   manageable(intx, CMSTriggerInterval, -1,                                  \
2067           "Commence a CMS collection cycle (at least) every so many "       \
2068           "milliseconds (0 permanently, -1 disabled)")                      \
2069           range(-1, max_intx)                                               \
2070                                                                             \
2071   product(bool, UseCMSInitiatingOccupancyOnly, false,                       \
2072           "Only use occupancy as a criterion for starting a CMS collection")\
2073                                                                             \
2074   product(uintx, CMSIsTooFullPercentage, 98,                                \
2075           "An absolute ceiling above which CMS will always consider the "   \
2076           "unloading of classes when class unloading is enabled")           \
2077           range(0, 100)                                                     \
2078                                                                             \
2079   develop(bool, CMSTestInFreeList, false,                                   \
2080           "Check if the coalesced range is already in the "                 \
2081           "free lists as claimed")                                          \
2082                                                                             \
2083   notproduct(bool, CMSVerifyReturnedBytes, false,                           \
2084           "Check that all the garbage collected was returned to the "       \
2085           "free lists")                                                     \
2086                                                                             \
2087   notproduct(bool, ScavengeALot, false,                                     \
2088           "Force scavenge at every Nth exit from the runtime system "       \
2089           "(N=ScavengeALotInterval)")                                       \
2090                                                                             \
2091   develop(bool, FullGCALot, false,                                          \
2092           "Force full gc at every Nth exit from the runtime system "        \
2093           "(N=FullGCALotInterval)")                                         \
2094                                                                             \
2095   notproduct(bool, GCALotAtAllSafepoints, false,                            \
2096           "Enforce ScavengeALot/GCALot at all potential safepoints")        \
2097                                                                             \
2098   product(bool, PrintPromotionFailure, false,                               \
2099           "Print additional diagnostic information following "              \
2100           "promotion failure")                                              \
2101                                                                             \
2102   notproduct(bool, PromotionFailureALot, false,                             \
2103           "Use promotion failure handling on every youngest generation "    \
2104           "collection")                                                     \
2105                                                                             \
2106   develop(uintx, PromotionFailureALotCount, 1000,                           \
2107           "Number of promotion failures occurring at PLAB "                 \
2108           "refill attempts (ParNew) or promotion attempts "                 \
2109           "(other young collectors)")                                       \
2110                                                                             \
2111   develop(uintx, PromotionFailureALotInterval, 5,                           \
2112           "Total collections between promotion failures a lot")             \
2113                                                                             \
2114   experimental(uintx, WorkStealingSleepMillis, 1,                           \
2115           "Sleep time when sleep is used for yields")                       \
2116                                                                             \
2117   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
2118           "Number of yields before a sleep is done during work stealing")   \
2119                                                                             \
2120   experimental(uintx, WorkStealingHardSpins, 4096,                          \
2121           "Number of iterations in a spin loop between checks on "          \
2122           "time out of hard spin")                                          \
2123                                                                             \
2124   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
2125           "Ratio of hard spins to calls to yield")                          \
2126                                                                             \
2127   develop(uintx, ObjArrayMarkingStride, 512,                                \
2128           "Number of object array elements to push onto the marking stack " \
2129           "before pushing a continuation entry")                            \
2130                                                                             \
2131   develop(bool, MetadataAllocationFailALot, false,                          \
2132           "Fail metadata allocations at intervals controlled by "           \
2133           "MetadataAllocationFailALotInterval")                             \
2134                                                                             \
2135   develop(uintx, MetadataAllocationFailALotInterval, 1000,                  \
2136           "Metadata allocation failure a lot interval")                     \
2137                                                                             \
2138   develop(bool, TraceMetadataChunkAllocation, false,                        \
2139           "Trace chunk metadata allocations")                               \
2140                                                                             \
2141   product(bool, TraceMetadataHumongousAllocation, false,                    \
2142           "Trace humongous metadata allocations")                           \
2143                                                                             \
2144   develop(bool, TraceMetavirtualspaceAllocation, false,                     \
2145           "Trace virtual space metadata allocations")                       \
2146                                                                             \
2147   notproduct(bool, ExecuteInternalVMTests, false,                           \
2148           "Enable execution of internal VM tests")                          \
2149                                                                             \
2150   notproduct(bool, VerboseInternalVMTests, false,                           \
2151           "Turn on logging for internal VM tests.")                         \
2152                                                                             \
2153   product_pd(bool, UseTLAB, "Use thread-local object allocation")           \
2154                                                                             \
2155   product_pd(bool, ResizeTLAB,                                              \
2156           "Dynamically resize TLAB size for threads")                       \
2157                                                                             \
2158   product(bool, ZeroTLAB, false,                                            \
2159           "Zero out the newly created TLAB")                                \
2160                                                                             \
2161   product(bool, FastTLABRefill, true,                                       \
2162           "Use fast TLAB refill code")                                      \
2163                                                                             \
2164   product(bool, PrintTLAB, false,                                           \
2165           "Print various TLAB related information")                         \
2166                                                                             \
2167   product(bool, TLABStats, true,                                            \
2168           "Provide more detailed and expensive TLAB statistics "            \
2169           "(with PrintTLAB)")                                               \
2170                                                                             \
2171   product_pd(bool, NeverActAsServerClassMachine,                            \
2172           "Never act like a server-class machine")                          \
2173                                                                             \
2174   product(bool, AlwaysActAsServerClassMachine, false,                       \
2175           "Always act like a server-class machine")                         \
2176                                                                             \
2177   product_pd(uint64_t, MaxRAM,                                              \
2178           "Real memory size (in bytes) used to set maximum heap size")      \
2179                                                                             \
2180   product(size_t, ErgoHeapSizeLimit, 0,                                     \
2181           "Maximum ergonomically set heap size (in bytes); zero means use " \
2182           "MaxRAM / MaxRAMFraction")                                        \
2183                                                                             \
2184   product(uintx, MaxRAMFraction, 4,                                         \
2185           "Maximum fraction (1/n) of real memory used for maximum heap "    \
2186           "size")                                                           \
2187           range(1, max_uintx)                                               \
2188                                                                             \
2189   product(uintx, MinRAMFraction, 2,                                         \
2190           "Minimum fraction (1/n) of real memory used for maximum heap "    \
2191           "size on systems with small physical memory size")                \
2192           range(1, max_uintx)                                               \
2193                                                                             \
2194   product(uintx, InitialRAMFraction, 64,                                    \
2195           "Fraction (1/n) of real memory used for initial heap size")       \
2196           range(1, max_uintx)                                               \
2197                                                                             \
2198   develop(uintx, MaxVirtMemFraction, 2,                                     \
2199           "Maximum fraction (1/n) of virtual memory used for ergonomically "\
2200           "determining maximum heap size")                                  \
2201                                                                             \
2202   product(bool, UseAutoGCSelectPolicy, false,                               \
2203           "Use automatic collection selection policy")                      \
2204                                                                             \
2205   product(uintx, AutoGCSelectPauseMillis, 5000,                             \
2206           "Automatic GC selection pause threshold in milliseconds")         \
2207                                                                             \
2208   product(bool, UseAdaptiveSizePolicy, true,                                \
2209           "Use adaptive generation sizing policies")                        \
2210                                                                             \
2211   product(bool, UsePSAdaptiveSurvivorSizePolicy, true,                      \
2212           "Use adaptive survivor sizing policies")                          \
2213                                                                             \
2214   product(bool, UseAdaptiveGenerationSizePolicyAtMinorCollection, true,     \
2215           "Use adaptive young-old sizing policies at minor collections")    \
2216                                                                             \
2217   product(bool, UseAdaptiveGenerationSizePolicyAtMajorCollection, true,     \
2218           "Use adaptive young-old sizing policies at major collections")    \
2219                                                                             \
2220   product(bool, UseAdaptiveSizePolicyWithSystemGC, false,                   \
2221           "Include statistics from System.gc() for adaptive size policy")   \
2222                                                                             \
2223   product(bool, UseAdaptiveGCBoundary, false,                               \
2224           "Allow young-old boundary to move")                               \
2225                                                                             \
2226   develop(bool, TraceAdaptiveGCBoundary, false,                             \
2227           "Trace young-old boundary moves")                                 \
2228                                                                             \
2229   develop(intx, PSAdaptiveSizePolicyResizeVirtualSpaceAlot, -1,             \
2230           "Resize the virtual spaces of the young or old generations")      \
2231                                                                             \
2232   product(uintx, AdaptiveSizeThroughPutPolicy, 0,                           \
2233           "Policy for changing generation size for throughput goals")       \
2234                                                                             \
2235   develop(bool, PSAdjustTenuredGenForMinorPause, false,                     \
2236           "Adjust tenured generation to achieve a minor pause goal")        \
2237                                                                             \
2238   develop(bool, PSAdjustYoungGenForMajorPause, false,                       \
2239           "Adjust young generation to achieve a major pause goal")          \
2240                                                                             \
2241   product(uintx, AdaptiveSizePolicyInitializingSteps, 20,                   \
2242           "Number of steps where heuristics is used before data is used")   \
2243                                                                             \
2244   develop(uintx, AdaptiveSizePolicyReadyThreshold, 5,                       \
2245           "Number of collections before the adaptive sizing is started")    \
2246                                                                             \
2247   product(uintx, AdaptiveSizePolicyOutputInterval, 0,                       \
2248           "Collection interval for printing information; zero means never") \
2249                                                                             \
2250   product(bool, UseAdaptiveSizePolicyFootprintGoal, true,                   \
2251           "Use adaptive minimum footprint as a goal")                       \
2252                                                                             \
2253   product(uintx, AdaptiveSizePolicyWeight, 10,                              \
2254           "Weight given to exponential resizing, between 0 and 100")        \
2255           range(0, 100)                                                     \
2256                                                                             \
2257   product(uintx, AdaptiveTimeWeight,       25,                              \
2258           "Weight given to time in adaptive policy, between 0 and 100")     \
2259           range(0, 100)                                                     \
2260                                                                             \
2261   product(uintx, PausePadding, 1,                                           \
2262           "How much buffer to keep for pause time")                         \
2263                                                                             \
2264   product(uintx, PromotedPadding, 3,                                        \
2265           "How much buffer to keep for promotion failure")                  \
2266                                                                             \
2267   product(uintx, SurvivorPadding, 3,                                        \
2268           "How much buffer to keep for survivor overflow")                  \
2269                                                                             \
2270   product(uintx, ThresholdTolerance, 10,                                    \
2271           "Allowed collection cost difference between generations")         \
2272           range(0, 100)                                                     \
2273                                                                             \
2274   product(uintx, AdaptiveSizePolicyCollectionCostMargin, 50,                \
2275           "If collection costs are within margin, reduce both by full "     \
2276           "delta")                                                          \
2277                                                                             \
2278   product(uintx, YoungGenerationSizeIncrement, 20,                          \
2279           "Adaptive size percentage change in young generation")            \
2280           range(0, 100)                                                     \
2281                                                                             \
2282   product(uintx, YoungGenerationSizeSupplement, 80,                         \
2283           "Supplement to YoungedGenerationSizeIncrement used at startup")   \
2284           range(0, 100)                                                     \
2285                                                                             \
2286   product(uintx, YoungGenerationSizeSupplementDecay, 8,                     \
2287           "Decay factor to YoungedGenerationSizeSupplement")                \
2288           range(1, max_uintx)                                               \
2289                                                                             \
2290   product(uintx, TenuredGenerationSizeIncrement, 20,                        \
2291           "Adaptive size percentage change in tenured generation")          \
2292           range(0, 100)                                                     \
2293                                                                             \
2294   product(uintx, TenuredGenerationSizeSupplement, 80,                       \
2295           "Supplement to TenuredGenerationSizeIncrement used at startup")   \
2296           range(0, 100)                                                     \
2297                                                                             \
2298   product(uintx, TenuredGenerationSizeSupplementDecay, 2,                   \
2299           "Decay factor to TenuredGenerationSizeIncrement")                 \
2300           range(1, max_uintx)                                               \
2301                                                                             \
2302   product(uintx, MaxGCPauseMillis, max_uintx,                               \
2303           "Adaptive size policy maximum GC pause time goal in millisecond, "\
2304           "or (G1 Only) the maximum GC time per MMU time slice")            \
2305                                                                             \
2306   product(uintx, GCPauseIntervalMillis, 0,                                  \
2307           "Time slice for MMU specification")                               \
2308                                                                             \
2309   product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \
2310           "Adaptive size policy maximum GC minor pause time goal "          \
2311           "in millisecond")                                                 \
2312                                                                             \
2313   product(uintx, GCTimeRatio, 99,                                           \
2314           "Adaptive size policy application time to GC time ratio")         \
2315                                                                             \
2316   product(uintx, AdaptiveSizeDecrementScaleFactor, 4,                       \
2317           "Adaptive size scale down factor for shrinking")                  \
2318           range(1, max_uintx)                                               \
2319                                                                             \
2320   product(bool, UseAdaptiveSizeDecayMajorGCCost, true,                      \
2321           "Adaptive size decays the major cost for long major intervals")   \
2322                                                                             \
2323   product(uintx, AdaptiveSizeMajorGCDecayTimeScale, 10,                     \
2324           "Time scale over which major costs decay")                        \
2325                                                                             \
2326   product(uintx, MinSurvivorRatio, 3,                                       \
2327           "Minimum ratio of young generation/survivor space size")          \
2328                                                                             \
2329   product(uintx, InitialSurvivorRatio, 8,                                   \
2330           "Initial ratio of young generation/survivor space size")          \
2331                                                                             \
2332   product(size_t, BaseFootPrintEstimate, 256*M,                             \
2333           "Estimate of footprint other than Java Heap")                     \
2334                                                                             \
2335   product(bool, UseGCOverheadLimit, true,                                   \
2336           "Use policy to limit of proportion of time spent in GC "          \
2337           "before an OutOfMemory error is thrown")                          \
2338                                                                             \
2339   product(uintx, GCTimeLimit, 98,                                           \
2340           "Limit of the proportion of time spent in GC before "             \
2341           "an OutOfMemoryError is thrown (used with GCHeapFreeLimit)")      \
2342           range(0, 100)                                                     \
2343                                                                             \
2344   product(uintx, GCHeapFreeLimit, 2,                                        \
2345           "Minimum percentage of free space after a full GC before an "     \
2346           "OutOfMemoryError is thrown (used with GCTimeLimit)")             \
2347           range(0, 100)                                                     \
2348                                                                             \
2349   develop(uintx, AdaptiveSizePolicyGCTimeLimitThreshold, 5,                 \
2350           "Number of consecutive collections before gc time limit fires")   \
2351                                                                             \
2352   product(bool, PrintAdaptiveSizePolicy, false,                             \
2353           "Print information about AdaptiveSizePolicy")                     \
2354                                                                             \
2355   product(intx, PrefetchCopyIntervalInBytes, -1,                            \
2356           "How far ahead to prefetch destination area (&lt;= 0 means off)")    \
2357                                                                             \
2358   product(intx, PrefetchScanIntervalInBytes, -1,                            \
2359           "How far ahead to prefetch scan area (&lt;= 0 means off)")           \
2360                                                                             \
2361   product(intx, PrefetchFieldsAhead, -1,                                    \
2362           "How many fields ahead to prefetch in oop scan (&lt;= 0 means off)") \
2363                                                                             \
2364   diagnostic(bool, VerifySilently, false,                                   \
2365           "Do not print the verification progress")                         \
2366                                                                             \
2367   diagnostic(bool, VerifyDuringStartup, false,                              \
2368           "Verify memory system before executing any Java code "            \
2369           "during VM initialization")                                       \
2370                                                                             \
2371   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
2372           "Verify system before exiting")                                   \
2373                                                                             \
2374   diagnostic(bool, VerifyBeforeGC, false,                                   \
2375           "Verify memory system before GC")                                 \
2376                                                                             \
2377   diagnostic(bool, VerifyAfterGC, false,                                    \
2378           "Verify memory system after GC")                                  \
2379                                                                             \
2380   diagnostic(bool, VerifyDuringGC, false,                                   \
2381           "Verify memory system during GC (between phases)")                \
2382                                                                             \
2383   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
2384           "Enable parallel memory system verification")                     \
2385                                                                             \
2386   diagnostic(bool, DeferInitialCardMark, false,                             \
2387           "When +ReduceInitialCardMarks, explicitly defer any that "        \
2388           "may arise from new_pre_store_barrier")                           \
2389                                                                             \
2390   product(bool, UseCondCardMark, false,                                     \
2391           "Check for already marked card before updating card table")       \
2392                                                                             \
2393   diagnostic(bool, VerifyRememberedSets, false,                             \
2394           "Verify GC remembered sets")                                      \
2395                                                                             \
2396   diagnostic(bool, VerifyObjectStartArray, true,                            \
2397           "Verify GC object start array if verify before/after")            \
2398                                                                             \
2399   product(bool, DisableExplicitGC, false,                                   \
2400           "Ignore calls to System.gc()")                                    \
2401                                                                             \
2402   notproduct(bool, CheckMemoryInitialization, false,                        \
2403           "Check memory initialization")                                    \
2404                                                                             \
2405   diagnostic(bool, BindCMSThreadToCPU, false,                               \
2406           "Bind CMS Thread to CPU if possible")                             \
2407                                                                             \
2408   diagnostic(uintx, CPUForCMSThread, 0,                                     \
2409           "When BindCMSThreadToCPU is true, the CPU to bind CMS thread to") \
2410                                                                             \
2411   product(bool, BindGCTaskThreadsToCPUs, false,                             \
2412           "Bind GCTaskThreads to CPUs if possible")                         \
2413                                                                             \
2414   product(bool, UseGCTaskAffinity, false,                                   \
2415           "Use worker affinity when asking for GCTasks")                    \
2416                                                                             \
2417   product(uintx, ProcessDistributionStride, 4,                              \
2418           "Stride through processors when distributing processes")          \
2419                                                                             \
2420   product(uintx, CMSCoordinatorYieldSleepCount, 10,                         \
2421           "Number of times the coordinator GC thread will sleep while "     \
2422           "yielding before giving up and resuming GC")                      \
2423                                                                             \
2424   product(uintx, CMSYieldSleepCount, 0,                                     \
2425           "Number of times a GC thread (minus the coordinator) "            \
2426           "will sleep while yielding before giving up and resuming GC")     \
2427                                                                             \
2428   /* gc tracing */                                                          \
2429   manageable(bool, PrintGC, false,                                          \
2430           "Print message at garbage collection")                            \
2431                                                                             \
2432   manageable(bool, PrintGCDetails, false,                                   \
2433           "Print more details at garbage collection")                       \
2434                                                                             \
2435   manageable(bool, PrintGCDateStamps, false,                                \
2436           "Print date stamps at garbage collection")                        \
2437                                                                             \
2438   manageable(bool, PrintGCTimeStamps, false,                                \
2439           "Print timestamps at garbage collection")                         \
2440                                                                             \
2441   manageable(bool, PrintGCID, true,                                         \
2442           "Print an identifier for each garbage collection")                \
2443                                                                             \
2444   product(bool, PrintGCTaskTimeStamps, false,                               \
2445           "Print timestamps for individual gc worker thread tasks")         \
2446                                                                             \
2447   develop(intx, ConcGCYieldTimeout, 0,                                      \
2448           "If non-zero, assert that GC threads yield within this "          \
2449           "number of milliseconds")                                         \
2450                                                                             \
2451   product(bool, PrintReferenceGC, false,                                    \
2452           "Print times spent handling reference objects during GC "         \
2453           "(enabled only when PrintGCDetails)")                             \
2454                                                                             \
2455   develop(bool, TraceReferenceGC, false,                                    \
2456           "Trace handling of soft/weak/final/phantom references")           \
2457                                                                             \
2458   develop(bool, TraceFinalizerRegistration, false,                          \
2459           "Trace registration of final references")                         \
2460                                                                             \
2461   notproduct(bool, TraceScavenge, false,                                    \
2462           "Trace scavenge")                                                 \
2463                                                                             \
2464   product(bool, IgnoreEmptyClassPaths, false,                               \
2465           "Ignore empty path elements in -classpath")                       \
2466                                                                             \
2467   product(bool, TraceClassPaths, false,                                     \
2468           "Trace processing of class paths")                                \
2469                                                                             \
2470   product_rw(bool, TraceClassLoading, false,                                \
2471           "Trace all classes loaded")                                       \
2472                                                                             \
2473   product(bool, TraceClassLoadingPreorder, false,                           \
2474           "Trace all classes loaded in order referenced (not loaded)")      \
2475                                                                             \
2476   product_rw(bool, TraceClassUnloading, false,                              \
2477           "Trace unloading of classes")                                     \
2478                                                                             \
2479   product_rw(bool, TraceLoaderConstraints, false,                           \
2480           "Trace loader constraints")                                       \
2481                                                                             \
2482   develop(bool, TraceClassLoaderData, false,                                \
2483           "Trace class loader loader_data lifetime")                        \
2484                                                                             \
2485   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
2486           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
2487           "Initial size of the boot class loader data metaspace")           \
2488                                                                             \
2489   product(bool, TraceYoungGenTime, false,                                   \
2490           "Trace accumulated time for young collection")                    \
2491                                                                             \
2492   product(bool, TraceOldGenTime, false,                                     \
2493           "Trace accumulated time for old collection")                      \
2494                                                                             \
2495   product(bool, PrintTenuringDistribution, false,                           \
2496           "Print tenuring age information")                                 \
2497                                                                             \
2498   product_rw(bool, PrintHeapAtGC, false,                                    \
2499           "Print heap layout before and after each GC")                     \
2500                                                                             \
2501   product_rw(bool, PrintHeapAtGCExtended, false,                            \
2502           "Print extended information about the layout of the heap "        \
2503           "when -XX:+PrintHeapAtGC is set")                                 \
2504                                                                             \
2505   product(bool, PrintHeapAtSIGBREAK, true,                                  \
2506           "Print heap layout in response to SIGBREAK")                      \
2507                                                                             \
2508   manageable(bool, PrintClassHistogramBeforeFullGC, false,                  \
2509           "Print a class histogram before any major stop-world GC")         \
2510                                                                             \
2511   manageable(bool, PrintClassHistogramAfterFullGC, false,                   \
2512           "Print a class histogram after any major stop-world GC")          \
2513                                                                             \
2514   manageable(bool, PrintClassHistogram, false,                              \
2515           "Print a histogram of class instances")                           \
2516                                                                             \
2517   develop(bool, TraceWorkGang, false,                                       \
2518           "Trace activities of work gangs")                                 \
2519                                                                             \
2520   product(bool, TraceParallelOldGCTasks, false,                             \
2521           "Trace multithreaded GC activity")                                \
2522                                                                             \
2523   develop(bool, TraceBlockOffsetTable, false,                               \
2524           "Print BlockOffsetTable maps")                                    \
2525                                                                             \
2526   develop(bool, TraceCardTableModRefBS, false,                              \
2527           "Print CardTableModRefBS maps")                                   \
2528                                                                             \
2529   develop(bool, TraceGCTaskManager, false,                                  \
2530           "Trace actions of the GC task manager")                           \
2531                                                                             \
2532   develop(bool, TraceGCTaskQueue, false,                                    \
2533           "Trace actions of the GC task queues")                            \
2534                                                                             \
2535   diagnostic(bool, TraceGCTaskThread, false,                                \
2536           "Trace actions of the GC task threads")                           \
2537                                                                             \
2538   product(bool, PrintParallelOldGCPhaseTimes, false,                        \
2539           "Print the time taken by each phase in ParallelOldGC "            \
2540           "(PrintGCDetails must also be enabled)")                          \
2541                                                                             \
2542   develop(bool, TraceParallelOldGCMarkingPhase, false,                      \
2543           "Trace marking phase in ParallelOldGC")                           \
2544                                                                             \
2545   develop(bool, TraceParallelOldGCSummaryPhase, false,                      \
2546           "Trace summary phase in ParallelOldGC")                           \
2547                                                                             \
2548   develop(bool, TraceParallelOldGCCompactionPhase, false,                   \
2549           "Trace compaction phase in ParallelOldGC")                        \
2550                                                                             \
2551   develop(bool, TraceParallelOldGCDensePrefix, false,                       \
2552           "Trace dense prefix computation for ParallelOldGC")               \
2553                                                                             \
2554   develop(bool, IgnoreLibthreadGPFault, false,                              \
2555           "Suppress workaround for libthread GP fault")                     \
2556                                                                             \
2557   product(bool, PrintJNIGCStalls, false,                                    \
2558           "Print diagnostic message when GC is stalled "                    \
2559           "by JNI critical section")                                        \
2560                                                                             \
2561   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
2562           "The percentage of the used heap that the instances of a class "  \
2563           "must occupy for the class to generate a trace event")            \
2564                                                                             \
2565   /* GC log rotation setting */                                             \
2566                                                                             \
2567   product(bool, UseGCLogFileRotation, false,                                \
2568           "Rotate gclog files (for long running applications). It requires "\
2569           "-Xloggc:&lt;filename&gt;")                                             \
2570                                                                             \
2571   product(uintx, NumberOfGCLogFiles, 0,                                     \
2572           "Number of gclog files in rotation "                              \
2573           "(default: 0, no rotation)")                                      \
2574                                                                             \
2575   product(size_t, GCLogFileSize, 8*K,                                       \
2576           "GC log file size, requires UseGCLogFileRotation. "               \
2577           "Set to 0 to only trigger rotation via jcmd")                     \
2578                                                                             \
2579   /* JVMTI heap profiling */                                                \
2580                                                                             \
2581   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
2582           "Trace JVMTI object tagging calls")                               \
2583                                                                             \
2584   diagnostic(bool, VerifyBeforeIteration, false,                            \
2585           "Verify memory system before JVMTI iteration")                    \
2586                                                                             \
2587   /* compiler interface */                                                  \
2588                                                                             \
2589   develop(bool, CIPrintCompilerName, false,                                 \
2590           "when CIPrint is active, print the name of the active compiler")  \
2591                                                                             \
2592   diagnostic(bool, CIPrintCompileQueue, false,                              \
2593           "display the contents of the compile queue whenever a "           \
2594           "compilation is enqueued")                                        \
2595                                                                             \
2596   develop(bool, CIPrintRequests, false,                                     \
2597           "display every request for compilation")                          \
2598                                                                             \
2599   product(bool, CITime, false,                                              \
2600           "collect timing information for compilation")                     \
2601                                                                             \
2602   develop(bool, CITimeVerbose, false,                                       \
2603           "be more verbose in compilation timings")                         \
2604                                                                             \
2605   develop(bool, CITimeEach, false,                                          \
2606           "display timing information after each successful compilation")   \
2607                                                                             \
2608   develop(bool, CICountOSR, false,                                          \
2609           "use a separate counter when assigning ids to osr compilations")  \
2610                                                                             \
2611   develop(bool, CICompileNatives, true,                                     \
2612           "compile native methods if supported by the compiler")            \
2613                                                                             \
2614   develop_pd(bool, CICompileOSR,                                            \
2615           "compile on stack replacement methods if supported by the "       \
2616           "compiler")                                                       \
2617                                                                             \
2618   develop(bool, CIPrintMethodCodes, false,                                  \
2619           "print method bytecodes of the compiled code")                    \
2620                                                                             \
2621   develop(bool, CIPrintTypeFlow, false,                                     \
2622           "print the results of ciTypeFlow analysis")                       \
2623                                                                             \
2624   develop(bool, CITraceTypeFlow, false,                                     \
2625           "detailed per-bytecode tracing of ciTypeFlow analysis")           \
2626                                                                             \
2627   develop(intx, OSROnlyBCI, -1,                                             \
2628           "OSR only at this bci.  Negative values mean exclude that bci")   \
2629                                                                             \
2630   /* compiler */                                                            \
2631                                                                             \
2632   /* notice: the max range value here is max_jint, not max_intx  */         \
2633   /* because of overflow issue                                   */         \
2634   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
2635           "Number of compiler threads to run")                              \
2636           range(0, max_jint)                                                \
2637           constraint(CICompilerCountConstraintFunc, AtParse)                \
2638                                                                             \
2639   product(intx, CompilationPolicyChoice, 0,                                 \
2640           "which compilation policy (0-3)")                                 \
2641           range(0, 3)                                                       \
2642                                                                             \
2643   develop(bool, UseStackBanging, true,                                      \
2644           "use stack banging for stack overflow checks (required for "      \
2645           "proper StackOverflow handling; disable only to measure cost "    \
2646           "of stackbanging)")                                               \
2647                                                                             \
2648   develop(bool, UseStrictFP, true,                                          \
2649           "use strict fp if modifier strictfp is set")                      \
2650                                                                             \
2651   develop(bool, GenerateSynchronizationCode, true,                          \
2652           "generate locking/unlocking code for synchronized methods and "   \
2653           "monitors")                                                       \
2654                                                                             \
2655   develop(bool, GenerateCompilerNullChecks, true,                           \
2656           "Generate explicit null checks for loads/stores/calls")           \
2657                                                                             \
2658   develop(bool, GenerateRangeChecks, true,                                  \
2659           "Generate range checks for array accesses")                       \
2660                                                                             \
2661   develop_pd(bool, ImplicitNullChecks,                                      \
2662           "Generate code for implicit null checks")                         \
2663                                                                             \
2664   product_pd(bool, TrapBasedNullChecks,                                     \
2665           "Generate code for null checks that uses a cmp and trap "         \
2666           "instruction raising SIGTRAP.  This is only used if an access to" \
2667           "null (+offset) will not raise a SIGSEGV, i.e.,"                  \
2668           "ImplicitNullChecks don't work (PPC64).")                         \
2669                                                                             \
2670   product(bool, PrintSafepointStatistics, false,                            \
2671           "Print statistics about safepoint synchronization")               \
2672                                                                             \
2673   product(intx, PrintSafepointStatisticsCount, 300,                         \
2674           "Total number of safepoint statistics collected "                 \
2675           "before printing them out")                                       \
2676                                                                             \
2677   product(intx, PrintSafepointStatisticsTimeout,  -1,                       \
2678           "Print safepoint statistics only when safepoint takes "           \
2679           "more than PrintSafepointSatisticsTimeout in millis")             \
2680                                                                             \
2681   product(bool, TraceSafepointCleanupTime, false,                           \
2682           "Print the break down of clean up tasks performed during "        \
2683           "safepoint")                                                      \
2684                                                                             \
2685   product(bool, Inline, true,                                               \
2686           "Enable inlining")                                                \
2687                                                                             \
2688   product(bool, ClipInlining, true,                                         \
2689           "Clip inlining if aggregate method exceeds DesiredMethodLimit")   \
2690                                                                             \
2691   develop(bool, UseCHA, true,                                               \
2692           "Enable CHA")                                                     \
2693                                                                             \
2694   product(bool, UseTypeProfile, true,                                       \
2695           "Check interpreter profile for historically monomorphic calls")   \
2696                                                                             \
2697   diagnostic(bool, PrintInlining, false,                                    \
2698           "Print inlining optimizations")                                   \
2699                                                                             \
2700   product(bool, UsePopCountInstruction, false,                              \
2701           "Use population count instruction")                               \
2702                                                                             \
2703   develop(bool, EagerInitialization, false,                                 \
2704           "Eagerly initialize classes if possible")                         \
2705                                                                             \
2706   diagnostic(bool, LogTouchedMethods, false,                                \
2707           "Log methods which have been ever touched in runtime")            \
2708                                                                             \
2709   diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \
2710           "Print all methods that have been ever touched in runtime")       \
2711                                                                             \
2712   develop(bool, TraceMethodReplacement, false,                              \
2713           "Print when methods are replaced do to recompilation")            \
2714                                                                             \
2715   develop(bool, PrintMethodFlushing, false,                                 \
2716           "Print the nmethods being flushed")                               \
2717                                                                             \
2718   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
2719           "print statistics about method flushing")                         \
2720                                                                             \
2721   diagnostic(intx, HotMethodDetectionLimit, 100000,                         \
2722           "Number of compiled code invocations after which "                \
2723           "the method is considered as hot by the flusher")                 \
2724                                                                             \
2725   diagnostic(intx, MinPassesBeforeFlush, 10,                                \
2726           "Minimum number of sweeper passes before an nmethod "             \
2727           "can be flushed")                                                 \
2728                                                                             \
2729   product(bool, UseCodeAging, true,                                         \
2730           "Insert counter to detect warm methods")                          \
2731                                                                             \
2732   diagnostic(bool, StressCodeAging, false,                                  \
2733           "Start with counters compiled in")                                \
2734                                                                             \
2735   develop(bool, UseRelocIndex, false,                                       \
2736           "Use an index to speed random access to relocations")             \
2737                                                                             \
2738   develop(bool, StressCodeBuffers, false,                                   \
2739           "Exercise code buffer expansion and other rare state changes")    \
2740                                                                             \
2741   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
2742           "Generate extra debugging information for non-safepoints in "     \
2743           "nmethods")                                                       \
2744                                                                             \
2745   product(bool, PrintVMOptions, false,                                      \
2746           "Print flags that appeared on the command line")                  \
2747                                                                             \
2748   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
2749           "Ignore unrecognized VM options")                                 \
2750                                                                             \
2751   product(bool, PrintCommandLineFlags, false,                               \
2752           "Print flags specified on command line or set by ergonomics")     \
2753                                                                             \
2754   product(bool, PrintFlagsInitial, false,                                   \
2755           "Print all VM flags before argument processing and exit VM")      \
2756                                                                             \
2757   product(bool, PrintFlagsFinal, false,                                     \
2758           "Print all VM flags after argument and ergonomic processing")     \
2759                                                                             \
2760   notproduct(bool, PrintFlagsWithComments, false,                           \
2761           "Print all VM flags with default values and descriptions and "    \
2762           "exit")                                                           \
2763                                                                             \
2764   product(bool, PrintFlagsRanges, false,                                    \
2765           "Print VM flags and their ranges and exit VM")                    \
2766                                                                             \
2767   diagnostic(bool, SerializeVMOutput, true,                                 \
2768           "Use a mutex to serialize output to tty and LogFile")             \
2769                                                                             \
2770   diagnostic(bool, DisplayVMOutput, true,                                   \
2771           "Display all VM output on the tty, independently of LogVMOutput") \
2772                                                                             \
2773   diagnostic(bool, LogVMOutput, false,                                      \
2774           "Save VM output to LogFile")                                      \
2775                                                                             \
2776   diagnostic(ccstr, LogFile, NULL,                                          \
2777           "If LogVMOutput or LogCompilation is on, save VM output to "      \
2778           "this file [default: ./hotspot_pid%p.log] (%p replaced with pid)")\
2779                                                                             \
2780   product(ccstr, ErrorFile, NULL,                                           \
2781           "If an error occurs, save the error data to this file "           \
2782           "[default: ./hs_err_pid%p.log] (%p replaced with pid)")           \
2783                                                                             \
2784   product(bool, DisplayVMOutputToStderr, false,                             \
2785           "If DisplayVMOutput is true, display all VM output to stderr")    \
2786                                                                             \
2787   product(bool, DisplayVMOutputToStdout, false,                             \
2788           "If DisplayVMOutput is true, display all VM output to stdout")    \
2789                                                                             \
2790   product(bool, UseHeavyMonitors, false,                                    \
2791           "use heavyweight instead of lightweight Java monitors")           \
2792                                                                             \
2793   product(bool, PrintStringTableStatistics, false,                          \
2794           "print statistics about the StringTable and SymbolTable")         \
2795                                                                             \
2796   diagnostic(bool, VerifyStringTableAtExit, false,                          \
2797           "verify StringTable contents at exit")                            \
2798                                                                             \
2799   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
2800           "print histogram of the symbol table")                            \
2801                                                                             \
2802   notproduct(bool, ExitVMOnVerifyError, false,                              \
2803           "standard exit from VM if bytecode verify error "                 \
2804           "(only in debug mode)")                                           \
2805                                                                             \
2806   notproduct(ccstr, AbortVMOnException, NULL,                               \
2807           "Call fatal if this exception is thrown.  Example: "              \
2808           "java -XX:AbortVMOnException=java.lang.NullPointerException Foo") \
2809                                                                             \
2810   notproduct(ccstr, AbortVMOnExceptionMessage, NULL,                        \
2811           "Call fatal if the exception pointed by AbortVMOnException "      \
2812           "has this message")                                               \
2813                                                                             \
2814   develop(bool, DebugVtables, false,                                        \
2815           "add debugging code to vtable dispatch")                          \
2816                                                                             \
2817   develop(bool, PrintVtables, false,                                        \
2818           "print vtables when printing klass")                              \
2819                                                                             \
2820   notproduct(bool, PrintVtableStats, false,                                 \
2821           "print vtables stats at end of run")                              \
2822                                                                             \
2823   develop(bool, TraceCreateZombies, false,                                  \
2824           "trace creation of zombie nmethods")                              \
2825                                                                             \
2826   notproduct(bool, IgnoreLockingAssertions, false,                          \
2827           "disable locking assertions (for speed)")                         \
2828                                                                             \
2829   product(bool, RangeCheckElimination, true,                                \
2830           "Eliminate range checks")                                         \
2831                                                                             \
2832   develop_pd(bool, UncommonNullCast,                                        \
2833           "track occurrences of null in casts; adjust compiler tactics")    \
2834                                                                             \
2835   develop(bool, TypeProfileCasts,  true,                                    \
2836           "treat casts like calls for purposes of type profiling")          \
2837                                                                             \
2838   develop(bool, DelayCompilationDuringStartup, true,                        \
2839           "Delay invoking the compiler until main application class is "    \
2840           "loaded")                                                         \
2841                                                                             \
2842   develop(bool, CompileTheWorld, false,                                     \
2843           "Compile all methods in all classes in bootstrap class path "     \
2844           "(stress test)")                                                  \
2845                                                                             \
2846   develop(bool, CompileTheWorldPreloadClasses, true,                        \
2847           "Preload all classes used by a class before start loading")       \
2848                                                                             \
2849   notproduct(intx, CompileTheWorldSafepointInterval, 100,                   \
2850           "Force a safepoint every n compiles so sweeper can keep up")      \
2851                                                                             \
2852   develop(bool, FillDelaySlots, true,                                       \
2853           "Fill delay slots (on SPARC only)")                               \
2854                                                                             \
2855   develop(bool, TimeLivenessAnalysis, false,                                \
2856           "Time computation of bytecode liveness analysis")                 \
2857                                                                             \
2858   develop(bool, TraceLivenessGen, false,                                    \
2859           "Trace the generation of liveness analysis information")          \
2860                                                                             \
2861   notproduct(bool, TraceLivenessQuery, false,                               \
2862           "Trace queries of liveness analysis information")                 \
2863                                                                             \
2864   notproduct(bool, CollectIndexSetStatistics, false,                        \
2865           "Collect information about IndexSets")                            \
2866                                                                             \
2867   develop(bool, UseLoopSafepoints, true,                                    \
2868           "Generate Safepoint nodes in every loop")                         \
2869                                                                             \
2870   develop(intx, FastAllocateSizeLimit, 128*K,                               \
2871           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
2872           "Inline allocations larger than this in doublewords must go slow")\
2873                                                                             \
2874   product(bool, AggressiveOpts, false,                                      \
2875           "Enable aggressive optimizations - see arguments.cpp")            \
2876                                                                             \
2877   product_pd(uintx, TypeProfileLevel,                                       \
2878           "=XYZ, with Z: Type profiling of arguments at call; "             \
2879                      "Y: Type profiling of return value at call; "          \
2880                      "X: Type profiling of parameters to methods; "         \
2881           "X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods")             \
2882                                                                             \
2883   product(intx, TypeProfileArgsLimit,     2,                                \
2884           "max number of call arguments to consider for type profiling")    \
2885                                                                             \
2886   product(intx, TypeProfileParmsLimit,    2,                                \
2887           "max number of incoming parameters to consider for type profiling"\
2888           ", -1 for all")                                                   \
2889                                                                             \
2890   /* statistics */                                                          \
2891   develop(bool, CountCompiledCalls, false,                                  \
2892           "Count method invocations")                                       \
2893                                                                             \
2894   notproduct(bool, CountRuntimeCalls, false,                                \
2895           "Count VM runtime calls")                                         \
2896                                                                             \
2897   develop(bool, CountJNICalls, false,                                       \
2898           "Count jni method invocations")                                   \
2899                                                                             \
2900   notproduct(bool, CountJVMCalls, false,                                    \
2901           "Count jvm method invocations")                                   \
2902                                                                             \
2903   notproduct(bool, CountRemovableExceptions, false,                         \
2904           "Count exceptions that could be replaced by branches due to "     \
2905           "inlining")                                                       \
2906                                                                             \
2907   notproduct(bool, ICMissHistogram, false,                                  \
2908           "Produce histogram of IC misses")                                 \
2909                                                                             \
2910   /* interpreter */                                                         \
2911   develop(bool, ClearInterpreterLocals, false,                              \
2912           "Always clear local variables of interpreter activations upon "   \
2913           "entry")                                                          \
2914                                                                             \
2915   product_pd(bool, RewriteBytecodes,                                        \
2916           "Allow rewriting of bytecodes (bytecodes are not immutable)")     \
2917                                                                             \
2918   product_pd(bool, RewriteFrequentPairs,                                    \
2919           "Rewrite frequently used bytecode pairs into a single bytecode")  \
2920                                                                             \
2921   diagnostic(bool, PrintInterpreter, false,                                 \
2922           "Print the generated interpreter code")                           \
2923                                                                             \
2924   product(bool, UseInterpreter, true,                                       \
2925           "Use interpreter for non-compiled methods")                       \
2926                                                                             \
2927   develop(bool, UseFastSignatureHandlers, true,                             \
2928           "Use fast signature handlers for native calls")                   \
2929                                                                             \
2930   product(bool, UseLoopCounter, true,                                       \
2931           "Increment invocation counter on backward branch")                \
2932                                                                             \
2933   product_pd(bool, UseOnStackReplacement,                                   \
2934           "Use on stack replacement, calls runtime if invoc. counter "      \
2935           "overflows in loop")                                              \
2936                                                                             \
2937   notproduct(bool, TraceOnStackReplacement, false,                          \
2938           "Trace on stack replacement")                                     \
2939                                                                             \
2940   product_pd(bool, PreferInterpreterNativeStubs,                            \
2941           "Use always interpreter stubs for native methods invoked via "    \
2942           "interpreter")                                                    \
2943                                                                             \
2944   develop(bool, CountBytecodes, false,                                      \
2945           "Count number of bytecodes executed")                             \
2946                                                                             \
2947   develop(bool, PrintBytecodeHistogram, false,                              \
2948           "Print histogram of the executed bytecodes")                      \
2949                                                                             \
2950   develop(bool, PrintBytecodePairHistogram, false,                          \
2951           "Print histogram of the executed bytecode pairs")                 \
2952                                                                             \
2953   diagnostic(bool, PrintSignatureHandlers, false,                           \
2954           "Print code generated for native method signature handlers")      \
2955                                                                             \
2956   develop(bool, VerifyOops, false,                                          \
2957           "Do plausibility checks for oops")                                \
2958                                                                             \
2959   develop(bool, CheckUnhandledOops, false,                                  \
2960           "Check for unhandled oops in VM code")                            \
2961                                                                             \
2962   develop(bool, VerifyJNIFields, trueInDebug,                               \
2963           "Verify jfieldIDs for instance fields")                           \
2964                                                                             \
2965   notproduct(bool, VerifyJNIEnvThread, false,                               \
2966           "Verify JNIEnv.thread == Thread::current() when entering VM "     \
2967           "from JNI")                                                       \
2968                                                                             \
2969   develop(bool, VerifyFPU, false,                                           \
2970           "Verify FPU state (check for NaN's, etc.)")                       \
2971                                                                             \
2972   develop(bool, VerifyThread, false,                                        \
2973           "Watch the thread register for corruption (SPARC only)")          \
2974                                                                             \
2975   develop(bool, VerifyActivationFrameSize, false,                           \
2976           "Verify that activation frame didn't become smaller than its "    \
2977           "minimal size")                                                   \
2978                                                                             \
2979   develop(bool, TraceFrequencyInlining, false,                              \
2980           "Trace frequency based inlining")                                 \
2981                                                                             \
2982   develop_pd(bool, InlineIntrinsics,                                        \
2983           "Inline intrinsics that can be statically resolved")              \
2984                                                                             \
2985   product_pd(bool, ProfileInterpreter,                                      \
2986           "Profile at the bytecode level during interpretation")            \
2987                                                                             \
2988   develop(bool, TraceProfileInterpreter, false,                             \
2989           "Trace profiling at the bytecode level during interpretation. "   \
2990           "This outputs the profiling information collected to improve "    \
2991           "jit compilation.")                                               \
2992                                                                             \
2993   develop_pd(bool, ProfileTraps,                                            \
2994           "Profile deoptimization traps at the bytecode level")             \
2995                                                                             \
2996   product(intx, ProfileMaturityPercentage, 20,                              \
2997           "number of method invocations/branches (expressed as % of "       \
2998           "CompileThreshold) before using the method's profile")            \
2999           range(0, 100)                                                     \
3000                                                                             \
3001   diagnostic(bool, PrintMethodData, false,                                  \
3002           "Print the results of +ProfileInterpreter at end of run")         \
3003                                                                             \
3004   develop(bool, VerifyDataPointer, trueInDebug,                             \
3005           "Verify the method data pointer during interpreter profiling")    \
3006                                                                             \
3007   develop(bool, VerifyCompiledCode, false,                                  \
3008           "Include miscellaneous runtime verifications in nmethod code; "   \
3009           "default off because it disturbs nmethod size heuristics")        \
3010                                                                             \
3011   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
3012           "Manually make GC thread crash then dump java stack trace;  "     \
3013           "Test only")                                                      \
3014                                                                             \
3015   /* compilation */                                                         \
3016   product(bool, UseCompiler, true,                                          \
3017           "Use Just-In-Time compilation")                                   \
3018                                                                             \
3019   develop(bool, TraceCompilationPolicy, false,                              \
3020           "Trace compilation policy")                                       \
3021                                                                             \
3022   develop(bool, TimeCompilationPolicy, false,                               \
3023           "Time the compilation policy")                                    \
3024                                                                             \
3025   product(bool, UseCounterDecay, true,                                      \
3026           "Adjust recompilation counters")                                  \
3027                                                                             \
3028   develop(intx, CounterHalfLifeTime,    30,                                 \
3029           "Half-life time of invocation counters (in seconds)")             \
3030                                                                             \
3031   develop(intx, CounterDecayMinIntervalLength,   500,                       \
3032           "The minimum interval (in milliseconds) between invocation of "   \
3033           "CounterDecay")                                                   \
3034                                                                             \
3035   product(bool, AlwaysCompileLoopMethods, false,                            \
3036           "When using recompilation, never interpret methods "              \
3037           "containing loops")                                               \
3038                                                                             \
3039   product(bool, DontCompileHugeMethods, true,                               \
3040           "Do not compile methods &gt; HugeMethodLimit")                       \
3041                                                                             \
3042   /* Bytecode escape analysis estimation. */                                \
3043   product(bool, EstimateArgEscape, true,                                    \
3044           "Analyze bytecodes to estimate escape state of arguments")        \
3045                                                                             \
3046   product(intx, BCEATraceLevel, 0,                                          \
3047           "How much tracing to do of bytecode escape analysis estimates")   \
3048                                                                             \
3049   product(intx, MaxBCEAEstimateLevel, 5,                                    \
3050           "Maximum number of nested calls that are analyzed by BC EA")      \
3051                                                                             \
3052   product(intx, MaxBCEAEstimateSize, 150,                                   \
3053           "Maximum bytecode size of a method to be analyzed by BC EA")      \
3054                                                                             \
3055   product(intx,  AllocatePrefetchStyle, 1,                                  \
3056           "0 = no prefetch, "                                               \
3057           "1 = prefetch instructions for each allocation, "                 \
3058           "2 = use TLAB watermark to gate allocation prefetch, "            \
3059           "3 = use BIS instruction on Sparc for allocation prefetch")       \
3060           range(0, 3)                                                       \
3061                                                                             \
3062   product(intx,  AllocatePrefetchDistance, -1,                              \
3063           "Distance to prefetch ahead of allocation pointer")               \
3064                                                                             \
3065   product(intx,  AllocatePrefetchLines, 3,                                  \
3066           "Number of lines to prefetch ahead of array allocation pointer")  \
3067                                                                             \
3068   product(intx,  AllocateInstancePrefetchLines, 1,                          \
3069           "Number of lines to prefetch ahead of instance allocation "       \
3070           "pointer")                                                        \
3071                                                                             \
3072   product(intx,  AllocatePrefetchStepSize, 16,                              \
3073           "Step size in bytes of sequential prefetch instructions")         \
3074                                                                             \
3075   product(intx,  AllocatePrefetchInstr, 0,                                  \
3076           "Prefetch instruction to prefetch ahead of allocation pointer")   \
3077                                                                             \
3078   /* deoptimization */                                                      \
3079   develop(bool, TraceDeoptimization, false,                                 \
3080           "Trace deoptimization")                                           \
3081                                                                             \
3082   develop(bool, DebugDeoptimization, false,                                 \
3083           "Tracing various information while debugging deoptimization")     \
3084                                                                             \
3085   product(intx, SelfDestructTimer, 0,                                       \
3086           "Will cause VM to terminate after a given time (in minutes) "     \
3087           "(0 means off)")                                                  \
3088                                                                             \
3089   product(intx, MaxJavaStackTraceDepth, 1024,                               \
3090           "The maximum number of lines in the stack trace for Java "        \
3091           "exceptions (0 means all)")                                       \
3092                                                                             \
3093   NOT_EMBEDDED(diagnostic(intx, GuaranteedSafepointInterval, 1000,          \
3094           "Guarantee a safepoint (at least) every so many milliseconds "    \
3095           "(0 means none)"))                                                \
3096                                                                             \
3097   EMBEDDED_ONLY(product(intx, GuaranteedSafepointInterval, 0,               \
3098           "Guarantee a safepoint (at least) every so many milliseconds "    \
3099           "(0 means none)"))                                                \
3100                                                                             \
3101   product(intx, SafepointTimeoutDelay, 10000,                               \
3102           "Delay in milliseconds for option SafepointTimeout")              \
3103                                                                             \
3104   product(intx, NmethodSweepActivity, 10,                                   \
3105           "Removes cold nmethods from code cache if &gt; 0. Higher values "    \
3106           "result in more aggressive sweeping")                             \
3107           range(0, 2000)                                                    \
3108                                                                             \
3109   notproduct(bool, LogSweeper, false,                                       \
3110           "Keep a ring buffer of sweeper activity")                         \
3111                                                                             \
3112   notproduct(intx, SweeperLogEntries, 1024,                                 \
3113           "Number of records in the ring buffer of sweeper activity")       \
3114                                                                             \
3115   notproduct(intx, MemProfilingInterval, 500,                               \
3116           "Time between each invocation of the MemProfiler")                \
3117                                                                             \
3118   develop(intx, MallocCatchPtr, -1,                                         \
3119           "Hit breakpoint when mallocing/freeing this pointer")             \
3120                                                                             \
3121   notproduct(ccstrlist, SuppressErrorAt, "",                                \
3122           "List of assertions (file:line) to muzzle")                       \
3123                                                                             \
3124   notproduct(size_t, HandleAllocationLimit, 1024,                           \
3125           "Threshold for HandleMark allocation when +TraceHandleAllocation "\
3126           "is used")                                                        \
3127                                                                             \
3128   develop(size_t, TotalHandleAllocationLimit, 1024,                         \
3129           "Threshold for total handle allocation when "                     \
3130           "+TraceHandleAllocation is used")                                 \
3131                                                                             \
3132   develop(intx, StackPrintLimit, 100,                                       \
3133           "number of stack frames to print in VM-level stack dump")         \
3134                                                                             \
3135   notproduct(intx, MaxElementPrintSize, 256,                                \
3136           "maximum number of elements to print")                            \
3137                                                                             \
3138   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
3139           "maximum number of subklasses to print when printing klass")      \
3140                                                                             \
3141   product(intx, MaxInlineLevel, 9,                                          \
3142           "maximum number of nested calls that are inlined")                \
3143                                                                             \
3144   product(intx, MaxRecursiveInlineLevel, 1,                                 \
3145           "maximum number of nested recursive calls that are inlined")      \
3146                                                                             \
3147   develop(intx, MaxForceInlineLevel, 100,                                   \
3148           "maximum number of nested calls that are forced for inlining "    \
3149           "(using CompilerOracle or marked w/ @ForceInline)")               \
3150                                                                             \
3151   product_pd(intx, InlineSmallCode,                                         \
3152           "Only inline already compiled methods if their code size is "     \
3153           "less than this")                                                 \
3154                                                                             \
3155   product(intx, MaxInlineSize, 35,                                          \
3156           "The maximum bytecode size of a method to be inlined")            \
3157                                                                             \
3158   product_pd(intx, FreqInlineSize,                                          \
3159           "The maximum bytecode size of a frequent method to be inlined")   \
3160                                                                             \
3161   product(intx, MaxTrivialSize, 6,                                          \
3162           "The maximum bytecode size of a trivial method to be inlined")    \
3163                                                                             \
3164   product(intx, MinInliningThreshold, 250,                                  \
3165           "The minimum invocation count a method needs to have to be "      \
3166           "inlined")                                                        \
3167                                                                             \
3168   develop(intx, MethodHistogramCutoff, 100,                                 \
3169           "The cutoff value for method invocation histogram (+CountCalls)") \
3170                                                                             \
3171   develop(intx, ProfilerNumberOfInterpretedMethods, 25,                     \
3172           "Number of interpreted methods to show in profile")               \
3173                                                                             \
3174   develop(intx, ProfilerNumberOfCompiledMethods, 25,                        \
3175           "Number of compiled methods to show in profile")                  \
3176                                                                             \
3177   develop(intx, ProfilerNumberOfStubMethods, 25,                            \
3178           "Number of stub methods to show in profile")                      \
3179                                                                             \
3180   develop(intx, ProfilerNumberOfRuntimeStubNodes, 25,                       \
3181           "Number of runtime stub nodes to show in profile")                \
3182                                                                             \
3183   product(intx, ProfileIntervalsTicks, 100,                                 \
3184           "Number of ticks between printing of interval profile "           \
3185           "(+ProfileIntervals)")                                            \
3186                                                                             \
3187   notproduct(intx, ScavengeALotInterval,     1,                             \
3188           "Interval between which scavenge will occur with +ScavengeALot")  \
3189                                                                             \
3190   notproduct(intx, FullGCALotInterval,     1,                               \
3191           "Interval between which full gc will occur with +FullGCALot")     \
3192                                                                             \
3193   notproduct(intx, FullGCALotStart,     0,                                  \
3194           "For which invocation to start FullGCAlot")                       \
3195                                                                             \
3196   notproduct(intx, FullGCALotDummies,  32*K,                                \
3197           "Dummy object allocated with +FullGCALot, forcing all objects "   \
3198           "to move")                                                        \
3199                                                                             \
3200   develop(intx, DontYieldALotInterval,    10,                               \
3201           "Interval between which yields will be dropped (milliseconds)")   \
3202                                                                             \
3203   develop(intx, MinSleepInterval,     1,                                    \
3204           "Minimum sleep() interval (milliseconds) when "                   \
3205           "ConvertSleepToYield is off (used for Solaris)")                  \
3206                                                                             \
3207   develop(intx, ProfilerPCTickThreshold,    15,                             \
3208           "Number of ticks in a PC buckets to be a hotspot")                \
3209                                                                             \
3210   notproduct(intx, DeoptimizeALotInterval,     5,                           \
3211           "Number of exits until DeoptimizeALot kicks in")                  \
3212                                                                             \
3213   notproduct(intx, ZombieALotInterval,     5,                               \
3214           "Number of exits until ZombieALot kicks in")                      \
3215                                                                             \
3216   diagnostic(intx, MallocVerifyInterval,     0,                             \
3217           "If non-zero, verify C heap after every N calls to "              \
3218           "malloc/realloc/free")                                            \
3219                                                                             \
3220   diagnostic(intx, MallocVerifyStart,     0,                                \
3221           "If non-zero, start verifying C heap after Nth call to "          \
3222           "malloc/realloc/free")                                            \
3223                                                                             \
3224   diagnostic(uintx, MallocMaxTestWords,     0,                              \
3225           "If non-zero, maximum number of words that malloc/realloc can "   \
3226           "allocate (for testing only)")                                    \
3227                                                                             \
3228   product(intx, TypeProfileWidth,     2,                                    \
3229           "Number of receiver types to record in call/cast profile")        \
3230                                                                             \
3231   develop(intx, BciProfileWidth,      2,                                    \
3232           "Number of return bci's to record in ret profile")                \
3233                                                                             \
3234   product(intx, PerMethodRecompilationCutoff, 400,                          \
3235           "After recompiling N times, stay in the interpreter (-1=&gt;'Inf')") \
3236           range(-1, max_intx)                                               \
3237                                                                             \
3238   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
3239           "Per-BCI limit on repeated recompilation (-1=&gt;'Inf')")            \
3240           range(-1, max_intx)                                               \
3241                                                                             \
3242   product(intx, PerMethodTrapLimit,  100,                                   \
3243           "Limit on traps (of one kind) in a method (includes inlines)")    \
3244                                                                             \
3245   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
3246           "Limit on speculative traps (of one kind) in a method "           \
3247           "(includes inlines)")                                             \
3248                                                                             \
3249   product(intx, PerBytecodeTrapLimit,  4,                                   \
3250           "Limit on traps (of one kind) at a particular BCI")               \
3251                                                                             \
3252   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
3253           "Extra method data trap entries for speculation")                 \
3254                                                                             \
3255   develop(intx, InlineFrequencyRatio,    20,                                \
3256           "Ratio of call site execution to caller method invocation")       \
3257                                                                             \
3258   develop_pd(intx, InlineFrequencyCount,                                    \
3259           "Count of call site execution necessary to trigger frequent "     \
3260           "inlining")                                                       \
3261                                                                             \
3262   develop(intx, InlineThrowCount,    50,                                    \
3263           "Force inlining of interpreted methods that throw this often")    \
3264                                                                             \
3265   develop(intx, InlineThrowMaxSize,   200,                                  \
3266           "Force inlining of throwing methods smaller than this")           \
3267                                                                             \
3268   develop(intx, ProfilerNodeSize,  1024,                                    \
3269           "Size in K to allocate for the Profile Nodes of each thread")     \
3270                                                                             \
3271   /* gc parameters */                                                       \
3272   product(size_t, InitialHeapSize, 0,                                       \
3273           "Initial heap size (in bytes); zero means use ergonomics")        \
3274                                                                             \
3275   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
3276           "Maximum heap size (in bytes)")                                   \
3277                                                                             \
3278   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
3279           "Initial tenured generation size (in bytes)")                     \
3280                                                                             \
3281   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
3282           "Initial new generation size (in bytes)")                         \
3283                                                                             \
3284   product(size_t, MaxNewSize, max_uintx,                                    \
3285           "Maximum new generation size (in bytes), max_uintx means set "    \
3286           "ergonomically")                                                  \
3287                                                                             \
3288   product(size_t, PretenureSizeThreshold, 0,                                \
3289           "Maximum size in bytes of objects allocated in DefNew "           \
3290           "generation; zero means no maximum")                              \
3291                                                                             \
3292   product(size_t, TLABSize, 0,                                              \
3293           "Starting TLAB size (in bytes); zero means set ergonomically")    \
3294                                                                             \
3295   product(size_t, MinTLABSize, 2*K,                                         \
3296           "Minimum allowed TLAB size (in bytes)")                           \
3297           range(1, max_uintx)                                               \
3298                                                                             \
3299   product(uintx, TLABAllocationWeight, 35,                                  \
3300           "Allocation averaging weight")                                    \
3301           range(0, 100)                                                     \
3302                                                                             \
3303   /* Limit the lower bound of this flag to 1 as it is used  */              \
3304   /* in a division expression.                              */              \
3305   product(uintx, TLABWasteTargetPercent, 1,                                 \
3306           "Percentage of Eden that can be wasted")                          \
3307           range(1, 100)                                                     \
3308                                                                             \
3309   product(uintx, TLABRefillWasteFraction,    64,                            \
3310           "Maximum TLAB waste at a refill (internal fragmentation)")        \
3311           range(1, max_uintx)                                               \
3312                                                                             \
3313   product(uintx, TLABWasteIncrement,    4,                                  \
3314           "Increment allowed waste at slow allocation")                     \
3315                                                                             \
3316   product(uintx, SurvivorRatio, 8,                                          \
3317           "Ratio of eden/survivor space size")                              \
3318                                                                             \
3319   product(uintx, NewRatio, 2,                                               \
3320           "Ratio of old/new generation sizes")                              \
3321                                                                             \
3322   product_pd(size_t, NewSizeThreadIncrease,                                 \
3323           "Additional size added to desired new generation size per "       \
3324           "non-daemon thread (in bytes)")                                   \
3325                                                                             \
3326   product_pd(size_t, MetaspaceSize,                                         \
3327           "Initial size of Metaspaces (in bytes)")                          \
3328                                                                             \
3329   product(size_t, MaxMetaspaceSize, max_uintx,                              \
3330           "Maximum size of Metaspaces (in bytes)")                          \
3331                                                                             \
3332   product(size_t, CompressedClassSpaceSize, 1*G,                            \
3333           "Maximum size of class area in Metaspace when compressed "        \
3334           "class pointers are used")                                        \
3335           range(1*M, 3*G)                                                   \
3336                                                                             \
3337   manageable(uintx, MinHeapFreeRatio, 40,                                   \
3338           "The minimum percentage of heap free after GC to avoid expansion."\
3339           " For most GCs this applies to the old generation. In G1 and"     \
3340           " ParallelGC it applies to the whole heap.")                      \
3341           range(0, 100)                                                     \
3342           constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \
3343                                                                             \
3344   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
3345           "The maximum percentage of heap free after GC to avoid shrinking."\
3346           " For most GCs this applies to the old generation. In G1 and"     \
3347           " ParallelGC it applies to the whole heap.")                      \
3348           range(0, 100)                                                     \
3349           constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \
3350                                                                             \
3351   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
3352           "Number of milliseconds per MB of free space in the heap")        \
3353                                                                             \
3354   product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),               \
3355           "The minimum change in heap space due to GC (in bytes)")          \
3356                                                                             \
3357   product(size_t, MinMetaspaceExpansion, ScaleForWordSize(256*K),           \
3358           "The minimum expansion of Metaspace (in bytes)")                  \
3359                                                                             \
3360   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
3361           "The maximum percentage of Metaspace free after GC to avoid "     \
3362           "shrinking")                                                      \
3363           range(0, 100)                                                     \
3364           constraint(MaxMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3365                                                                             \
3366   product(uintx, MinMetaspaceFreeRatio,    40,                              \
3367           "The minimum percentage of Metaspace free after GC to avoid "     \
3368           "expansion")                                                      \
3369           range(0, 99)                                                      \
3370           constraint(MinMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3371                                                                             \
3372   product(size_t, MaxMetaspaceExpansion, ScaleForWordSize(4*M),             \
3373           "The maximum expansion of Metaspace without full GC (in bytes)")  \
3374                                                                             \
3375   product(uintx, QueuedAllocationWarningCount, 0,                           \
3376           "Number of times an allocation that queues behind a GC "          \
3377           "will retry before printing a warning")                           \
3378                                                                             \
3379   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
3380           "GC invoke count where +VerifyBefore/AfterGC kicks in")           \
3381                                                                             \
3382   diagnostic(intx, VerifyGCLevel,     0,                                    \
3383           "Generation level at which to start +VerifyBefore/AfterGC")       \
3384                                                                             \
3385   product(uintx, MaxTenuringThreshold,    15,                               \
3386           "Maximum value for tenuring threshold")                           \
3387           range(0, markOopDesc::max_age + 1)                                \
3388           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
3389                                                                             \
3390   product(uintx, InitialTenuringThreshold,    7,                            \
3391           "Initial value for tenuring threshold")                           \
3392           range(0, markOopDesc::max_age + 1)                                \
3393           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
3394                                                                             \
3395   product(uintx, TargetSurvivorRatio,    50,                                \
3396           "Desired percentage of survivor space used after scavenge")       \
3397           range(0, 100)                                                     \
3398                                                                             \
3399   product(uintx, MarkSweepDeadRatio,     5,                                 \
3400           "Percentage (0-100) of the old gen allowed as dead wood. "        \
3401           "Serial mark sweep treats this as both the minimum and maximum "  \
3402           "value. "                                                         \
3403           "CMS uses this value only if it falls back to mark sweep. "       \
3404           "Par compact uses a variable scale based on the density of the "  \
3405           "generation and treats this as the maximum value when the heap "  \
3406           "is either completely full or completely empty.  Par compact "    \
3407           "also has a smaller default value; see arguments.cpp.")           \
3408           range(0, 100)                                                     \
3409                                                                             \
3410   product(uintx, MarkSweepAlwaysCompactCount,     4,                        \
3411           "How often should we fully compact the heap (ignoring the dead "  \
3412           "space parameters)")                                              \
3413           range(1, max_uintx)                                               \
3414                                                                             \
3415   product(intx, PrintCMSStatistics, 0,                                      \
3416           "Statistics for CMS")                                             \
3417                                                                             \
3418   product(bool, PrintCMSInitiationStatistics, false,                        \
3419           "Statistics for initiating a CMS collection")                     \
3420                                                                             \
3421   product(intx, PrintFLSStatistics, 0,                                      \
3422           "Statistics for CMS' FreeListSpace")                              \
3423                                                                             \
3424   product(intx, PrintFLSCensus, 0,                                          \
3425           "Census for CMS' FreeListSpace")                                  \
3426                                                                             \
3427   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
3428           "Delay between expansion and allocation (in milliseconds)")       \
3429                                                                             \
3430   develop(uintx, GCWorkerDelayMillis, 0,                                    \
3431           "Delay in scheduling GC workers (in milliseconds)")               \
3432                                                                             \
3433   product(intx, DeferThrSuspendLoopCount,     4000,                         \
3434           "(Unstable) Number of times to iterate in safepoint loop "        \
3435           "before blocking VM threads ")                                    \
3436                                                                             \
3437   product(intx, DeferPollingPageLoopCount,     -1,                          \
3438           "(Unsafe,Unstable) Number of iterations in safepoint loop "       \
3439           "before changing safepoint polling page to RO ")                  \
3440                                                                             \
3441   product(intx, SafepointSpinBeforeYield, 2000, "(Unstable)")               \
3442                                                                             \
3443   product(bool, PSChunkLargeArrays, true,                                   \
3444           "Process large arrays in chunks")                                 \
3445                                                                             \
3446   product(uintx, GCDrainStackTargetSize, 64,                                \
3447           "Number of entries we will try to leave on the stack "            \
3448           "during parallel gc")                                             \
3449                                                                             \
3450   /* stack parameters */                                                    \
3451   product_pd(intx, StackYellowPages,                                        \
3452           "Number of yellow zone (recoverable overflows) pages")            \
3453           range(1, max_intx)                                                \
3454                                                                             \
3455   product_pd(intx, StackRedPages,                                           \
3456           "Number of red zone (unrecoverable overflows) pages")             \
3457           range(1, max_intx)                                                \
3458                                                                             \
3459   /* greater stack shadow pages can't generate instruction to bang stack */ \
3460   product_pd(intx, StackShadowPages,                                        \
3461           "Number of shadow zone (for overflow checking) pages "            \
3462           "this should exceed the depth of the VM and native call stack")   \
3463           range(1, 50)                                                      \
3464                                                                             \
3465   product_pd(intx, ThreadStackSize,                                         \
3466           "Thread Stack Size (in Kbytes)")                                  \
3467                                                                             \
3468   product_pd(intx, VMThreadStackSize,                                       \
3469           "Non-Java Thread Stack Size (in Kbytes)")                         \
3470                                                                             \
3471   product_pd(intx, CompilerThreadStackSize,                                 \
3472           "Compiler Thread Stack Size (in Kbytes)")                         \
3473                                                                             \
3474   develop_pd(size_t, JVMInvokeMethodSlack,                                  \
3475           "Stack space (bytes) required for JVM_InvokeMethod to complete")  \
3476                                                                             \
3477   /* code cache parameters                                    */            \
3478   /* ppc64/tiered compilation has large code-entry alignment. */            \
3479   develop(uintx, CodeCacheSegmentSize, 64 PPC64_ONLY(+64) NOT_PPC64(TIERED_ONLY(+64)),\
3480           "Code cache segment size (in bytes) - smallest unit of "          \
3481           "allocation")                                                     \
3482           range(1, 1024)                                                    \
3483                                                                             \
3484   develop_pd(intx, CodeEntryAlignment,                                      \
3485           "Code entry alignment for generated code (in bytes)")             \
3486                                                                             \
3487   product_pd(intx, OptoLoopAlignment,                                       \
3488           "Align inner loops to zero relative to this modulus")             \
3489                                                                             \
3490   product_pd(uintx, InitialCodeCacheSize,                                   \
3491           "Initial code cache size (in bytes)")                             \
3492                                                                             \
3493   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
3494           "Minimum code cache size (in bytes) required to start VM.")       \
3495                                                                             \
3496   product(bool, SegmentedCodeCache, false,                                  \
3497           "Use a segmented code cache")                                     \
3498                                                                             \
3499   product_pd(uintx, ReservedCodeCacheSize,                                  \
3500           "Reserved code cache size (in bytes) - maximum code cache size")  \
3501                                                                             \
3502   product_pd(uintx, NonProfiledCodeHeapSize,                                \
3503           "Size of code heap with non-profiled methods (in bytes)")         \
3504                                                                             \
3505   product_pd(uintx, ProfiledCodeHeapSize,                                   \
3506           "Size of code heap with profiled methods (in bytes)")             \
3507                                                                             \
3508   product_pd(uintx, NonNMethodCodeHeapSize,                                 \
3509           "Size of code heap with non-nmethods (in bytes)")                 \
3510                                                                             \
3511   product_pd(uintx, CodeCacheExpansionSize,                                 \
3512           "Code cache expansion size (in bytes)")                           \
3513                                                                             \
3514   develop_pd(uintx, CodeCacheMinBlockLength,                                \
3515           "Minimum number of segments in a code cache block")               \
3516           range(1, 100)                                                     \
3517                                                                             \
3518   notproduct(bool, ExitOnFullCodeCache, false,                              \
3519           "Exit the VM if we fill the code cache")                          \
3520                                                                             \
3521   product(bool, UseCodeCacheFlushing, true,                                 \
3522           "Remove cold/old nmethods from the code cache")                   \
3523                                                                             \
3524   product(uintx, StartAggressiveSweepingAt, 10,                             \
3525           "Start aggressive sweeping if X[%] of the code cache is free."    \
3526           "Segmented code cache: X[%] of the non-profiled heap."            \
3527           "Non-segmented code cache: X[%] of the total code cache")         \
3528           range(0, 100)                                                     \
3529                                                                             \
3530   /* interpreter debugging */                                               \
3531   develop(intx, BinarySwitchThreshold, 5,                                   \
3532           "Minimal number of lookupswitch entries for rewriting to binary " \
3533           "switch")                                                         \
3534                                                                             \
3535   develop(intx, StopInterpreterAt, 0,                                       \
3536           "Stop interpreter execution at specified bytecode number")        \
3537                                                                             \
3538   develop(intx, TraceBytecodesAt, 0,                                        \
3539           "Trace bytecodes starting with specified bytecode number")        \
3540                                                                             \
3541   /* compiler interface */                                                  \
3542   develop(intx, CIStart, 0,                                                 \
3543           "The id of the first compilation to permit")                      \
3544                                                                             \
3545   develop(intx, CIStop, max_jint,                                           \
3546           "The id of the last compilation to permit")                       \
3547                                                                             \
3548   develop(intx, CIStartOSR, 0,                                              \
3549           "The id of the first osr compilation to permit "                  \
3550           "(CICountOSR must be on)")                                        \
3551                                                                             \
3552   develop(intx, CIStopOSR, max_jint,                                        \
3553           "The id of the last osr compilation to permit "                   \
3554           "(CICountOSR must be on)")                                        \
3555                                                                             \
3556   develop(intx, CIBreakAtOSR, -1,                                           \
3557           "The id of osr compilation to break at")                          \
3558                                                                             \
3559   develop(intx, CIBreakAt, -1,                                              \
3560           "The id of compilation to break at")                              \
3561                                                                             \
3562   product(ccstrlist, CompileOnly, "",                                       \
3563           "List of methods (pkg/class.name) to restrict compilation to")    \
3564                                                                             \
3565   product(ccstr, CompileCommandFile, NULL,                                  \
3566           "Read compiler commands from this file [.hotspot_compiler]")      \
3567                                                                             \
3568   product(ccstrlist, CompileCommand, "",                                    \
3569           "Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;") \
3570                                                                             \
3571   develop(bool, ReplayCompiles, false,                                      \
3572           "Enable replay of compilations from ReplayDataFile")              \
3573                                                                             \
3574   product(ccstr, ReplayDataFile, NULL,                                      \
3575           "File containing compilation replay information"                  \
3576           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
3577                                                                             \
3578    product(ccstr, InlineDataFile, NULL,                                     \
3579           "File containing inlining replay information"                     \
3580           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
3581                                                                             \
3582   develop(intx, ReplaySuppressInitializers, 2,                              \
3583           "Control handling of class initialization during replay: "        \
3584           "0 - don't do anything special; "                                 \
3585           "1 - treat all class initializers as empty; "                     \
3586           "2 - treat class initializers for application classes as empty; " \
3587           "3 - allow all class initializers to run during bootstrap but "   \
3588           "    pretend they are empty after starting replay")               \
3589           range(0, 3)                                                       \
3590                                                                             \
3591   develop(bool, ReplayIgnoreInitErrors, false,                              \
3592           "Ignore exceptions thrown during initialization for replay")      \
3593                                                                             \
3594   product(bool, DumpReplayDataOnError, true,                                \
3595           "Record replay data for crashing compiler threads")               \
3596                                                                             \
3597   product(bool, CICompilerCountPerCPU, false,                               \
3598           "1 compiler thread for log(N CPUs)")                              \
3599                                                                             \
3600   develop(intx, CIFireOOMAt,    -1,                                         \
3601           "Fire OutOfMemoryErrors throughout CI for testing the compiler "  \
3602           "(non-negative value throws OOM after this many CI accesses "     \
3603           "in each compile)")                                               \
3604   notproduct(intx, CICrashAt, -1,                                           \
3605           "id of compilation to trigger assert in compiler thread for "     \
3606           "the purpose of testing, e.g. generation of replay data")         \
3607   notproduct(bool, CIObjectFactoryVerify, false,                            \
3608           "enable potentially expensive verification in ciObjectFactory")   \
3609                                                                             \
3610   /* Priorities */                                                          \
3611   product_pd(bool, UseThreadPriorities,  "Use native thread priorities")    \
3612                                                                             \
3613   product(intx, ThreadPriorityPolicy, 0,                                    \
3614           "0 : Normal.                                                     "\
3615           "    VM chooses priorities that are appropriate for normal       "\
3616           "    applications. On Solaris NORM_PRIORITY and above are mapped "\
3617           "    to normal native priority. Java priorities below "           \
3618           "    NORM_PRIORITY map to lower native priority values. On       "\
3619           "    Windows applications are allowed to use higher native       "\
3620           "    priorities. However, with ThreadPriorityPolicy=0, VM will   "\
3621           "    not use the highest possible native priority,               "\
3622           "    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     "\
3623           "    system threads. On Linux thread priorities are ignored      "\
3624           "    because the OS does not support static priority in          "\
3625           "    SCHED_OTHER scheduling class which is the only choice for   "\
3626           "    non-root, non-realtime applications.                        "\
3627           "1 : Aggressive.                                                 "\
3628           "    Java thread priorities map over to the entire range of      "\
3629           "    native thread priorities. Higher Java thread priorities map "\
3630           "    to higher native thread priorities. This policy should be   "\
3631           "    used with care, as sometimes it can cause performance       "\
3632           "    degradation in the application and/or the entire system. On "\
3633           "    Linux this policy requires root privilege.")                 \
3634           range(0, 1)                                                       \
3635                                                                             \
3636   product(bool, ThreadPriorityVerbose, false,                               \
3637           "Print priority changes")                                         \
3638                                                                             \
3639   product(intx, CompilerThreadPriority, -1,                                 \
3640           "The native priority at which compiler threads should run "       \
3641           "(-1 means no change)")                                           \
3642                                                                             \
3643   product(intx, VMThreadPriority, -1,                                       \
3644           "The native priority at which the VM thread should run "          \
3645           "(-1 means no change)")                                           \
3646                                                                             \
3647   product(bool, CompilerThreadHintNoPreempt, true,                          \
3648           "(Solaris only) Give compiler threads an extra quanta")           \
3649                                                                             \
3650   product(bool, VMThreadHintNoPreempt, false,                               \
3651           "(Solaris only) Give VM thread an extra quanta")                  \
3652                                                                             \
3653   product(intx, JavaPriority1_To_OSPriority, -1,                            \
3654           "Map Java priorities to OS priorities")                           \
3655                                                                             \
3656   product(intx, JavaPriority2_To_OSPriority, -1,                            \
3657           "Map Java priorities to OS priorities")                           \
3658                                                                             \
3659   product(intx, JavaPriority3_To_OSPriority, -1,                            \
3660           "Map Java priorities to OS priorities")                           \
3661                                                                             \
3662   product(intx, JavaPriority4_To_OSPriority, -1,                            \
3663           "Map Java priorities to OS priorities")                           \
3664                                                                             \
3665   product(intx, JavaPriority5_To_OSPriority, -1,                            \
3666           "Map Java priorities to OS priorities")                           \
3667                                                                             \
3668   product(intx, JavaPriority6_To_OSPriority, -1,                            \
3669           "Map Java priorities to OS priorities")                           \
3670                                                                             \
3671   product(intx, JavaPriority7_To_OSPriority, -1,                            \
3672           "Map Java priorities to OS priorities")                           \
3673                                                                             \
3674   product(intx, JavaPriority8_To_OSPriority, -1,                            \
3675           "Map Java priorities to OS priorities")                           \
3676                                                                             \
3677   product(intx, JavaPriority9_To_OSPriority, -1,                            \
3678           "Map Java priorities to OS priorities")                           \
3679                                                                             \
3680   product(intx, JavaPriority10_To_OSPriority,-1,                            \
3681           "Map Java priorities to OS priorities")                           \
3682                                                                             \
3683   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
3684           "Java thread priority 10 maps to critical scheduling priority")   \
3685                                                                             \
3686   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
3687           "Compiler thread(s) run at critical scheduling priority")         \
3688                                                                             \
3689   experimental(bool, UseCriticalCMSThreadPriority, false,                   \
3690           "ConcurrentMarkSweep thread runs at critical scheduling priority")\
3691                                                                             \
3692   /* compiler debugging */                                                  \
3693   notproduct(intx, CompileTheWorldStartAt,     1,                           \
3694           "First class to consider when using +CompileTheWorld")            \
3695                                                                             \
3696   notproduct(intx, CompileTheWorldStopAt, max_jint,                         \
3697           "Last class to consider when using +CompileTheWorld")             \
3698                                                                             \
3699   develop(intx, NewCodeParameter,      0,                                   \
3700           "Testing Only: Create a dedicated integer parameter before "      \
3701           "putback")                                                        \
3702                                                                             \
3703   /* new oopmap storage allocation */                                       \
3704   develop(intx, MinOopMapAllocation,     8,                                 \
3705           "Minimum number of OopMap entries in an OopMapSet")               \
3706                                                                             \
3707   /* Background Compilation */                                              \
3708   develop(intx, LongCompileThreshold,     50,                               \
3709           "Used with +TraceLongCompiles")                                   \
3710                                                                             \
3711   /* recompilation */                                                       \
3712   product_pd(intx, CompileThreshold,                                        \
3713           "number of interpreted method invocations before (re-)compiling") \
3714                                                                             \
3715   product(double, CompileThresholdScaling, 1.0,                             \
3716           "Factor to control when first compilation happens "               \
3717           "(both with and without tiered compilation): "                    \
3718           "values greater than 1.0 delay counter overflow, "                \
3719           "values between 0 and 1.0 rush counter overflow, "                \
3720           "value of 1.0 leaves compilation thresholds unchanged "           \
3721           "value of 0.0 is equivalent to -Xint. "                           \
3722           ""                                                                \
3723           "Flag can be set as per-method option. "                          \
3724           "If a value is specified for a method, compilation thresholds "   \
3725           "for that method are scaled by both the value of the global flag "\
3726           "and the value of the per-method flag.")                          \
3727                                                                             \
3728   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
3729           "Interpreter (tier 0) invocation notification frequency")         \
3730                                                                             \
3731   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
3732           "C1 without MDO (tier 2) invocation notification frequency")      \
3733                                                                             \
3734   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
3735           "C1 with MDO profiling (tier 3) invocation notification "         \
3736           "frequency")                                                      \
3737                                                                             \
3738   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
3739           "Inlinee invocation (tiers 2 and 3) notification frequency")      \
3740                                                                             \
3741   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
3742           "Interpreter (tier 0) invocation notification frequency")         \
3743                                                                             \
3744   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
3745           "C1 without MDO (tier 2) invocation notification frequency")      \
3746                                                                             \
3747   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
3748           "C1 with MDO profiling (tier 3) invocation notification "         \
3749           "frequency")                                                      \
3750                                                                             \
3751   product(intx, Tier2CompileThreshold, 0,                                   \
3752           "threshold at which tier 2 compilation is invoked")               \
3753                                                                             \
3754   product(intx, Tier2BackEdgeThreshold, 0,                                  \
3755           "Back edge threshold at which tier 2 compilation is invoked")     \
3756                                                                             \
3757   product(intx, Tier3InvocationThreshold, 200,                              \
3758           "Compile if number of method invocations crosses this "           \
3759           "threshold")                                                      \
3760                                                                             \
3761   product(intx, Tier3MinInvocationThreshold, 100,                           \
3762           "Minimum invocation to compile at tier 3")                        \
3763                                                                             \
3764   product(intx, Tier3CompileThreshold, 2000,                                \
3765           "Threshold at which tier 3 compilation is invoked (invocation "   \
3766           "minimum must be satisfied")                                      \
3767                                                                             \
3768   product(intx, Tier3BackEdgeThreshold,  60000,                             \
3769           "Back edge threshold at which tier 3 OSR compilation is invoked") \
3770                                                                             \
3771   product(intx, Tier4InvocationThreshold, 5000,                             \
3772           "Compile if number of method invocations crosses this "           \
3773           "threshold")                                                      \
3774                                                                             \
3775   product(intx, Tier4MinInvocationThreshold, 600,                           \
3776           "Minimum invocation to compile at tier 4")                        \
3777                                                                             \
3778   product(intx, Tier4CompileThreshold, 15000,                               \
3779           "Threshold at which tier 4 compilation is invoked (invocation "   \
3780           "minimum must be satisfied")                                      \
3781                                                                             \
3782   product(intx, Tier4BackEdgeThreshold, 40000,                              \
3783           "Back edge threshold at which tier 4 OSR compilation is invoked") \
3784                                                                             \
3785   product(intx, Tier3DelayOn, 5,                                            \
3786           "If C2 queue size grows over this amount per compiler thread "    \
3787           "stop compiling at tier 3 and start compiling at tier 2")         \
3788                                                                             \
3789   product(intx, Tier3DelayOff, 2,                                           \
3790           "If C2 queue size is less than this amount per compiler thread "  \
3791           "allow methods compiled at tier 2 transition to tier 3")          \
3792                                                                             \
3793   product(intx, Tier3LoadFeedback, 5,                                       \
3794           "Tier 3 thresholds will increase twofold when C1 queue size "     \
3795           "reaches this amount per compiler thread")                        \
3796                                                                             \
3797   product(intx, Tier4LoadFeedback, 3,                                       \
3798           "Tier 4 thresholds will increase twofold when C2 queue size "     \
3799           "reaches this amount per compiler thread")                        \
3800                                                                             \
3801   product(intx, TieredCompileTaskTimeout, 50,                               \
3802           "Kill compile task if method was not used within "                \
3803           "given timeout in milliseconds")                                  \
3804                                                                             \
3805   product(intx, TieredStopAtLevel, 4,                                       \
3806           "Stop at given compilation level")                                \
3807                                                                             \
3808   product(intx, Tier0ProfilingStartPercentage, 200,                         \
3809           "Start profiling in interpreter if the counters exceed tier 3 "   \
3810           "thresholds by the specified percentage")                         \
3811                                                                             \
3812   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
3813           "Increase the compile threshold for C1 compilation if the code "  \
3814           "cache is filled by the specified percentage")                    \
3815           range(0, 99)                                                      \
3816                                                                             \
3817   product(intx, TieredRateUpdateMinTime, 1,                                 \
3818           "Minimum rate sampling interval (in milliseconds)")               \
3819                                                                             \
3820   product(intx, TieredRateUpdateMaxTime, 25,                                \
3821           "Maximum rate sampling interval (in milliseconds)")               \
3822                                                                             \
3823   product_pd(bool, TieredCompilation,                                       \
3824           "Enable tiered compilation")                                      \
3825                                                                             \
3826   product(bool, PrintTieredEvents, false,                                   \
3827           "Print tiered events notifications")                              \
3828                                                                             \
3829   product_pd(intx, OnStackReplacePercentage,                                \
3830           "NON_TIERED number of method invocations/branches (expressed as " \
3831           "% of CompileThreshold) before (re-)compiling OSR code")          \
3832                                                                             \
3833   product(intx, InterpreterProfilePercentage, 33,                           \
3834           "NON_TIERED number of method invocations/branches (expressed as " \
3835           "% of CompileThreshold) before profiling in the interpreter")     \
3836           range(0, 100)                                                     \
3837                                                                             \
3838   develop(intx, MaxRecompilationSearchLength,    10,                        \
3839           "The maximum number of frames to inspect when searching for "     \
3840           "recompilee")                                                     \
3841                                                                             \
3842   develop(intx, MaxInterpretedSearchLength,     3,                          \
3843           "The maximum number of interpreted frames to skip when searching "\
3844           "for recompilee")                                                 \
3845                                                                             \
3846   develop(intx, DesiredMethodLimit,  8000,                                  \
3847           "The desired maximum method size (in bytecodes) after inlining")  \
3848                                                                             \
3849   develop(intx, HugeMethodLimit,  8000,                                     \
3850           "Don't compile methods larger than this if "                      \
3851           "+DontCompileHugeMethods")                                        \
3852                                                                             \
3853   /* New JDK 1.4 reflection implementation */                               \
3854                                                                             \
3855   develop(intx, FastSuperclassLimit, 8,                                     \
3856           "Depth of hardwired instanceof accelerator array")                \
3857                                                                             \
3858   /* Properties for Java libraries  */                                      \
3859                                                                             \
3860   product(size_t, MaxDirectMemorySize, 0,                                   \
3861           "Maximum total size of NIO direct-buffer allocations")            \
3862                                                                             \
3863   /* Flags used for temporary code during development  */                   \
3864                                                                             \
3865   diagnostic(bool, UseNewCode, false,                                       \
3866           "Testing Only: Use the new version while testing")                \
3867                                                                             \
3868   diagnostic(bool, UseNewCode2, false,                                      \
3869           "Testing Only: Use the new version while testing")                \
3870                                                                             \
3871   diagnostic(bool, UseNewCode3, false,                                      \
3872           "Testing Only: Use the new version while testing")                \
3873                                                                             \
3874   /* flags for performance data collection */                               \
3875                                                                             \
3876   product(bool, UsePerfData, falseInEmbedded,                               \
3877           "Flag to disable jvmstat instrumentation for performance testing "\
3878           "and problem isolation purposes")                                 \
3879                                                                             \
3880   product(bool, PerfDataSaveToFile, false,                                  \
3881           "Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit")          \
3882                                                                             \
3883   product(ccstr, PerfDataSaveFile, NULL,                                    \
3884           "Save PerfData memory to the specified absolute pathname. "       \
3885           "The string %p in the file name (if present) "                    \
3886           "will be replaced by pid")                                        \
3887                                                                             \
3888   product(intx, PerfDataSamplingInterval, 50,                               \
3889           "Data sampling interval (in milliseconds)")                       \
3890                                                                             \
3891   develop(bool, PerfTraceDataCreation, false,                               \
3892           "Trace creation of Performance Data Entries")                     \
3893                                                                             \
3894   develop(bool, PerfTraceMemOps, false,                                     \
3895           "Trace PerfMemory create/attach/detach calls")                    \
3896                                                                             \
3897   product(bool, PerfDisableSharedMem, false,                                \
3898           "Store performance data in standard memory")                      \
3899                                                                             \
3900   product(intx, PerfDataMemorySize, 64*K,                                   \
3901           "Size of performance data memory region. Will be rounded "        \
3902           "up to a multiple of the native os page size.")                   \
3903                                                                             \
3904   product(intx, PerfMaxStringConstLength, 1024,                             \
3905           "Maximum PerfStringConstant string length before truncation")     \
3906                                                                             \
3907   product(bool, PerfAllowAtExitRegistration, false,                         \
3908           "Allow registration of atexit() methods")                         \
3909                                                                             \
3910   product(bool, PerfBypassFileSystemCheck, false,                           \
3911           "Bypass Win32 file system criteria checks (Windows Only)")        \
3912                                                                             \
3913   product(intx, UnguardOnExecutionViolation, 0,                             \
3914           "Unguard page and retry on no-execute fault (Win32 only) "        \
3915           "0=off, 1=conservative, 2=aggressive")                            \
3916           range(0, 2)                                                       \
3917                                                                             \
3918   /* Serviceability Support */                                              \
3919                                                                             \
3920   product(bool, ManagementServer, false,                                    \
3921           "Create JMX Management Server")                                   \
3922                                                                             \
3923   product(bool, DisableAttachMechanism, false,                              \
3924           "Disable mechanism that allows tools to attach to this VM")       \
3925                                                                             \
3926   product(bool, StartAttachListener, false,                                 \
3927           "Always start Attach Listener at VM startup")                     \
3928                                                                             \
3929   manageable(bool, PrintConcurrentLocks, false,                             \
3930           "Print java.util.concurrent locks in thread dump")                \
3931                                                                             \
3932   product(bool, TransmitErrorReport, false,                                 \
3933           "Enable error report transmission on erroneous termination")      \
3934                                                                             \
3935   product(ccstr, ErrorReportServer, NULL,                                   \
3936           "Override built-in error report server address")                  \
3937                                                                             \
3938   /* Shared spaces */                                                       \
3939                                                                             \
3940   product(bool, UseSharedSpaces, true,                                      \
3941           "Use shared spaces for metadata")                                 \
3942                                                                             \
3943   product(bool, VerifySharedSpaces, false,                                  \
3944           "Verify shared spaces (false for default archive, true for "      \
3945           "archive specified by -XX:SharedArchiveFile)")                    \
3946                                                                             \
3947   product(bool, RequireSharedSpaces, false,                                 \
3948           "Require shared spaces for metadata")                             \
3949                                                                             \
3950   product(bool, DumpSharedSpaces, false,                                    \
3951           "Special mode: JVM reads a class list, loads classes, builds "    \
3952           "shared spaces, and dumps the shared spaces to a file to be "     \
3953           "used in future JVM runs")                                        \
3954                                                                             \
3955   product(bool, PrintSharedSpaces, false,                                   \
3956           "Print usage of shared spaces")                                   \
3957                                                                             \
3958   product(bool, PrintSharedArchiveAndExit, false,                           \
3959           "Print shared archive file contents")                             \
3960                                                                             \
3961   product(bool, PrintSharedDictionary, false,                               \
3962           "If PrintSharedArchiveAndExit is true, also print the shared "    \
3963           "dictionary")                                                     \
3964                                                                             \
3965   product(size_t, SharedReadWriteSize,  NOT_LP64(12*M) LP64_ONLY(16*M),     \
3966           "Size of read-write space for metadata (in bytes)")               \
3967                                                                             \
3968   product(size_t, SharedReadOnlySize,  NOT_LP64(12*M) LP64_ONLY(16*M),      \
3969           "Size of read-only space for metadata (in bytes)")                \
3970                                                                             \
3971   product(uintx, SharedMiscDataSize,    NOT_LP64(2*M) LP64_ONLY(4*M),       \
3972           "Size of the shared miscellaneous data area (in bytes)")          \
3973                                                                             \
3974   product(uintx, SharedMiscCodeSize,    120*K,                              \
3975           "Size of the shared miscellaneous code area (in bytes)")          \
3976                                                                             \
3977   product(uintx, SharedBaseAddress, LP64_ONLY(32*G)                         \
3978           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
3979           "Address to allocate shared memory region for class data")        \
3980                                                                             \
3981   product(uintx, SharedSymbolTableBucketSize, 4,                            \
3982           "Average number of symbols per bucket in shared table")           \
3983                                                                             \
3984   diagnostic(bool, IgnoreUnverifiableClassesDuringDump, false,              \
3985           "Do not quit -Xshare:dump even if we encounter unverifiable "     \
3986           "classes. Just exclude them from the shared dictionary.")         \
3987                                                                             \
3988   diagnostic(bool, PrintMethodHandleStubs, false,                           \
3989           "Print generated stub code for method handles")                   \
3990                                                                             \
3991   develop(bool, TraceMethodHandles, false,                                  \
3992           "trace internal method handle operations")                        \
3993                                                                             \
3994   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
3995           "perform extra checks when constructing method handles")          \
3996                                                                             \
3997   diagnostic(bool, ShowHiddenFrames, false,                                 \
3998           "show method handle implementation frames (usually hidden)")      \
3999                                                                             \
4000   experimental(bool, TrustFinalNonStaticFields, false,                      \
4001           "trust final non-static declarations for constant folding")       \
4002                                                                             \
4003   diagnostic(bool, FoldStableValues, true,                                  \
4004           "Optimize loads from stable fields (marked w/ @Stable)")          \
4005                                                                             \
4006   develop(bool, TraceInvokeDynamic, false,                                  \
4007           "trace internal invoke dynamic operations")                       \
4008                                                                             \
4009   diagnostic(bool, PauseAtStartup,      false,                              \
4010           "Causes the VM to pause at startup time and wait for the pause "  \
4011           "file to be removed (default: ./vm.paused.&lt;pid&gt;)")                \
4012                                                                             \
4013   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
4014           "The file to create and for whose removal to await when pausing " \
4015           "at startup. (default: ./vm.paused.&lt;pid&gt;)")                       \
4016                                                                             \
4017   diagnostic(bool, PauseAtExit, false,                                      \
4018           "Pause and wait for keypress on exit if a debugger is attached")  \
4019                                                                             \
4020   product(bool, ExtendedDTraceProbes,    false,                             \
4021           "Enable performance-impacting dtrace probes")                     \
4022                                                                             \
4023   product(bool, DTraceMethodProbes, false,                                  \
4024           "Enable dtrace probes for method-entry and method-exit")          \
4025                                                                             \
4026   product(bool, DTraceAllocProbes, false,                                   \
4027           "Enable dtrace probes for object allocation")                     \
4028                                                                             \
4029   product(bool, DTraceMonitorProbes, false,                                 \
4030           "Enable dtrace probes for monitor events")                        \
4031                                                                             \
4032   product(bool, RelaxAccessControlCheck, false,                             \
4033           "Relax the access control checks in the verifier")                \
4034                                                                             \
4035   product(uintx, StringTableSize, defaultStringTableSize,                   \
4036           "Number of buckets in the interned String table")                 \
4037           range(minimumStringTableSize, 111*defaultStringTableSize)         \
4038                                                                             \
4039   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
4040           "Number of buckets in the JVM internal Symbol table")             \
4041           range(minimumSymbolTableSize, 111*defaultSymbolTableSize)         \
4042                                                                             \
4043   product(bool, UseStringDeduplication, false,                              \
4044           "Use string deduplication")                                       \
4045                                                                             \
4046   product(bool, PrintStringDeduplicationStatistics, false,                  \
4047           "Print string deduplication statistics")                          \
4048                                                                             \
4049   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
4050           "A string must reach this age (or be promoted to an old region) " \
4051           "to be considered for deduplication")                             \
4052           range(1, markOopDesc::max_age)                                    \
4053                                                                             \
4054   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
4055           "Force table resize every time the table is scanned")             \
4056                                                                             \
4057   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
4058           "Force table rehash every time the table is scanned")             \
4059                                                                             \
4060   develop(bool, TraceDefaultMethods, false,                                 \
4061           "Trace the default method processing steps")                      \
4062                                                                             \
4063   diagnostic(bool, WhiteBoxAPI, false,                                      \
4064           "Enable internal testing APIs")                                   \
4065                                                                             \
4066   product(bool, PrintGCCause, true,                                         \
4067           "Include GC cause in GC logging")                                 \
4068                                                                             \
4069   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
4070            "Default survivor space alignment in bytes")                     \
4071            constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \
4072                                                                             \
4073   product(bool , AllowNonVirtualCalls, false,                               \
4074           "Obey the ACC_SUPER flag and allow invokenonvirtual calls")       \
4075                                                                             \
4076   product(ccstr, DumpLoadedClassList, NULL,                                 \
4077           "Dump the names all loaded classes, that could be stored into "   \
4078           "the CDS archive, in the specified file")                         \
4079                                                                             \
4080   product(ccstr, SharedClassListFile, NULL,                                 \
4081           "Override the default CDS class list")                            \
4082                                                                             \
4083   diagnostic(ccstr, SharedArchiveFile, NULL,                                \
4084           "Override the default location of the CDS archive file")          \
4085                                                                             \
4086   product(ccstr, ExtraSharedClassListFile, NULL,                            \
4087           "Extra classlist for building the CDS archive file")              \
4088                                                                             \
4089   experimental(size_t, ArrayAllocatorMallocLimit,                           \
4090           SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \
4091           "Allocation less than this value will be allocated "              \
4092           "using malloc. Larger allocations will use mmap.")                \
4093                                                                             \
4094   experimental(bool, AlwaysAtomicAccesses, false,                           \
4095           "Accesses to all variables should always be atomic")              \
4096                                                                             \
4097   product(bool, EnableTracing, false,                                       \
4098           "Enable event-based tracing")                                     \
4099                                                                             \
4100   product(bool, UseLockedTracing, false,                                    \
4101           "Use locked-tracing when doing event-based tracing")              \
4102                                                                             \
4103   diagnostic(bool, UseUnalignedAccesses, false,                             \
4104           "Use unaligned memory accesses in sun.misc.Unsafe")               \
4105                                                                             \
4106   product_pd(bool, PreserveFramePointer,                                    \
4107              "Use the FP register for holding the frame pointer "           \
4108              "and not as a general purpose register.")                      \
4109                                                                             \
4110   diagnostic(bool, CheckIntrinsics, true,                                   \
4111              "When a class C is loaded, check that "                        \
4112              "(1) all intrinsics defined by the VM for class C are present "\
4113              "in the loaded class file and are marked with the "            \
4114              "@HotSpotIntrinsicCandidate annotation, that "                 \
4115              "(2) there is an intrinsic registered for all loaded methods " \
4116              "that are annotated with the @HotSpotIntrinsicCandidate "      \
4117              "annotation, and that "                                        \
4118              "(3) no orphan methods exist for class C (i.e., methods for "  \
4119              "which the VM declares an intrinsic but that are not declared "\
4120              "in the loaded class C. "                                      \
4121              "Check (3) is available only in debug builds.")
4122 
4123 /*
4124  *  Macros for factoring of globals
4125  */
4126 
4127 // Interface macros
4128 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern "C" type name;
4129 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern "C" type name;
4130 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern "C" type name;
4131 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern "C" type name;
4132 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern "C" type name;
4133 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern "C" type name;
4134 #ifdef PRODUCT
4135 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type CONST_##name; const type name = value;
4136 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type CONST_##name; const type name = pd_##name;
4137 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type CONST_##name;
4138 #else
4139 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type name;
4140 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type name;
4141 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type name;
4142 #endif // PRODUCT
4143 // Special LP64 flags, product only needed for now.
4144 #ifdef _LP64
4145 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern "C" type name;
4146 #else
4147 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
4148 #endif // _LP64
4149 
4150 // Implementation macros
4151 #define MATERIALIZE_PRODUCT_FLAG(type, name, value, doc)      type name = value;
4152 #define MATERIALIZE_PD_PRODUCT_FLAG(type, name, doc)          type name = pd_##name;
4153 #define MATERIALIZE_DIAGNOSTIC_FLAG(type, name, value, doc)   type name = value;
4154 #define MATERIALIZE_EXPERIMENTAL_FLAG(type, name, value, doc) type name = value;
4155 #define MATERIALIZE_MANAGEABLE_FLAG(type, name, value, doc)   type name = value;
4156 #define MATERIALIZE_PRODUCT_RW_FLAG(type, name, value, doc)   type name = value;
4157 #ifdef PRODUCT
4158 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type CONST_##name = value;
4159 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type CONST_##name = pd_##name;
4160 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type CONST_##name = value;
4161 #else
4162 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type name = value;
4163 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type name = pd_##name;
4164 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type name = value;
4165 #endif // PRODUCT
4166 #ifdef _LP64
4167 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) type name = value;
4168 #else
4169 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) /* flag is constant */
4170 #endif // _LP64
4171 
4172 // Only materialize src code for range checking when required, ignore otherwise
4173 #define IGNORE_RANGE(a, b)
4174 // Only materialize src code for contraint checking when required, ignore otherwise
4175 #define IGNORE_CONSTRAINT(func,type)
4176 
4177 RUNTIME_FLAGS(DECLARE_DEVELOPER_FLAG, \
4178               DECLARE_PD_DEVELOPER_FLAG, \
4179               DECLARE_PRODUCT_FLAG, \
4180               DECLARE_PD_PRODUCT_FLAG, \
4181               DECLARE_DIAGNOSTIC_FLAG, \
4182               DECLARE_EXPERIMENTAL_FLAG, \
4183               DECLARE_NOTPRODUCT_FLAG, \
4184               DECLARE_MANAGEABLE_FLAG, \
4185               DECLARE_PRODUCT_RW_FLAG, \
4186               DECLARE_LP64_PRODUCT_FLAG, \
4187               IGNORE_RANGE, \
4188               IGNORE_CONSTRAINT)
4189 
4190 RUNTIME_OS_FLAGS(DECLARE_DEVELOPER_FLAG, \
4191                  DECLARE_PD_DEVELOPER_FLAG, \
4192                  DECLARE_PRODUCT_FLAG, \
4193                  DECLARE_PD_PRODUCT_FLAG, \
4194                  DECLARE_DIAGNOSTIC_FLAG, \
4195                  DECLARE_NOTPRODUCT_FLAG, \
4196                  IGNORE_RANGE, \
4197                  IGNORE_CONSTRAINT)
4198 
4199 ARCH_FLAGS(DECLARE_DEVELOPER_FLAG, \
4200            DECLARE_PRODUCT_FLAG, \
4201            DECLARE_DIAGNOSTIC_FLAG, \
4202            DECLARE_EXPERIMENTAL_FLAG, \
4203            DECLARE_NOTPRODUCT_FLAG, \
4204            IGNORE_RANGE, \
4205            IGNORE_CONSTRAINT)
4206 
4207 // Extensions
4208 
4209 #include "runtime/globals_ext.hpp"
4210 
4211 #endif // SHARE_VM_RUNTIME_GLOBALS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
