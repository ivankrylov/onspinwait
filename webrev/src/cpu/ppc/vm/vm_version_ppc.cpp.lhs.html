<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright 2012, 2015 SAP AG. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 #include "asm/assembler.inline.hpp"
  28 #include "asm/macroAssembler.inline.hpp"
  29 #include "compiler/disassembler.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "runtime/java.hpp"
  32 #include "runtime/os.hpp"
  33 #include "runtime/stubCodeGenerator.hpp"
  34 #include "utilities/defaultStream.hpp"
  35 #include "utilities/globalDefinitions.hpp"
  36 #include "vm_version_ppc.hpp"
  37 
  38 # include &lt;sys/sysinfo.h&gt;
  39 
  40 int VM_Version::_features = VM_Version::unknown_m;
  41 int VM_Version::_measured_cache_line_size = 32; // pessimistic init value
  42 const char* VM_Version::_features_str = "";
  43 bool VM_Version::_is_determine_features_test_running = false;
  44 
  45 
  46 #define MSG(flag)   \
  47   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
  48       jio_fprintf(defaultStream::error_stream(),                       \
  49                   "warning: -XX:+" #flag " requires -XX:+UseSIGTRAP\n" \
  50                   "         -XX:+" #flag " will be disabled!\n");
  51 
  52 void VM_Version::initialize() {
  53 
  54   // Test which instructions are supported and measure cache line size.
  55   determine_features();
  56 
  57   // If PowerArchitecturePPC64 hasn't been specified explicitly determine from features.
  58   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
  59     if (VM_Version::has_lqarx()) {
  60       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 8);
  61     } else if (VM_Version::has_popcntw()) {
  62       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 7);
  63     } else if (VM_Version::has_cmpb()) {
  64       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 6);
  65     } else if (VM_Version::has_popcntb()) {
  66       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 5);
  67     } else {
  68       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 0);
  69     }
  70   }
  71   guarantee(PowerArchitecturePPC64 == 0 || PowerArchitecturePPC64 == 5 ||
  72             PowerArchitecturePPC64 == 6 || PowerArchitecturePPC64 == 7 ||
  73             PowerArchitecturePPC64 == 8,
  74             "PowerArchitecturePPC64 should be 0, 5, 6, 7, or 8");
  75 
  76   // Power 8: Configure Data Stream Control Register.
  77   if (PowerArchitecturePPC64 &gt;= 8) {
  78     config_dscr();
  79   }
  80 
  81   if (!UseSIGTRAP) {
  82     MSG(TrapBasedICMissChecks);
  83     MSG(TrapBasedNotEntrantChecks);
  84     MSG(TrapBasedNullChecks);
  85     FLAG_SET_ERGO(bool, TrapBasedNotEntrantChecks, false);
  86     FLAG_SET_ERGO(bool, TrapBasedNullChecks,       false);
  87     FLAG_SET_ERGO(bool, TrapBasedICMissChecks,     false);
  88   }
  89 
  90 #ifdef COMPILER2
  91   if (!UseSIGTRAP) {
  92     MSG(TrapBasedRangeChecks);
  93     FLAG_SET_ERGO(bool, TrapBasedRangeChecks, false);
  94   }
  95 
  96   // On Power6 test for section size.
  97   if (PowerArchitecturePPC64 == 6) {
  98     determine_section_size();
  99   // TODO: PPC port } else {
 100   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
 101   }
 102 
 103   MaxVectorSize = 8;
 104 #endif
 105 
 106   // Create and print feature-string.
 107   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
 108   jio_snprintf(buf, sizeof(buf),
 109                "ppc64%s%s%s%s%s%s%s%s%s%s%s%s",
 110                (has_fsqrt()   ? " fsqrt"   : ""),
 111                (has_isel()    ? " isel"    : ""),
 112                (has_lxarxeh() ? " lxarxeh" : ""),
 113                (has_cmpb()    ? " cmpb"    : ""),
 114                //(has_mftgpr()? " mftgpr"  : ""),
 115                (has_popcntb() ? " popcntb" : ""),
 116                (has_popcntw() ? " popcntw" : ""),
 117                (has_fcfids()  ? " fcfids"  : ""),
 118                (has_vand()    ? " vand"    : ""),
 119                (has_lqarx()   ? " lqarx"   : ""),
 120                (has_vcipher() ? " vcipher" : ""),
 121                (has_vpmsumb() ? " vpmsumb" : ""),
 122                (has_tcheck()  ? " tcheck"  : "")
 123                // Make sure number of %s matches num_features!
 124               );
 125   _features_str = os::strdup(buf);
 126   if (Verbose) {
 127     print_features();
 128   }
 129 
 130   // PPC64 supports 8-byte compare-exchange operations (see
 131   // Atomic::cmpxchg and StubGenerator::generate_atomic_cmpxchg_ptr)
 132   // and 'atomic long memory ops' (see Unsafe_GetLongVolatile).
 133   _supports_cx8 = true;
 134 
 135   UseSSE = 0; // Only on x86 and x64
 136 
 137   intx cache_line_size = _measured_cache_line_size;
 138 
 139   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
 140 
 141   if (AllocatePrefetchStyle == 4) {
 142     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
 143     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
 144     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
 145   } else {
 146     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
 147     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
 148     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
 149   }
 150 
 151   assert(AllocatePrefetchLines &gt; 0, "invalid value");
 152   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
 153     AllocatePrefetchLines = 1; // Conservative value.
 154   }
 155 
 156   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
 157     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
 158   }
 159 
 160   assert(AllocatePrefetchStyle &gt;= 0, "AllocatePrefetchStyle should be positive");
 161 
 162   if (UseCRC32Intrinsics) {
 163     if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics))
 164       warning("CRC32 intrinsics  are not available on this CPU");
 165     FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);
 166   }
 167 
<a name="1" id="anc1"></a>





 168   // The AES intrinsic stubs require AES instruction support.
 169   if (UseAES) {
 170     warning("AES instructions are not available on this CPU");
 171     FLAG_SET_DEFAULT(UseAES, false);
 172   }
 173   if (UseAESIntrinsics) {
 174     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
 175       warning("AES intrinsics are not available on this CPU");
 176     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 177   }
 178 
 179   if (UseGHASHIntrinsics) {
 180     warning("GHASH intrinsics are not available on this CPU");
 181     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 182   }
 183 
 184   if (UseSHA) {
 185     warning("SHA instructions are not available on this CPU");
 186     FLAG_SET_DEFAULT(UseSHA, false);
 187   }
 188   if (UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics) {
 189     warning("SHA intrinsics are not available on this CPU");
 190     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 191     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 192     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 193   }
 194 
 195   if (UseCRC32CIntrinsics) {
 196     if (!FLAG_IS_DEFAULT(UseCRC32CIntrinsics))
 197       warning("CRC32C intrinsics are not available on this CPU");
 198     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 199   }
 200 
 201   // Adjust RTM (Restricted Transactional Memory) flags.
 202   if (!has_tcheck() &amp;&amp; UseRTMLocking) {
 203     // Can't continue because UseRTMLocking affects UseBiasedLocking flag
 204     // setting during arguments processing. See use_biased_locking().
 205     // VM_Version_init() is executed after UseBiasedLocking is used
 206     // in Thread::allocate().
 207     vm_exit_during_initialization("RTM instructions are not available on this CPU");
 208   }
 209 
 210   if (UseRTMLocking) {
 211 #if INCLUDE_RTM_OPT
 212     if (!UnlockExperimentalVMOptions) {
 213       vm_exit_during_initialization("UseRTMLocking is only available as experimental option on this platform. "
 214                                     "It must be enabled via -XX:+UnlockExperimentalVMOptions flag.");
 215     } else {
 216       warning("UseRTMLocking is only available as experimental option on this platform.");
 217     }
 218     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
 219       // RTM locking should be used only for applications with
 220       // high lock contention. For now we do not use it by default.
 221       vm_exit_during_initialization("UseRTMLocking flag should be only set on command line");
 222     }
 223     if (!is_power_of_2(RTMTotalCountIncrRate)) {
 224       warning("RTMTotalCountIncrRate must be a power of 2, resetting it to 64");
 225       FLAG_SET_DEFAULT(RTMTotalCountIncrRate, 64);
 226     }
 227     if (RTMAbortRatio &lt; 0 || RTMAbortRatio &gt; 100) {
 228       warning("RTMAbortRatio must be in the range 0 to 100, resetting it to 50");
 229       FLAG_SET_DEFAULT(RTMAbortRatio, 50);
 230     }
 231     FLAG_SET_ERGO(bool, UseNewFastLockPPC64, false); // Does not implement TM.
 232     guarantee(RTMSpinLoopCount &gt; 0, "unsupported");
 233 #else
 234     // Only C2 does RTM locking optimization.
 235     // Can't continue because UseRTMLocking affects UseBiasedLocking flag
 236     // setting during arguments processing. See use_biased_locking().
 237     vm_exit_during_initialization("RTM locking optimization is not supported in this VM");
 238 #endif
 239   } else { // !UseRTMLocking
 240     if (UseRTMForStackLocks) {
 241       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 242         warning("UseRTMForStackLocks flag should be off when UseRTMLocking flag is off");
 243       }
 244       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
 245     }
 246     if (UseRTMDeopt) {
 247       FLAG_SET_DEFAULT(UseRTMDeopt, false);
 248     }
 249     if (PrintPreciseRTMLockingStatistics) {
 250       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
 251     }
 252   }
 253 
 254   // This machine does not allow unaligned memory accesses
 255   if (UseUnalignedAccesses) {
 256     if (!FLAG_IS_DEFAULT(UseUnalignedAccesses))
 257       warning("Unaligned memory access is not available on this CPU");
 258     FLAG_SET_DEFAULT(UseUnalignedAccesses, false);
 259   }
 260 }
 261 
 262 bool VM_Version::use_biased_locking() {
 263 #if INCLUDE_RTM_OPT
 264   // RTM locking is most useful when there is high lock contention and
 265   // low data contention. With high lock contention the lock is usually
 266   // inflated and biased locking is not suitable for that case.
 267   // RTM locking code requires that biased locking is off.
 268   // Note: we can't switch off UseBiasedLocking in get_processor_features()
 269   // because it is used by Thread::allocate() which is called before
 270   // VM_Version::initialize().
 271   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
 272     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
 273       FLAG_SET_DEFAULT(UseBiasedLocking, false);
 274     } else {
 275       warning("Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag." );
 276       UseBiasedLocking = false;
 277     }
 278   }
 279 #endif
 280   return UseBiasedLocking;
 281 }
 282 
 283 void VM_Version::print_features() {
 284   tty-&gt;print_cr("Version: %s cache_line_size = %d", cpu_features(), (int) get_cache_line_size());
 285 }
 286 
 287 #ifdef COMPILER2
 288 // Determine section size on power6: If section size is 8 instructions,
 289 // there should be a difference between the two testloops of ~15 %. If
 290 // no difference is detected the section is assumed to be 32 instructions.
 291 void VM_Version::determine_section_size() {
 292 
 293   int unroll = 80;
 294 
 295   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
 296 
 297   // Allocate space for the code.
 298   ResourceMark rm;
 299   CodeBuffer cb("detect_section_size", code_size, 0);
 300   MacroAssembler* a = new MacroAssembler(&amp;cb);
 301 
 302   uint32_t *code = (uint32_t *)a-&gt;pc();
 303   // Emit code.
 304   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
 305 
 306   Label l1;
 307 
 308   a-&gt;li(R4, 1);
 309   a-&gt;sldi(R4, R4, 28);
 310   a-&gt;b(l1);
 311   a-&gt;align(CodeEntryAlignment);
 312 
 313   a-&gt;bind(l1);
 314 
 315   for (int i = 0; i &lt; unroll; i++) {
 316     // Schleife 1
 317     // ------- sector 0 ------------
 318     // ;; 0
 319     a-&gt;nop();                   // 1
 320     a-&gt;fpnop0();                // 2
 321     a-&gt;fpnop1();                // 3
 322     a-&gt;addi(R4,R4, -1); // 4
 323 
 324     // ;;  1
 325     a-&gt;nop();                   // 5
 326     a-&gt;fmr(F6, F6);             // 6
 327     a-&gt;fmr(F7, F7);             // 7
 328     a-&gt;endgroup();              // 8
 329     // ------- sector 8 ------------
 330 
 331     // ;;  2
 332     a-&gt;nop();                   // 9
 333     a-&gt;nop();                   // 10
 334     a-&gt;fmr(F8, F8);             // 11
 335     a-&gt;fmr(F9, F9);             // 12
 336 
 337     // ;;  3
 338     a-&gt;nop();                   // 13
 339     a-&gt;fmr(F10, F10);           // 14
 340     a-&gt;fmr(F11, F11);           // 15
 341     a-&gt;endgroup();              // 16
 342     // -------- sector 16 -------------
 343 
 344     // ;;  4
 345     a-&gt;nop();                   // 17
 346     a-&gt;nop();                   // 18
 347     a-&gt;fmr(F15, F15);           // 19
 348     a-&gt;fmr(F16, F16);           // 20
 349 
 350     // ;;  5
 351     a-&gt;nop();                   // 21
 352     a-&gt;fmr(F17, F17);           // 22
 353     a-&gt;fmr(F18, F18);           // 23
 354     a-&gt;endgroup();              // 24
 355     // ------- sector 24  ------------
 356 
 357     // ;;  6
 358     a-&gt;nop();                   // 25
 359     a-&gt;nop();                   // 26
 360     a-&gt;fmr(F19, F19);           // 27
 361     a-&gt;fmr(F20, F20);           // 28
 362 
 363     // ;;  7
 364     a-&gt;nop();                   // 29
 365     a-&gt;fmr(F21, F21);           // 30
 366     a-&gt;fmr(F22, F22);           // 31
 367     a-&gt;brnop0();                // 32
 368 
 369     // ------- sector 32 ------------
 370   }
 371 
 372   // ;; 8
 373   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
 374   a-&gt;bge(CCR0, l1);             // 34
 375   a-&gt;blr();
 376 
 377   // Emit code.
 378   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
 379   // uint32_t *code = (uint32_t *)a-&gt;pc();
 380 
 381   Label l2;
 382 
 383   a-&gt;li(R4, 1);
 384   a-&gt;sldi(R4, R4, 28);
 385   a-&gt;b(l2);
 386   a-&gt;align(CodeEntryAlignment);
 387 
 388   a-&gt;bind(l2);
 389 
 390   for (int i = 0; i &lt; unroll; i++) {
 391     // Schleife 2
 392     // ------- sector 0 ------------
 393     // ;; 0
 394     a-&gt;brnop0();                  // 1
 395     a-&gt;nop();                     // 2
 396     //a-&gt;cmpdi(CCR0, R4, unroll);
 397     a-&gt;fpnop0();                  // 3
 398     a-&gt;fpnop1();                  // 4
 399     a-&gt;addi(R4,R4, -1);           // 5
 400 
 401     // ;; 1
 402 
 403     a-&gt;nop();                     // 6
 404     a-&gt;fmr(F6, F6);               // 7
 405     a-&gt;fmr(F7, F7);               // 8
 406     // ------- sector 8 ---------------
 407 
 408     // ;; 2
 409     a-&gt;endgroup();                // 9
 410 
 411     // ;; 3
 412     a-&gt;nop();                     // 10
 413     a-&gt;nop();                     // 11
 414     a-&gt;fmr(F8, F8);               // 12
 415 
 416     // ;; 4
 417     a-&gt;fmr(F9, F9);               // 13
 418     a-&gt;nop();                     // 14
 419     a-&gt;fmr(F10, F10);             // 15
 420 
 421     // ;; 5
 422     a-&gt;fmr(F11, F11);             // 16
 423     // -------- sector 16 -------------
 424 
 425     // ;; 6
 426     a-&gt;endgroup();                // 17
 427 
 428     // ;; 7
 429     a-&gt;nop();                     // 18
 430     a-&gt;nop();                     // 19
 431     a-&gt;fmr(F15, F15);             // 20
 432 
 433     // ;; 8
 434     a-&gt;fmr(F16, F16);             // 21
 435     a-&gt;nop();                     // 22
 436     a-&gt;fmr(F17, F17);             // 23
 437 
 438     // ;; 9
 439     a-&gt;fmr(F18, F18);             // 24
 440     // -------- sector 24 -------------
 441 
 442     // ;; 10
 443     a-&gt;endgroup();                // 25
 444 
 445     // ;; 11
 446     a-&gt;nop();                     // 26
 447     a-&gt;nop();                     // 27
 448     a-&gt;fmr(F19, F19);             // 28
 449 
 450     // ;; 12
 451     a-&gt;fmr(F20, F20);             // 29
 452     a-&gt;nop();                     // 30
 453     a-&gt;fmr(F21, F21);             // 31
 454 
 455     // ;; 13
 456     a-&gt;fmr(F22, F22);             // 32
 457   }
 458 
 459   // -------- sector 32 -------------
 460   // ;; 14
 461   a-&gt;cmpdi(CCR0, R4, unroll); // 33
 462   a-&gt;bge(CCR0, l2);           // 34
 463 
 464   a-&gt;blr();
 465   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 466   a-&gt;flush();
 467 
 468   double loop1_seconds,loop2_seconds, rel_diff;
 469   uint64_t start1, stop1;
 470 
 471   start1 = os::current_thread_cpu_time(false);
 472   (*test1)();
 473   stop1 = os::current_thread_cpu_time(false);
 474   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
 475 
 476 
 477   start1 = os::current_thread_cpu_time(false);
 478   (*test2)();
 479   stop1 = os::current_thread_cpu_time(false);
 480 
 481   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
 482 
 483   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
 484 
 485   if (PrintAssembly) {
 486     ttyLocker ttyl;
 487     tty-&gt;print_cr("Decoding section size detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
 488     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 489     tty-&gt;print_cr("Time loop1 :%f", loop1_seconds);
 490     tty-&gt;print_cr("Time loop2 :%f", loop2_seconds);
 491     tty-&gt;print_cr("(time2 - time1) / time1 = %f %%", rel_diff);
 492 
 493     if (rel_diff &gt; 12.0) {
 494       tty-&gt;print_cr("Section Size 8 Instructions");
 495     } else{
 496       tty-&gt;print_cr("Section Size 32 Instructions or Power5");
 497     }
 498   }
 499 
 500 #if 0 // TODO: PPC port
 501   // Set sector size (if not set explicitly).
 502   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
 503     if (rel_diff &gt; 12.0) {
 504       PdScheduling::power6SectorSize = 0x20;
 505     } else {
 506       PdScheduling::power6SectorSize = 0x80;
 507     }
 508   } else if (Power6SectorSize128PPC64) {
 509     PdScheduling::power6SectorSize = 0x80;
 510   } else {
 511     PdScheduling::power6SectorSize = 0x20;
 512   }
 513 #endif
 514   if (UsePower6SchedulerPPC64) Unimplemented();
 515 }
 516 #endif // COMPILER2
 517 
 518 void VM_Version::determine_features() {
 519 #if defined(ABI_ELFv2)
 520   // 1 InstWord per call for the blr instruction.
 521   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
 522 #else
 523   // 7 InstWords for each call (function descriptor + blr instruction).
 524   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
 525 #endif
 526   int features = 0;
 527 
 528   // create test area
 529   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can't exceed min page size).
 530   char test_area[BUFFER_SIZE];
 531   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
 532 
 533   // Allocate space for the code.
 534   ResourceMark rm;
 535   CodeBuffer cb("detect_cpu_features", code_size, 0);
 536   MacroAssembler* a = new MacroAssembler(&amp;cb);
 537 
 538   // Must be set to true so we can generate the test code.
 539   _features = VM_Version::all_features_m;
 540 
 541   // Emit code.
 542   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
 543   uint32_t *code = (uint32_t *)a-&gt;pc();
 544   // Don't use R0 in ldarx.
 545   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
 546   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
 547   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
 548   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
 549   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
 550   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
 551   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
 552   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
 553   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
 554   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
 555   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
 556   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
 557   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
 558   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
 559   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
 560   a-&gt;tcheck(0);                                // code[12] -&gt; tcheck
 561   a-&gt;blr();
 562 
 563   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
 564   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
 565   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
 566   a-&gt;blr();
 567 
 568   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 569   a-&gt;flush();
 570   _features = VM_Version::unknown_m;
 571 
 572   // Print the detection code.
 573   if (PrintAssembly) {
 574     ttyLocker ttyl;
 575     tty-&gt;print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
 576     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 577   }
 578 
 579   // Measure cache line size.
 580   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
 581   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
 582   int count = 0; // count zeroed bytes
 583   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
 584   guarantee(is_power_of_2(count), "cache line size needs to be a power of 2");
 585   _measured_cache_line_size = count;
 586 
 587   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
 588   VM_Version::_is_determine_features_test_running = true;
 589   // We must align the first argument to 16 bytes because of the lqarx check.
 590   (*test)((address)align_size_up((intptr_t)mid_of_test_area, 16), (uint64_t)0);
 591   VM_Version::_is_determine_features_test_running = false;
 592 
 593   // determine which instructions are legal.
 594   int feature_cntr = 0;
 595   if (code[feature_cntr++]) features |= fsqrt_m;
 596   if (code[feature_cntr++]) features |= fsqrts_m;
 597   if (code[feature_cntr++]) features |= isel_m;
 598   if (code[feature_cntr++]) features |= lxarxeh_m;
 599   if (code[feature_cntr++]) features |= cmpb_m;
 600   if (code[feature_cntr++]) features |= popcntb_m;
 601   if (code[feature_cntr++]) features |= popcntw_m;
 602   if (code[feature_cntr++]) features |= fcfids_m;
 603   if (code[feature_cntr++]) features |= vand_m;
 604   if (code[feature_cntr++]) features |= lqarx_m;
 605   if (code[feature_cntr++]) features |= vcipher_m;
 606   if (code[feature_cntr++]) features |= vpmsumb_m;
 607   if (code[feature_cntr++]) features |= tcheck_m;
 608 
 609   // Print the detection code.
 610   if (PrintAssembly) {
 611     ttyLocker ttyl;
 612     tty-&gt;print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " after execution:", p2i(code));
 613     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 614   }
 615 
 616   _features = features;
 617 }
 618 
 619 // Power 8: Configure Data Stream Control Register.
 620 void VM_Version::config_dscr() {
 621   assert(has_tcheck(), "Only execute on Power 8 or later!");
 622 
 623   // 7 InstWords for each call (function descriptor + blr instruction).
 624   const int code_size = (2+2*7)*BytesPerInstWord;
 625 
 626   // Allocate space for the code.
 627   ResourceMark rm;
 628   CodeBuffer cb("config_dscr", code_size, 0);
 629   MacroAssembler* a = new MacroAssembler(&amp;cb);
 630 
 631   // Emit code.
 632   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
 633   uint32_t *code = (uint32_t *)a-&gt;pc();
 634   a-&gt;mfdscr(R3);
 635   a-&gt;blr();
 636 
 637   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
 638   a-&gt;mtdscr(R3);
 639   a-&gt;blr();
 640 
 641   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 642   a-&gt;flush();
 643 
 644   // Print the detection code.
 645   if (PrintAssembly) {
 646     ttyLocker ttyl;
 647     tty-&gt;print_cr("Decoding dscr configuration stub at " INTPTR_FORMAT " before execution:", p2i(code));
 648     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 649   }
 650 
 651   // Apply the configuration if needed.
 652   uint64_t dscr_val = (*get_dscr)();
 653   if (Verbose) {
 654     tty-&gt;print_cr("dscr value was 0x%lx" , dscr_val);
 655   }
 656   bool change_requested = false;
 657   if (DSCR_PPC64 != (uintx)-1) {
 658     dscr_val = DSCR_PPC64;
 659     change_requested = true;
 660   }
 661   if (DSCR_DPFD_PPC64 &lt;= 7) {
 662     uint64_t mask = 0x7;
 663     if ((dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
 664       dscr_val = (dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
 665       change_requested = true;
 666     }
 667   }
 668   if (DSCR_URG_PPC64 &lt;= 7) {
 669     uint64_t mask = 0x7 &lt;&lt; 6;
 670     if ((dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
 671       dscr_val = (dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
 672       change_requested = true;
 673     }
 674   }
 675   if (change_requested) {
 676     (*set_dscr)(dscr_val);
 677     if (Verbose) {
 678       tty-&gt;print_cr("dscr was set to 0x%lx" , (*get_dscr)());
 679     }
 680   }
 681 }
 682 
 683 static int saved_features = 0;
 684 
 685 void VM_Version::allow_all() {
 686   saved_features = _features;
 687   _features      = all_features_m;
 688 }
 689 
 690 void VM_Version::revert() {
 691   _features = saved_features;
 692 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
