<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/cpu/ppc/vm/vm_version_ppc.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * Copyright 2012, 2015 SAP AG. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include "precompiled.hpp"
  27 #include "asm/assembler.inline.hpp"
  28 #include "asm/macroAssembler.inline.hpp"
  29 #include "compiler/disassembler.hpp"
  30 #include "memory/resourceArea.hpp"
  31 #include "runtime/java.hpp"
  32 #include "runtime/os.hpp"
  33 #include "runtime/stubCodeGenerator.hpp"
  34 #include "utilities/defaultStream.hpp"
  35 #include "utilities/globalDefinitions.hpp"
  36 #include "vm_version_ppc.hpp"
  37 
  38 # include &lt;sys/sysinfo.h&gt;
  39 
  40 int VM_Version::_features = VM_Version::unknown_m;
  41 int VM_Version::_measured_cache_line_size = 32; // pessimistic init value
  42 const char* VM_Version::_features_str = "";
  43 bool VM_Version::_is_determine_features_test_running = false;
  44 
  45 
  46 #define MSG(flag)   \
  47   if (flag &amp;&amp; !FLAG_IS_DEFAULT(flag))                                  \
  48       jio_fprintf(defaultStream::error_stream(),                       \
  49                   "warning: -XX:+" #flag " requires -XX:+UseSIGTRAP\n" \
  50                   "         -XX:+" #flag " will be disabled!\n");
  51 
  52 void VM_Version::initialize() {
  53 
  54   // Test which instructions are supported and measure cache line size.
  55   determine_features();
  56 
  57   // If PowerArchitecturePPC64 hasn't been specified explicitly determine from features.
  58   if (FLAG_IS_DEFAULT(PowerArchitecturePPC64)) {
  59     if (VM_Version::has_lqarx()) {
  60       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 8);
  61     } else if (VM_Version::has_popcntw()) {
  62       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 7);
  63     } else if (VM_Version::has_cmpb()) {
  64       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 6);
  65     } else if (VM_Version::has_popcntb()) {
  66       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 5);
  67     } else {
  68       FLAG_SET_ERGO(uintx, PowerArchitecturePPC64, 0);
  69     }
  70   }
  71   guarantee(PowerArchitecturePPC64 == 0 || PowerArchitecturePPC64 == 5 ||
  72             PowerArchitecturePPC64 == 6 || PowerArchitecturePPC64 == 7 ||
  73             PowerArchitecturePPC64 == 8,
  74             "PowerArchitecturePPC64 should be 0, 5, 6, 7, or 8");
  75 
  76   // Power 8: Configure Data Stream Control Register.
  77   if (PowerArchitecturePPC64 &gt;= 8) {
  78     config_dscr();
  79   }
  80 
  81   if (!UseSIGTRAP) {
  82     MSG(TrapBasedICMissChecks);
  83     MSG(TrapBasedNotEntrantChecks);
  84     MSG(TrapBasedNullChecks);
  85     FLAG_SET_ERGO(bool, TrapBasedNotEntrantChecks, false);
  86     FLAG_SET_ERGO(bool, TrapBasedNullChecks,       false);
  87     FLAG_SET_ERGO(bool, TrapBasedICMissChecks,     false);
  88   }
  89 
  90 #ifdef COMPILER2
  91   if (!UseSIGTRAP) {
  92     MSG(TrapBasedRangeChecks);
  93     FLAG_SET_ERGO(bool, TrapBasedRangeChecks, false);
  94   }
  95 
  96   // On Power6 test for section size.
  97   if (PowerArchitecturePPC64 == 6) {
  98     determine_section_size();
  99   // TODO: PPC port } else {
 100   // TODO: PPC port PdScheduling::power6SectorSize = 0x20;
 101   }
 102 
 103   MaxVectorSize = 8;
 104 #endif
 105 
 106   // Create and print feature-string.
 107   char buf[(num_features+1) * 16]; // Max 16 chars per feature.
 108   jio_snprintf(buf, sizeof(buf),
 109                "ppc64%s%s%s%s%s%s%s%s%s%s%s%s",
 110                (has_fsqrt()   ? " fsqrt"   : ""),
 111                (has_isel()    ? " isel"    : ""),
 112                (has_lxarxeh() ? " lxarxeh" : ""),
 113                (has_cmpb()    ? " cmpb"    : ""),
 114                //(has_mftgpr()? " mftgpr"  : ""),
 115                (has_popcntb() ? " popcntb" : ""),
 116                (has_popcntw() ? " popcntw" : ""),
 117                (has_fcfids()  ? " fcfids"  : ""),
 118                (has_vand()    ? " vand"    : ""),
 119                (has_lqarx()   ? " lqarx"   : ""),
 120                (has_vcipher() ? " vcipher" : ""),
 121                (has_vpmsumb() ? " vpmsumb" : ""),
 122                (has_tcheck()  ? " tcheck"  : "")
 123                // Make sure number of %s matches num_features!
 124               );
 125   _features_str = os::strdup(buf);
 126   if (Verbose) {
 127     print_features();
 128   }
 129 
 130   // PPC64 supports 8-byte compare-exchange operations (see
 131   // Atomic::cmpxchg and StubGenerator::generate_atomic_cmpxchg_ptr)
 132   // and 'atomic long memory ops' (see Unsafe_GetLongVolatile).
 133   _supports_cx8 = true;
 134 
 135   UseSSE = 0; // Only on x86 and x64
 136 
 137   intx cache_line_size = _measured_cache_line_size;
 138 
 139   if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) AllocatePrefetchStyle = 1;
 140 
 141   if (AllocatePrefetchStyle == 4) {
 142     AllocatePrefetchStepSize = cache_line_size; // Need exact value.
 143     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 12; // Use larger blocks by default.
 144     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 2*cache_line_size; // Default is not defined?
 145   } else {
 146     if (cache_line_size &gt; AllocatePrefetchStepSize) AllocatePrefetchStepSize = cache_line_size;
 147     if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) AllocatePrefetchLines = 3; // Optimistic value.
 148     if (AllocatePrefetchDistance &lt; 0) AllocatePrefetchDistance = 3*cache_line_size; // Default is not defined?
 149   }
 150 
 151   assert(AllocatePrefetchLines &gt; 0, "invalid value");
 152   if (AllocatePrefetchLines &lt; 1) { // Set valid value in product VM.
 153     AllocatePrefetchLines = 1; // Conservative value.
 154   }
 155 
 156   if (AllocatePrefetchStyle == 3 &amp;&amp; AllocatePrefetchDistance &lt; cache_line_size) {
 157     AllocatePrefetchStyle = 1; // Fall back if inappropriate.
 158   }
 159 
 160   assert(AllocatePrefetchStyle &gt;= 0, "AllocatePrefetchStyle should be positive");
 161 
 162   if (UseCRC32Intrinsics) {
 163     if (!FLAG_IS_DEFAULT(UseCRC32Intrinsics))
 164       warning("CRC32 intrinsics  are not available on this CPU");
 165     FLAG_SET_DEFAULT(UseCRC32Intrinsics, false);
 166   }
 167 
 168   if (UseSpinLoopHintIntrinsic) {
 169     if (!FLAG_IS_DEFAULT(UseSpinLoopHintIntrinsic))
 170       warning("spinLoopHint intrinsic is not available on this CPU");
 171     FLAG_SET_DEFAULT(UseSpinLoopHintIntrinsic, false);
 172   }
 173 
 174   // The AES intrinsic stubs require AES instruction support.
 175   if (UseAES) {
 176     warning("AES instructions are not available on this CPU");
 177     FLAG_SET_DEFAULT(UseAES, false);
 178   }
 179   if (UseAESIntrinsics) {
 180     if (!FLAG_IS_DEFAULT(UseAESIntrinsics))
 181       warning("AES intrinsics are not available on this CPU");
 182     FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 183   }
 184 
 185   if (UseGHASHIntrinsics) {
 186     warning("GHASH intrinsics are not available on this CPU");
 187     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 188   }
 189 
 190   if (UseSHA) {
 191     warning("SHA instructions are not available on this CPU");
 192     FLAG_SET_DEFAULT(UseSHA, false);
 193   }
 194   if (UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics) {
 195     warning("SHA intrinsics are not available on this CPU");
 196     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 197     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 198     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 199   }
 200 
 201   if (UseCRC32CIntrinsics) {
 202     if (!FLAG_IS_DEFAULT(UseCRC32CIntrinsics))
 203       warning("CRC32C intrinsics are not available on this CPU");
 204     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 205   }
 206 
 207   // Adjust RTM (Restricted Transactional Memory) flags.
 208   if (!has_tcheck() &amp;&amp; UseRTMLocking) {
 209     // Can't continue because UseRTMLocking affects UseBiasedLocking flag
 210     // setting during arguments processing. See use_biased_locking().
 211     // VM_Version_init() is executed after UseBiasedLocking is used
 212     // in Thread::allocate().
 213     vm_exit_during_initialization("RTM instructions are not available on this CPU");
 214   }
 215 
 216   if (UseRTMLocking) {
 217 #if INCLUDE_RTM_OPT
 218     if (!UnlockExperimentalVMOptions) {
 219       vm_exit_during_initialization("UseRTMLocking is only available as experimental option on this platform. "
 220                                     "It must be enabled via -XX:+UnlockExperimentalVMOptions flag.");
 221     } else {
 222       warning("UseRTMLocking is only available as experimental option on this platform.");
 223     }
 224     if (!FLAG_IS_CMDLINE(UseRTMLocking)) {
 225       // RTM locking should be used only for applications with
 226       // high lock contention. For now we do not use it by default.
 227       vm_exit_during_initialization("UseRTMLocking flag should be only set on command line");
 228     }
 229     if (!is_power_of_2(RTMTotalCountIncrRate)) {
 230       warning("RTMTotalCountIncrRate must be a power of 2, resetting it to 64");
 231       FLAG_SET_DEFAULT(RTMTotalCountIncrRate, 64);
 232     }
 233     if (RTMAbortRatio &lt; 0 || RTMAbortRatio &gt; 100) {
 234       warning("RTMAbortRatio must be in the range 0 to 100, resetting it to 50");
 235       FLAG_SET_DEFAULT(RTMAbortRatio, 50);
 236     }
 237     FLAG_SET_ERGO(bool, UseNewFastLockPPC64, false); // Does not implement TM.
 238     guarantee(RTMSpinLoopCount &gt; 0, "unsupported");
 239 #else
 240     // Only C2 does RTM locking optimization.
 241     // Can't continue because UseRTMLocking affects UseBiasedLocking flag
 242     // setting during arguments processing. See use_biased_locking().
 243     vm_exit_during_initialization("RTM locking optimization is not supported in this VM");
 244 #endif
 245   } else { // !UseRTMLocking
 246     if (UseRTMForStackLocks) {
 247       if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {
 248         warning("UseRTMForStackLocks flag should be off when UseRTMLocking flag is off");
 249       }
 250       FLAG_SET_DEFAULT(UseRTMForStackLocks, false);
 251     }
 252     if (UseRTMDeopt) {
 253       FLAG_SET_DEFAULT(UseRTMDeopt, false);
 254     }
 255     if (PrintPreciseRTMLockingStatistics) {
 256       FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);
 257     }
 258   }
 259 
 260   // This machine does not allow unaligned memory accesses
 261   if (UseUnalignedAccesses) {
 262     if (!FLAG_IS_DEFAULT(UseUnalignedAccesses))
 263       warning("Unaligned memory access is not available on this CPU");
 264     FLAG_SET_DEFAULT(UseUnalignedAccesses, false);
 265   }
 266 }
 267 
 268 bool VM_Version::use_biased_locking() {
 269 #if INCLUDE_RTM_OPT
 270   // RTM locking is most useful when there is high lock contention and
 271   // low data contention. With high lock contention the lock is usually
 272   // inflated and biased locking is not suitable for that case.
 273   // RTM locking code requires that biased locking is off.
 274   // Note: we can't switch off UseBiasedLocking in get_processor_features()
 275   // because it is used by Thread::allocate() which is called before
 276   // VM_Version::initialize().
 277   if (UseRTMLocking &amp;&amp; UseBiasedLocking) {
 278     if (FLAG_IS_DEFAULT(UseBiasedLocking)) {
 279       FLAG_SET_DEFAULT(UseBiasedLocking, false);
 280     } else {
 281       warning("Biased locking is not supported with RTM locking; ignoring UseBiasedLocking flag." );
 282       UseBiasedLocking = false;
 283     }
 284   }
 285 #endif
 286   return UseBiasedLocking;
 287 }
 288 
 289 void VM_Version::print_features() {
 290   tty-&gt;print_cr("Version: %s cache_line_size = %d", cpu_features(), (int) get_cache_line_size());
 291 }
 292 
 293 #ifdef COMPILER2
 294 // Determine section size on power6: If section size is 8 instructions,
 295 // there should be a difference between the two testloops of ~15 %. If
 296 // no difference is detected the section is assumed to be 32 instructions.
 297 void VM_Version::determine_section_size() {
 298 
 299   int unroll = 80;
 300 
 301   const int code_size = (2* unroll * 32 + 100)*BytesPerInstWord;
 302 
 303   // Allocate space for the code.
 304   ResourceMark rm;
 305   CodeBuffer cb("detect_section_size", code_size, 0);
 306   MacroAssembler* a = new MacroAssembler(&amp;cb);
 307 
 308   uint32_t *code = (uint32_t *)a-&gt;pc();
 309   // Emit code.
 310   void (*test1)() = (void(*)())(void *)a-&gt;function_entry();
 311 
 312   Label l1;
 313 
 314   a-&gt;li(R4, 1);
 315   a-&gt;sldi(R4, R4, 28);
 316   a-&gt;b(l1);
 317   a-&gt;align(CodeEntryAlignment);
 318 
 319   a-&gt;bind(l1);
 320 
 321   for (int i = 0; i &lt; unroll; i++) {
 322     // Schleife 1
 323     // ------- sector 0 ------------
 324     // ;; 0
 325     a-&gt;nop();                   // 1
 326     a-&gt;fpnop0();                // 2
 327     a-&gt;fpnop1();                // 3
 328     a-&gt;addi(R4,R4, -1); // 4
 329 
 330     // ;;  1
 331     a-&gt;nop();                   // 5
 332     a-&gt;fmr(F6, F6);             // 6
 333     a-&gt;fmr(F7, F7);             // 7
 334     a-&gt;endgroup();              // 8
 335     // ------- sector 8 ------------
 336 
 337     // ;;  2
 338     a-&gt;nop();                   // 9
 339     a-&gt;nop();                   // 10
 340     a-&gt;fmr(F8, F8);             // 11
 341     a-&gt;fmr(F9, F9);             // 12
 342 
 343     // ;;  3
 344     a-&gt;nop();                   // 13
 345     a-&gt;fmr(F10, F10);           // 14
 346     a-&gt;fmr(F11, F11);           // 15
 347     a-&gt;endgroup();              // 16
 348     // -------- sector 16 -------------
 349 
 350     // ;;  4
 351     a-&gt;nop();                   // 17
 352     a-&gt;nop();                   // 18
 353     a-&gt;fmr(F15, F15);           // 19
 354     a-&gt;fmr(F16, F16);           // 20
 355 
 356     // ;;  5
 357     a-&gt;nop();                   // 21
 358     a-&gt;fmr(F17, F17);           // 22
 359     a-&gt;fmr(F18, F18);           // 23
 360     a-&gt;endgroup();              // 24
 361     // ------- sector 24  ------------
 362 
 363     // ;;  6
 364     a-&gt;nop();                   // 25
 365     a-&gt;nop();                   // 26
 366     a-&gt;fmr(F19, F19);           // 27
 367     a-&gt;fmr(F20, F20);           // 28
 368 
 369     // ;;  7
 370     a-&gt;nop();                   // 29
 371     a-&gt;fmr(F21, F21);           // 30
 372     a-&gt;fmr(F22, F22);           // 31
 373     a-&gt;brnop0();                // 32
 374 
 375     // ------- sector 32 ------------
 376   }
 377 
 378   // ;; 8
 379   a-&gt;cmpdi(CCR0, R4, unroll);   // 33
 380   a-&gt;bge(CCR0, l1);             // 34
 381   a-&gt;blr();
 382 
 383   // Emit code.
 384   void (*test2)() = (void(*)())(void *)a-&gt;function_entry();
 385   // uint32_t *code = (uint32_t *)a-&gt;pc();
 386 
 387   Label l2;
 388 
 389   a-&gt;li(R4, 1);
 390   a-&gt;sldi(R4, R4, 28);
 391   a-&gt;b(l2);
 392   a-&gt;align(CodeEntryAlignment);
 393 
 394   a-&gt;bind(l2);
 395 
 396   for (int i = 0; i &lt; unroll; i++) {
 397     // Schleife 2
 398     // ------- sector 0 ------------
 399     // ;; 0
 400     a-&gt;brnop0();                  // 1
 401     a-&gt;nop();                     // 2
 402     //a-&gt;cmpdi(CCR0, R4, unroll);
 403     a-&gt;fpnop0();                  // 3
 404     a-&gt;fpnop1();                  // 4
 405     a-&gt;addi(R4,R4, -1);           // 5
 406 
 407     // ;; 1
 408 
 409     a-&gt;nop();                     // 6
 410     a-&gt;fmr(F6, F6);               // 7
 411     a-&gt;fmr(F7, F7);               // 8
 412     // ------- sector 8 ---------------
 413 
 414     // ;; 2
 415     a-&gt;endgroup();                // 9
 416 
 417     // ;; 3
 418     a-&gt;nop();                     // 10
 419     a-&gt;nop();                     // 11
 420     a-&gt;fmr(F8, F8);               // 12
 421 
 422     // ;; 4
 423     a-&gt;fmr(F9, F9);               // 13
 424     a-&gt;nop();                     // 14
 425     a-&gt;fmr(F10, F10);             // 15
 426 
 427     // ;; 5
 428     a-&gt;fmr(F11, F11);             // 16
 429     // -------- sector 16 -------------
 430 
 431     // ;; 6
 432     a-&gt;endgroup();                // 17
 433 
 434     // ;; 7
 435     a-&gt;nop();                     // 18
 436     a-&gt;nop();                     // 19
 437     a-&gt;fmr(F15, F15);             // 20
 438 
 439     // ;; 8
 440     a-&gt;fmr(F16, F16);             // 21
 441     a-&gt;nop();                     // 22
 442     a-&gt;fmr(F17, F17);             // 23
 443 
 444     // ;; 9
 445     a-&gt;fmr(F18, F18);             // 24
 446     // -------- sector 24 -------------
 447 
 448     // ;; 10
 449     a-&gt;endgroup();                // 25
 450 
 451     // ;; 11
 452     a-&gt;nop();                     // 26
 453     a-&gt;nop();                     // 27
 454     a-&gt;fmr(F19, F19);             // 28
 455 
 456     // ;; 12
 457     a-&gt;fmr(F20, F20);             // 29
 458     a-&gt;nop();                     // 30
 459     a-&gt;fmr(F21, F21);             // 31
 460 
 461     // ;; 13
 462     a-&gt;fmr(F22, F22);             // 32
 463   }
 464 
 465   // -------- sector 32 -------------
 466   // ;; 14
 467   a-&gt;cmpdi(CCR0, R4, unroll); // 33
 468   a-&gt;bge(CCR0, l2);           // 34
 469 
 470   a-&gt;blr();
 471   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 472   a-&gt;flush();
 473 
 474   double loop1_seconds,loop2_seconds, rel_diff;
 475   uint64_t start1, stop1;
 476 
 477   start1 = os::current_thread_cpu_time(false);
 478   (*test1)();
 479   stop1 = os::current_thread_cpu_time(false);
 480   loop1_seconds = (stop1- start1) / (1000 *1000 *1000.0);
 481 
 482 
 483   start1 = os::current_thread_cpu_time(false);
 484   (*test2)();
 485   stop1 = os::current_thread_cpu_time(false);
 486 
 487   loop2_seconds = (stop1 - start1) / (1000 *1000 *1000.0);
 488 
 489   rel_diff = (loop2_seconds - loop1_seconds) / loop1_seconds *100;
 490 
 491   if (PrintAssembly) {
 492     ttyLocker ttyl;
 493     tty-&gt;print_cr("Decoding section size detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
 494     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 495     tty-&gt;print_cr("Time loop1 :%f", loop1_seconds);
 496     tty-&gt;print_cr("Time loop2 :%f", loop2_seconds);
 497     tty-&gt;print_cr("(time2 - time1) / time1 = %f %%", rel_diff);
 498 
 499     if (rel_diff &gt; 12.0) {
 500       tty-&gt;print_cr("Section Size 8 Instructions");
 501     } else{
 502       tty-&gt;print_cr("Section Size 32 Instructions or Power5");
 503     }
 504   }
 505 
 506 #if 0 // TODO: PPC port
 507   // Set sector size (if not set explicitly).
 508   if (FLAG_IS_DEFAULT(Power6SectorSize128PPC64)) {
 509     if (rel_diff &gt; 12.0) {
 510       PdScheduling::power6SectorSize = 0x20;
 511     } else {
 512       PdScheduling::power6SectorSize = 0x80;
 513     }
 514   } else if (Power6SectorSize128PPC64) {
 515     PdScheduling::power6SectorSize = 0x80;
 516   } else {
 517     PdScheduling::power6SectorSize = 0x20;
 518   }
 519 #endif
 520   if (UsePower6SchedulerPPC64) Unimplemented();
 521 }
 522 #endif // COMPILER2
 523 
 524 void VM_Version::determine_features() {
 525 #if defined(ABI_ELFv2)
 526   // 1 InstWord per call for the blr instruction.
 527   const int code_size = (num_features+1+2*1)*BytesPerInstWord;
 528 #else
 529   // 7 InstWords for each call (function descriptor + blr instruction).
 530   const int code_size = (num_features+1+2*7)*BytesPerInstWord;
 531 #endif
 532   int features = 0;
 533 
 534   // create test area
 535   enum { BUFFER_SIZE = 2*4*K }; // Needs to be &gt;=2* max cache line size (cache line size can't exceed min page size).
 536   char test_area[BUFFER_SIZE];
 537   char *mid_of_test_area = &amp;test_area[BUFFER_SIZE&gt;&gt;1];
 538 
 539   // Allocate space for the code.
 540   ResourceMark rm;
 541   CodeBuffer cb("detect_cpu_features", code_size, 0);
 542   MacroAssembler* a = new MacroAssembler(&amp;cb);
 543 
 544   // Must be set to true so we can generate the test code.
 545   _features = VM_Version::all_features_m;
 546 
 547   // Emit code.
 548   void (*test)(address addr, uint64_t offset)=(void(*)(address addr, uint64_t offset))(void *)a-&gt;function_entry();
 549   uint32_t *code = (uint32_t *)a-&gt;pc();
 550   // Don't use R0 in ldarx.
 551   // Keep R3_ARG1 unmodified, it contains &amp;field (see below).
 552   // Keep R4_ARG2 unmodified, it contains offset = 0 (see below).
 553   a-&gt;fsqrt(F3, F4);                            // code[0]  -&gt; fsqrt_m
 554   a-&gt;fsqrts(F3, F4);                           // code[1]  -&gt; fsqrts_m
 555   a-&gt;isel(R7, R5, R6, 0);                      // code[2]  -&gt; isel_m
 556   a-&gt;ldarx_unchecked(R7, R3_ARG1, R4_ARG2, 1); // code[3]  -&gt; lxarx_m
 557   a-&gt;cmpb(R7, R5, R6);                         // code[4]  -&gt; cmpb
 558   a-&gt;popcntb(R7, R5);                          // code[5]  -&gt; popcntb
 559   a-&gt;popcntw(R7, R5);                          // code[6]  -&gt; popcntw
 560   a-&gt;fcfids(F3, F4);                           // code[7]  -&gt; fcfids
 561   a-&gt;vand(VR0, VR0, VR0);                      // code[8]  -&gt; vand
 562   // arg0 of lqarx must be an even register, (arg1 + arg2) must be a multiple of 16
 563   a-&gt;lqarx_unchecked(R6, R3_ARG1, R4_ARG2, 1); // code[9]  -&gt; lqarx_m
 564   a-&gt;vcipher(VR0, VR1, VR2);                   // code[10] -&gt; vcipher
 565   a-&gt;vpmsumb(VR0, VR1, VR2);                   // code[11] -&gt; vpmsumb
 566   a-&gt;tcheck(0);                                // code[12] -&gt; tcheck
 567   a-&gt;blr();
 568 
 569   // Emit function to set one cache line to zero. Emit function descriptor and get pointer to it.
 570   void (*zero_cacheline_func_ptr)(char*) = (void(*)(char*))(void *)a-&gt;function_entry();
 571   a-&gt;dcbz(R3_ARG1); // R3_ARG1 = addr
 572   a-&gt;blr();
 573 
 574   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 575   a-&gt;flush();
 576   _features = VM_Version::unknown_m;
 577 
 578   // Print the detection code.
 579   if (PrintAssembly) {
 580     ttyLocker ttyl;
 581     tty-&gt;print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " before execution:", p2i(code));
 582     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 583   }
 584 
 585   // Measure cache line size.
 586   memset(test_area, 0xFF, BUFFER_SIZE); // Fill test area with 0xFF.
 587   (*zero_cacheline_func_ptr)(mid_of_test_area); // Call function which executes dcbz to the middle.
 588   int count = 0; // count zeroed bytes
 589   for (int i = 0; i &lt; BUFFER_SIZE; i++) if (test_area[i] == 0) count++;
 590   guarantee(is_power_of_2(count), "cache line size needs to be a power of 2");
 591   _measured_cache_line_size = count;
 592 
 593   // Execute code. Illegal instructions will be replaced by 0 in the signal handler.
 594   VM_Version::_is_determine_features_test_running = true;
 595   // We must align the first argument to 16 bytes because of the lqarx check.
 596   (*test)((address)align_size_up((intptr_t)mid_of_test_area, 16), (uint64_t)0);
 597   VM_Version::_is_determine_features_test_running = false;
 598 
 599   // determine which instructions are legal.
 600   int feature_cntr = 0;
 601   if (code[feature_cntr++]) features |= fsqrt_m;
 602   if (code[feature_cntr++]) features |= fsqrts_m;
 603   if (code[feature_cntr++]) features |= isel_m;
 604   if (code[feature_cntr++]) features |= lxarxeh_m;
 605   if (code[feature_cntr++]) features |= cmpb_m;
 606   if (code[feature_cntr++]) features |= popcntb_m;
 607   if (code[feature_cntr++]) features |= popcntw_m;
 608   if (code[feature_cntr++]) features |= fcfids_m;
 609   if (code[feature_cntr++]) features |= vand_m;
 610   if (code[feature_cntr++]) features |= lqarx_m;
 611   if (code[feature_cntr++]) features |= vcipher_m;
 612   if (code[feature_cntr++]) features |= vpmsumb_m;
 613   if (code[feature_cntr++]) features |= tcheck_m;
 614 
 615   // Print the detection code.
 616   if (PrintAssembly) {
 617     ttyLocker ttyl;
 618     tty-&gt;print_cr("Decoding cpu-feature detection stub at " INTPTR_FORMAT " after execution:", p2i(code));
 619     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 620   }
 621 
 622   _features = features;
 623 }
 624 
 625 // Power 8: Configure Data Stream Control Register.
 626 void VM_Version::config_dscr() {
 627   assert(has_tcheck(), "Only execute on Power 8 or later!");
 628 
 629   // 7 InstWords for each call (function descriptor + blr instruction).
 630   const int code_size = (2+2*7)*BytesPerInstWord;
 631 
 632   // Allocate space for the code.
 633   ResourceMark rm;
 634   CodeBuffer cb("config_dscr", code_size, 0);
 635   MacroAssembler* a = new MacroAssembler(&amp;cb);
 636 
 637   // Emit code.
 638   uint64_t (*get_dscr)() = (uint64_t(*)())(void *)a-&gt;function_entry();
 639   uint32_t *code = (uint32_t *)a-&gt;pc();
 640   a-&gt;mfdscr(R3);
 641   a-&gt;blr();
 642 
 643   void (*set_dscr)(long) = (void(*)(long))(void *)a-&gt;function_entry();
 644   a-&gt;mtdscr(R3);
 645   a-&gt;blr();
 646 
 647   uint32_t *code_end = (uint32_t *)a-&gt;pc();
 648   a-&gt;flush();
 649 
 650   // Print the detection code.
 651   if (PrintAssembly) {
 652     ttyLocker ttyl;
 653     tty-&gt;print_cr("Decoding dscr configuration stub at " INTPTR_FORMAT " before execution:", p2i(code));
 654     Disassembler::decode((u_char*)code, (u_char*)code_end, tty);
 655   }
 656 
 657   // Apply the configuration if needed.
 658   uint64_t dscr_val = (*get_dscr)();
 659   if (Verbose) {
 660     tty-&gt;print_cr("dscr value was 0x%lx" , dscr_val);
 661   }
 662   bool change_requested = false;
 663   if (DSCR_PPC64 != (uintx)-1) {
 664     dscr_val = DSCR_PPC64;
 665     change_requested = true;
 666   }
 667   if (DSCR_DPFD_PPC64 &lt;= 7) {
 668     uint64_t mask = 0x7;
 669     if ((dscr_val &amp; mask) != DSCR_DPFD_PPC64) {
 670       dscr_val = (dscr_val &amp; ~mask) | (DSCR_DPFD_PPC64);
 671       change_requested = true;
 672     }
 673   }
 674   if (DSCR_URG_PPC64 &lt;= 7) {
 675     uint64_t mask = 0x7 &lt;&lt; 6;
 676     if ((dscr_val &amp; mask) != DSCR_DPFD_PPC64 &lt;&lt; 6) {
 677       dscr_val = (dscr_val &amp; ~mask) | (DSCR_URG_PPC64 &lt;&lt; 6);
 678       change_requested = true;
 679     }
 680   }
 681   if (change_requested) {
 682     (*set_dscr)(dscr_val);
 683     if (Verbose) {
 684       tty-&gt;print_cr("dscr was set to 0x%lx" , (*get_dscr)());
 685     }
 686   }
 687 }
 688 
 689 static int saved_features = 0;
 690 
 691 void VM_Version::allow_all() {
 692   saved_features = _features;
 693   _features      = all_features_m;
 694 }
 695 
 696 void VM_Version::revert() {
 697   _features = saved_features;
 698 }
</pre></body></html>
