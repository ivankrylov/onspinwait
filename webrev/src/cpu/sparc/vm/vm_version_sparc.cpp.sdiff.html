<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>hotspot Sdiff src/cpu/sparc/vm </title>
</head><body id="SUNWwebrev">
<h2>src/cpu/sparc/vm/vm_version_sparc.cpp</h2>
<a class="print" href="javascript:print()">Print this page</a>
<pre></pre>

<table><tr valign="top">
<td><pre>

</pre><hr></hr><pre>
 364     }
 365   }
 366 
 367   // SPARC T4 and above should have support for CRC32C instruction
 368   if (has_crc32c()) {
 369     if (UseVIS &gt; 2) { // CRC32C intrinsics use VIS3 instructions
 370       if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 371         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 372       }
 373     } else {
 374       if (UseCRC32CIntrinsics) {
 375         warning("SPARC CRC32C intrinsics require VIS3 instruction support. Intrinsics will be disabled.");
 376         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 377       }
 378     }
 379   } else if (UseCRC32CIntrinsics) {
 380     warning("CRC32C instruction is not available on this CPU");
 381     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 382   }
 383 






 384   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
 385     (cache_line_size &gt; ContendedPaddingWidth))
 386     ContendedPaddingWidth = cache_line_size;
 387 
 388   // This machine does not allow unaligned memory accesses
 389   if (UseUnalignedAccesses) {
 390     if (!FLAG_IS_DEFAULT(UseUnalignedAccesses))
 391       warning("Unaligned memory access is not available on this CPU");
 392     FLAG_SET_DEFAULT(UseUnalignedAccesses, false);
 393   }
 394 
 395 #ifndef PRODUCT
 396   if (PrintMiscellaneous &amp;&amp; Verbose) {
 397     tty-&gt;print_cr("L1 data cache line size: %u", L1_data_cache_line_size());
 398     tty-&gt;print_cr("L2 data cache line size: %u", L2_data_cache_line_size());
 399     tty-&gt;print("Allocation");
 400     if (AllocatePrefetchStyle &lt;= 0) {
 401       tty-&gt;print_cr(": no prefetching");
 402     } else {
 403       tty-&gt;print(" prefetching: ");

</pre><hr></hr>
</pre></td><td><pre>

</pre><hr></hr><pre>
 364     }
 365   }
 366 
 367   // SPARC T4 and above should have support for CRC32C instruction
 368   if (has_crc32c()) {
 369     if (UseVIS &gt; 2) { // CRC32C intrinsics use VIS3 instructions
 370       if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 371         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 372       }
 373     } else {
 374       if (UseCRC32CIntrinsics) {
 375         warning("SPARC CRC32C intrinsics require VIS3 instruction support. Intrinsics will be disabled.");
 376         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 377       }
 378     }
 379   } else if (UseCRC32CIntrinsics) {
 380     warning("CRC32C instruction is not available on this CPU");
 381     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 382   }
 383 
<span class="new"> 384   if (UseSpinLoopHintIntrinsic) {</span>
<span class="new"> 385     if (!FLAG_IS_DEFAULT(UseSpinLoopHintIntrinsic))</span>
<span class="new"> 386       warning("spinLoopHint intrinsic is not available on this CPU");</span>
<span class="new"> 387     FLAG_SET_DEFAULT(UseSpinLoopHintIntrinsic, false);</span>
<span class="new"> 388   }</span>
<span class="new"> 389 </span>
 390   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
 391     (cache_line_size &gt; ContendedPaddingWidth))
 392     ContendedPaddingWidth = cache_line_size;
 393 
 394   // This machine does not allow unaligned memory accesses
 395   if (UseUnalignedAccesses) {
 396     if (!FLAG_IS_DEFAULT(UseUnalignedAccesses))
 397       warning("Unaligned memory access is not available on this CPU");
 398     FLAG_SET_DEFAULT(UseUnalignedAccesses, false);
 399   }
 400 
 401 #ifndef PRODUCT
 402   if (PrintMiscellaneous &amp;&amp; Verbose) {
 403     tty-&gt;print_cr("L1 data cache line size: %u", L1_data_cache_line_size());
 404     tty-&gt;print_cr("L2 data cache line size: %u", L2_data_cache_line_size());
 405     tty-&gt;print("Allocation");
 406     if (AllocatePrefetchStyle &lt;= 0) {
 407       tty-&gt;print_cr(": no prefetching");
 408     } else {
 409       tty-&gt;print(" prefetching: ");

</pre><hr></hr>
</pre></td>
</tr></table>
</body></html>
