<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include "precompiled.hpp"
  26 #include "asm/macroAssembler.inline.hpp"
  27 #include "memory/resourceArea.hpp"
  28 #include "runtime/java.hpp"
  29 #include "runtime/os.hpp"
  30 #include "runtime/stubCodeGenerator.hpp"
  31 #include "vm_version_sparc.hpp"
  32 
  33 int VM_Version::_features = VM_Version::unknown_m;
  34 const char* VM_Version::_features_str = "";
  35 unsigned int VM_Version::_L2_data_cache_line_size = 0;
  36 
  37 void VM_Version::initialize() {
  38   _features = determine_features();
  39   PrefetchCopyIntervalInBytes = prefetch_copy_interval_in_bytes();
  40   PrefetchScanIntervalInBytes = prefetch_scan_interval_in_bytes();
  41   PrefetchFieldsAhead         = prefetch_fields_ahead();
  42 
  43   assert(0 &lt;= AllocatePrefetchInstr &amp;&amp; AllocatePrefetchInstr &lt;= 1, "invalid value");
  44   if( AllocatePrefetchInstr &lt; 0 ) AllocatePrefetchInstr = 0;
  45   if( AllocatePrefetchInstr &gt; 1 ) AllocatePrefetchInstr = 0;
  46 
  47   // Allocation prefetch settings
  48   intx cache_line_size = prefetch_data_size();
  49   if( cache_line_size &gt; AllocatePrefetchStepSize )
  50     AllocatePrefetchStepSize = cache_line_size;
  51 
  52   assert(AllocatePrefetchLines &gt; 0, "invalid value");
  53   if( AllocatePrefetchLines &lt; 1 )     // set valid value in product VM
  54     AllocatePrefetchLines = 3;
  55   assert(AllocateInstancePrefetchLines &gt; 0, "invalid value");
  56   if( AllocateInstancePrefetchLines &lt; 1 ) // set valid value in product VM
  57     AllocateInstancePrefetchLines = 1;
  58 
  59   AllocatePrefetchDistance = allocate_prefetch_distance();
  60   AllocatePrefetchStyle    = allocate_prefetch_style();
  61 
  62   assert((AllocatePrefetchDistance % AllocatePrefetchStepSize) == 0 &amp;&amp;
  63          (AllocatePrefetchDistance &gt; 0), "invalid value");
  64   if ((AllocatePrefetchDistance % AllocatePrefetchStepSize) != 0 ||
  65       (AllocatePrefetchDistance &lt;= 0)) {
  66     AllocatePrefetchDistance = AllocatePrefetchStepSize;
  67   }
  68 
  69   if (AllocatePrefetchStyle == 3 &amp;&amp; !has_blk_init()) {
  70     warning("BIS instructions are not available on this CPU");
  71     FLAG_SET_DEFAULT(AllocatePrefetchStyle, 1);
  72   }
  73 
  74   guarantee(VM_Version::has_v9(), "only SPARC v9 is supported");
  75 
  76   assert(ArraycopySrcPrefetchDistance &lt; 4096, "invalid value");
  77   if (ArraycopySrcPrefetchDistance &gt;= 4096)
  78     ArraycopySrcPrefetchDistance = 4064;
  79   assert(ArraycopyDstPrefetchDistance &lt; 4096, "invalid value");
  80   if (ArraycopyDstPrefetchDistance &gt;= 4096)
  81     ArraycopyDstPrefetchDistance = 4064;
  82 
  83   UseSSE = 0; // Only on x86 and x64
  84 
  85   _supports_cx8 = has_v9();
  86   _supports_atomic_getset4 = true; // swap instruction
  87 
  88   if (is_niagara()) {
  89     // Indirect branch is the same cost as direct
  90     if (FLAG_IS_DEFAULT(UseInlineCaches)) {
  91       FLAG_SET_DEFAULT(UseInlineCaches, false);
  92     }
  93     // Align loops on a single instruction boundary.
  94     if (FLAG_IS_DEFAULT(OptoLoopAlignment)) {
  95       FLAG_SET_DEFAULT(OptoLoopAlignment, 4);
  96     }
  97 #ifdef _LP64
  98     // 32-bit oops don't make sense for the 64-bit VM on sparc
  99     // since the 32-bit VM has the same registers and smaller objects.
 100     Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);
 101     Universe::set_narrow_klass_shift(LogKlassAlignmentInBytes);
 102 #endif // _LP64
 103 #ifdef COMPILER2
 104     // Indirect branch is the same cost as direct
 105     if (FLAG_IS_DEFAULT(UseJumpTables)) {
 106       FLAG_SET_DEFAULT(UseJumpTables, true);
 107     }
 108     // Single-issue, so entry and loop tops are
 109     // aligned on a single instruction boundary
 110     if (FLAG_IS_DEFAULT(InteriorEntryAlignment)) {
 111       FLAG_SET_DEFAULT(InteriorEntryAlignment, 4);
 112     }
 113     if (is_niagara_plus()) {
 114       if (has_blk_init() &amp;&amp; UseTLAB &amp;&amp;
 115           FLAG_IS_DEFAULT(AllocatePrefetchInstr)) {
 116         // Use BIS instruction for TLAB allocation prefetch.
 117         FLAG_SET_ERGO(intx, AllocatePrefetchInstr, 1);
 118         if (FLAG_IS_DEFAULT(AllocatePrefetchStyle)) {
 119           FLAG_SET_ERGO(intx, AllocatePrefetchStyle, 3);
 120         }
 121         if (FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
 122           // Use smaller prefetch distance with BIS
 123           FLAG_SET_DEFAULT(AllocatePrefetchDistance, 64);
 124         }
 125       }
 126       if (is_T4()) {
 127         // Double number of prefetched cache lines on T4
 128         // since L2 cache line size is smaller (32 bytes).
 129         if (FLAG_IS_DEFAULT(AllocatePrefetchLines)) {
 130           FLAG_SET_ERGO(intx, AllocatePrefetchLines, AllocatePrefetchLines*2);
 131         }
 132         if (FLAG_IS_DEFAULT(AllocateInstancePrefetchLines)) {
 133           FLAG_SET_ERGO(intx, AllocateInstancePrefetchLines, AllocateInstancePrefetchLines*2);
 134         }
 135       }
 136       if (AllocatePrefetchStyle != 3 &amp;&amp; FLAG_IS_DEFAULT(AllocatePrefetchDistance)) {
 137         // Use different prefetch distance without BIS
 138         FLAG_SET_DEFAULT(AllocatePrefetchDistance, 256);
 139       }
 140       if (AllocatePrefetchInstr == 1) {
 141         // Need a space at the end of TLAB for BIS since it
 142         // will fault when accessing memory outside of heap.
 143 
 144         // +1 for rounding up to next cache line, +1 to be safe
 145         int lines = AllocatePrefetchLines + 2;
 146         int step_size = AllocatePrefetchStepSize;
 147         int distance = AllocatePrefetchDistance;
 148         _reserve_for_allocation_prefetch = (distance + step_size*lines)/(int)HeapWordSize;
 149       }
 150     }
 151 #endif
 152   }
 153 
 154   // Use hardware population count instruction if available.
 155   if (has_hardware_popc()) {
 156     if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {
 157       FLAG_SET_DEFAULT(UsePopCountInstruction, true);
 158     }
 159   } else if (UsePopCountInstruction) {
 160     warning("POPC instruction is not available on this CPU");
 161     FLAG_SET_DEFAULT(UsePopCountInstruction, false);
 162   }
 163 
 164   // T4 and newer Sparc cpus have new compare and branch instruction.
 165   if (has_cbcond()) {
 166     if (FLAG_IS_DEFAULT(UseCBCond)) {
 167       FLAG_SET_DEFAULT(UseCBCond, true);
 168     }
 169   } else if (UseCBCond) {
 170     warning("CBCOND instruction is not available on this CPU");
 171     FLAG_SET_DEFAULT(UseCBCond, false);
 172   }
 173 
 174   assert(BlockZeroingLowLimit &gt; 0, "invalid value");
 175   if (has_block_zeroing() &amp;&amp; cache_line_size &gt; 0) {
 176     if (FLAG_IS_DEFAULT(UseBlockZeroing)) {
 177       FLAG_SET_DEFAULT(UseBlockZeroing, true);
 178     }
 179   } else if (UseBlockZeroing) {
 180     warning("BIS zeroing instructions are not available on this CPU");
 181     FLAG_SET_DEFAULT(UseBlockZeroing, false);
 182   }
 183 
 184   assert(BlockCopyLowLimit &gt; 0, "invalid value");
 185   if (has_block_zeroing() &amp;&amp; cache_line_size &gt; 0) { // has_blk_init() &amp;&amp; is_T4(): core's local L2 cache
 186     if (FLAG_IS_DEFAULT(UseBlockCopy)) {
 187       FLAG_SET_DEFAULT(UseBlockCopy, true);
 188     }
 189   } else if (UseBlockCopy) {
 190     warning("BIS instructions are not available or expensive on this CPU");
 191     FLAG_SET_DEFAULT(UseBlockCopy, false);
 192   }
 193 
 194 #ifdef COMPILER2
 195   // T4 and newer Sparc cpus have fast RDPC.
 196   if (has_fast_rdpc() &amp;&amp; FLAG_IS_DEFAULT(UseRDPCForConstantTableBase)) {
 197     FLAG_SET_DEFAULT(UseRDPCForConstantTableBase, true);
 198   }
 199 
 200   // Currently not supported anywhere.
 201   FLAG_SET_DEFAULT(UseFPUForSpilling, false);
 202 
 203   MaxVectorSize = 8;
 204 
 205   assert((InteriorEntryAlignment % relocInfo::addr_unit()) == 0, "alignment is not a multiple of NOP size");
 206 #endif
 207 
 208   assert((CodeEntryAlignment % relocInfo::addr_unit()) == 0, "alignment is not a multiple of NOP size");
 209   assert((OptoLoopAlignment % relocInfo::addr_unit()) == 0, "alignment is not a multiple of NOP size");
 210 
 211   char buf[512];
 212   jio_snprintf(buf, sizeof(buf), "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
 213                (has_v9() ? ", v9" : (has_v8() ? ", v8" : "")),
 214                (has_hardware_popc() ? ", popc" : ""),
 215                (has_vis1() ? ", vis1" : ""),
 216                (has_vis2() ? ", vis2" : ""),
 217                (has_vis3() ? ", vis3" : ""),
 218                (has_blk_init() ? ", blk_init" : ""),
 219                (has_cbcond() ? ", cbcond" : ""),
 220                (has_aes() ? ", aes" : ""),
 221                (has_sha1() ? ", sha1" : ""),
 222                (has_sha256() ? ", sha256" : ""),
 223                (has_sha512() ? ", sha512" : ""),
 224                (has_crc32c() ? ", crc32c" : ""),
 225                (is_ultra3() ? ", ultra3" : ""),
 226                (is_sun4v() ? ", sun4v" : ""),
 227                (is_niagara_plus() ? ", niagara_plus" : (is_niagara() ? ", niagara" : "")),
 228                (is_sparc64() ? ", sparc64" : ""),
 229                (!has_hardware_mul32() ? ", no-mul32" : ""),
 230                (!has_hardware_div32() ? ", no-div32" : ""),
 231                (!has_hardware_fsmuld() ? ", no-fsmuld" : ""));
 232 
 233   // buf is started with ", " or is empty
 234   _features_str = os::strdup(strlen(buf) &gt; 2 ? buf + 2 : buf);
 235 
 236   // UseVIS is set to the smallest of what hardware supports and what
 237   // the command line requires.  I.e., you cannot set UseVIS to 3 on
 238   // older UltraSparc which do not support it.
 239   if (UseVIS &gt; 3) UseVIS=3;
 240   if (UseVIS &lt; 0) UseVIS=0;
 241   if (!has_vis3()) // Drop to 2 if no VIS3 support
 242     UseVIS = MIN2((intx)2,UseVIS);
 243   if (!has_vis2()) // Drop to 1 if no VIS2 support
 244     UseVIS = MIN2((intx)1,UseVIS);
 245   if (!has_vis1()) // Drop to 0 if no VIS1 support
 246     UseVIS = 0;
 247 
 248   // SPARC T4 and above should have support for AES instructions
 249   if (has_aes()) {
 250     if (UseVIS &gt; 2) { // AES intrinsics use MOVxTOd/MOVdTOx which are VIS3
 251       if (FLAG_IS_DEFAULT(UseAES)) {
 252         FLAG_SET_DEFAULT(UseAES, true);
 253       }
 254       if (FLAG_IS_DEFAULT(UseAESIntrinsics)) {
 255         FLAG_SET_DEFAULT(UseAESIntrinsics, true);
 256       }
 257       // we disable both the AES flags if either of them is disabled on the command line
 258       if (!UseAES || !UseAESIntrinsics) {
 259         FLAG_SET_DEFAULT(UseAES, false);
 260         FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 261       }
 262     } else {
 263         if (UseAES || UseAESIntrinsics) {
 264           warning("SPARC AES intrinsics require VIS3 instruction support. Intrinsics will be disabled.");
 265           if (UseAES) {
 266             FLAG_SET_DEFAULT(UseAES, false);
 267           }
 268           if (UseAESIntrinsics) {
 269             FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 270           }
 271         }
 272     }
 273   } else if (UseAES || UseAESIntrinsics) {
 274     warning("AES instructions are not available on this CPU");
 275     if (UseAES) {
 276       FLAG_SET_DEFAULT(UseAES, false);
 277     }
 278     if (UseAESIntrinsics) {
 279       FLAG_SET_DEFAULT(UseAESIntrinsics, false);
 280     }
 281   }
 282 
 283   // GHASH/GCM intrinsics
 284   if (has_vis3() &amp;&amp; (UseVIS &gt; 2)) {
 285     if (FLAG_IS_DEFAULT(UseGHASHIntrinsics)) {
 286       UseGHASHIntrinsics = true;
 287     }
 288   } else if (UseGHASHIntrinsics) {
 289     if (!FLAG_IS_DEFAULT(UseGHASHIntrinsics))
 290       warning("GHASH intrinsics require VIS3 instruction support. Intrinsics will be disabled");
 291     FLAG_SET_DEFAULT(UseGHASHIntrinsics, false);
 292   }
 293 
 294   // SHA1, SHA256, and SHA512 instructions were added to SPARC T-series at different times
 295   if (has_sha1() || has_sha256() || has_sha512()) {
 296     if (UseVIS &gt; 0) { // SHA intrinsics use VIS1 instructions
 297       if (FLAG_IS_DEFAULT(UseSHA)) {
 298         FLAG_SET_DEFAULT(UseSHA, true);
 299       }
 300     } else {
 301       if (UseSHA) {
 302         warning("SPARC SHA intrinsics require VIS1 instruction support. Intrinsics will be disabled.");
 303         FLAG_SET_DEFAULT(UseSHA, false);
 304       }
 305     }
 306   } else if (UseSHA) {
 307     warning("SHA instructions are not available on this CPU");
 308     FLAG_SET_DEFAULT(UseSHA, false);
 309   }
 310 
 311   if (UseSHA &amp;&amp; has_sha1()) {
 312     if (FLAG_IS_DEFAULT(UseSHA1Intrinsics)) {
 313       FLAG_SET_DEFAULT(UseSHA1Intrinsics, true);
 314     }
 315   } else if (UseSHA1Intrinsics) {
 316     warning("Intrinsics for SHA-1 crypto hash functions not available on this CPU.");
 317     FLAG_SET_DEFAULT(UseSHA1Intrinsics, false);
 318   }
 319 
 320   if (UseSHA &amp;&amp; has_sha256()) {
 321     if (FLAG_IS_DEFAULT(UseSHA256Intrinsics)) {
 322       FLAG_SET_DEFAULT(UseSHA256Intrinsics, true);
 323     }
 324   } else if (UseSHA256Intrinsics) {
 325     warning("Intrinsics for SHA-224 and SHA-256 crypto hash functions not available on this CPU.");
 326     FLAG_SET_DEFAULT(UseSHA256Intrinsics, false);
 327   }
 328 
 329   if (UseSHA &amp;&amp; has_sha512()) {
 330     if (FLAG_IS_DEFAULT(UseSHA512Intrinsics)) {
 331       FLAG_SET_DEFAULT(UseSHA512Intrinsics, true);
 332     }
 333   } else if (UseSHA512Intrinsics) {
 334     warning("Intrinsics for SHA-384 and SHA-512 crypto hash functions not available on this CPU.");
 335     FLAG_SET_DEFAULT(UseSHA512Intrinsics, false);
 336   }
 337 
 338   if (!(UseSHA1Intrinsics || UseSHA256Intrinsics || UseSHA512Intrinsics)) {
 339     FLAG_SET_DEFAULT(UseSHA, false);
 340   }
 341 
 342   // SPARC T4 and above should have support for CRC32C instruction
 343   if (has_crc32c()) {
 344     if (UseVIS &gt; 2) { // CRC32C intrinsics use VIS3 instructions
 345       if (FLAG_IS_DEFAULT(UseCRC32CIntrinsics)) {
 346         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, true);
 347       }
 348     } else {
 349       if (UseCRC32CIntrinsics) {
 350         warning("SPARC CRC32C intrinsics require VIS3 instruction support. Intrinsics will be disabled.");
 351         FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 352       }
 353     }
 354   } else if (UseCRC32CIntrinsics) {
 355     warning("CRC32C instruction is not available on this CPU");
 356     FLAG_SET_DEFAULT(UseCRC32CIntrinsics, false);
 357   }
 358 
 359   if (UseVIS &gt; 2) {
 360     if (FLAG_IS_DEFAULT(UseAdler32Intrinsics)) {
 361       FLAG_SET_DEFAULT(UseAdler32Intrinsics, true);
 362     }
 363   } else if (UseAdler32Intrinsics) {
 364     warning("SPARC Adler32 intrinsics require VIS3 instruction support. Intrinsics will be disabled.");
 365     FLAG_SET_DEFAULT(UseAdler32Intrinsics, false);
 366   }
 367 
<a name="1" id="anc1"></a>





 368   if (FLAG_IS_DEFAULT(ContendedPaddingWidth) &amp;&amp;
 369     (cache_line_size &gt; ContendedPaddingWidth))
 370     ContendedPaddingWidth = cache_line_size;
 371 
 372   // This machine does not allow unaligned memory accesses
 373   if (UseUnalignedAccesses) {
 374     if (!FLAG_IS_DEFAULT(UseUnalignedAccesses))
 375       warning("Unaligned memory access is not available on this CPU");
 376     FLAG_SET_DEFAULT(UseUnalignedAccesses, false);
 377   }
 378 
 379 #ifndef PRODUCT
 380   if (PrintMiscellaneous &amp;&amp; Verbose) {
 381     tty-&gt;print_cr("L1 data cache line size: %u", L1_data_cache_line_size());
 382     tty-&gt;print_cr("L2 data cache line size: %u", L2_data_cache_line_size());
 383     tty-&gt;print("Allocation");
 384     if (AllocatePrefetchStyle &lt;= 0) {
 385       tty-&gt;print_cr(": no prefetching");
 386     } else {
 387       tty-&gt;print(" prefetching: ");
 388       if (AllocatePrefetchInstr == 0) {
 389           tty-&gt;print("PREFETCH");
 390       } else if (AllocatePrefetchInstr == 1) {
 391           tty-&gt;print("BIS");
 392       }
 393       if (AllocatePrefetchLines &gt; 1) {
 394         tty-&gt;print_cr(" at distance %d, %d lines of %d bytes", (int) AllocatePrefetchDistance, (int) AllocatePrefetchLines, (int) AllocatePrefetchStepSize);
 395       } else {
 396         tty-&gt;print_cr(" at distance %d, one line of %d bytes", (int) AllocatePrefetchDistance, (int) AllocatePrefetchStepSize);
 397       }
 398     }
 399     if (PrefetchCopyIntervalInBytes &gt; 0) {
 400       tty-&gt;print_cr("PrefetchCopyIntervalInBytes %d", (int) PrefetchCopyIntervalInBytes);
 401     }
 402     if (PrefetchScanIntervalInBytes &gt; 0) {
 403       tty-&gt;print_cr("PrefetchScanIntervalInBytes %d", (int) PrefetchScanIntervalInBytes);
 404     }
 405     if (PrefetchFieldsAhead &gt; 0) {
 406       tty-&gt;print_cr("PrefetchFieldsAhead %d", (int) PrefetchFieldsAhead);
 407     }
 408     if (ContendedPaddingWidth &gt; 0) {
 409       tty-&gt;print_cr("ContendedPaddingWidth %d", (int) ContendedPaddingWidth);
 410     }
 411   }
 412 #endif // PRODUCT
 413 }
 414 
 415 void VM_Version::print_features() {
 416   tty-&gt;print_cr("Version:%s", cpu_features());
 417 }
 418 
 419 int VM_Version::determine_features() {
 420   if (UseV8InstrsOnly) {
 421     NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) tty-&gt;print_cr("Version is Forced-V8");)
 422     return generic_v8_m;
 423   }
 424 
 425   int features = platform_features(unknown_m); // platform_features() is os_arch specific
 426 
 427   if (features == unknown_m) {
 428     features = generic_v9_m;
 429     warning("Cannot recognize SPARC version. Default to V9");
 430   }
 431 
 432   assert(is_T_family(features) == is_niagara(features), "Niagara should be T series");
 433   if (UseNiagaraInstrs) { // Force code generation for Niagara
 434     if (is_T_family(features)) {
 435       // Happy to accomodate...
 436     } else {
 437       NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) tty-&gt;print_cr("Version is Forced-Niagara");)
 438       features |= T_family_m;
 439     }
 440   } else {
 441     if (is_T_family(features) &amp;&amp; !FLAG_IS_DEFAULT(UseNiagaraInstrs)) {
 442       NOT_PRODUCT(if (PrintMiscellaneous &amp;&amp; Verbose) tty-&gt;print_cr("Version is Forced-Not-Niagara");)
 443       features &amp;= ~(T_family_m | T1_model_m);
 444     } else {
 445       // Happy to accomodate...
 446     }
 447   }
 448 
 449   return features;
 450 }
 451 
 452 static int saved_features = 0;
 453 
 454 void VM_Version::allow_all() {
 455   saved_features = _features;
 456   _features      = all_features_m;
 457 }
 458 
 459 void VM_Version::revert() {
 460   _features = saved_features;
 461 }
 462 
 463 unsigned int VM_Version::calc_parallel_worker_threads() {
 464   unsigned int result;
 465   if (is_M_series()) {
 466     // for now, use same gc thread calculation for M-series as for niagara-plus
 467     // in future, we may want to tweak parameters for nof_parallel_worker_thread
 468     result = nof_parallel_worker_threads(5, 16, 8);
 469   } else if (is_niagara_plus()) {
 470     result = nof_parallel_worker_threads(5, 16, 8);
 471   } else {
 472     result = nof_parallel_worker_threads(5, 8, 8);
 473   }
 474   return result;
 475 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
