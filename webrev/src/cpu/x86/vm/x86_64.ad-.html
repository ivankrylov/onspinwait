<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old src/cpu/x86/vm/x86_64.ad</title>
<body id="SUNWwebrev">
<pre>
   1 //
   2 // Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 // AMD64 Architecture Description File
  26 
  27 //----------REGISTER DEFINITION BLOCK------------------------------------------
  28 // This information is used by the matcher and the register allocator to
  29 // describe individual registers and classes of registers within the target
  30 // archtecture.
  31 
  32 register %{
  33 //----------Architecture Description Register Definitions----------------------
  34 // General Registers
  35 // "reg_def"  name ( register save type, C convention save type,
  36 //                   ideal register type, encoding );
  37 // Register Save Types:
  38 //
  39 // NS  = No-Save:       The register allocator assumes that these registers
  40 //                      can be used without saving upon entry to the method, &amp;
  41 //                      that they do not need to be saved at call sites.
  42 //
  43 // SOC = Save-On-Call:  The register allocator assumes that these registers
  44 //                      can be used without saving upon entry to the method,
  45 //                      but that they must be saved at call sites.
  46 //
  47 // SOE = Save-On-Entry: The register allocator assumes that these registers
  48 //                      must be saved before using them upon entry to the
  49 //                      method, but they do not need to be saved at call
  50 //                      sites.
  51 //
  52 // AS  = Always-Save:   The register allocator assumes that these registers
  53 //                      must be saved before using them upon entry to the
  54 //                      method, &amp; that they must be saved at call sites.
  55 //
  56 // Ideal Register Type is used to determine how to save &amp; restore a
  57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
  59 //
  60 // The encoding number is the actual bit-pattern placed into the opcodes.
  61 
  62 // General Registers
  63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
  64 // used as byte registers)
  65 
  66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
  67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
  68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
  69 
  70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
  71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
  72 
  73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
  74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
  75 
  76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
  77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
  78 
  79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
  80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
  81 
  82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
  83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
  84 
  85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
  86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
  87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
  88 
  89 #ifdef _WIN64
  90 
  91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
  92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  93 
  94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
  95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  96 
  97 #else
  98 
  99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
 100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
 101 
 102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
 103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
 104 
 105 #endif
 106 
 107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
 108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
 109 
 110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
 111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
 112 
 113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
 114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
 115 
 116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
 117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
 118 
 119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
 120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
 121 
 122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
 123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
 124 
 125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
 126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
 127 
 128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
 129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
 130 
 131 
 132 // Floating Point Registers
 133 
 134 // Specify priority of register selection within phases of register
 135 // allocation.  Highest priority is first.  A useful heuristic is to
 136 // give registers a low priority when they are required by machine
 137 // instructions, like EAX and EDX on I486, and choose no-save registers
 138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
 139 // which participate in fixed calling sequences should come last.
 140 // Registers which are used as pairs must fall on an even boundary.
 141 
 142 alloc_class chunk0(R10,         R10_H,
 143                    R11,         R11_H,
 144                    R8,          R8_H,
 145                    R9,          R9_H,
 146                    R12,         R12_H,
 147                    RCX,         RCX_H,
 148                    RBX,         RBX_H,
 149                    RDI,         RDI_H,
 150                    RDX,         RDX_H,
 151                    RSI,         RSI_H,
 152                    RAX,         RAX_H,
 153                    RBP,         RBP_H,
 154                    R13,         R13_H,
 155                    R14,         R14_H,
 156                    R15,         R15_H,
 157                    RSP,         RSP_H);
 158 
 159 
 160 //----------Architecture Description Register Classes--------------------------
 161 // Several register classes are automatically defined based upon information in
 162 // this architecture description.
 163 // 1) reg_class inline_cache_reg           ( /* as def'd in frame section */ )
 164 // 2) reg_class compiler_method_oop_reg    ( /* as def'd in frame section */ )
 165 // 2) reg_class interpreter_method_oop_reg ( /* as def'd in frame section */ )
 166 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 167 //
 168 
 169 // Empty register class.
 170 reg_class no_reg();
 171 
 172 // Class for all pointer registers (including RSP and RBP)
 173 reg_class any_reg_with_rbp(RAX, RAX_H,
 174                            RDX, RDX_H,
 175                            RBP, RBP_H,
 176                            RDI, RDI_H,
 177                            RSI, RSI_H,
 178                            RCX, RCX_H,
 179                            RBX, RBX_H,
 180                            RSP, RSP_H,
 181                            R8,  R8_H,
 182                            R9,  R9_H,
 183                            R10, R10_H,
 184                            R11, R11_H,
 185                            R12, R12_H,
 186                            R13, R13_H,
 187                            R14, R14_H,
 188                            R15, R15_H);
 189 
 190 // Class for all pointer registers (including RSP, but excluding RBP)
 191 reg_class any_reg_no_rbp(RAX, RAX_H,
 192                          RDX, RDX_H,
 193                          RDI, RDI_H,
 194                          RSI, RSI_H,
 195                          RCX, RCX_H,
 196                          RBX, RBX_H,
 197                          RSP, RSP_H,
 198                          R8,  R8_H,
 199                          R9,  R9_H,
 200                          R10, R10_H,
 201                          R11, R11_H,
 202                          R12, R12_H,
 203                          R13, R13_H,
 204                          R14, R14_H,
 205                          R15, R15_H);
 206 
 207 // Dynamic register class that selects at runtime between register classes
 208 // any_reg_no_rbp and any_reg_with_rbp (depending on the value of the flag PreserveFramePointer).
 209 // Equivalent to: return PreserveFramePointer ? any_reg_no_rbp : any_reg_with_rbp;
 210 reg_class_dynamic any_reg(any_reg_no_rbp, any_reg_with_rbp, %{ PreserveFramePointer %});
 211 
 212 // Class for all pointer registers (excluding RSP)
 213 reg_class ptr_reg_with_rbp(RAX, RAX_H,
 214                            RDX, RDX_H,
 215                            RBP, RBP_H,
 216                            RDI, RDI_H,
 217                            RSI, RSI_H,
 218                            RCX, RCX_H,
 219                            RBX, RBX_H,
 220                            R8,  R8_H,
 221                            R9,  R9_H,
 222                            R10, R10_H,
 223                            R11, R11_H,
 224                            R13, R13_H,
 225                            R14, R14_H);
 226 
 227 // Class for all pointer registers (excluding RSP and RBP)
 228 reg_class ptr_reg_no_rbp(RAX, RAX_H,
 229                          RDX, RDX_H,
 230                          RDI, RDI_H,
 231                          RSI, RSI_H,
 232                          RCX, RCX_H,
 233                          RBX, RBX_H,
 234                          R8,  R8_H,
 235                          R9,  R9_H,
 236                          R10, R10_H,
 237                          R11, R11_H,
 238                          R13, R13_H,
 239                          R14, R14_H);
 240 
 241 // Dynamic register class that selects between ptr_reg_no_rbp and ptr_reg_with_rbp.
 242 reg_class_dynamic ptr_reg(ptr_reg_no_rbp, ptr_reg_with_rbp, %{ PreserveFramePointer %});
 243 
 244 // Class for all pointer registers (excluding RAX and RSP)
 245 reg_class ptr_no_rax_reg_with_rbp(RDX, RDX_H,
 246                                   RBP, RBP_H,
 247                                   RDI, RDI_H,
 248                                   RSI, RSI_H,
 249                                   RCX, RCX_H,
 250                                   RBX, RBX_H,
 251                                   R8,  R8_H,
 252                                   R9,  R9_H,
 253                                   R10, R10_H,
 254                                   R11, R11_H,
 255                                   R13, R13_H,
 256                                   R14, R14_H);
 257 
 258 // Class for all pointer registers (excluding RAX, RSP, and RBP)
 259 reg_class ptr_no_rax_reg_no_rbp(RDX, RDX_H,
 260                                 RDI, RDI_H,
 261                                 RSI, RSI_H,
 262                                 RCX, RCX_H,
 263                                 RBX, RBX_H,
 264                                 R8,  R8_H,
 265                                 R9,  R9_H,
 266                                 R10, R10_H,
 267                                 R11, R11_H,
 268                                 R13, R13_H,
 269                                 R14, R14_H);
 270 
 271 // Dynamic register class that selects between ptr_no_rax_reg_no_rbp and ptr_no_rax_reg_with_rbp.
 272 reg_class_dynamic ptr_no_rax_reg(ptr_no_rax_reg_no_rbp, ptr_no_rax_reg_with_rbp, %{ PreserveFramePointer %});
 273 
 274 // Class for all pointer registers (excluding RAX, RBX, and RSP)
 275 reg_class ptr_no_rax_rbx_reg_with_rbp(RDX, RDX_H,
 276                                       RBP, RBP_H,
 277                                       RDI, RDI_H,
 278                                       RSI, RSI_H,
 279                                       RCX, RCX_H,
 280                                       R8,  R8_H,
 281                                       R9,  R9_H,
 282                                       R10, R10_H,
 283                                       R11, R11_H,
 284                                       R13, R13_H,
 285                                       R14, R14_H);
 286 
 287 // Class for all pointer registers (excluding RAX, RBX, RSP, and RBP)
 288 reg_class ptr_no_rax_rbx_reg_no_rbp(RDX, RDX_H,
 289                                     RDI, RDI_H,
 290                                     RSI, RSI_H,
 291                                     RCX, RCX_H,
 292                                     R8,  R8_H,
 293                                     R9,  R9_H,
 294                                     R10, R10_H,
 295                                     R11, R11_H,
 296                                     R13, R13_H,
 297                                     R14, R14_H);
 298 
 299 // Dynamic register class that selects between ptr_no_rax_rbx_reg_no_rbp and ptr_no_rax_rbx_reg_with_rbp.
 300 reg_class_dynamic ptr_no_rax_rbx_reg(ptr_no_rax_rbx_reg_no_rbp, ptr_no_rax_rbx_reg_with_rbp, %{ PreserveFramePointer %});
 301 
 302 // Singleton class for RAX pointer register
 303 reg_class ptr_rax_reg(RAX, RAX_H);
 304 
 305 // Singleton class for RBX pointer register
 306 reg_class ptr_rbx_reg(RBX, RBX_H);
 307 
 308 // Singleton class for RSI pointer register
 309 reg_class ptr_rsi_reg(RSI, RSI_H);
 310 
 311 // Singleton class for RDI pointer register
 312 reg_class ptr_rdi_reg(RDI, RDI_H);
 313 
 314 // Singleton class for stack pointer
 315 reg_class ptr_rsp_reg(RSP, RSP_H);
 316 
 317 // Singleton class for TLS pointer
 318 reg_class ptr_r15_reg(R15, R15_H);
 319 
 320 // Class for all long registers (excluding RSP)
 321 reg_class long_reg_with_rbp(RAX, RAX_H,
 322                             RDX, RDX_H,
 323                             RBP, RBP_H,
 324                             RDI, RDI_H,
 325                             RSI, RSI_H,
 326                             RCX, RCX_H,
 327                             RBX, RBX_H,
 328                             R8,  R8_H,
 329                             R9,  R9_H,
 330                             R10, R10_H,
 331                             R11, R11_H,
 332                             R13, R13_H,
 333                             R14, R14_H);
 334 
 335 // Class for all long registers (excluding RSP and RBP)
 336 reg_class long_reg_no_rbp(RAX, RAX_H,
 337                           RDX, RDX_H,
 338                           RDI, RDI_H,
 339                           RSI, RSI_H,
 340                           RCX, RCX_H,
 341                           RBX, RBX_H,
 342                           R8,  R8_H,
 343                           R9,  R9_H,
 344                           R10, R10_H,
 345                           R11, R11_H,
 346                           R13, R13_H,
 347                           R14, R14_H);
 348 
 349 // Dynamic register class that selects between long_reg_no_rbp and long_reg_with_rbp.
 350 reg_class_dynamic long_reg(long_reg_no_rbp, long_reg_with_rbp, %{ PreserveFramePointer %});
 351 
 352 // Class for all long registers (excluding RAX, RDX and RSP)
 353 reg_class long_no_rax_rdx_reg_with_rbp(RBP, RBP_H,
 354                                        RDI, RDI_H,
 355                                        RSI, RSI_H,
 356                                        RCX, RCX_H,
 357                                        RBX, RBX_H,
 358                                        R8,  R8_H,
 359                                        R9,  R9_H,
 360                                        R10, R10_H,
 361                                        R11, R11_H,
 362                                        R13, R13_H,
 363                                        R14, R14_H);
 364 
 365 // Class for all long registers (excluding RAX, RDX, RSP, and RBP)
 366 reg_class long_no_rax_rdx_reg_no_rbp(RDI, RDI_H,
 367                                      RSI, RSI_H,
 368                                      RCX, RCX_H,
 369                                      RBX, RBX_H,
 370                                      R8,  R8_H,
 371                                      R9,  R9_H,
 372                                      R10, R10_H,
 373                                      R11, R11_H,
 374                                      R13, R13_H,
 375                                      R14, R14_H);
 376 
 377 // Dynamic register class that selects between long_no_rax_rdx_reg_no_rbp and long_no_rax_rdx_reg_with_rbp.
 378 reg_class_dynamic long_no_rax_rdx_reg(long_no_rax_rdx_reg_no_rbp, long_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 379 
 380 // Class for all long registers (excluding RCX and RSP)
 381 reg_class long_no_rcx_reg_with_rbp(RBP, RBP_H,
 382                                    RDI, RDI_H,
 383                                    RSI, RSI_H,
 384                                    RAX, RAX_H,
 385                                    RDX, RDX_H,
 386                                    RBX, RBX_H,
 387                                    R8,  R8_H,
 388                                    R9,  R9_H,
 389                                    R10, R10_H,
 390                                    R11, R11_H,
 391                                    R13, R13_H,
 392                                    R14, R14_H);
 393 
 394 // Class for all long registers (excluding RCX, RSP, and RBP)
 395 reg_class long_no_rcx_reg_no_rbp(RDI, RDI_H,
 396                                  RSI, RSI_H,
 397                                  RAX, RAX_H,
 398                                  RDX, RDX_H,
 399                                  RBX, RBX_H,
 400                                  R8,  R8_H,
 401                                  R9,  R9_H,
 402                                  R10, R10_H,
 403                                  R11, R11_H,
 404                                  R13, R13_H,
 405                                  R14, R14_H);
 406 
 407 // Dynamic register class that selects between long_no_rcx_reg_no_rbp and long_no_rcx_reg_with_rbp.
 408 reg_class_dynamic long_no_rcx_reg(long_no_rcx_reg_no_rbp, long_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 409 
 410 // Singleton class for RAX long register
 411 reg_class long_rax_reg(RAX, RAX_H);
 412 
 413 // Singleton class for RCX long register
 414 reg_class long_rcx_reg(RCX, RCX_H);
 415 
 416 // Singleton class for RDX long register
 417 reg_class long_rdx_reg(RDX, RDX_H);
 418 
 419 // Class for all int registers (excluding RSP)
 420 reg_class int_reg_with_rbp(RAX,
 421                            RDX,
 422                            RBP,
 423                            RDI,
 424                            RSI,
 425                            RCX,
 426                            RBX,
 427                            R8,
 428                            R9,
 429                            R10,
 430                            R11,
 431                            R13,
 432                            R14);
 433 
 434 // Class for all int registers (excluding RSP and RBP)
 435 reg_class int_reg_no_rbp(RAX,
 436                          RDX,
 437                          RDI,
 438                          RSI,
 439                          RCX,
 440                          RBX,
 441                          R8,
 442                          R9,
 443                          R10,
 444                          R11,
 445                          R13,
 446                          R14);
 447 
 448 // Dynamic register class that selects between int_reg_no_rbp and int_reg_with_rbp.
 449 reg_class_dynamic int_reg(int_reg_no_rbp, int_reg_with_rbp, %{ PreserveFramePointer %});
 450 
 451 // Class for all int registers (excluding RCX and RSP)
 452 reg_class int_no_rcx_reg_with_rbp(RAX,
 453                                   RDX,
 454                                   RBP,
 455                                   RDI,
 456                                   RSI,
 457                                   RBX,
 458                                   R8,
 459                                   R9,
 460                                   R10,
 461                                   R11,
 462                                   R13,
 463                                   R14);
 464 
 465 // Class for all int registers (excluding RCX, RSP, and RBP)
 466 reg_class int_no_rcx_reg_no_rbp(RAX,
 467                                 RDX,
 468                                 RDI,
 469                                 RSI,
 470                                 RBX,
 471                                 R8,
 472                                 R9,
 473                                 R10,
 474                                 R11,
 475                                 R13,
 476                                 R14);
 477 
 478 // Dynamic register class that selects between int_no_rcx_reg_no_rbp and int_no_rcx_reg_with_rbp.
 479 reg_class_dynamic int_no_rcx_reg(int_no_rcx_reg_no_rbp, int_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 480 
 481 // Class for all int registers (excluding RAX, RDX, and RSP)
 482 reg_class int_no_rax_rdx_reg_with_rbp(RBP,
 483                                       RDI,
 484                                       RSI,
 485                                       RCX,
 486                                       RBX,
 487                                       R8,
 488                                       R9,
 489                                       R10,
 490                                       R11,
 491                                       R13,
 492                                       R14);
 493 
 494 // Class for all int registers (excluding RAX, RDX, RSP, and RBP)
 495 reg_class int_no_rax_rdx_reg_no_rbp(RDI,
 496                                     RSI,
 497                                     RCX,
 498                                     RBX,
 499                                     R8,
 500                                     R9,
 501                                     R10,
 502                                     R11,
 503                                     R13,
 504                                     R14);
 505 
 506 // Dynamic register class that selects between int_no_rax_rdx_reg_no_rbp and int_no_rax_rdx_reg_with_rbp.
 507 reg_class_dynamic int_no_rax_rdx_reg(int_no_rax_rdx_reg_no_rbp, int_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 508 
 509 // Singleton class for RAX int register
 510 reg_class int_rax_reg(RAX);
 511 
 512 // Singleton class for RBX int register
 513 reg_class int_rbx_reg(RBX);
 514 
 515 // Singleton class for RCX int register
 516 reg_class int_rcx_reg(RCX);
 517 
 518 // Singleton class for RCX int register
 519 reg_class int_rdx_reg(RDX);
 520 
 521 // Singleton class for RCX int register
 522 reg_class int_rdi_reg(RDI);
 523 
 524 // Singleton class for instruction pointer
 525 // reg_class ip_reg(RIP);
 526 
 527 %}
 528 
 529 //----------SOURCE BLOCK-------------------------------------------------------
 530 // This is a block of C++ code which provides values, functions, and
 531 // definitions necessary in the rest of the architecture description
 532 source %{
 533 #define   RELOC_IMM64    Assembler::imm_operand
 534 #define   RELOC_DISP32   Assembler::disp32_operand
 535 
 536 #define __ _masm.
 537 
 538 static int clear_avx_size() {
 539   if(UseAVX &gt; 2) {
 540     return 0; // vzeroupper is ignored
 541   } else {
 542     return (Compile::current()-&gt;max_vector_size() &gt; 16) ? 3 : 0;  // vzeroupper
 543   }
 544 }
 545 
 546 // !!!!! Special hack to get all types of calls to specify the byte offset
 547 //       from the start of the call to the point where the return address
 548 //       will point.
 549 int MachCallStaticJavaNode::ret_addr_offset()
 550 {
 551   int offset = 5; // 5 bytes from start of call to where return address points
 552   offset += clear_avx_size();
 553   return offset;
 554 }
 555 
 556 int MachCallDynamicJavaNode::ret_addr_offset()
 557 {
 558   int offset = 15; // 15 bytes from start of call to where return address points
 559   offset += clear_avx_size();
 560   return offset;
 561 }
 562 
 563 int MachCallRuntimeNode::ret_addr_offset() {
 564   int offset = 13; // movq r10,#addr; callq (r10)
 565   offset += clear_avx_size();
 566   return offset;
 567 }
 568 
 569 // Indicate if the safepoint node needs the polling page as an input,
 570 // it does if the polling page is more than disp32 away.
 571 bool SafePointNode::needs_polling_address_input()
 572 {
 573   return Assembler::is_polling_page_far();
 574 }
 575 
 576 //
 577 // Compute padding required for nodes which need alignment
 578 //
 579 
 580 // The address of the call instruction needs to be 4-byte aligned to
 581 // ensure that it does not span a cache line so that it can be patched.
 582 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
 583 {
 584   current_offset += clear_avx_size(); // skip vzeroupper
 585   current_offset += 1; // skip call opcode byte
 586   return round_to(current_offset, alignment_required()) - current_offset;
 587 }
 588 
 589 // The address of the call instruction needs to be 4-byte aligned to
 590 // ensure that it does not span a cache line so that it can be patched.
 591 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
 592 {
 593   current_offset += clear_avx_size(); // skip vzeroupper
 594   current_offset += 11; // skip movq instruction + call opcode byte
 595   return round_to(current_offset, alignment_required()) - current_offset;
 596 }
 597 
 598 // EMIT_RM()
 599 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
 600   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
 601   cbuf.insts()-&gt;emit_int8(c);
 602 }
 603 
 604 // EMIT_CC()
 605 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
 606   unsigned char c = (unsigned char) (f1 | f2);
 607   cbuf.insts()-&gt;emit_int8(c);
 608 }
 609 
 610 // EMIT_OPCODE()
 611 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
 612   cbuf.insts()-&gt;emit_int8((unsigned char) code);
 613 }
 614 
 615 // EMIT_OPCODE() w/ relocation information
 616 void emit_opcode(CodeBuffer &amp;cbuf,
 617                  int code, relocInfo::relocType reloc, int offset, int format)
 618 {
 619   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
 620   emit_opcode(cbuf, code);
 621 }
 622 
 623 // EMIT_D8()
 624 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
 625   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
 626 }
 627 
 628 // EMIT_D16()
 629 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
 630   cbuf.insts()-&gt;emit_int16(d16);
 631 }
 632 
 633 // EMIT_D32()
 634 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
 635   cbuf.insts()-&gt;emit_int32(d32);
 636 }
 637 
 638 // EMIT_D64()
 639 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
 640   cbuf.insts()-&gt;emit_int64(d64);
 641 }
 642 
 643 // emit 32 bit value and construct relocation entry from relocInfo::relocType
 644 void emit_d32_reloc(CodeBuffer&amp; cbuf,
 645                     int d32,
 646                     relocInfo::relocType reloc,
 647                     int format)
 648 {
 649   assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
 650   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 651   cbuf.insts()-&gt;emit_int32(d32);
 652 }
 653 
 654 // emit 32 bit value and construct relocation entry from RelocationHolder
 655 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
 656 #ifdef ASSERT
 657   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 658       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
 659     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), "should be real oop");
 660     assert(cast_to_oop((intptr_t)d32)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop((intptr_t)d32)-&gt;is_scavengable()), "cannot embed scavengable oops in code");
 661   }
 662 #endif
 663   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 664   cbuf.insts()-&gt;emit_int32(d32);
 665 }
 666 
 667 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
 668   address next_ip = cbuf.insts_end() + 4;
 669   emit_d32_reloc(cbuf, (int) (addr - next_ip),
 670                  external_word_Relocation::spec(addr),
 671                  RELOC_DISP32);
 672 }
 673 
 674 
 675 // emit 64 bit value and construct relocation entry from relocInfo::relocType
 676 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
 677   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 678   cbuf.insts()-&gt;emit_int64(d64);
 679 }
 680 
 681 // emit 64 bit value and construct relocation entry from RelocationHolder
 682 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
 683 #ifdef ASSERT
 684   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 685       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
 686     assert(Universe::heap()-&gt;is_in_reserved((address)d64), "should be real oop");
 687     assert(cast_to_oop(d64)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop(d64)-&gt;is_scavengable()),
 688            "cannot embed scavengable oops in code");
 689   }
 690 #endif
 691   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 692   cbuf.insts()-&gt;emit_int64(d64);
 693 }
 694 
 695 // Access stack slot for load or store
 696 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
 697 {
 698   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
 699   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
 700     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
 701     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 702     emit_d8(cbuf, disp);     // Displacement  // R/M byte
 703   } else {
 704     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
 705     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 706     emit_d32(cbuf, disp);     // Displacement // R/M byte
 707   }
 708 }
 709 
 710    // rRegI ereg, memory mem) %{    // emit_reg_mem
 711 void encode_RegMem(CodeBuffer &amp;cbuf,
 712                    int reg,
 713                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
 714 {
 715   assert(disp_reloc == relocInfo::none, "cannot have disp");
 716   int regenc = reg &amp; 7;
 717   int baseenc = base &amp; 7;
 718   int indexenc = index &amp; 7;
 719 
 720   // There is no index &amp; no scale, use form without SIB byte
 721   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
 722     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 723     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 724       emit_rm(cbuf, 0x0, regenc, baseenc); // *
 725     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 726       // If 8-bit displacement, mode 0x1
 727       emit_rm(cbuf, 0x1, regenc, baseenc); // *
 728       emit_d8(cbuf, disp);
 729     } else {
 730       // If 32-bit displacement
 731       if (base == -1) { // Special flag for absolute address
 732         emit_rm(cbuf, 0x0, regenc, 0x5); // *
 733         if (disp_reloc != relocInfo::none) {
 734           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 735         } else {
 736           emit_d32(cbuf, disp);
 737         }
 738       } else {
 739         // Normal base + offset
 740         emit_rm(cbuf, 0x2, regenc, baseenc); // *
 741         if (disp_reloc != relocInfo::none) {
 742           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 743         } else {
 744           emit_d32(cbuf, disp);
 745         }
 746       }
 747     }
 748   } else {
 749     // Else, encode with the SIB byte
 750     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 751     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 752       // If no displacement
 753       emit_rm(cbuf, 0x0, regenc, 0x4); // *
 754       emit_rm(cbuf, scale, indexenc, baseenc);
 755     } else {
 756       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 757         // If 8-bit displacement, mode 0x1
 758         emit_rm(cbuf, 0x1, regenc, 0x4); // *
 759         emit_rm(cbuf, scale, indexenc, baseenc);
 760         emit_d8(cbuf, disp);
 761       } else {
 762         // If 32-bit displacement
 763         if (base == 0x04 ) {
 764           emit_rm(cbuf, 0x2, regenc, 0x4);
 765           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
 766         } else {
 767           emit_rm(cbuf, 0x2, regenc, 0x4);
 768           emit_rm(cbuf, scale, indexenc, baseenc); // *
 769         }
 770         if (disp_reloc != relocInfo::none) {
 771           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 772         } else {
 773           emit_d32(cbuf, disp);
 774         }
 775       }
 776     }
 777   }
 778 }
 779 
 780 // This could be in MacroAssembler but it's fairly C2 specific
 781 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
 782   Label exit;
 783   __ jccb(Assembler::noParity, exit);
 784   __ pushf();
 785   //
 786   // comiss/ucomiss instructions set ZF,PF,CF flags and
 787   // zero OF,AF,SF for NaN values.
 788   // Fixup flags by zeroing ZF,PF so that compare of NaN
 789   // values returns 'less than' result (CF is set).
 790   // Leave the rest of flags unchanged.
 791   //
 792   //    7 6 5 4 3 2 1 0
 793   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
 794   //    0 0 1 0 1 0 1 1   (0x2B)
 795   //
 796   __ andq(Address(rsp, 0), 0xffffff2b);
 797   __ popf();
 798   __ bind(exit);
 799 }
 800 
 801 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
 802   Label done;
 803   __ movl(dst, -1);
 804   __ jcc(Assembler::parity, done);
 805   __ jcc(Assembler::below, done);
 806   __ setb(Assembler::notEqual, dst);
 807   __ movzbl(dst, dst);
 808   __ bind(done);
 809 }
 810 
 811 
 812 //=============================================================================
 813 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 814 
 815 int Compile::ConstantTable::calculate_table_base_offset() const {
 816   return 0;  // absolute addressing, no offset
 817 }
 818 
 819 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 820 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 821   ShouldNotReachHere();
 822 }
 823 
 824 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 825   // Empty encoding
 826 }
 827 
 828 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 829   return 0;
 830 }
 831 
 832 #ifndef PRODUCT
 833 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 834   st-&gt;print("# MachConstantBaseNode (empty encoding)");
 835 }
 836 #endif
 837 
 838 
 839 //=============================================================================
 840 #ifndef PRODUCT
 841 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 842   Compile* C = ra_-&gt;C;
 843 
 844   int framesize = C-&gt;frame_size_in_bytes();
 845   int bangsize = C-&gt;bang_size_in_bytes();
 846   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 847   // Remove wordSize for return addr which is already pushed.
 848   framesize -= wordSize;
 849 
 850   if (C-&gt;need_stack_bang(bangsize)) {
 851     framesize -= wordSize;
 852     st-&gt;print("# stack bang (%d bytes)", bangsize);
 853     st-&gt;print("\n\t");
 854     st-&gt;print("pushq   rbp\t# Save rbp");
 855     if (PreserveFramePointer) {
 856         st-&gt;print("\n\t");
 857         st-&gt;print("movq    rbp, rsp\t# Save the caller's SP into rbp");
 858     }
 859     if (framesize) {
 860       st-&gt;print("\n\t");
 861       st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 862     }
 863   } else {
 864     st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 865     st-&gt;print("\n\t");
 866     framesize -= wordSize;
 867     st-&gt;print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
 868     if (PreserveFramePointer) {
 869       st-&gt;print("\n\t");
 870       st-&gt;print("movq    rbp, [rsp + #%d]\t# Save the caller's SP into rbp", (framesize + wordSize));
 871     }
 872   }
 873 
 874   if (VerifyStackAtCalls) {
 875     st-&gt;print("\n\t");
 876     framesize -= wordSize;
 877     st-&gt;print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
 878 #ifdef ASSERT
 879     st-&gt;print("\n\t");
 880     st-&gt;print("# stack alignment check");
 881 #endif
 882   }
 883   st-&gt;cr();
 884 }
 885 #endif
 886 
 887 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 888   Compile* C = ra_-&gt;C;
 889   MacroAssembler _masm(&amp;cbuf);
 890 
 891   int framesize = C-&gt;frame_size_in_bytes();
 892   int bangsize = C-&gt;bang_size_in_bytes();
 893 
 894   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false);
 895 
 896   C-&gt;set_frame_complete(cbuf.insts_size());
 897 
 898   if (C-&gt;has_mach_constant_base_node()) {
 899     // NOTE: We set the table base offset here because users might be
 900     // emitted before MachConstantBaseNode.
 901     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 902     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 903   }
 904 }
 905 
 906 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 907 {
 908   return MachNode::size(ra_); // too many variables; just compute it
 909                               // the hard way
 910 }
 911 
 912 int MachPrologNode::reloc() const
 913 {
 914   return 0; // a large enough number
 915 }
 916 
 917 //=============================================================================
 918 #ifndef PRODUCT
 919 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 920 {
 921   Compile* C = ra_-&gt;C;
 922   if (C-&gt;max_vector_size() &gt; 16) {
 923     st-&gt;print("vzeroupper");
 924     st-&gt;cr(); st-&gt;print("\t");
 925   }
 926 
 927   int framesize = C-&gt;frame_size_in_bytes();
 928   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 929   // Remove word for return adr already pushed
 930   // and RBP
 931   framesize -= 2*wordSize;
 932 
 933   if (framesize) {
 934     st-&gt;print_cr("addq    rsp, %d\t# Destroy frame", framesize);
 935     st-&gt;print("\t");
 936   }
 937 
 938   st-&gt;print_cr("popq   rbp");
 939   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 940     st-&gt;print("\t");
 941     if (Assembler::is_polling_page_far()) {
 942       st-&gt;print_cr("movq   rscratch1, #polling_page_address\n\t"
 943                    "testl  rax, [rscratch1]\t"
 944                    "# Safepoint: poll for GC");
 945     } else {
 946       st-&gt;print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
 947                    "# Safepoint: poll for GC");
 948     }
 949   }
 950 }
 951 #endif
 952 
 953 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 954 {
 955   Compile* C = ra_-&gt;C;
 956   if (C-&gt;max_vector_size() &gt; 16) {
 957     // Clear upper bits of YMM registers when current compiled code uses
 958     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 959     MacroAssembler _masm(&amp;cbuf);
 960     __ vzeroupper();
 961   }
 962 
 963   int framesize = C-&gt;frame_size_in_bytes();
 964   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 965   // Remove word for return adr already pushed
 966   // and RBP
 967   framesize -= 2*wordSize;
 968 
 969   // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here
 970 
 971   if (framesize) {
 972     emit_opcode(cbuf, Assembler::REX_W);
 973     if (framesize &lt; 0x80) {
 974       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
 975       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 976       emit_d8(cbuf, framesize);
 977     } else {
 978       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
 979       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 980       emit_d32(cbuf, framesize);
 981     }
 982   }
 983 
 984   // popq rbp
 985   emit_opcode(cbuf, 0x58 | RBP_enc);
 986 
 987   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 988     MacroAssembler _masm(&amp;cbuf);
 989     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 990     if (Assembler::is_polling_page_far()) {
 991       __ lea(rscratch1, polling_page);
 992       __ relocate(relocInfo::poll_return_type);
 993       __ testl(rax, Address(rscratch1, 0));
 994     } else {
 995       __ testl(rax, polling_page);
 996     }
 997   }
 998 }
 999 
1000 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
1001 {
1002   return MachNode::size(ra_); // too many variables; just compute it
1003                               // the hard way
1004 }
1005 
1006 int MachEpilogNode::reloc() const
1007 {
1008   return 2; // a large enough number
1009 }
1010 
1011 const Pipeline* MachEpilogNode::pipeline() const
1012 {
1013   return MachNode::pipeline_class();
1014 }
1015 
1016 int MachEpilogNode::safepoint_offset() const
1017 {
1018   return 0;
1019 }
1020 
1021 //=============================================================================
1022 
1023 enum RC {
1024   rc_bad,
1025   rc_int,
1026   rc_float,
1027   rc_stack
1028 };
1029 
1030 static enum RC rc_class(OptoReg::Name reg)
1031 {
1032   if( !OptoReg::is_valid(reg)  ) return rc_bad;
1033 
1034   if (OptoReg::is_stack(reg)) return rc_stack;
1035 
1036   VMReg r = OptoReg::as_VMReg(reg);
1037 
1038   if (r-&gt;is_Register()) return rc_int;
1039 
1040   assert(r-&gt;is_XMMRegister(), "must be");
1041   return rc_float;
1042 }
1043 
1044 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
1045 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
1046                           int src_hi, int dst_hi, uint ireg, outputStream* st);
1047 
1048 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
1049                             int stack_offset, int reg, uint ireg, outputStream* st);
1050 
1051 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
1052                                       int dst_offset, uint ireg, outputStream* st) {
1053   if (cbuf) {
1054     MacroAssembler _masm(cbuf);
1055     switch (ireg) {
1056     case Op_VecS:
1057       __ movq(Address(rsp, -8), rax);
1058       __ movl(rax, Address(rsp, src_offset));
1059       __ movl(Address(rsp, dst_offset), rax);
1060       __ movq(rax, Address(rsp, -8));
1061       break;
1062     case Op_VecD:
1063       __ pushq(Address(rsp, src_offset));
1064       __ popq (Address(rsp, dst_offset));
1065       break;
1066     case Op_VecX:
1067       __ pushq(Address(rsp, src_offset));
1068       __ popq (Address(rsp, dst_offset));
1069       __ pushq(Address(rsp, src_offset+8));
1070       __ popq (Address(rsp, dst_offset+8));
1071       break;
1072     case Op_VecY:
1073       __ vmovdqu(Address(rsp, -32), xmm0);
1074       __ vmovdqu(xmm0, Address(rsp, src_offset));
1075       __ vmovdqu(Address(rsp, dst_offset), xmm0);
1076       __ vmovdqu(xmm0, Address(rsp, -32));
1077     case Op_VecZ:
1078       __ evmovdqul(Address(rsp, -64), xmm0, 2);
1079       __ evmovdqul(xmm0, Address(rsp, src_offset), 2);
1080       __ evmovdqul(Address(rsp, dst_offset), xmm0, 2);
1081       __ evmovdqul(xmm0, Address(rsp, -64), 2);
1082       break;
1083     default:
1084       ShouldNotReachHere();
1085     }
1086 #ifndef PRODUCT
1087   } else {
1088     switch (ireg) {
1089     case Op_VecS:
1090       st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1091                 "movl    rax, [rsp + #%d]\n\t"
1092                 "movl    [rsp + #%d], rax\n\t"
1093                 "movq    rax, [rsp - #8]",
1094                 src_offset, dst_offset);
1095       break;
1096     case Op_VecD:
1097       st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1098                 "popq    [rsp + #%d]",
1099                 src_offset, dst_offset);
1100       break;
1101      case Op_VecX:
1102       st-&gt;print("pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t"
1103                 "popq    [rsp + #%d]\n\t"
1104                 "pushq   [rsp + #%d]\n\t"
1105                 "popq    [rsp + #%d]",
1106                 src_offset, dst_offset, src_offset+8, dst_offset+8);
1107       break;
1108     case Op_VecY:
1109       st-&gt;print("vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t"
1110                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1111                 "vmovdqu [rsp + #%d], xmm0\n\t"
1112                 "vmovdqu xmm0, [rsp - #32]",
1113                 src_offset, dst_offset);
1114       break;
1115     case Op_VecZ:
1116       st-&gt;print("vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t"
1117                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1118                 "vmovdqu [rsp + #%d], xmm0\n\t"
1119                 "vmovdqu xmm0, [rsp - #64]",
1120                 src_offset, dst_offset);
1121       break;
1122     default:
1123       ShouldNotReachHere();
1124     }
1125 #endif
1126   }
1127 }
1128 
1129 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
1130                                        PhaseRegAlloc* ra_,
1131                                        bool do_size,
1132                                        outputStream* st) const {
1133   assert(cbuf != NULL || st  != NULL, "sanity");
1134   // Get registers to move
1135   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
1136   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
1137   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
1138   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
1139 
1140   enum RC src_second_rc = rc_class(src_second);
1141   enum RC src_first_rc = rc_class(src_first);
1142   enum RC dst_second_rc = rc_class(dst_second);
1143   enum RC dst_first_rc = rc_class(dst_first);
1144 
1145   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
1146          "must move at least 1 register" );
1147 
1148   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
1149     // Self copy, no move
1150     return 0;
1151   }
1152   if (bottom_type()-&gt;isa_vect() != NULL) {
1153     uint ireg = ideal_reg();
1154     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), "sanity");
1155     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), "sanity");
1156     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
1157       // mem -&gt; mem
1158       int src_offset = ra_-&gt;reg2offset(src_first);
1159       int dst_offset = ra_-&gt;reg2offset(dst_first);
1160       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
1161     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
1162       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
1163     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
1164       int stack_offset = ra_-&gt;reg2offset(dst_first);
1165       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
1166     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
1167       int stack_offset = ra_-&gt;reg2offset(src_first);
1168       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
1169     } else {
1170       ShouldNotReachHere();
1171     }
1172     return 0;
1173   }
1174   if (src_first_rc == rc_stack) {
1175     // mem -&gt;
1176     if (dst_first_rc == rc_stack) {
1177       // mem -&gt; mem
1178       assert(src_second != dst_first, "overlap");
1179       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1180           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1181         // 64-bit
1182         int src_offset = ra_-&gt;reg2offset(src_first);
1183         int dst_offset = ra_-&gt;reg2offset(dst_first);
1184         if (cbuf) {
1185           MacroAssembler _masm(cbuf);
1186           __ pushq(Address(rsp, src_offset));
1187           __ popq (Address(rsp, dst_offset));
1188 #ifndef PRODUCT
1189         } else {
1190           st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1191                     "popq    [rsp + #%d]",
1192                      src_offset, dst_offset);
1193 #endif
1194         }
1195       } else {
1196         // 32-bit
1197         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1198         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1199         // No pushl/popl, so:
1200         int src_offset = ra_-&gt;reg2offset(src_first);
1201         int dst_offset = ra_-&gt;reg2offset(dst_first);
1202         if (cbuf) {
1203           MacroAssembler _masm(cbuf);
1204           __ movq(Address(rsp, -8), rax);
1205           __ movl(rax, Address(rsp, src_offset));
1206           __ movl(Address(rsp, dst_offset), rax);
1207           __ movq(rax, Address(rsp, -8));
1208 #ifndef PRODUCT
1209         } else {
1210           st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1211                     "movl    rax, [rsp + #%d]\n\t"
1212                     "movl    [rsp + #%d], rax\n\t"
1213                     "movq    rax, [rsp - #8]",
1214                      src_offset, dst_offset);
1215 #endif
1216         }
1217       }
1218       return 0;
1219     } else if (dst_first_rc == rc_int) {
1220       // mem -&gt; gpr
1221       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1222           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1223         // 64-bit
1224         int offset = ra_-&gt;reg2offset(src_first);
1225         if (cbuf) {
1226           MacroAssembler _masm(cbuf);
1227           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1228 #ifndef PRODUCT
1229         } else {
1230           st-&gt;print("movq    %s, [rsp + #%d]\t# spill",
1231                      Matcher::regName[dst_first],
1232                      offset);
1233 #endif
1234         }
1235       } else {
1236         // 32-bit
1237         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1238         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1239         int offset = ra_-&gt;reg2offset(src_first);
1240         if (cbuf) {
1241           MacroAssembler _masm(cbuf);
1242           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1243 #ifndef PRODUCT
1244         } else {
1245           st-&gt;print("movl    %s, [rsp + #%d]\t# spill",
1246                      Matcher::regName[dst_first],
1247                      offset);
1248 #endif
1249         }
1250       }
1251       return 0;
1252     } else if (dst_first_rc == rc_float) {
1253       // mem-&gt; xmm
1254       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1255           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1256         // 64-bit
1257         int offset = ra_-&gt;reg2offset(src_first);
1258         if (cbuf) {
1259           MacroAssembler _masm(cbuf);
1260           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1261 #ifndef PRODUCT
1262         } else {
1263           st-&gt;print("%s  %s, [rsp + #%d]\t# spill",
1264                      UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
1265                      Matcher::regName[dst_first],
1266                      offset);
1267 #endif
1268         }
1269       } else {
1270         // 32-bit
1271         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1272         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1273         int offset = ra_-&gt;reg2offset(src_first);
1274         if (cbuf) {
1275           MacroAssembler _masm(cbuf);
1276           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1277 #ifndef PRODUCT
1278         } else {
1279           st-&gt;print("movss   %s, [rsp + #%d]\t# spill",
1280                      Matcher::regName[dst_first],
1281                      offset);
1282 #endif
1283         }
1284       }
1285       return 0;
1286     }
1287   } else if (src_first_rc == rc_int) {
1288     // gpr -&gt;
1289     if (dst_first_rc == rc_stack) {
1290       // gpr -&gt; mem
1291       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1292           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1293         // 64-bit
1294         int offset = ra_-&gt;reg2offset(dst_first);
1295         if (cbuf) {
1296           MacroAssembler _masm(cbuf);
1297           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1298 #ifndef PRODUCT
1299         } else {
1300           st-&gt;print("movq    [rsp + #%d], %s\t# spill",
1301                      offset,
1302                      Matcher::regName[src_first]);
1303 #endif
1304         }
1305       } else {
1306         // 32-bit
1307         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1308         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1309         int offset = ra_-&gt;reg2offset(dst_first);
1310         if (cbuf) {
1311           MacroAssembler _masm(cbuf);
1312           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1313 #ifndef PRODUCT
1314         } else {
1315           st-&gt;print("movl    [rsp + #%d], %s\t# spill",
1316                      offset,
1317                      Matcher::regName[src_first]);
1318 #endif
1319         }
1320       }
1321       return 0;
1322     } else if (dst_first_rc == rc_int) {
1323       // gpr -&gt; gpr
1324       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1325           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1326         // 64-bit
1327         if (cbuf) {
1328           MacroAssembler _masm(cbuf);
1329           __ movq(as_Register(Matcher::_regEncode[dst_first]),
1330                   as_Register(Matcher::_regEncode[src_first]));
1331 #ifndef PRODUCT
1332         } else {
1333           st-&gt;print("movq    %s, %s\t# spill",
1334                      Matcher::regName[dst_first],
1335                      Matcher::regName[src_first]);
1336 #endif
1337         }
1338         return 0;
1339       } else {
1340         // 32-bit
1341         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1342         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1343         if (cbuf) {
1344           MacroAssembler _masm(cbuf);
1345           __ movl(as_Register(Matcher::_regEncode[dst_first]),
1346                   as_Register(Matcher::_regEncode[src_first]));
1347 #ifndef PRODUCT
1348         } else {
1349           st-&gt;print("movl    %s, %s\t# spill",
1350                      Matcher::regName[dst_first],
1351                      Matcher::regName[src_first]);
1352 #endif
1353         }
1354         return 0;
1355       }
1356     } else if (dst_first_rc == rc_float) {
1357       // gpr -&gt; xmm
1358       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1359           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1360         // 64-bit
1361         if (cbuf) {
1362           MacroAssembler _masm(cbuf);
1363           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1364 #ifndef PRODUCT
1365         } else {
1366           st-&gt;print("movdq   %s, %s\t# spill",
1367                      Matcher::regName[dst_first],
1368                      Matcher::regName[src_first]);
1369 #endif
1370         }
1371       } else {
1372         // 32-bit
1373         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1374         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1375         if (cbuf) {
1376           MacroAssembler _masm(cbuf);
1377           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1378 #ifndef PRODUCT
1379         } else {
1380           st-&gt;print("movdl   %s, %s\t# spill",
1381                      Matcher::regName[dst_first],
1382                      Matcher::regName[src_first]);
1383 #endif
1384         }
1385       }
1386       return 0;
1387     }
1388   } else if (src_first_rc == rc_float) {
1389     // xmm -&gt;
1390     if (dst_first_rc == rc_stack) {
1391       // xmm -&gt; mem
1392       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1393           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1394         // 64-bit
1395         int offset = ra_-&gt;reg2offset(dst_first);
1396         if (cbuf) {
1397           MacroAssembler _masm(cbuf);
1398           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1399 #ifndef PRODUCT
1400         } else {
1401           st-&gt;print("movsd   [rsp + #%d], %s\t# spill",
1402                      offset,
1403                      Matcher::regName[src_first]);
1404 #endif
1405         }
1406       } else {
1407         // 32-bit
1408         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1409         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1410         int offset = ra_-&gt;reg2offset(dst_first);
1411         if (cbuf) {
1412           MacroAssembler _masm(cbuf);
1413           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1414 #ifndef PRODUCT
1415         } else {
1416           st-&gt;print("movss   [rsp + #%d], %s\t# spill",
1417                      offset,
1418                      Matcher::regName[src_first]);
1419 #endif
1420         }
1421       }
1422       return 0;
1423     } else if (dst_first_rc == rc_int) {
1424       // xmm -&gt; gpr
1425       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1426           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1427         // 64-bit
1428         if (cbuf) {
1429           MacroAssembler _masm(cbuf);
1430           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1431 #ifndef PRODUCT
1432         } else {
1433           st-&gt;print("movdq   %s, %s\t# spill",
1434                      Matcher::regName[dst_first],
1435                      Matcher::regName[src_first]);
1436 #endif
1437         }
1438       } else {
1439         // 32-bit
1440         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1441         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1442         if (cbuf) {
1443           MacroAssembler _masm(cbuf);
1444           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1445 #ifndef PRODUCT
1446         } else {
1447           st-&gt;print("movdl   %s, %s\t# spill",
1448                      Matcher::regName[dst_first],
1449                      Matcher::regName[src_first]);
1450 #endif
1451         }
1452       }
1453       return 0;
1454     } else if (dst_first_rc == rc_float) {
1455       // xmm -&gt; xmm
1456       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1457           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1458         // 64-bit
1459         if (cbuf) {
1460           MacroAssembler _masm(cbuf);
1461           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1462 #ifndef PRODUCT
1463         } else {
1464           st-&gt;print("%s  %s, %s\t# spill",
1465                      UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
1466                      Matcher::regName[dst_first],
1467                      Matcher::regName[src_first]);
1468 #endif
1469         }
1470       } else {
1471         // 32-bit
1472         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1473         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1474         if (cbuf) {
1475           MacroAssembler _masm(cbuf);
1476           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1477 #ifndef PRODUCT
1478         } else {
1479           st-&gt;print("%s  %s, %s\t# spill",
1480                      UseXmmRegToRegMoveAll ? "movaps" : "movss ",
1481                      Matcher::regName[dst_first],
1482                      Matcher::regName[src_first]);
1483 #endif
1484         }
1485       }
1486       return 0;
1487     }
1488   }
1489 
1490   assert(0," foo ");
1491   Unimplemented();
1492   return 0;
1493 }
1494 
1495 #ifndef PRODUCT
1496 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
1497   implementation(NULL, ra_, false, st);
1498 }
1499 #endif
1500 
1501 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1502   implementation(&amp;cbuf, ra_, false, NULL);
1503 }
1504 
1505 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1506   return MachNode::size(ra_);
1507 }
1508 
1509 //=============================================================================
1510 #ifndef PRODUCT
1511 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1512 {
1513   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1514   int reg = ra_-&gt;get_reg_first(this);
1515   st-&gt;print("leaq    %s, [rsp + #%d]\t# box lock",
1516             Matcher::regName[reg], offset);
1517 }
1518 #endif
1519 
1520 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1521 {
1522   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1523   int reg = ra_-&gt;get_encode(this);
1524   if (offset &gt;= 0x80) {
1525     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1526     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1527     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
1528     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1529     emit_d32(cbuf, offset);
1530   } else {
1531     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1532     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1533     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
1534     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1535     emit_d8(cbuf, offset);
1536   }
1537 }
1538 
1539 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
1540 {
1541   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1542   return (offset &lt; 0x80) ? 5 : 8; // REX
1543 }
1544 
1545 //=============================================================================
1546 #ifndef PRODUCT
1547 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1548 {
1549   if (UseCompressedClassPointers) {
1550     st-&gt;print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
1551     st-&gt;print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
1552     st-&gt;print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
1553   } else {
1554     st-&gt;print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
1555                  "# Inline cache check");
1556   }
1557   st-&gt;print_cr("\tjne     SharedRuntime::_ic_miss_stub");
1558   st-&gt;print_cr("\tnop\t# nops to align entry point");
1559 }
1560 #endif
1561 
1562 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1563 {
1564   MacroAssembler masm(&amp;cbuf);
1565   uint insts_size = cbuf.insts_size();
1566   if (UseCompressedClassPointers) {
1567     masm.load_klass(rscratch1, j_rarg0);
1568     masm.cmpptr(rax, rscratch1);
1569   } else {
1570     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
1571   }
1572 
1573   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1574 
1575   /* WARNING these NOPs are critical so that verified entry point is properly
1576      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
1577   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
1578   if (OptoBreakpoint) {
1579     // Leave space for int3
1580     nops_cnt -= 1;
1581   }
1582   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
1583   if (nops_cnt &gt; 0)
1584     masm.nop(nops_cnt);
1585 }
1586 
1587 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
1588 {
1589   return MachNode::size(ra_); // too many variables; just compute it
1590                               // the hard way
1591 }
1592 
1593 
1594 //=============================================================================
1595 
1596 int Matcher::regnum_to_fpu_offset(int regnum)
1597 {
1598   return regnum - 32; // The FP registers are in the second chunk
1599 }
1600 
1601 // This is UltraSparc specific, true just means we have fast l2f conversion
1602 const bool Matcher::convL2FSupported(void) {
1603   return true;
1604 }
1605 
1606 // Is this branch offset short enough that a short branch can be used?
1607 //
1608 // NOTE: If the platform does not provide any short branch variants, then
1609 //       this method should return false for offset 0.
1610 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
1611   // The passed offset is relative to address of the branch.
1612   // On 86 a branch displacement is calculated relative to address
1613   // of a next instruction.
1614   offset -= br_size;
1615 
1616   // the short version of jmpConUCF2 contains multiple branches,
1617   // making the reach slightly less
1618   if (rule == jmpConUCF2_rule)
1619     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
1620   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
1621 }
1622 
1623 const bool Matcher::isSimpleConstant64(jlong value) {
1624   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
1625   //return value == (int) value;  // Cf. storeImmL and immL32.
1626 
1627   // Probably always true, even if a temp register is required.
1628   return true;
1629 }
1630 
1631 // The ecx parameter to rep stosq for the ClearArray node is in words.
1632 const bool Matcher::init_array_count_is_in_bytes = false;
1633 
1634 // Threshold size for cleararray.
1635 const int Matcher::init_array_short_size = 8 * BytesPerLong;
1636 
1637 // No additional cost for CMOVL.
1638 const int Matcher::long_cmove_cost() { return 0; }
1639 
1640 // No CMOVF/CMOVD with SSE2
1641 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
1642 
1643 // Does the CPU require late expand (see block.cpp for description of late expand)?
1644 const bool Matcher::require_postalloc_expand = false;
1645 
1646 // Should the Matcher clone shifts on addressing modes, expecting them
1647 // to be subsumed into complex addressing expressions or compute them
1648 // into registers?  True for Intel but false for most RISCs
1649 const bool Matcher::clone_shift_expressions = true;
1650 
1651 // Do we need to mask the count passed to shift instructions or does
1652 // the cpu only look at the lower 5/6 bits anyway?
1653 const bool Matcher::need_masked_shift_count = false;
1654 
1655 bool Matcher::narrow_oop_use_complex_address() {
1656   assert(UseCompressedOops, "only for compressed oops code");
1657   return (LogMinObjAlignmentInBytes &lt;= 3);
1658 }
1659 
1660 bool Matcher::narrow_klass_use_complex_address() {
1661   assert(UseCompressedClassPointers, "only for compressed klass code");
1662   return (LogKlassAlignmentInBytes &lt;= 3);
1663 }
1664 
1665 // Is it better to copy float constants, or load them directly from
1666 // memory?  Intel can load a float constant from a direct address,
1667 // requiring no extra registers.  Most RISCs will have to materialize
1668 // an address into a register first, so they would do better to copy
1669 // the constant from stack.
1670 const bool Matcher::rematerialize_float_constants = true; // XXX
1671 
1672 // If CPU can load and store mis-aligned doubles directly then no
1673 // fixup is needed.  Else we split the double into 2 integer pieces
1674 // and move it piece-by-piece.  Only happens when passing doubles into
1675 // C code as the Java calling convention forces doubles to be aligned.
1676 const bool Matcher::misaligned_doubles_ok = true;
1677 
1678 // No-op on amd64
1679 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
1680 
1681 // Advertise here if the CPU requires explicit rounding operations to
1682 // implement the UseStrictFP mode.
1683 const bool Matcher::strict_fp_requires_explicit_rounding = true;
1684 
1685 // Are floats conerted to double when stored to stack during deoptimization?
1686 // On x64 it is stored without convertion so we can use normal access.
1687 bool Matcher::float_in_double() { return false; }
1688 
1689 // Do ints take an entire long register or just half?
1690 const bool Matcher::int_in_long = true;
1691 
1692 // Return whether or not this register is ever used as an argument.
1693 // This function is used on startup to build the trampoline stubs in
1694 // generateOptoStub.  Registers not mentioned will be killed by the VM
1695 // call in the trampoline, and arguments in those registers not be
1696 // available to the callee.
1697 bool Matcher::can_be_java_arg(int reg)
1698 {
1699   return
1700     reg ==  RDI_num || reg == RDI_H_num ||
1701     reg ==  RSI_num || reg == RSI_H_num ||
1702     reg ==  RDX_num || reg == RDX_H_num ||
1703     reg ==  RCX_num || reg == RCX_H_num ||
1704     reg ==   R8_num || reg ==  R8_H_num ||
1705     reg ==   R9_num || reg ==  R9_H_num ||
1706     reg ==  R12_num || reg == R12_H_num ||
1707     reg == XMM0_num || reg == XMM0b_num ||
1708     reg == XMM1_num || reg == XMM1b_num ||
1709     reg == XMM2_num || reg == XMM2b_num ||
1710     reg == XMM3_num || reg == XMM3b_num ||
1711     reg == XMM4_num || reg == XMM4b_num ||
1712     reg == XMM5_num || reg == XMM5b_num ||
1713     reg == XMM6_num || reg == XMM6b_num ||
1714     reg == XMM7_num || reg == XMM7b_num;
1715 }
1716 
1717 bool Matcher::is_spillable_arg(int reg)
1718 {
1719   return can_be_java_arg(reg);
1720 }
1721 
1722 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
1723   // In 64 bit mode a code which use multiply when
1724   // devisor is constant is faster than hardware
1725   // DIV instruction (it uses MulHiL).
1726   return false;
1727 }
1728 
1729 // Register for DIVI projection of divmodI
1730 RegMask Matcher::divI_proj_mask() {
1731   return INT_RAX_REG_mask();
1732 }
1733 
1734 // Register for MODI projection of divmodI
1735 RegMask Matcher::modI_proj_mask() {
1736   return INT_RDX_REG_mask();
1737 }
1738 
1739 // Register for DIVL projection of divmodL
1740 RegMask Matcher::divL_proj_mask() {
1741   return LONG_RAX_REG_mask();
1742 }
1743 
1744 // Register for MODL projection of divmodL
1745 RegMask Matcher::modL_proj_mask() {
1746   return LONG_RDX_REG_mask();
1747 }
1748 
1749 // Register for saving SP into on method handle invokes. Not used on x86_64.
1750 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
1751     return NO_REG_mask();
1752 }
1753 
1754 %}
1755 
1756 //----------ENCODING BLOCK-----------------------------------------------------
1757 // This block specifies the encoding classes used by the compiler to
1758 // output byte streams.  Encoding classes are parameterized macros
1759 // used by Machine Instruction Nodes in order to generate the bit
1760 // encoding of the instruction.  Operands specify their base encoding
1761 // interface with the interface keyword.  There are currently
1762 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
1763 // COND_INTER.  REG_INTER causes an operand to generate a function
1764 // which returns its register number when queried.  CONST_INTER causes
1765 // an operand to generate a function which returns the value of the
1766 // constant when queried.  MEMORY_INTER causes an operand to generate
1767 // four functions which return the Base Register, the Index Register,
1768 // the Scale Value, and the Offset Value of the operand when queried.
1769 // COND_INTER causes an operand to generate six functions which return
1770 // the encoding code (ie - encoding bits for the instruction)
1771 // associated with each basic boolean condition for a conditional
1772 // instruction.
1773 //
1774 // Instructions specify two basic values for encoding.  Again, a
1775 // function is available to check if the constant displacement is an
1776 // oop. They use the ins_encode keyword to specify their encoding
1777 // classes (which must be a sequence of enc_class names, and their
1778 // parameters, specified in the encoding block), and they use the
1779 // opcode keyword to specify, in order, their primary, secondary, and
1780 // tertiary opcode.  Only the opcode sections which a particular
1781 // instruction needs for encoding need to be specified.
1782 encode %{
1783   // Build emit functions for each basic byte or larger field in the
1784   // intel encoding scheme (opcode, rm, sib, immediate), and call them
1785   // from C++ code in the enc_class source block.  Emit functions will
1786   // live in the main source block for now.  In future, we can
1787   // generalize this by adding a syntax that specifies the sizes of
1788   // fields in an order, so that the adlc can build the emit functions
1789   // automagically
1790 
1791   // Emit primary opcode
1792   enc_class OpcP
1793   %{
1794     emit_opcode(cbuf, $primary);
1795   %}
1796 
1797   // Emit secondary opcode
1798   enc_class OpcS
1799   %{
1800     emit_opcode(cbuf, $secondary);
1801   %}
1802 
1803   // Emit tertiary opcode
1804   enc_class OpcT
1805   %{
1806     emit_opcode(cbuf, $tertiary);
1807   %}
1808 
1809   // Emit opcode directly
1810   enc_class Opcode(immI d8)
1811   %{
1812     emit_opcode(cbuf, $d8$$constant);
1813   %}
1814 
1815   // Emit size prefix
1816   enc_class SizePrefix
1817   %{
1818     emit_opcode(cbuf, 0x66);
1819   %}
1820 
1821   enc_class reg(rRegI reg)
1822   %{
1823     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
1824   %}
1825 
1826   enc_class reg_reg(rRegI dst, rRegI src)
1827   %{
1828     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1829   %}
1830 
1831   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
1832   %{
1833     emit_opcode(cbuf, $opcode$$constant);
1834     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1835   %}
1836 
1837   enc_class cdql_enc(no_rax_rdx_RegI div)
1838   %{
1839     // Full implementation of Java idiv and irem; checks for
1840     // special case as described in JVM spec., p.243 &amp; p.271.
1841     //
1842     //         normal case                           special case
1843     //
1844     // input : rax: dividend                         min_int
1845     //         reg: divisor                          -1
1846     //
1847     // output: rax: quotient  (= rax idiv reg)       min_int
1848     //         rdx: remainder (= rax irem reg)       0
1849     //
1850     //  Code sequnce:
1851     //
1852     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
1853     //    5:   75 07/08                jne    e &lt;normal&gt;
1854     //    7:   33 d2                   xor    %edx,%edx
1855     //  [div &gt;= 8 -&gt; offset + 1]
1856     //  [REX_B]
1857     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
1858     //    c:   74 03/04                je     11 &lt;done&gt;
1859     // 000000000000000e &lt;normal&gt;:
1860     //    e:   99                      cltd
1861     //  [div &gt;= 8 -&gt; offset + 1]
1862     //  [REX_B]
1863     //    f:   f7 f9                   idiv   $div
1864     // 0000000000000011 &lt;done&gt;:
1865 
1866     // cmp    $0x80000000,%eax
1867     emit_opcode(cbuf, 0x3d);
1868     emit_d8(cbuf, 0x00);
1869     emit_d8(cbuf, 0x00);
1870     emit_d8(cbuf, 0x00);
1871     emit_d8(cbuf, 0x80);
1872 
1873     // jne    e &lt;normal&gt;
1874     emit_opcode(cbuf, 0x75);
1875     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
1876 
1877     // xor    %edx,%edx
1878     emit_opcode(cbuf, 0x33);
1879     emit_d8(cbuf, 0xD2);
1880 
1881     // cmp    $0xffffffffffffffff,%ecx
1882     if ($div$$reg &gt;= 8) {
1883       emit_opcode(cbuf, Assembler::REX_B);
1884     }
1885     emit_opcode(cbuf, 0x83);
1886     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1887     emit_d8(cbuf, 0xFF);
1888 
1889     // je     11 &lt;done&gt;
1890     emit_opcode(cbuf, 0x74);
1891     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
1892 
1893     // &lt;normal&gt;
1894     // cltd
1895     emit_opcode(cbuf, 0x99);
1896 
1897     // idivl (note: must be emitted by the user of this rule)
1898     // &lt;done&gt;
1899   %}
1900 
1901   enc_class cdqq_enc(no_rax_rdx_RegL div)
1902   %{
1903     // Full implementation of Java ldiv and lrem; checks for
1904     // special case as described in JVM spec., p.243 &amp; p.271.
1905     //
1906     //         normal case                           special case
1907     //
1908     // input : rax: dividend                         min_long
1909     //         reg: divisor                          -1
1910     //
1911     // output: rax: quotient  (= rax idiv reg)       min_long
1912     //         rdx: remainder (= rax irem reg)       0
1913     //
1914     //  Code sequnce:
1915     //
1916     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
1917     //    7:   00 00 80
1918     //    a:   48 39 d0                cmp    %rdx,%rax
1919     //    d:   75 08                   jne    17 &lt;normal&gt;
1920     //    f:   33 d2                   xor    %edx,%edx
1921     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
1922     //   15:   74 05                   je     1c &lt;done&gt;
1923     // 0000000000000017 &lt;normal&gt;:
1924     //   17:   48 99                   cqto
1925     //   19:   48 f7 f9                idiv   $div
1926     // 000000000000001c &lt;done&gt;:
1927 
1928     // mov    $0x8000000000000000,%rdx
1929     emit_opcode(cbuf, Assembler::REX_W);
1930     emit_opcode(cbuf, 0xBA);
1931     emit_d8(cbuf, 0x00);
1932     emit_d8(cbuf, 0x00);
1933     emit_d8(cbuf, 0x00);
1934     emit_d8(cbuf, 0x00);
1935     emit_d8(cbuf, 0x00);
1936     emit_d8(cbuf, 0x00);
1937     emit_d8(cbuf, 0x00);
1938     emit_d8(cbuf, 0x80);
1939 
1940     // cmp    %rdx,%rax
1941     emit_opcode(cbuf, Assembler::REX_W);
1942     emit_opcode(cbuf, 0x39);
1943     emit_d8(cbuf, 0xD0);
1944 
1945     // jne    17 &lt;normal&gt;
1946     emit_opcode(cbuf, 0x75);
1947     emit_d8(cbuf, 0x08);
1948 
1949     // xor    %edx,%edx
1950     emit_opcode(cbuf, 0x33);
1951     emit_d8(cbuf, 0xD2);
1952 
1953     // cmp    $0xffffffffffffffff,$div
1954     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
1955     emit_opcode(cbuf, 0x83);
1956     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1957     emit_d8(cbuf, 0xFF);
1958 
1959     // je     1e &lt;done&gt;
1960     emit_opcode(cbuf, 0x74);
1961     emit_d8(cbuf, 0x05);
1962 
1963     // &lt;normal&gt;
1964     // cqto
1965     emit_opcode(cbuf, Assembler::REX_W);
1966     emit_opcode(cbuf, 0x99);
1967 
1968     // idivq (note: must be emitted by the user of this rule)
1969     // &lt;done&gt;
1970   %}
1971 
1972   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
1973   enc_class OpcSE(immI imm)
1974   %{
1975     // Emit primary opcode and set sign-extend bit
1976     // Check for 8-bit immediate, and set sign extend bit in opcode
1977     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1978       emit_opcode(cbuf, $primary | 0x02);
1979     } else {
1980       // 32-bit immediate
1981       emit_opcode(cbuf, $primary);
1982     }
1983   %}
1984 
1985   enc_class OpcSErm(rRegI dst, immI imm)
1986   %{
1987     // OpcSEr/m
1988     int dstenc = $dst$$reg;
1989     if (dstenc &gt;= 8) {
1990       emit_opcode(cbuf, Assembler::REX_B);
1991       dstenc -= 8;
1992     }
1993     // Emit primary opcode and set sign-extend bit
1994     // Check for 8-bit immediate, and set sign extend bit in opcode
1995     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1996       emit_opcode(cbuf, $primary | 0x02);
1997     } else {
1998       // 32-bit immediate
1999       emit_opcode(cbuf, $primary);
2000     }
2001     // Emit r/m byte with secondary opcode, after primary opcode.
2002     emit_rm(cbuf, 0x3, $secondary, dstenc);
2003   %}
2004 
2005   enc_class OpcSErm_wide(rRegL dst, immI imm)
2006   %{
2007     // OpcSEr/m
2008     int dstenc = $dst$$reg;
2009     if (dstenc &lt; 8) {
2010       emit_opcode(cbuf, Assembler::REX_W);
2011     } else {
2012       emit_opcode(cbuf, Assembler::REX_WB);
2013       dstenc -= 8;
2014     }
2015     // Emit primary opcode and set sign-extend bit
2016     // Check for 8-bit immediate, and set sign extend bit in opcode
2017     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2018       emit_opcode(cbuf, $primary | 0x02);
2019     } else {
2020       // 32-bit immediate
2021       emit_opcode(cbuf, $primary);
2022     }
2023     // Emit r/m byte with secondary opcode, after primary opcode.
2024     emit_rm(cbuf, 0x3, $secondary, dstenc);
2025   %}
2026 
2027   enc_class Con8or32(immI imm)
2028   %{
2029     // Check for 8-bit immediate, and set sign extend bit in opcode
2030     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2031       $$$emit8$imm$$constant;
2032     } else {
2033       // 32-bit immediate
2034       $$$emit32$imm$$constant;
2035     }
2036   %}
2037 
2038   enc_class opc2_reg(rRegI dst)
2039   %{
2040     // BSWAP
2041     emit_cc(cbuf, $secondary, $dst$$reg);
2042   %}
2043 
2044   enc_class opc3_reg(rRegI dst)
2045   %{
2046     // BSWAP
2047     emit_cc(cbuf, $tertiary, $dst$$reg);
2048   %}
2049 
2050   enc_class reg_opc(rRegI div)
2051   %{
2052     // INC, DEC, IDIV, IMOD, JMP indirect, ...
2053     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
2054   %}
2055 
2056   enc_class enc_cmov(cmpOp cop)
2057   %{
2058     // CMOV
2059     $$$emit8$primary;
2060     emit_cc(cbuf, $secondary, $cop$$cmpcode);
2061   %}
2062 
2063   enc_class enc_PartialSubtypeCheck()
2064   %{
2065     Register Rrdi = as_Register(RDI_enc); // result register
2066     Register Rrax = as_Register(RAX_enc); // super class
2067     Register Rrcx = as_Register(RCX_enc); // killed
2068     Register Rrsi = as_Register(RSI_enc); // sub class
2069     Label miss;
2070     const bool set_cond_codes = true;
2071 
2072     MacroAssembler _masm(&amp;cbuf);
2073     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
2074                                      NULL, &amp;miss,
2075                                      /*set_cond_codes:*/ true);
2076     if ($primary) {
2077       __ xorptr(Rrdi, Rrdi);
2078     }
2079     __ bind(miss);
2080   %}
2081 
2082   enc_class clear_avx %{
2083     debug_only(int off0 = cbuf.insts_size());
2084     if (ra_-&gt;C-&gt;max_vector_size() &gt; 16) {
2085       // Clear upper bits of YMM registers when current compiled code uses
2086       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
2087       MacroAssembler _masm(&amp;cbuf);
2088       __ vzeroupper();
2089     }
2090     debug_only(int off1 = cbuf.insts_size());
2091     assert(off1 - off0 == clear_avx_size(), "correct size prediction");
2092   %}
2093 
2094   enc_class Java_To_Runtime(method meth) %{
2095     // No relocation needed
2096     MacroAssembler _masm(&amp;cbuf);
2097     __ mov64(r10, (int64_t) $meth$$method);
2098     __ call(r10);
2099   %}
2100 
2101   enc_class Java_To_Interpreter(method meth)
2102   %{
2103     // CALL Java_To_Interpreter
2104     // This is the instruction starting address for relocation info.
2105     cbuf.set_insts_mark();
2106     $$$emit8$primary;
2107     // CALL directly to the runtime
2108     emit_d32_reloc(cbuf,
2109                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2110                    runtime_call_Relocation::spec(),
2111                    RELOC_DISP32);
2112   %}
2113 
2114   enc_class Java_Static_Call(method meth)
2115   %{
2116     // JAVA STATIC CALL
2117     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
2118     // determine who we intended to call.
2119     cbuf.set_insts_mark();
2120     $$$emit8$primary;
2121 
2122     if (!_method) {
2123       emit_d32_reloc(cbuf,
2124                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2125                      runtime_call_Relocation::spec(),
2126                      RELOC_DISP32);
2127     } else if (_optimized_virtual) {
2128       emit_d32_reloc(cbuf,
2129                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2130                      opt_virtual_call_Relocation::spec(),
2131                      RELOC_DISP32);
2132     } else {
2133       emit_d32_reloc(cbuf,
2134                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2135                      static_call_Relocation::spec(),
2136                      RELOC_DISP32);
2137     }
2138     if (_method) {
2139       // Emit stub for static call.
2140       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
2141       if (stub == NULL) {
2142         ciEnv::current()-&gt;record_failure("CodeCache is full");
2143         return;
2144       } 
2145     }
2146   %}
2147 
2148   enc_class Java_Dynamic_Call(method meth) %{
2149     MacroAssembler _masm(&amp;cbuf);
2150     __ ic_call((address)$meth$$method);
2151   %}
2152 
2153   enc_class Java_Compiled_Call(method meth)
2154   %{
2155     // JAVA COMPILED CALL
2156     int disp = in_bytes(Method:: from_compiled_offset());
2157 
2158     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
2159     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, "compiled_code_offset isn't small");
2160 
2161     // callq *disp(%rax)
2162     cbuf.set_insts_mark();
2163     $$$emit8$primary;
2164     if (disp &lt; 0x80) {
2165       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
2166       emit_d8(cbuf, disp); // Displacement
2167     } else {
2168       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
2169       emit_d32(cbuf, disp); // Displacement
2170     }
2171   %}
2172 
2173   enc_class reg_opc_imm(rRegI dst, immI8 shift)
2174   %{
2175     // SAL, SAR, SHR
2176     int dstenc = $dst$$reg;
2177     if (dstenc &gt;= 8) {
2178       emit_opcode(cbuf, Assembler::REX_B);
2179       dstenc -= 8;
2180     }
2181     $$$emit8$primary;
2182     emit_rm(cbuf, 0x3, $secondary, dstenc);
2183     $$$emit8$shift$$constant;
2184   %}
2185 
2186   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
2187   %{
2188     // SAL, SAR, SHR
2189     int dstenc = $dst$$reg;
2190     if (dstenc &lt; 8) {
2191       emit_opcode(cbuf, Assembler::REX_W);
2192     } else {
2193       emit_opcode(cbuf, Assembler::REX_WB);
2194       dstenc -= 8;
2195     }
2196     $$$emit8$primary;
2197     emit_rm(cbuf, 0x3, $secondary, dstenc);
2198     $$$emit8$shift$$constant;
2199   %}
2200 
2201   enc_class load_immI(rRegI dst, immI src)
2202   %{
2203     int dstenc = $dst$$reg;
2204     if (dstenc &gt;= 8) {
2205       emit_opcode(cbuf, Assembler::REX_B);
2206       dstenc -= 8;
2207     }
2208     emit_opcode(cbuf, 0xB8 | dstenc);
2209     $$$emit32$src$$constant;
2210   %}
2211 
2212   enc_class load_immL(rRegL dst, immL src)
2213   %{
2214     int dstenc = $dst$$reg;
2215     if (dstenc &lt; 8) {
2216       emit_opcode(cbuf, Assembler::REX_W);
2217     } else {
2218       emit_opcode(cbuf, Assembler::REX_WB);
2219       dstenc -= 8;
2220     }
2221     emit_opcode(cbuf, 0xB8 | dstenc);
2222     emit_d64(cbuf, $src$$constant);
2223   %}
2224 
2225   enc_class load_immUL32(rRegL dst, immUL32 src)
2226   %{
2227     // same as load_immI, but this time we care about zeroes in the high word
2228     int dstenc = $dst$$reg;
2229     if (dstenc &gt;= 8) {
2230       emit_opcode(cbuf, Assembler::REX_B);
2231       dstenc -= 8;
2232     }
2233     emit_opcode(cbuf, 0xB8 | dstenc);
2234     $$$emit32$src$$constant;
2235   %}
2236 
2237   enc_class load_immL32(rRegL dst, immL32 src)
2238   %{
2239     int dstenc = $dst$$reg;
2240     if (dstenc &lt; 8) {
2241       emit_opcode(cbuf, Assembler::REX_W);
2242     } else {
2243       emit_opcode(cbuf, Assembler::REX_WB);
2244       dstenc -= 8;
2245     }
2246     emit_opcode(cbuf, 0xC7);
2247     emit_rm(cbuf, 0x03, 0x00, dstenc);
2248     $$$emit32$src$$constant;
2249   %}
2250 
2251   enc_class load_immP31(rRegP dst, immP32 src)
2252   %{
2253     // same as load_immI, but this time we care about zeroes in the high word
2254     int dstenc = $dst$$reg;
2255     if (dstenc &gt;= 8) {
2256       emit_opcode(cbuf, Assembler::REX_B);
2257       dstenc -= 8;
2258     }
2259     emit_opcode(cbuf, 0xB8 | dstenc);
2260     $$$emit32$src$$constant;
2261   %}
2262 
2263   enc_class load_immP(rRegP dst, immP src)
2264   %{
2265     int dstenc = $dst$$reg;
2266     if (dstenc &lt; 8) {
2267       emit_opcode(cbuf, Assembler::REX_W);
2268     } else {
2269       emit_opcode(cbuf, Assembler::REX_WB);
2270       dstenc -= 8;
2271     }
2272     emit_opcode(cbuf, 0xB8 | dstenc);
2273     // This next line should be generated from ADLC
2274     if ($src-&gt;constant_reloc() != relocInfo::none) {
2275       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
2276     } else {
2277       emit_d64(cbuf, $src$$constant);
2278     }
2279   %}
2280 
2281   enc_class Con32(immI src)
2282   %{
2283     // Output immediate
2284     $$$emit32$src$$constant;
2285   %}
2286 
2287   enc_class Con32F_as_bits(immF src)
2288   %{
2289     // Output Float immediate bits
2290     jfloat jf = $src$$constant;
2291     jint jf_as_bits = jint_cast(jf);
2292     emit_d32(cbuf, jf_as_bits);
2293   %}
2294 
2295   enc_class Con16(immI src)
2296   %{
2297     // Output immediate
2298     $$$emit16$src$$constant;
2299   %}
2300 
2301   // How is this different from Con32??? XXX
2302   enc_class Con_d32(immI src)
2303   %{
2304     emit_d32(cbuf,$src$$constant);
2305   %}
2306 
2307   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
2308     // Output immediate memory reference
2309     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
2310     emit_d32(cbuf, 0x00);
2311   %}
2312 
2313   enc_class lock_prefix()
2314   %{
2315     if (os::is_MP()) {
2316       emit_opcode(cbuf, 0xF0); // lock
2317     }
2318   %}
2319 
2320   enc_class REX_mem(memory mem)
2321   %{
2322     if ($mem$$base &gt;= 8) {
2323       if ($mem$$index &lt; 8) {
2324         emit_opcode(cbuf, Assembler::REX_B);
2325       } else {
2326         emit_opcode(cbuf, Assembler::REX_XB);
2327       }
2328     } else {
2329       if ($mem$$index &gt;= 8) {
2330         emit_opcode(cbuf, Assembler::REX_X);
2331       }
2332     }
2333   %}
2334 
2335   enc_class REX_mem_wide(memory mem)
2336   %{
2337     if ($mem$$base &gt;= 8) {
2338       if ($mem$$index &lt; 8) {
2339         emit_opcode(cbuf, Assembler::REX_WB);
2340       } else {
2341         emit_opcode(cbuf, Assembler::REX_WXB);
2342       }
2343     } else {
2344       if ($mem$$index &lt; 8) {
2345         emit_opcode(cbuf, Assembler::REX_W);
2346       } else {
2347         emit_opcode(cbuf, Assembler::REX_WX);
2348       }
2349     }
2350   %}
2351 
2352   // for byte regs
2353   enc_class REX_breg(rRegI reg)
2354   %{
2355     if ($reg$$reg &gt;= 4) {
2356       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2357     }
2358   %}
2359 
2360   // for byte regs
2361   enc_class REX_reg_breg(rRegI dst, rRegI src)
2362   %{
2363     if ($dst$$reg &lt; 8) {
2364       if ($src$$reg &gt;= 4) {
2365         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2366       }
2367     } else {
2368       if ($src$$reg &lt; 8) {
2369         emit_opcode(cbuf, Assembler::REX_R);
2370       } else {
2371         emit_opcode(cbuf, Assembler::REX_RB);
2372       }
2373     }
2374   %}
2375 
2376   // for byte regs
2377   enc_class REX_breg_mem(rRegI reg, memory mem)
2378   %{
2379     if ($reg$$reg &lt; 8) {
2380       if ($mem$$base &lt; 8) {
2381         if ($mem$$index &gt;= 8) {
2382           emit_opcode(cbuf, Assembler::REX_X);
2383         } else if ($reg$$reg &gt;= 4) {
2384           emit_opcode(cbuf, Assembler::REX);
2385         }
2386       } else {
2387         if ($mem$$index &lt; 8) {
2388           emit_opcode(cbuf, Assembler::REX_B);
2389         } else {
2390           emit_opcode(cbuf, Assembler::REX_XB);
2391         }
2392       }
2393     } else {
2394       if ($mem$$base &lt; 8) {
2395         if ($mem$$index &lt; 8) {
2396           emit_opcode(cbuf, Assembler::REX_R);
2397         } else {
2398           emit_opcode(cbuf, Assembler::REX_RX);
2399         }
2400       } else {
2401         if ($mem$$index &lt; 8) {
2402           emit_opcode(cbuf, Assembler::REX_RB);
2403         } else {
2404           emit_opcode(cbuf, Assembler::REX_RXB);
2405         }
2406       }
2407     }
2408   %}
2409 
2410   enc_class REX_reg(rRegI reg)
2411   %{
2412     if ($reg$$reg &gt;= 8) {
2413       emit_opcode(cbuf, Assembler::REX_B);
2414     }
2415   %}
2416 
2417   enc_class REX_reg_wide(rRegI reg)
2418   %{
2419     if ($reg$$reg &lt; 8) {
2420       emit_opcode(cbuf, Assembler::REX_W);
2421     } else {
2422       emit_opcode(cbuf, Assembler::REX_WB);
2423     }
2424   %}
2425 
2426   enc_class REX_reg_reg(rRegI dst, rRegI src)
2427   %{
2428     if ($dst$$reg &lt; 8) {
2429       if ($src$$reg &gt;= 8) {
2430         emit_opcode(cbuf, Assembler::REX_B);
2431       }
2432     } else {
2433       if ($src$$reg &lt; 8) {
2434         emit_opcode(cbuf, Assembler::REX_R);
2435       } else {
2436         emit_opcode(cbuf, Assembler::REX_RB);
2437       }
2438     }
2439   %}
2440 
2441   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
2442   %{
2443     if ($dst$$reg &lt; 8) {
2444       if ($src$$reg &lt; 8) {
2445         emit_opcode(cbuf, Assembler::REX_W);
2446       } else {
2447         emit_opcode(cbuf, Assembler::REX_WB);
2448       }
2449     } else {
2450       if ($src$$reg &lt; 8) {
2451         emit_opcode(cbuf, Assembler::REX_WR);
2452       } else {
2453         emit_opcode(cbuf, Assembler::REX_WRB);
2454       }
2455     }
2456   %}
2457 
2458   enc_class REX_reg_mem(rRegI reg, memory mem)
2459   %{
2460     if ($reg$$reg &lt; 8) {
2461       if ($mem$$base &lt; 8) {
2462         if ($mem$$index &gt;= 8) {
2463           emit_opcode(cbuf, Assembler::REX_X);
2464         }
2465       } else {
2466         if ($mem$$index &lt; 8) {
2467           emit_opcode(cbuf, Assembler::REX_B);
2468         } else {
2469           emit_opcode(cbuf, Assembler::REX_XB);
2470         }
2471       }
2472     } else {
2473       if ($mem$$base &lt; 8) {
2474         if ($mem$$index &lt; 8) {
2475           emit_opcode(cbuf, Assembler::REX_R);
2476         } else {
2477           emit_opcode(cbuf, Assembler::REX_RX);
2478         }
2479       } else {
2480         if ($mem$$index &lt; 8) {
2481           emit_opcode(cbuf, Assembler::REX_RB);
2482         } else {
2483           emit_opcode(cbuf, Assembler::REX_RXB);
2484         }
2485       }
2486     }
2487   %}
2488 
2489   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
2490   %{
2491     if ($reg$$reg &lt; 8) {
2492       if ($mem$$base &lt; 8) {
2493         if ($mem$$index &lt; 8) {
2494           emit_opcode(cbuf, Assembler::REX_W);
2495         } else {
2496           emit_opcode(cbuf, Assembler::REX_WX);
2497         }
2498       } else {
2499         if ($mem$$index &lt; 8) {
2500           emit_opcode(cbuf, Assembler::REX_WB);
2501         } else {
2502           emit_opcode(cbuf, Assembler::REX_WXB);
2503         }
2504       }
2505     } else {
2506       if ($mem$$base &lt; 8) {
2507         if ($mem$$index &lt; 8) {
2508           emit_opcode(cbuf, Assembler::REX_WR);
2509         } else {
2510           emit_opcode(cbuf, Assembler::REX_WRX);
2511         }
2512       } else {
2513         if ($mem$$index &lt; 8) {
2514           emit_opcode(cbuf, Assembler::REX_WRB);
2515         } else {
2516           emit_opcode(cbuf, Assembler::REX_WRXB);
2517         }
2518       }
2519     }
2520   %}
2521 
2522   enc_class reg_mem(rRegI ereg, memory mem)
2523   %{
2524     // High registers handle in encode_RegMem
2525     int reg = $ereg$$reg;
2526     int base = $mem$$base;
2527     int index = $mem$$index;
2528     int scale = $mem$$scale;
2529     int disp = $mem$$disp;
2530     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
2531 
2532     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
2533   %}
2534 
2535   enc_class RM_opc_mem(immI rm_opcode, memory mem)
2536   %{
2537     int rm_byte_opcode = $rm_opcode$$constant;
2538 
2539     // High registers handle in encode_RegMem
2540     int base = $mem$$base;
2541     int index = $mem$$index;
2542     int scale = $mem$$scale;
2543     int displace = $mem$$disp;
2544 
2545     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
2546                                             // working with static
2547                                             // globals
2548     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
2549                   disp_reloc);
2550   %}
2551 
2552   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
2553   %{
2554     int reg_encoding = $dst$$reg;
2555     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
2556     int index        = 0x04;            // 0x04 indicates no index
2557     int scale        = 0x00;            // 0x00 indicates no scale
2558     int displace     = $src1$$constant; // 0x00 indicates no displacement
2559     relocInfo::relocType disp_reloc = relocInfo::none;
2560     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
2561                   disp_reloc);
2562   %}
2563 
2564   enc_class neg_reg(rRegI dst)
2565   %{
2566     int dstenc = $dst$$reg;
2567     if (dstenc &gt;= 8) {
2568       emit_opcode(cbuf, Assembler::REX_B);
2569       dstenc -= 8;
2570     }
2571     // NEG $dst
2572     emit_opcode(cbuf, 0xF7);
2573     emit_rm(cbuf, 0x3, 0x03, dstenc);
2574   %}
2575 
2576   enc_class neg_reg_wide(rRegI dst)
2577   %{
2578     int dstenc = $dst$$reg;
2579     if (dstenc &lt; 8) {
2580       emit_opcode(cbuf, Assembler::REX_W);
2581     } else {
2582       emit_opcode(cbuf, Assembler::REX_WB);
2583       dstenc -= 8;
2584     }
2585     // NEG $dst
2586     emit_opcode(cbuf, 0xF7);
2587     emit_rm(cbuf, 0x3, 0x03, dstenc);
2588   %}
2589 
2590   enc_class setLT_reg(rRegI dst)
2591   %{
2592     int dstenc = $dst$$reg;
2593     if (dstenc &gt;= 8) {
2594       emit_opcode(cbuf, Assembler::REX_B);
2595       dstenc -= 8;
2596     } else if (dstenc &gt;= 4) {
2597       emit_opcode(cbuf, Assembler::REX);
2598     }
2599     // SETLT $dst
2600     emit_opcode(cbuf, 0x0F);
2601     emit_opcode(cbuf, 0x9C);
2602     emit_rm(cbuf, 0x3, 0x0, dstenc);
2603   %}
2604 
2605   enc_class setNZ_reg(rRegI dst)
2606   %{
2607     int dstenc = $dst$$reg;
2608     if (dstenc &gt;= 8) {
2609       emit_opcode(cbuf, Assembler::REX_B);
2610       dstenc -= 8;
2611     } else if (dstenc &gt;= 4) {
2612       emit_opcode(cbuf, Assembler::REX);
2613     }
2614     // SETNZ $dst
2615     emit_opcode(cbuf, 0x0F);
2616     emit_opcode(cbuf, 0x95);
2617     emit_rm(cbuf, 0x3, 0x0, dstenc);
2618   %}
2619 
2620 
2621   // Compare the lonogs and set -1, 0, or 1 into dst
2622   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
2623   %{
2624     int src1enc = $src1$$reg;
2625     int src2enc = $src2$$reg;
2626     int dstenc = $dst$$reg;
2627 
2628     // cmpq $src1, $src2
2629     if (src1enc &lt; 8) {
2630       if (src2enc &lt; 8) {
2631         emit_opcode(cbuf, Assembler::REX_W);
2632       } else {
2633         emit_opcode(cbuf, Assembler::REX_WB);
2634       }
2635     } else {
2636       if (src2enc &lt; 8) {
2637         emit_opcode(cbuf, Assembler::REX_WR);
2638       } else {
2639         emit_opcode(cbuf, Assembler::REX_WRB);
2640       }
2641     }
2642     emit_opcode(cbuf, 0x3B);
2643     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
2644 
2645     // movl $dst, -1
2646     if (dstenc &gt;= 8) {
2647       emit_opcode(cbuf, Assembler::REX_B);
2648     }
2649     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
2650     emit_d32(cbuf, -1);
2651 
2652     // jl,s done
2653     emit_opcode(cbuf, 0x7C);
2654     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
2655 
2656     // setne $dst
2657     if (dstenc &gt;= 4) {
2658       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
2659     }
2660     emit_opcode(cbuf, 0x0F);
2661     emit_opcode(cbuf, 0x95);
2662     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
2663 
2664     // movzbl $dst, $dst
2665     if (dstenc &gt;= 4) {
2666       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
2667     }
2668     emit_opcode(cbuf, 0x0F);
2669     emit_opcode(cbuf, 0xB6);
2670     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
2671   %}
2672 
2673   enc_class Push_ResultXD(regD dst) %{
2674     MacroAssembler _masm(&amp;cbuf);
2675     __ fstp_d(Address(rsp, 0));
2676     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
2677     __ addptr(rsp, 8);
2678   %}
2679 
2680   enc_class Push_SrcXD(regD src) %{
2681     MacroAssembler _masm(&amp;cbuf);
2682     __ subptr(rsp, 8);
2683     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
2684     __ fld_d(Address(rsp, 0));
2685   %}
2686 
2687 
2688   enc_class enc_rethrow()
2689   %{
2690     cbuf.set_insts_mark();
2691     emit_opcode(cbuf, 0xE9); // jmp entry
2692     emit_d32_reloc(cbuf,
2693                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
2694                    runtime_call_Relocation::spec(),
2695                    RELOC_DISP32);
2696   %}
2697 
2698 %}
2699 
2700 
2701 
2702 //----------FRAME--------------------------------------------------------------
2703 // Definition of frame structure and management information.
2704 //
2705 //  S T A C K   L A Y O U T    Allocators stack-slot number
2706 //                             |   (to get allocators register number
2707 //  G  Owned by    |        |  v    add OptoReg::stack0())
2708 //  r   CALLER     |        |
2709 //  o     |        +--------+      pad to even-align allocators stack-slot
2710 //  w     V        |  pad0  |        numbers; owned by CALLER
2711 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
2712 //  h     ^        |   in   |  5
2713 //        |        |  args  |  4   Holes in incoming args owned by SELF
2714 //  |     |        |        |  3
2715 //  |     |        +--------+
2716 //  V     |        | old out|      Empty on Intel, window on Sparc
2717 //        |    old |preserve|      Must be even aligned.
2718 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
2719 //        |        |   in   |  3   area for Intel ret address
2720 //     Owned by    |preserve|      Empty on Sparc.
2721 //       SELF      +--------+
2722 //        |        |  pad2  |  2   pad to align old SP
2723 //        |        +--------+  1
2724 //        |        | locks  |  0
2725 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
2726 //        |        |  pad1  | 11   pad to align new SP
2727 //        |        +--------+
2728 //        |        |        | 10
2729 //        |        | spills |  9   spills
2730 //        V        |        |  8   (pad0 slot for callee)
2731 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
2732 //        ^        |  out   |  7
2733 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
2734 //     Owned by    +--------+
2735 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
2736 //        |    new |preserve|      Must be even-aligned.
2737 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
2738 //        |        |        |
2739 //
2740 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
2741 //         known from SELF's arguments and the Java calling convention.
2742 //         Region 6-7 is determined per call site.
2743 // Note 2: If the calling convention leaves holes in the incoming argument
2744 //         area, those holes are owned by SELF.  Holes in the outgoing area
2745 //         are owned by the CALLEE.  Holes should not be nessecary in the
2746 //         incoming area, as the Java calling convention is completely under
2747 //         the control of the AD file.  Doubles can be sorted and packed to
2748 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
2749 //         varargs C calling conventions.
2750 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
2751 //         even aligned with pad0 as needed.
2752 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
2753 //         region 6-11 is even aligned; it may be padded out more so that
2754 //         the region from SP to FP meets the minimum stack alignment.
2755 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
2756 //         alignment.  Region 11, pad1, may be dynamically extended so that
2757 //         SP meets the minimum alignment.
2758 
2759 frame
2760 %{
2761   // What direction does stack grow in (assumed to be same for C &amp; Java)
2762   stack_direction(TOWARDS_LOW);
2763 
2764   // These three registers define part of the calling convention
2765   // between compiled code and the interpreter.
2766   inline_cache_reg(RAX);                // Inline Cache Register
2767   interpreter_method_oop_reg(RBX);      // Method Oop Register when
2768                                         // calling interpreter
2769 
2770   // Optional: name the operand used by cisc-spilling to access
2771   // [stack_pointer + offset]
2772   cisc_spilling_operand_name(indOffset32);
2773 
2774   // Number of stack slots consumed by locking an object
2775   sync_stack_slots(2);
2776 
2777   // Compiled code's Frame Pointer
2778   frame_pointer(RSP);
2779 
2780   // Interpreter stores its frame pointer in a register which is
2781   // stored to the stack by I2CAdaptors.
2782   // I2CAdaptors convert from interpreted java to compiled java.
2783   interpreter_frame_pointer(RBP);
2784 
2785   // Stack alignment requirement
2786   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
2787 
2788   // Number of stack slots between incoming argument block and the start of
2789   // a new frame.  The PROLOG must add this many slots to the stack.  The
2790   // EPILOG must remove this many slots.  amd64 needs two slots for
2791   // return address.
2792   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
2793 
2794   // Number of outgoing stack slots killed above the out_preserve_stack_slots
2795   // for calls to C.  Supports the var-args backing area for register parms.
2796   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
2797 
2798   // The after-PROLOG location of the return address.  Location of
2799   // return address specifies a type (REG or STACK) and a number
2800   // representing the register number (i.e. - use a register name) or
2801   // stack slot.
2802   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
2803   // Otherwise, it is above the locks and verification slot and alignment word
2804   return_addr(STACK - 2 +
2805               round_to((Compile::current()-&gt;in_preserve_stack_slots() +
2806                         Compile::current()-&gt;fixed_slots()),
2807                        stack_alignment_in_slots()));
2808 
2809   // Body of function which returns an integer array locating
2810   // arguments either in registers or in stack slots.  Passed an array
2811   // of ideal registers called "sig" and a "length" count.  Stack-slot
2812   // offsets are based on outgoing arguments, i.e. a CALLER setting up
2813   // arguments for a CALLEE.  Incoming stack arguments are
2814   // automatically biased by the preserve_stack_slots field above.
2815 
2816   calling_convention
2817   %{
2818     // No difference between ingoing/outgoing just pass false
2819     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
2820   %}
2821 
2822   c_calling_convention
2823   %{
2824     // This is obviously always outgoing
2825     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
2826   %}
2827 
2828   // Location of compiled Java return values.  Same as C for now.
2829   return_value
2830   %{
2831     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
2832            "only return normal values");
2833 
2834     static const int lo[Op_RegL + 1] = {
2835       0,
2836       0,
2837       RAX_num,  // Op_RegN
2838       RAX_num,  // Op_RegI
2839       RAX_num,  // Op_RegP
2840       XMM0_num, // Op_RegF
2841       XMM0_num, // Op_RegD
2842       RAX_num   // Op_RegL
2843     };
2844     static const int hi[Op_RegL + 1] = {
2845       0,
2846       0,
2847       OptoReg::Bad, // Op_RegN
2848       OptoReg::Bad, // Op_RegI
2849       RAX_H_num,    // Op_RegP
2850       OptoReg::Bad, // Op_RegF
2851       XMM0b_num,    // Op_RegD
2852       RAX_H_num     // Op_RegL
2853     };
2854     // Excluded flags and vector registers.
2855     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, "missing type");
2856     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
2857   %}
2858 %}
2859 
2860 //----------ATTRIBUTES---------------------------------------------------------
2861 //----------Operand Attributes-------------------------------------------------
2862 op_attrib op_cost(0);        // Required cost attribute
2863 
2864 //----------Instruction Attributes---------------------------------------------
2865 ins_attrib ins_cost(100);       // Required cost attribute
2866 ins_attrib ins_size(8);         // Required size attribute (in bits)
2867 ins_attrib ins_short_branch(0); // Required flag: is this instruction
2868                                 // a non-matching short branch variant
2869                                 // of some long branch?
2870 ins_attrib ins_alignment(1);    // Required alignment attribute (must
2871                                 // be a power of 2) specifies the
2872                                 // alignment that some part of the
2873                                 // instruction (not necessarily the
2874                                 // start) requires.  If &gt; 1, a
2875                                 // compute_padding() function must be
2876                                 // provided for the instruction
2877 
2878 //----------OPERANDS-----------------------------------------------------------
2879 // Operand definitions must precede instruction definitions for correct parsing
2880 // in the ADLC because operands constitute user defined types which are used in
2881 // instruction definitions.
2882 
2883 //----------Simple Operands----------------------------------------------------
2884 // Immediate Operands
2885 // Integer Immediate
2886 operand immI()
2887 %{
2888   match(ConI);
2889 
2890   op_cost(10);
2891   format %{ %}
2892   interface(CONST_INTER);
2893 %}
2894 
2895 // Constant for test vs zero
2896 operand immI0()
2897 %{
2898   predicate(n-&gt;get_int() == 0);
2899   match(ConI);
2900 
2901   op_cost(0);
2902   format %{ %}
2903   interface(CONST_INTER);
2904 %}
2905 
2906 // Constant for increment
2907 operand immI1()
2908 %{
2909   predicate(n-&gt;get_int() == 1);
2910   match(ConI);
2911 
2912   op_cost(0);
2913   format %{ %}
2914   interface(CONST_INTER);
2915 %}
2916 
2917 // Constant for decrement
2918 operand immI_M1()
2919 %{
2920   predicate(n-&gt;get_int() == -1);
2921   match(ConI);
2922 
2923   op_cost(0);
2924   format %{ %}
2925   interface(CONST_INTER);
2926 %}
2927 
2928 // Valid scale values for addressing modes
2929 operand immI2()
2930 %{
2931   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
2932   match(ConI);
2933 
2934   format %{ %}
2935   interface(CONST_INTER);
2936 %}
2937 
2938 operand immI8()
2939 %{
2940   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
2941   match(ConI);
2942 
2943   op_cost(5);
2944   format %{ %}
2945   interface(CONST_INTER);
2946 %}
2947 
2948 operand immI16()
2949 %{
2950   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
2951   match(ConI);
2952 
2953   op_cost(10);
2954   format %{ %}
2955   interface(CONST_INTER);
2956 %}
2957 
2958 // Int Immediate non-negative
2959 operand immU31()
2960 %{
2961   predicate(n-&gt;get_int() &gt;= 0);
2962   match(ConI);
2963 
2964   op_cost(0);
2965   format %{ %}
2966   interface(CONST_INTER);
2967 %}
2968 
2969 // Constant for long shifts
2970 operand immI_32()
2971 %{
2972   predicate( n-&gt;get_int() == 32 );
2973   match(ConI);
2974 
2975   op_cost(0);
2976   format %{ %}
2977   interface(CONST_INTER);
2978 %}
2979 
2980 // Constant for long shifts
2981 operand immI_64()
2982 %{
2983   predicate( n-&gt;get_int() == 64 );
2984   match(ConI);
2985 
2986   op_cost(0);
2987   format %{ %}
2988   interface(CONST_INTER);
2989 %}
2990 
2991 // Pointer Immediate
2992 operand immP()
2993 %{
2994   match(ConP);
2995 
2996   op_cost(10);
2997   format %{ %}
2998   interface(CONST_INTER);
2999 %}
3000 
3001 // NULL Pointer Immediate
3002 operand immP0()
3003 %{
3004   predicate(n-&gt;get_ptr() == 0);
3005   match(ConP);
3006 
3007   op_cost(5);
3008   format %{ %}
3009   interface(CONST_INTER);
3010 %}
3011 
3012 // Pointer Immediate
3013 operand immN() %{
3014   match(ConN);
3015 
3016   op_cost(10);
3017   format %{ %}
3018   interface(CONST_INTER);
3019 %}
3020 
3021 operand immNKlass() %{
3022   match(ConNKlass);
3023 
3024   op_cost(10);
3025   format %{ %}
3026   interface(CONST_INTER);
3027 %}
3028 
3029 // NULL Pointer Immediate
3030 operand immN0() %{
3031   predicate(n-&gt;get_narrowcon() == 0);
3032   match(ConN);
3033 
3034   op_cost(5);
3035   format %{ %}
3036   interface(CONST_INTER);
3037 %}
3038 
3039 operand immP31()
3040 %{
3041   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
3042             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
3043   match(ConP);
3044 
3045   op_cost(5);
3046   format %{ %}
3047   interface(CONST_INTER);
3048 %}
3049 
3050 
3051 // Long Immediate
3052 operand immL()
3053 %{
3054   match(ConL);
3055 
3056   op_cost(20);
3057   format %{ %}
3058   interface(CONST_INTER);
3059 %}
3060 
3061 // Long Immediate 8-bit
3062 operand immL8()
3063 %{
3064   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
3065   match(ConL);
3066 
3067   op_cost(5);
3068   format %{ %}
3069   interface(CONST_INTER);
3070 %}
3071 
3072 // Long Immediate 32-bit unsigned
3073 operand immUL32()
3074 %{
3075   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
3076   match(ConL);
3077 
3078   op_cost(10);
3079   format %{ %}
3080   interface(CONST_INTER);
3081 %}
3082 
3083 // Long Immediate 32-bit signed
3084 operand immL32()
3085 %{
3086   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
3087   match(ConL);
3088 
3089   op_cost(15);
3090   format %{ %}
3091   interface(CONST_INTER);
3092 %}
3093 
3094 // Long Immediate zero
3095 operand immL0()
3096 %{
3097   predicate(n-&gt;get_long() == 0L);
3098   match(ConL);
3099 
3100   op_cost(10);
3101   format %{ %}
3102   interface(CONST_INTER);
3103 %}
3104 
3105 // Constant for increment
3106 operand immL1()
3107 %{
3108   predicate(n-&gt;get_long() == 1);
3109   match(ConL);
3110 
3111   format %{ %}
3112   interface(CONST_INTER);
3113 %}
3114 
3115 // Constant for decrement
3116 operand immL_M1()
3117 %{
3118   predicate(n-&gt;get_long() == -1);
3119   match(ConL);
3120 
3121   format %{ %}
3122   interface(CONST_INTER);
3123 %}
3124 
3125 // Long Immediate: the value 10
3126 operand immL10()
3127 %{
3128   predicate(n-&gt;get_long() == 10);
3129   match(ConL);
3130 
3131   format %{ %}
3132   interface(CONST_INTER);
3133 %}
3134 
3135 // Long immediate from 0 to 127.
3136 // Used for a shorter form of long mul by 10.
3137 operand immL_127()
3138 %{
3139   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
3140   match(ConL);
3141 
3142   op_cost(10);
3143   format %{ %}
3144   interface(CONST_INTER);
3145 %}
3146 
3147 // Long Immediate: low 32-bit mask
3148 operand immL_32bits()
3149 %{
3150   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
3151   match(ConL);
3152   op_cost(20);
3153 
3154   format %{ %}
3155   interface(CONST_INTER);
3156 %}
3157 
3158 // Float Immediate zero
3159 operand immF0()
3160 %{
3161   predicate(jint_cast(n-&gt;getf()) == 0);
3162   match(ConF);
3163 
3164   op_cost(5);
3165   format %{ %}
3166   interface(CONST_INTER);
3167 %}
3168 
3169 // Float Immediate
3170 operand immF()
3171 %{
3172   match(ConF);
3173 
3174   op_cost(15);
3175   format %{ %}
3176   interface(CONST_INTER);
3177 %}
3178 
3179 // Double Immediate zero
3180 operand immD0()
3181 %{
3182   predicate(jlong_cast(n-&gt;getd()) == 0);
3183   match(ConD);
3184 
3185   op_cost(5);
3186   format %{ %}
3187   interface(CONST_INTER);
3188 %}
3189 
3190 // Double Immediate
3191 operand immD()
3192 %{
3193   match(ConD);
3194 
3195   op_cost(15);
3196   format %{ %}
3197   interface(CONST_INTER);
3198 %}
3199 
3200 // Immediates for special shifts (sign extend)
3201 
3202 // Constants for increment
3203 operand immI_16()
3204 %{
3205   predicate(n-&gt;get_int() == 16);
3206   match(ConI);
3207 
3208   format %{ %}
3209   interface(CONST_INTER);
3210 %}
3211 
3212 operand immI_24()
3213 %{
3214   predicate(n-&gt;get_int() == 24);
3215   match(ConI);
3216 
3217   format %{ %}
3218   interface(CONST_INTER);
3219 %}
3220 
3221 // Constant for byte-wide masking
3222 operand immI_255()
3223 %{
3224   predicate(n-&gt;get_int() == 255);
3225   match(ConI);
3226 
3227   format %{ %}
3228   interface(CONST_INTER);
3229 %}
3230 
3231 // Constant for short-wide masking
3232 operand immI_65535()
3233 %{
3234   predicate(n-&gt;get_int() == 65535);
3235   match(ConI);
3236 
3237   format %{ %}
3238   interface(CONST_INTER);
3239 %}
3240 
3241 // Constant for byte-wide masking
3242 operand immL_255()
3243 %{
3244   predicate(n-&gt;get_long() == 255);
3245   match(ConL);
3246 
3247   format %{ %}
3248   interface(CONST_INTER);
3249 %}
3250 
3251 // Constant for short-wide masking
3252 operand immL_65535()
3253 %{
3254   predicate(n-&gt;get_long() == 65535);
3255   match(ConL);
3256 
3257   format %{ %}
3258   interface(CONST_INTER);
3259 %}
3260 
3261 // Register Operands
3262 // Integer Register
3263 operand rRegI()
3264 %{
3265   constraint(ALLOC_IN_RC(int_reg));
3266   match(RegI);
3267 
3268   match(rax_RegI);
3269   match(rbx_RegI);
3270   match(rcx_RegI);
3271   match(rdx_RegI);
3272   match(rdi_RegI);
3273 
3274   format %{ %}
3275   interface(REG_INTER);
3276 %}
3277 
3278 // Special Registers
3279 operand rax_RegI()
3280 %{
3281   constraint(ALLOC_IN_RC(int_rax_reg));
3282   match(RegI);
3283   match(rRegI);
3284 
3285   format %{ "RAX" %}
3286   interface(REG_INTER);
3287 %}
3288 
3289 // Special Registers
3290 operand rbx_RegI()
3291 %{
3292   constraint(ALLOC_IN_RC(int_rbx_reg));
3293   match(RegI);
3294   match(rRegI);
3295 
3296   format %{ "RBX" %}
3297   interface(REG_INTER);
3298 %}
3299 
3300 operand rcx_RegI()
3301 %{
3302   constraint(ALLOC_IN_RC(int_rcx_reg));
3303   match(RegI);
3304   match(rRegI);
3305 
3306   format %{ "RCX" %}
3307   interface(REG_INTER);
3308 %}
3309 
3310 operand rdx_RegI()
3311 %{
3312   constraint(ALLOC_IN_RC(int_rdx_reg));
3313   match(RegI);
3314   match(rRegI);
3315 
3316   format %{ "RDX" %}
3317   interface(REG_INTER);
3318 %}
3319 
3320 operand rdi_RegI()
3321 %{
3322   constraint(ALLOC_IN_RC(int_rdi_reg));
3323   match(RegI);
3324   match(rRegI);
3325 
3326   format %{ "RDI" %}
3327   interface(REG_INTER);
3328 %}
3329 
3330 operand no_rcx_RegI()
3331 %{
3332   constraint(ALLOC_IN_RC(int_no_rcx_reg));
3333   match(RegI);
3334   match(rax_RegI);
3335   match(rbx_RegI);
3336   match(rdx_RegI);
3337   match(rdi_RegI);
3338 
3339   format %{ %}
3340   interface(REG_INTER);
3341 %}
3342 
3343 operand no_rax_rdx_RegI()
3344 %{
3345   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
3346   match(RegI);
3347   match(rbx_RegI);
3348   match(rcx_RegI);
3349   match(rdi_RegI);
3350 
3351   format %{ %}
3352   interface(REG_INTER);
3353 %}
3354 
3355 // Pointer Register
3356 operand any_RegP()
3357 %{
3358   constraint(ALLOC_IN_RC(any_reg));
3359   match(RegP);
3360   match(rax_RegP);
3361   match(rbx_RegP);
3362   match(rdi_RegP);
3363   match(rsi_RegP);
3364   match(rbp_RegP);
3365   match(r15_RegP);
3366   match(rRegP);
3367 
3368   format %{ %}
3369   interface(REG_INTER);
3370 %}
3371 
3372 operand rRegP()
3373 %{
3374   constraint(ALLOC_IN_RC(ptr_reg));
3375   match(RegP);
3376   match(rax_RegP);
3377   match(rbx_RegP);
3378   match(rdi_RegP);
3379   match(rsi_RegP);
3380   match(rbp_RegP);  // See Q&amp;A below about
3381   match(r15_RegP);  // r15_RegP and rbp_RegP.
3382 
3383   format %{ %}
3384   interface(REG_INTER);
3385 %}
3386 
3387 operand rRegN() %{
3388   constraint(ALLOC_IN_RC(int_reg));
3389   match(RegN);
3390 
3391   format %{ %}
3392   interface(REG_INTER);
3393 %}
3394 
3395 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
3396 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
3397 // It's fine for an instruction input that expects rRegP to match a r15_RegP.
3398 // The output of an instruction is controlled by the allocator, which respects
3399 // register class masks, not match rules.  Unless an instruction mentions
3400 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
3401 // by the allocator as an input.
3402 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
3403 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
3404 // result, RBP is not included in the output of the instruction either.
3405 
3406 operand no_rax_RegP()
3407 %{
3408   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
3409   match(RegP);
3410   match(rbx_RegP);
3411   match(rsi_RegP);
3412   match(rdi_RegP);
3413 
3414   format %{ %}
3415   interface(REG_INTER);
3416 %}
3417 
3418 // This operand is not allowed to use RBP even if
3419 // RBP is not used to hold the frame pointer.
3420 operand no_rbp_RegP()
3421 %{
3422   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
3423   match(RegP);
3424   match(rbx_RegP);
3425   match(rsi_RegP);
3426   match(rdi_RegP);
3427 
3428   format %{ %}
3429   interface(REG_INTER);
3430 %}
3431 
3432 operand no_rax_rbx_RegP()
3433 %{
3434   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
3435   match(RegP);
3436   match(rsi_RegP);
3437   match(rdi_RegP);
3438 
3439   format %{ %}
3440   interface(REG_INTER);
3441 %}
3442 
3443 // Special Registers
3444 // Return a pointer value
3445 operand rax_RegP()
3446 %{
3447   constraint(ALLOC_IN_RC(ptr_rax_reg));
3448   match(RegP);
3449   match(rRegP);
3450 
3451   format %{ %}
3452   interface(REG_INTER);
3453 %}
3454 
3455 // Special Registers
3456 // Return a compressed pointer value
3457 operand rax_RegN()
3458 %{
3459   constraint(ALLOC_IN_RC(int_rax_reg));
3460   match(RegN);
3461   match(rRegN);
3462 
3463   format %{ %}
3464   interface(REG_INTER);
3465 %}
3466 
3467 // Used in AtomicAdd
3468 operand rbx_RegP()
3469 %{
3470   constraint(ALLOC_IN_RC(ptr_rbx_reg));
3471   match(RegP);
3472   match(rRegP);
3473 
3474   format %{ %}
3475   interface(REG_INTER);
3476 %}
3477 
3478 operand rsi_RegP()
3479 %{
3480   constraint(ALLOC_IN_RC(ptr_rsi_reg));
3481   match(RegP);
3482   match(rRegP);
3483 
3484   format %{ %}
3485   interface(REG_INTER);
3486 %}
3487 
3488 // Used in rep stosq
3489 operand rdi_RegP()
3490 %{
3491   constraint(ALLOC_IN_RC(ptr_rdi_reg));
3492   match(RegP);
3493   match(rRegP);
3494 
3495   format %{ %}
3496   interface(REG_INTER);
3497 %}
3498 
3499 operand r15_RegP()
3500 %{
3501   constraint(ALLOC_IN_RC(ptr_r15_reg));
3502   match(RegP);
3503   match(rRegP);
3504 
3505   format %{ %}
3506   interface(REG_INTER);
3507 %}
3508 
3509 operand rRegL()
3510 %{
3511   constraint(ALLOC_IN_RC(long_reg));
3512   match(RegL);
3513   match(rax_RegL);
3514   match(rdx_RegL);
3515 
3516   format %{ %}
3517   interface(REG_INTER);
3518 %}
3519 
3520 // Special Registers
3521 operand no_rax_rdx_RegL()
3522 %{
3523   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3524   match(RegL);
3525   match(rRegL);
3526 
3527   format %{ %}
3528   interface(REG_INTER);
3529 %}
3530 
3531 operand no_rax_RegL()
3532 %{
3533   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3534   match(RegL);
3535   match(rRegL);
3536   match(rdx_RegL);
3537 
3538   format %{ %}
3539   interface(REG_INTER);
3540 %}
3541 
3542 operand no_rcx_RegL()
3543 %{
3544   constraint(ALLOC_IN_RC(long_no_rcx_reg));
3545   match(RegL);
3546   match(rRegL);
3547 
3548   format %{ %}
3549   interface(REG_INTER);
3550 %}
3551 
3552 operand rax_RegL()
3553 %{
3554   constraint(ALLOC_IN_RC(long_rax_reg));
3555   match(RegL);
3556   match(rRegL);
3557 
3558   format %{ "RAX" %}
3559   interface(REG_INTER);
3560 %}
3561 
3562 operand rcx_RegL()
3563 %{
3564   constraint(ALLOC_IN_RC(long_rcx_reg));
3565   match(RegL);
3566   match(rRegL);
3567 
3568   format %{ %}
3569   interface(REG_INTER);
3570 %}
3571 
3572 operand rdx_RegL()
3573 %{
3574   constraint(ALLOC_IN_RC(long_rdx_reg));
3575   match(RegL);
3576   match(rRegL);
3577 
3578   format %{ %}
3579   interface(REG_INTER);
3580 %}
3581 
3582 // Flags register, used as output of compare instructions
3583 operand rFlagsReg()
3584 %{
3585   constraint(ALLOC_IN_RC(int_flags));
3586   match(RegFlags);
3587 
3588   format %{ "RFLAGS" %}
3589   interface(REG_INTER);
3590 %}
3591 
3592 // Flags register, used as output of FLOATING POINT compare instructions
3593 operand rFlagsRegU()
3594 %{
3595   constraint(ALLOC_IN_RC(int_flags));
3596   match(RegFlags);
3597 
3598   format %{ "RFLAGS_U" %}
3599   interface(REG_INTER);
3600 %}
3601 
3602 operand rFlagsRegUCF() %{
3603   constraint(ALLOC_IN_RC(int_flags));
3604   match(RegFlags);
3605   predicate(false);
3606 
3607   format %{ "RFLAGS_U_CF" %}
3608   interface(REG_INTER);
3609 %}
3610 
3611 // Float register operands
3612 operand regF() %{
3613    constraint(ALLOC_IN_RC(float_reg));
3614    match(RegF);
3615 
3616    format %{ %}
3617    interface(REG_INTER);
3618 %}
3619 
3620 // Double register operands
3621 operand regD() %{
3622    constraint(ALLOC_IN_RC(double_reg));
3623    match(RegD);
3624 
3625    format %{ %}
3626    interface(REG_INTER);
3627 %}
3628 
3629 // Vectors
3630 operand vecS() %{
3631   constraint(ALLOC_IN_RC(vectors_reg));
3632   match(VecS);
3633 
3634   format %{ %}
3635   interface(REG_INTER);
3636 %}
3637 
3638 operand vecD() %{
3639   constraint(ALLOC_IN_RC(vectord_reg));
3640   match(VecD);
3641 
3642   format %{ %}
3643   interface(REG_INTER);
3644 %}
3645 
3646 operand vecX() %{
3647   constraint(ALLOC_IN_RC(vectorx_reg));
3648   match(VecX);
3649 
3650   format %{ %}
3651   interface(REG_INTER);
3652 %}
3653 
3654 operand vecY() %{
3655   constraint(ALLOC_IN_RC(vectory_reg));
3656   match(VecY);
3657 
3658   format %{ %}
3659   interface(REG_INTER);
3660 %}
3661 
3662 //----------Memory Operands----------------------------------------------------
3663 // Direct Memory Operand
3664 // operand direct(immP addr)
3665 // %{
3666 //   match(addr);
3667 
3668 //   format %{ "[$addr]" %}
3669 //   interface(MEMORY_INTER) %{
3670 //     base(0xFFFFFFFF);
3671 //     index(0x4);
3672 //     scale(0x0);
3673 //     disp($addr);
3674 //   %}
3675 // %}
3676 
3677 // Indirect Memory Operand
3678 operand indirect(any_RegP reg)
3679 %{
3680   constraint(ALLOC_IN_RC(ptr_reg));
3681   match(reg);
3682 
3683   format %{ "[$reg]" %}
3684   interface(MEMORY_INTER) %{
3685     base($reg);
3686     index(0x4);
3687     scale(0x0);
3688     disp(0x0);
3689   %}
3690 %}
3691 
3692 // Indirect Memory Plus Short Offset Operand
3693 operand indOffset8(any_RegP reg, immL8 off)
3694 %{
3695   constraint(ALLOC_IN_RC(ptr_reg));
3696   match(AddP reg off);
3697 
3698   format %{ "[$reg + $off (8-bit)]" %}
3699   interface(MEMORY_INTER) %{
3700     base($reg);
3701     index(0x4);
3702     scale(0x0);
3703     disp($off);
3704   %}
3705 %}
3706 
3707 // Indirect Memory Plus Long Offset Operand
3708 operand indOffset32(any_RegP reg, immL32 off)
3709 %{
3710   constraint(ALLOC_IN_RC(ptr_reg));
3711   match(AddP reg off);
3712 
3713   format %{ "[$reg + $off (32-bit)]" %}
3714   interface(MEMORY_INTER) %{
3715     base($reg);
3716     index(0x4);
3717     scale(0x0);
3718     disp($off);
3719   %}
3720 %}
3721 
3722 // Indirect Memory Plus Index Register Plus Offset Operand
3723 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
3724 %{
3725   constraint(ALLOC_IN_RC(ptr_reg));
3726   match(AddP (AddP reg lreg) off);
3727 
3728   op_cost(10);
3729   format %{"[$reg + $off + $lreg]" %}
3730   interface(MEMORY_INTER) %{
3731     base($reg);
3732     index($lreg);
3733     scale(0x0);
3734     disp($off);
3735   %}
3736 %}
3737 
3738 // Indirect Memory Plus Index Register Plus Offset Operand
3739 operand indIndex(any_RegP reg, rRegL lreg)
3740 %{
3741   constraint(ALLOC_IN_RC(ptr_reg));
3742   match(AddP reg lreg);
3743 
3744   op_cost(10);
3745   format %{"[$reg + $lreg]" %}
3746   interface(MEMORY_INTER) %{
3747     base($reg);
3748     index($lreg);
3749     scale(0x0);
3750     disp(0x0);
3751   %}
3752 %}
3753 
3754 // Indirect Memory Times Scale Plus Index Register
3755 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
3756 %{
3757   constraint(ALLOC_IN_RC(ptr_reg));
3758   match(AddP reg (LShiftL lreg scale));
3759 
3760   op_cost(10);
3761   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3762   interface(MEMORY_INTER) %{
3763     base($reg);
3764     index($lreg);
3765     scale($scale);
3766     disp(0x0);
3767   %}
3768 %}
3769 
3770 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3771 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
3772 %{
3773   constraint(ALLOC_IN_RC(ptr_reg));
3774   match(AddP (AddP reg (LShiftL lreg scale)) off);
3775 
3776   op_cost(10);
3777   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3778   interface(MEMORY_INTER) %{
3779     base($reg);
3780     index($lreg);
3781     scale($scale);
3782     disp($off);
3783   %}
3784 %}
3785 
3786 // Indirect Memory Plus Positive Index Register Plus Offset Operand
3787 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
3788 %{
3789   constraint(ALLOC_IN_RC(ptr_reg));
3790   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3791   match(AddP (AddP reg (ConvI2L idx)) off);
3792 
3793   op_cost(10);
3794   format %{"[$reg + $off + $idx]" %}
3795   interface(MEMORY_INTER) %{
3796     base($reg);
3797     index($idx);
3798     scale(0x0);
3799     disp($off);
3800   %}
3801 %}
3802 
3803 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3804 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
3805 %{
3806   constraint(ALLOC_IN_RC(ptr_reg));
3807   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3808   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
3809 
3810   op_cost(10);
3811   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3812   interface(MEMORY_INTER) %{
3813     base($reg);
3814     index($idx);
3815     scale($scale);
3816     disp($off);
3817   %}
3818 %}
3819 
3820 // Indirect Narrow Oop Plus Offset Operand
3821 // Note: x86 architecture doesn't support "scale * index + offset" without a base
3822 // we can't free r12 even with Universe::narrow_oop_base() == NULL.
3823 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
3824   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));
3825   constraint(ALLOC_IN_RC(ptr_reg));
3826   match(AddP (DecodeN reg) off);
3827 
3828   op_cost(10);
3829   format %{"[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)" %}
3830   interface(MEMORY_INTER) %{
3831     base(0xc); // R12
3832     index($reg);
3833     scale(0x3);
3834     disp($off);
3835   %}
3836 %}
3837 
3838 // Indirect Memory Operand
3839 operand indirectNarrow(rRegN reg)
3840 %{
3841   predicate(Universe::narrow_oop_shift() == 0);
3842   constraint(ALLOC_IN_RC(ptr_reg));
3843   match(DecodeN reg);
3844 
3845   format %{ "[$reg]" %}
3846   interface(MEMORY_INTER) %{
3847     base($reg);
3848     index(0x4);
3849     scale(0x0);
3850     disp(0x0);
3851   %}
3852 %}
3853 
3854 // Indirect Memory Plus Short Offset Operand
3855 operand indOffset8Narrow(rRegN reg, immL8 off)
3856 %{
3857   predicate(Universe::narrow_oop_shift() == 0);
3858   constraint(ALLOC_IN_RC(ptr_reg));
3859   match(AddP (DecodeN reg) off);
3860 
3861   format %{ "[$reg + $off (8-bit)]" %}
3862   interface(MEMORY_INTER) %{
3863     base($reg);
3864     index(0x4);
3865     scale(0x0);
3866     disp($off);
3867   %}
3868 %}
3869 
3870 // Indirect Memory Plus Long Offset Operand
3871 operand indOffset32Narrow(rRegN reg, immL32 off)
3872 %{
3873   predicate(Universe::narrow_oop_shift() == 0);
3874   constraint(ALLOC_IN_RC(ptr_reg));
3875   match(AddP (DecodeN reg) off);
3876 
3877   format %{ "[$reg + $off (32-bit)]" %}
3878   interface(MEMORY_INTER) %{
3879     base($reg);
3880     index(0x4);
3881     scale(0x0);
3882     disp($off);
3883   %}
3884 %}
3885 
3886 // Indirect Memory Plus Index Register Plus Offset Operand
3887 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
3888 %{
3889   predicate(Universe::narrow_oop_shift() == 0);
3890   constraint(ALLOC_IN_RC(ptr_reg));
3891   match(AddP (AddP (DecodeN reg) lreg) off);
3892 
3893   op_cost(10);
3894   format %{"[$reg + $off + $lreg]" %}
3895   interface(MEMORY_INTER) %{
3896     base($reg);
3897     index($lreg);
3898     scale(0x0);
3899     disp($off);
3900   %}
3901 %}
3902 
3903 // Indirect Memory Plus Index Register Plus Offset Operand
3904 operand indIndexNarrow(rRegN reg, rRegL lreg)
3905 %{
3906   predicate(Universe::narrow_oop_shift() == 0);
3907   constraint(ALLOC_IN_RC(ptr_reg));
3908   match(AddP (DecodeN reg) lreg);
3909 
3910   op_cost(10);
3911   format %{"[$reg + $lreg]" %}
3912   interface(MEMORY_INTER) %{
3913     base($reg);
3914     index($lreg);
3915     scale(0x0);
3916     disp(0x0);
3917   %}
3918 %}
3919 
3920 // Indirect Memory Times Scale Plus Index Register
3921 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
3922 %{
3923   predicate(Universe::narrow_oop_shift() == 0);
3924   constraint(ALLOC_IN_RC(ptr_reg));
3925   match(AddP (DecodeN reg) (LShiftL lreg scale));
3926 
3927   op_cost(10);
3928   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3929   interface(MEMORY_INTER) %{
3930     base($reg);
3931     index($lreg);
3932     scale($scale);
3933     disp(0x0);
3934   %}
3935 %}
3936 
3937 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3938 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
3939 %{
3940   predicate(Universe::narrow_oop_shift() == 0);
3941   constraint(ALLOC_IN_RC(ptr_reg));
3942   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
3943 
3944   op_cost(10);
3945   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3946   interface(MEMORY_INTER) %{
3947     base($reg);
3948     index($lreg);
3949     scale($scale);
3950     disp($off);
3951   %}
3952 %}
3953 
3954 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
3955 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
3956 %{
3957   constraint(ALLOC_IN_RC(ptr_reg));
3958   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3959   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
3960 
3961   op_cost(10);
3962   format %{"[$reg + $off + $idx]" %}
3963   interface(MEMORY_INTER) %{
3964     base($reg);
3965     index($idx);
3966     scale(0x0);
3967     disp($off);
3968   %}
3969 %}
3970 
3971 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3972 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
3973 %{
3974   constraint(ALLOC_IN_RC(ptr_reg));
3975   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3976   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
3977 
3978   op_cost(10);
3979   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3980   interface(MEMORY_INTER) %{
3981     base($reg);
3982     index($idx);
3983     scale($scale);
3984     disp($off);
3985   %}
3986 %}
3987 
3988 //----------Special Memory Operands--------------------------------------------
3989 // Stack Slot Operand - This operand is used for loading and storing temporary
3990 //                      values on the stack where a match requires a value to
3991 //                      flow through memory.
3992 operand stackSlotP(sRegP reg)
3993 %{
3994   constraint(ALLOC_IN_RC(stack_slots));
3995   // No match rule because this operand is only generated in matching
3996 
3997   format %{ "[$reg]" %}
3998   interface(MEMORY_INTER) %{
3999     base(0x4);   // RSP
4000     index(0x4);  // No Index
4001     scale(0x0);  // No Scale
4002     disp($reg);  // Stack Offset
4003   %}
4004 %}
4005 
4006 operand stackSlotI(sRegI reg)
4007 %{
4008   constraint(ALLOC_IN_RC(stack_slots));
4009   // No match rule because this operand is only generated in matching
4010 
4011   format %{ "[$reg]" %}
4012   interface(MEMORY_INTER) %{
4013     base(0x4);   // RSP
4014     index(0x4);  // No Index
4015     scale(0x0);  // No Scale
4016     disp($reg);  // Stack Offset
4017   %}
4018 %}
4019 
4020 operand stackSlotF(sRegF reg)
4021 %{
4022   constraint(ALLOC_IN_RC(stack_slots));
4023   // No match rule because this operand is only generated in matching
4024 
4025   format %{ "[$reg]" %}
4026   interface(MEMORY_INTER) %{
4027     base(0x4);   // RSP
4028     index(0x4);  // No Index
4029     scale(0x0);  // No Scale
4030     disp($reg);  // Stack Offset
4031   %}
4032 %}
4033 
4034 operand stackSlotD(sRegD reg)
4035 %{
4036   constraint(ALLOC_IN_RC(stack_slots));
4037   // No match rule because this operand is only generated in matching
4038 
4039   format %{ "[$reg]" %}
4040   interface(MEMORY_INTER) %{
4041     base(0x4);   // RSP
4042     index(0x4);  // No Index
4043     scale(0x0);  // No Scale
4044     disp($reg);  // Stack Offset
4045   %}
4046 %}
4047 operand stackSlotL(sRegL reg)
4048 %{
4049   constraint(ALLOC_IN_RC(stack_slots));
4050   // No match rule because this operand is only generated in matching
4051 
4052   format %{ "[$reg]" %}
4053   interface(MEMORY_INTER) %{
4054     base(0x4);   // RSP
4055     index(0x4);  // No Index
4056     scale(0x0);  // No Scale
4057     disp($reg);  // Stack Offset
4058   %}
4059 %}
4060 
4061 //----------Conditional Branch Operands----------------------------------------
4062 // Comparison Op  - This is the operation of the comparison, and is limited to
4063 //                  the following set of codes:
4064 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
4065 //
4066 // Other attributes of the comparison, such as unsignedness, are specified
4067 // by the comparison instruction that sets a condition code flags register.
4068 // That result is represented by a flags operand whose subtype is appropriate
4069 // to the unsignedness (etc.) of the comparison.
4070 //
4071 // Later, the instruction which matches both the Comparison Op (a Bool) and
4072 // the flags (produced by the Cmp) specifies the coding of the comparison op
4073 // by matching a specific subtype of Bool operand below, such as cmpOpU.
4074 
4075 // Comparision Code
4076 operand cmpOp()
4077 %{
4078   match(Bool);
4079 
4080   format %{ "" %}
4081   interface(COND_INTER) %{
4082     equal(0x4, "e");
4083     not_equal(0x5, "ne");
4084     less(0xC, "l");
4085     greater_equal(0xD, "ge");
4086     less_equal(0xE, "le");
4087     greater(0xF, "g");
4088     overflow(0x0, "o");
4089     no_overflow(0x1, "no");
4090   %}
4091 %}
4092 
4093 // Comparison Code, unsigned compare.  Used by FP also, with
4094 // C2 (unordered) turned into GT or LT already.  The other bits
4095 // C0 and C3 are turned into Carry &amp; Zero flags.
4096 operand cmpOpU()
4097 %{
4098   match(Bool);
4099 
4100   format %{ "" %}
4101   interface(COND_INTER) %{
4102     equal(0x4, "e");
4103     not_equal(0x5, "ne");
4104     less(0x2, "b");
4105     greater_equal(0x3, "nb");
4106     less_equal(0x6, "be");
4107     greater(0x7, "nbe");
4108     overflow(0x0, "o");
4109     no_overflow(0x1, "no");
4110   %}
4111 %}
4112 
4113 
4114 // Floating comparisons that don't require any fixup for the unordered case
4115 operand cmpOpUCF() %{
4116   match(Bool);
4117   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
4118             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
4119             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
4120             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
4121   format %{ "" %}
4122   interface(COND_INTER) %{
4123     equal(0x4, "e");
4124     not_equal(0x5, "ne");
4125     less(0x2, "b");
4126     greater_equal(0x3, "nb");
4127     less_equal(0x6, "be");
4128     greater(0x7, "nbe");
4129     overflow(0x0, "o");
4130     no_overflow(0x1, "no");
4131   %}
4132 %}
4133 
4134 
4135 // Floating comparisons that can be fixed up with extra conditional jumps
4136 operand cmpOpUCF2() %{
4137   match(Bool);
4138   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
4139             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
4140   format %{ "" %}
4141   interface(COND_INTER) %{
4142     equal(0x4, "e");
4143     not_equal(0x5, "ne");
4144     less(0x2, "b");
4145     greater_equal(0x3, "nb");
4146     less_equal(0x6, "be");
4147     greater(0x7, "nbe");
4148     overflow(0x0, "o");
4149     no_overflow(0x1, "no");
4150   %}
4151 %}
4152 
4153 
4154 //----------OPERAND CLASSES----------------------------------------------------
4155 // Operand Classes are groups of operands that are used as to simplify
4156 // instruction definitions by not requiring the AD writer to specify separate
4157 // instructions for every form of operand when the instruction accepts
4158 // multiple operand types with the same basic encoding and format.  The classic
4159 // case of this is memory operands.
4160 
4161 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
4162                indIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
4163                indCompressedOopOffset,
4164                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
4165                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
4166                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
4167 
4168 //----------PIPELINE-----------------------------------------------------------
4169 // Rules which define the behavior of the target architectures pipeline.
4170 pipeline %{
4171 
4172 //----------ATTRIBUTES---------------------------------------------------------
4173 attributes %{
4174   variable_size_instructions;        // Fixed size instructions
4175   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
4176   instruction_unit_size = 1;         // An instruction is 1 bytes long
4177   instruction_fetch_unit_size = 16;  // The processor fetches one line
4178   instruction_fetch_units = 1;       // of 16 bytes
4179 
4180   // List of nop instructions
4181   nops( MachNop );
4182 %}
4183 
4184 //----------RESOURCES----------------------------------------------------------
4185 // Resources are the functional units available to the machine
4186 
4187 // Generic P2/P3 pipeline
4188 // 3 decoders, only D0 handles big operands; a "bundle" is the limit of
4189 // 3 instructions decoded per cycle.
4190 // 2 load/store ops per cycle, 1 branch, 1 FPU,
4191 // 3 ALU op, only ALU0 handles mul instructions.
4192 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
4193            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
4194            BR, FPU,
4195            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
4196 
4197 //----------PIPELINE DESCRIPTION-----------------------------------------------
4198 // Pipeline Description specifies the stages in the machine's pipeline
4199 
4200 // Generic P2/P3 pipeline
4201 pipe_desc(S0, S1, S2, S3, S4, S5);
4202 
4203 //----------PIPELINE CLASSES---------------------------------------------------
4204 // Pipeline Classes describe the stages in which input and output are
4205 // referenced by the hardware pipeline.
4206 
4207 // Naming convention: ialu or fpu
4208 // Then: _reg
4209 // Then: _reg if there is a 2nd register
4210 // Then: _long if it's a pair of instructions implementing a long
4211 // Then: _fat if it requires the big decoder
4212 //   Or: _mem if it requires the big decoder and a memory unit.
4213 
4214 // Integer ALU reg operation
4215 pipe_class ialu_reg(rRegI dst)
4216 %{
4217     single_instruction;
4218     dst    : S4(write);
4219     dst    : S3(read);
4220     DECODE : S0;        // any decoder
4221     ALU    : S3;        // any alu
4222 %}
4223 
4224 // Long ALU reg operation
4225 pipe_class ialu_reg_long(rRegL dst)
4226 %{
4227     instruction_count(2);
4228     dst    : S4(write);
4229     dst    : S3(read);
4230     DECODE : S0(2);     // any 2 decoders
4231     ALU    : S3(2);     // both alus
4232 %}
4233 
4234 // Integer ALU reg operation using big decoder
4235 pipe_class ialu_reg_fat(rRegI dst)
4236 %{
4237     single_instruction;
4238     dst    : S4(write);
4239     dst    : S3(read);
4240     D0     : S0;        // big decoder only
4241     ALU    : S3;        // any alu
4242 %}
4243 
4244 // Long ALU reg operation using big decoder
4245 pipe_class ialu_reg_long_fat(rRegL dst)
4246 %{
4247     instruction_count(2);
4248     dst    : S4(write);
4249     dst    : S3(read);
4250     D0     : S0(2);     // big decoder only; twice
4251     ALU    : S3(2);     // any 2 alus
4252 %}
4253 
4254 // Integer ALU reg-reg operation
4255 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
4256 %{
4257     single_instruction;
4258     dst    : S4(write);
4259     src    : S3(read);
4260     DECODE : S0;        // any decoder
4261     ALU    : S3;        // any alu
4262 %}
4263 
4264 // Long ALU reg-reg operation
4265 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
4266 %{
4267     instruction_count(2);
4268     dst    : S4(write);
4269     src    : S3(read);
4270     DECODE : S0(2);     // any 2 decoders
4271     ALU    : S3(2);     // both alus
4272 %}
4273 
4274 // Integer ALU reg-reg operation
4275 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
4276 %{
4277     single_instruction;
4278     dst    : S4(write);
4279     src    : S3(read);
4280     D0     : S0;        // big decoder only
4281     ALU    : S3;        // any alu
4282 %}
4283 
4284 // Long ALU reg-reg operation
4285 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
4286 %{
4287     instruction_count(2);
4288     dst    : S4(write);
4289     src    : S3(read);
4290     D0     : S0(2);     // big decoder only; twice
4291     ALU    : S3(2);     // both alus
4292 %}
4293 
4294 // Integer ALU reg-mem operation
4295 pipe_class ialu_reg_mem(rRegI dst, memory mem)
4296 %{
4297     single_instruction;
4298     dst    : S5(write);
4299     mem    : S3(read);
4300     D0     : S0;        // big decoder only
4301     ALU    : S4;        // any alu
4302     MEM    : S3;        // any mem
4303 %}
4304 
4305 // Integer mem operation (prefetch)
4306 pipe_class ialu_mem(memory mem)
4307 %{
4308     single_instruction;
4309     mem    : S3(read);
4310     D0     : S0;        // big decoder only
4311     MEM    : S3;        // any mem
4312 %}
4313 
4314 // Integer Store to Memory
4315 pipe_class ialu_mem_reg(memory mem, rRegI src)
4316 %{
4317     single_instruction;
4318     mem    : S3(read);
4319     src    : S5(read);
4320     D0     : S0;        // big decoder only
4321     ALU    : S4;        // any alu
4322     MEM    : S3;
4323 %}
4324 
4325 // // Long Store to Memory
4326 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
4327 // %{
4328 //     instruction_count(2);
4329 //     mem    : S3(read);
4330 //     src    : S5(read);
4331 //     D0     : S0(2);          // big decoder only; twice
4332 //     ALU    : S4(2);     // any 2 alus
4333 //     MEM    : S3(2);  // Both mems
4334 // %}
4335 
4336 // Integer Store to Memory
4337 pipe_class ialu_mem_imm(memory mem)
4338 %{
4339     single_instruction;
4340     mem    : S3(read);
4341     D0     : S0;        // big decoder only
4342     ALU    : S4;        // any alu
4343     MEM    : S3;
4344 %}
4345 
4346 // Integer ALU0 reg-reg operation
4347 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
4348 %{
4349     single_instruction;
4350     dst    : S4(write);
4351     src    : S3(read);
4352     D0     : S0;        // Big decoder only
4353     ALU0   : S3;        // only alu0
4354 %}
4355 
4356 // Integer ALU0 reg-mem operation
4357 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
4358 %{
4359     single_instruction;
4360     dst    : S5(write);
4361     mem    : S3(read);
4362     D0     : S0;        // big decoder only
4363     ALU0   : S4;        // ALU0 only
4364     MEM    : S3;        // any mem
4365 %}
4366 
4367 // Integer ALU reg-reg operation
4368 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
4369 %{
4370     single_instruction;
4371     cr     : S4(write);
4372     src1   : S3(read);
4373     src2   : S3(read);
4374     DECODE : S0;        // any decoder
4375     ALU    : S3;        // any alu
4376 %}
4377 
4378 // Integer ALU reg-imm operation
4379 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
4380 %{
4381     single_instruction;
4382     cr     : S4(write);
4383     src1   : S3(read);
4384     DECODE : S0;        // any decoder
4385     ALU    : S3;        // any alu
4386 %}
4387 
4388 // Integer ALU reg-mem operation
4389 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
4390 %{
4391     single_instruction;
4392     cr     : S4(write);
4393     src1   : S3(read);
4394     src2   : S3(read);
4395     D0     : S0;        // big decoder only
4396     ALU    : S4;        // any alu
4397     MEM    : S3;
4398 %}
4399 
4400 // Conditional move reg-reg
4401 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
4402 %{
4403     instruction_count(4);
4404     y      : S4(read);
4405     q      : S3(read);
4406     p      : S3(read);
4407     DECODE : S0(4);     // any decoder
4408 %}
4409 
4410 // Conditional move reg-reg
4411 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
4412 %{
4413     single_instruction;
4414     dst    : S4(write);
4415     src    : S3(read);
4416     cr     : S3(read);
4417     DECODE : S0;        // any decoder
4418 %}
4419 
4420 // Conditional move reg-mem
4421 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
4422 %{
4423     single_instruction;
4424     dst    : S4(write);
4425     src    : S3(read);
4426     cr     : S3(read);
4427     DECODE : S0;        // any decoder
4428     MEM    : S3;
4429 %}
4430 
4431 // Conditional move reg-reg long
4432 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
4433 %{
4434     single_instruction;
4435     dst    : S4(write);
4436     src    : S3(read);
4437     cr     : S3(read);
4438     DECODE : S0(2);     // any 2 decoders
4439 %}
4440 
4441 // XXX
4442 // // Conditional move double reg-reg
4443 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
4444 // %{
4445 //     single_instruction;
4446 //     dst    : S4(write);
4447 //     src    : S3(read);
4448 //     cr     : S3(read);
4449 //     DECODE : S0;     // any decoder
4450 // %}
4451 
4452 // Float reg-reg operation
4453 pipe_class fpu_reg(regD dst)
4454 %{
4455     instruction_count(2);
4456     dst    : S3(read);
4457     DECODE : S0(2);     // any 2 decoders
4458     FPU    : S3;
4459 %}
4460 
4461 // Float reg-reg operation
4462 pipe_class fpu_reg_reg(regD dst, regD src)
4463 %{
4464     instruction_count(2);
4465     dst    : S4(write);
4466     src    : S3(read);
4467     DECODE : S0(2);     // any 2 decoders
4468     FPU    : S3;
4469 %}
4470 
4471 // Float reg-reg operation
4472 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
4473 %{
4474     instruction_count(3);
4475     dst    : S4(write);
4476     src1   : S3(read);
4477     src2   : S3(read);
4478     DECODE : S0(3);     // any 3 decoders
4479     FPU    : S3(2);
4480 %}
4481 
4482 // Float reg-reg operation
4483 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
4484 %{
4485     instruction_count(4);
4486     dst    : S4(write);
4487     src1   : S3(read);
4488     src2   : S3(read);
4489     src3   : S3(read);
4490     DECODE : S0(4);     // any 3 decoders
4491     FPU    : S3(2);
4492 %}
4493 
4494 // Float reg-reg operation
4495 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
4496 %{
4497     instruction_count(4);
4498     dst    : S4(write);
4499     src1   : S3(read);
4500     src2   : S3(read);
4501     src3   : S3(read);
4502     DECODE : S1(3);     // any 3 decoders
4503     D0     : S0;        // Big decoder only
4504     FPU    : S3(2);
4505     MEM    : S3;
4506 %}
4507 
4508 // Float reg-mem operation
4509 pipe_class fpu_reg_mem(regD dst, memory mem)
4510 %{
4511     instruction_count(2);
4512     dst    : S5(write);
4513     mem    : S3(read);
4514     D0     : S0;        // big decoder only
4515     DECODE : S1;        // any decoder for FPU POP
4516     FPU    : S4;
4517     MEM    : S3;        // any mem
4518 %}
4519 
4520 // Float reg-mem operation
4521 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
4522 %{
4523     instruction_count(3);
4524     dst    : S5(write);
4525     src1   : S3(read);
4526     mem    : S3(read);
4527     D0     : S0;        // big decoder only
4528     DECODE : S1(2);     // any decoder for FPU POP
4529     FPU    : S4;
4530     MEM    : S3;        // any mem
4531 %}
4532 
4533 // Float mem-reg operation
4534 pipe_class fpu_mem_reg(memory mem, regD src)
4535 %{
4536     instruction_count(2);
4537     src    : S5(read);
4538     mem    : S3(read);
4539     DECODE : S0;        // any decoder for FPU PUSH
4540     D0     : S1;        // big decoder only
4541     FPU    : S4;
4542     MEM    : S3;        // any mem
4543 %}
4544 
4545 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
4546 %{
4547     instruction_count(3);
4548     src1   : S3(read);
4549     src2   : S3(read);
4550     mem    : S3(read);
4551     DECODE : S0(2);     // any decoder for FPU PUSH
4552     D0     : S1;        // big decoder only
4553     FPU    : S4;
4554     MEM    : S3;        // any mem
4555 %}
4556 
4557 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
4558 %{
4559     instruction_count(3);
4560     src1   : S3(read);
4561     src2   : S3(read);
4562     mem    : S4(read);
4563     DECODE : S0;        // any decoder for FPU PUSH
4564     D0     : S0(2);     // big decoder only
4565     FPU    : S4;
4566     MEM    : S3(2);     // any mem
4567 %}
4568 
4569 pipe_class fpu_mem_mem(memory dst, memory src1)
4570 %{
4571     instruction_count(2);
4572     src1   : S3(read);
4573     dst    : S4(read);
4574     D0     : S0(2);     // big decoder only
4575     MEM    : S3(2);     // any mem
4576 %}
4577 
4578 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
4579 %{
4580     instruction_count(3);
4581     src1   : S3(read);
4582     src2   : S3(read);
4583     dst    : S4(read);
4584     D0     : S0(3);     // big decoder only
4585     FPU    : S4;
4586     MEM    : S3(3);     // any mem
4587 %}
4588 
4589 pipe_class fpu_mem_reg_con(memory mem, regD src1)
4590 %{
4591     instruction_count(3);
4592     src1   : S4(read);
4593     mem    : S4(read);
4594     DECODE : S0;        // any decoder for FPU PUSH
4595     D0     : S0(2);     // big decoder only
4596     FPU    : S4;
4597     MEM    : S3(2);     // any mem
4598 %}
4599 
4600 // Float load constant
4601 pipe_class fpu_reg_con(regD dst)
4602 %{
4603     instruction_count(2);
4604     dst    : S5(write);
4605     D0     : S0;        // big decoder only for the load
4606     DECODE : S1;        // any decoder for FPU POP
4607     FPU    : S4;
4608     MEM    : S3;        // any mem
4609 %}
4610 
4611 // Float load constant
4612 pipe_class fpu_reg_reg_con(regD dst, regD src)
4613 %{
4614     instruction_count(3);
4615     dst    : S5(write);
4616     src    : S3(read);
4617     D0     : S0;        // big decoder only for the load
4618     DECODE : S1(2);     // any decoder for FPU POP
4619     FPU    : S4;
4620     MEM    : S3;        // any mem
4621 %}
4622 
4623 // UnConditional branch
4624 pipe_class pipe_jmp(label labl)
4625 %{
4626     single_instruction;
4627     BR   : S3;
4628 %}
4629 
4630 // Conditional branch
4631 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
4632 %{
4633     single_instruction;
4634     cr    : S1(read);
4635     BR    : S3;
4636 %}
4637 
4638 // Allocation idiom
4639 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
4640 %{
4641     instruction_count(1); force_serialization;
4642     fixed_latency(6);
4643     heap_ptr : S3(read);
4644     DECODE   : S0(3);
4645     D0       : S2;
4646     MEM      : S3;
4647     ALU      : S3(2);
4648     dst      : S5(write);
4649     BR       : S5;
4650 %}
4651 
4652 // Generic big/slow expanded idiom
4653 pipe_class pipe_slow()
4654 %{
4655     instruction_count(10); multiple_bundles; force_serialization;
4656     fixed_latency(100);
4657     D0  : S0(2);
4658     MEM : S3(2);
4659 %}
4660 
4661 // The real do-nothing guy
4662 pipe_class empty()
4663 %{
4664     instruction_count(0);
4665 %}
4666 
4667 // Define the class for the Nop node
4668 define
4669 %{
4670    MachNop = empty;
4671 %}
4672 
4673 %}
4674 
4675 //----------INSTRUCTIONS-------------------------------------------------------
4676 //
4677 // match      -- States which machine-independent subtree may be replaced
4678 //               by this instruction.
4679 // ins_cost   -- The estimated cost of this instruction is used by instruction
4680 //               selection to identify a minimum cost tree of machine
4681 //               instructions that matches a tree of machine-independent
4682 //               instructions.
4683 // format     -- A string providing the disassembly for this instruction.
4684 //               The value of an instruction's operand may be inserted
4685 //               by referring to it with a '$' prefix.
4686 // opcode     -- Three instruction opcodes may be provided.  These are referred
4687 //               to within an encode class as $primary, $secondary, and $tertiary
4688 //               rrspectively.  The primary opcode is commonly used to
4689 //               indicate the type of machine instruction, while secondary
4690 //               and tertiary are often used for prefix options or addressing
4691 //               modes.
4692 // ins_encode -- A list of encode classes with parameters. The encode class
4693 //               name must have been defined in an 'enc_class' specification
4694 //               in the encode section of the architecture description.
4695 
4696 
4697 //----------Load/Store/Move Instructions---------------------------------------
4698 //----------Load Instructions--------------------------------------------------
4699 
4700 // Load Byte (8 bit signed)
4701 instruct loadB(rRegI dst, memory mem)
4702 %{
4703   match(Set dst (LoadB mem));
4704 
4705   ins_cost(125);
4706   format %{ "movsbl  $dst, $mem\t# byte" %}
4707 
4708   ins_encode %{
4709     __ movsbl($dst$$Register, $mem$$Address);
4710   %}
4711 
4712   ins_pipe(ialu_reg_mem);
4713 %}
4714 
4715 // Load Byte (8 bit signed) into Long Register
4716 instruct loadB2L(rRegL dst, memory mem)
4717 %{
4718   match(Set dst (ConvI2L (LoadB mem)));
4719 
4720   ins_cost(125);
4721   format %{ "movsbq  $dst, $mem\t# byte -&gt; long" %}
4722 
4723   ins_encode %{
4724     __ movsbq($dst$$Register, $mem$$Address);
4725   %}
4726 
4727   ins_pipe(ialu_reg_mem);
4728 %}
4729 
4730 // Load Unsigned Byte (8 bit UNsigned)
4731 instruct loadUB(rRegI dst, memory mem)
4732 %{
4733   match(Set dst (LoadUB mem));
4734 
4735   ins_cost(125);
4736   format %{ "movzbl  $dst, $mem\t# ubyte" %}
4737 
4738   ins_encode %{
4739     __ movzbl($dst$$Register, $mem$$Address);
4740   %}
4741 
4742   ins_pipe(ialu_reg_mem);
4743 %}
4744 
4745 // Load Unsigned Byte (8 bit UNsigned) into Long Register
4746 instruct loadUB2L(rRegL dst, memory mem)
4747 %{
4748   match(Set dst (ConvI2L (LoadUB mem)));
4749 
4750   ins_cost(125);
4751   format %{ "movzbq  $dst, $mem\t# ubyte -&gt; long" %}
4752 
4753   ins_encode %{
4754     __ movzbq($dst$$Register, $mem$$Address);
4755   %}
4756 
4757   ins_pipe(ialu_reg_mem);
4758 %}
4759 
4760 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
4761 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4762   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
4763   effect(KILL cr);
4764 
4765   format %{ "movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t"
4766             "andl    $dst, right_n_bits($mask, 8)" %}
4767   ins_encode %{
4768     Register Rdst = $dst$$Register;
4769     __ movzbq(Rdst, $mem$$Address);
4770     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
4771   %}
4772   ins_pipe(ialu_reg_mem);
4773 %}
4774 
4775 // Load Short (16 bit signed)
4776 instruct loadS(rRegI dst, memory mem)
4777 %{
4778   match(Set dst (LoadS mem));
4779 
4780   ins_cost(125);
4781   format %{ "movswl $dst, $mem\t# short" %}
4782 
4783   ins_encode %{
4784     __ movswl($dst$$Register, $mem$$Address);
4785   %}
4786 
4787   ins_pipe(ialu_reg_mem);
4788 %}
4789 
4790 // Load Short (16 bit signed) to Byte (8 bit signed)
4791 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4792   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
4793 
4794   ins_cost(125);
4795   format %{ "movsbl $dst, $mem\t# short -&gt; byte" %}
4796   ins_encode %{
4797     __ movsbl($dst$$Register, $mem$$Address);
4798   %}
4799   ins_pipe(ialu_reg_mem);
4800 %}
4801 
4802 // Load Short (16 bit signed) into Long Register
4803 instruct loadS2L(rRegL dst, memory mem)
4804 %{
4805   match(Set dst (ConvI2L (LoadS mem)));
4806 
4807   ins_cost(125);
4808   format %{ "movswq $dst, $mem\t# short -&gt; long" %}
4809 
4810   ins_encode %{
4811     __ movswq($dst$$Register, $mem$$Address);
4812   %}
4813 
4814   ins_pipe(ialu_reg_mem);
4815 %}
4816 
4817 // Load Unsigned Short/Char (16 bit UNsigned)
4818 instruct loadUS(rRegI dst, memory mem)
4819 %{
4820   match(Set dst (LoadUS mem));
4821 
4822   ins_cost(125);
4823   format %{ "movzwl  $dst, $mem\t# ushort/char" %}
4824 
4825   ins_encode %{
4826     __ movzwl($dst$$Register, $mem$$Address);
4827   %}
4828 
4829   ins_pipe(ialu_reg_mem);
4830 %}
4831 
4832 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
4833 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4834   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
4835 
4836   ins_cost(125);
4837   format %{ "movsbl $dst, $mem\t# ushort -&gt; byte" %}
4838   ins_encode %{
4839     __ movsbl($dst$$Register, $mem$$Address);
4840   %}
4841   ins_pipe(ialu_reg_mem);
4842 %}
4843 
4844 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
4845 instruct loadUS2L(rRegL dst, memory mem)
4846 %{
4847   match(Set dst (ConvI2L (LoadUS mem)));
4848 
4849   ins_cost(125);
4850   format %{ "movzwq  $dst, $mem\t# ushort/char -&gt; long" %}
4851 
4852   ins_encode %{
4853     __ movzwq($dst$$Register, $mem$$Address);
4854   %}
4855 
4856   ins_pipe(ialu_reg_mem);
4857 %}
4858 
4859 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
4860 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4861   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4862 
4863   format %{ "movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long" %}
4864   ins_encode %{
4865     __ movzbq($dst$$Register, $mem$$Address);
4866   %}
4867   ins_pipe(ialu_reg_mem);
4868 %}
4869 
4870 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
4871 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4872   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4873   effect(KILL cr);
4874 
4875   format %{ "movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t"
4876             "andl    $dst, right_n_bits($mask, 16)" %}
4877   ins_encode %{
4878     Register Rdst = $dst$$Register;
4879     __ movzwq(Rdst, $mem$$Address);
4880     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
4881   %}
4882   ins_pipe(ialu_reg_mem);
4883 %}
4884 
4885 // Load Integer
4886 instruct loadI(rRegI dst, memory mem)
4887 %{
4888   match(Set dst (LoadI mem));
4889 
4890   ins_cost(125);
4891   format %{ "movl    $dst, $mem\t# int" %}
4892 
4893   ins_encode %{
4894     __ movl($dst$$Register, $mem$$Address);
4895   %}
4896 
4897   ins_pipe(ialu_reg_mem);
4898 %}
4899 
4900 // Load Integer (32 bit signed) to Byte (8 bit signed)
4901 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4902   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
4903 
4904   ins_cost(125);
4905   format %{ "movsbl  $dst, $mem\t# int -&gt; byte" %}
4906   ins_encode %{
4907     __ movsbl($dst$$Register, $mem$$Address);
4908   %}
4909   ins_pipe(ialu_reg_mem);
4910 %}
4911 
4912 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
4913 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
4914   match(Set dst (AndI (LoadI mem) mask));
4915 
4916   ins_cost(125);
4917   format %{ "movzbl  $dst, $mem\t# int -&gt; ubyte" %}
4918   ins_encode %{
4919     __ movzbl($dst$$Register, $mem$$Address);
4920   %}
4921   ins_pipe(ialu_reg_mem);
4922 %}
4923 
4924 // Load Integer (32 bit signed) to Short (16 bit signed)
4925 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
4926   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
4927 
4928   ins_cost(125);
4929   format %{ "movswl  $dst, $mem\t# int -&gt; short" %}
4930   ins_encode %{
4931     __ movswl($dst$$Register, $mem$$Address);
4932   %}
4933   ins_pipe(ialu_reg_mem);
4934 %}
4935 
4936 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
4937 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
4938   match(Set dst (AndI (LoadI mem) mask));
4939 
4940   ins_cost(125);
4941   format %{ "movzwl  $dst, $mem\t# int -&gt; ushort/char" %}
4942   ins_encode %{
4943     __ movzwl($dst$$Register, $mem$$Address);
4944   %}
4945   ins_pipe(ialu_reg_mem);
4946 %}
4947 
4948 // Load Integer into Long Register
4949 instruct loadI2L(rRegL dst, memory mem)
4950 %{
4951   match(Set dst (ConvI2L (LoadI mem)));
4952 
4953   ins_cost(125);
4954   format %{ "movslq  $dst, $mem\t# int -&gt; long" %}
4955 
4956   ins_encode %{
4957     __ movslq($dst$$Register, $mem$$Address);
4958   %}
4959 
4960   ins_pipe(ialu_reg_mem);
4961 %}
4962 
4963 // Load Integer with mask 0xFF into Long Register
4964 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4965   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4966 
4967   format %{ "movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long" %}
4968   ins_encode %{
4969     __ movzbq($dst$$Register, $mem$$Address);
4970   %}
4971   ins_pipe(ialu_reg_mem);
4972 %}
4973 
4974 // Load Integer with mask 0xFFFF into Long Register
4975 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
4976   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4977 
4978   format %{ "movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long" %}
4979   ins_encode %{
4980     __ movzwq($dst$$Register, $mem$$Address);
4981   %}
4982   ins_pipe(ialu_reg_mem);
4983 %}
4984 
4985 // Load Integer with a 31-bit mask into Long Register
4986 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
4987   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4988   effect(KILL cr);
4989 
4990   format %{ "movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t"
4991             "andl    $dst, $mask" %}
4992   ins_encode %{
4993     Register Rdst = $dst$$Register;
4994     __ movl(Rdst, $mem$$Address);
4995     __ andl(Rdst, $mask$$constant);
4996   %}
4997   ins_pipe(ialu_reg_mem);
4998 %}
4999 
5000 // Load Unsigned Integer into Long Register
5001 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
5002 %{
5003   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
5004 
5005   ins_cost(125);
5006   format %{ "movl    $dst, $mem\t# uint -&gt; long" %}
5007 
5008   ins_encode %{
5009     __ movl($dst$$Register, $mem$$Address);
5010   %}
5011 
5012   ins_pipe(ialu_reg_mem);
5013 %}
5014 
5015 // Load Long
5016 instruct loadL(rRegL dst, memory mem)
5017 %{
5018   match(Set dst (LoadL mem));
5019 
5020   ins_cost(125);
5021   format %{ "movq    $dst, $mem\t# long" %}
5022 
5023   ins_encode %{
5024     __ movq($dst$$Register, $mem$$Address);
5025   %}
5026 
5027   ins_pipe(ialu_reg_mem); // XXX
5028 %}
5029 
5030 // Load Range
5031 instruct loadRange(rRegI dst, memory mem)
5032 %{
5033   match(Set dst (LoadRange mem));
5034 
5035   ins_cost(125); // XXX
5036   format %{ "movl    $dst, $mem\t# range" %}
5037   opcode(0x8B);
5038   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
5039   ins_pipe(ialu_reg_mem);
5040 %}
5041 
5042 // Load Pointer
5043 instruct loadP(rRegP dst, memory mem)
5044 %{
5045   match(Set dst (LoadP mem));
5046 
5047   ins_cost(125); // XXX
5048   format %{ "movq    $dst, $mem\t# ptr" %}
5049   opcode(0x8B);
5050   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5051   ins_pipe(ialu_reg_mem); // XXX
5052 %}
5053 
5054 // Load Compressed Pointer
5055 instruct loadN(rRegN dst, memory mem)
5056 %{
5057    match(Set dst (LoadN mem));
5058 
5059    ins_cost(125); // XXX
5060    format %{ "movl    $dst, $mem\t# compressed ptr" %}
5061    ins_encode %{
5062      __ movl($dst$$Register, $mem$$Address);
5063    %}
5064    ins_pipe(ialu_reg_mem); // XXX
5065 %}
5066 
5067 
5068 // Load Klass Pointer
5069 instruct loadKlass(rRegP dst, memory mem)
5070 %{
5071   match(Set dst (LoadKlass mem));
5072 
5073   ins_cost(125); // XXX
5074   format %{ "movq    $dst, $mem\t# class" %}
5075   opcode(0x8B);
5076   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5077   ins_pipe(ialu_reg_mem); // XXX
5078 %}
5079 
5080 // Load narrow Klass Pointer
5081 instruct loadNKlass(rRegN dst, memory mem)
5082 %{
5083   match(Set dst (LoadNKlass mem));
5084 
5085   ins_cost(125); // XXX
5086   format %{ "movl    $dst, $mem\t# compressed klass ptr" %}
5087   ins_encode %{
5088     __ movl($dst$$Register, $mem$$Address);
5089   %}
5090   ins_pipe(ialu_reg_mem); // XXX
5091 %}
5092 
5093 // Load Float
5094 instruct loadF(regF dst, memory mem)
5095 %{
5096   match(Set dst (LoadF mem));
5097 
5098   ins_cost(145); // XXX
5099   format %{ "movss   $dst, $mem\t# float" %}
5100   ins_encode %{
5101     __ movflt($dst$$XMMRegister, $mem$$Address);
5102   %}
5103   ins_pipe(pipe_slow); // XXX
5104 %}
5105 
5106 // Load Double
5107 instruct loadD_partial(regD dst, memory mem)
5108 %{
5109   predicate(!UseXmmLoadAndClearUpper);
5110   match(Set dst (LoadD mem));
5111 
5112   ins_cost(145); // XXX
5113   format %{ "movlpd  $dst, $mem\t# double" %}
5114   ins_encode %{
5115     __ movdbl($dst$$XMMRegister, $mem$$Address);
5116   %}
5117   ins_pipe(pipe_slow); // XXX
5118 %}
5119 
5120 instruct loadD(regD dst, memory mem)
5121 %{
5122   predicate(UseXmmLoadAndClearUpper);
5123   match(Set dst (LoadD mem));
5124 
5125   ins_cost(145); // XXX
5126   format %{ "movsd   $dst, $mem\t# double" %}
5127   ins_encode %{
5128     __ movdbl($dst$$XMMRegister, $mem$$Address);
5129   %}
5130   ins_pipe(pipe_slow); // XXX
5131 %}
5132 
5133 // Load Effective Address
5134 instruct leaP8(rRegP dst, indOffset8 mem)
5135 %{
5136   match(Set dst mem);
5137 
5138   ins_cost(110); // XXX
5139   format %{ "leaq    $dst, $mem\t# ptr 8" %}
5140   opcode(0x8D);
5141   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5142   ins_pipe(ialu_reg_reg_fat);
5143 %}
5144 
5145 instruct leaP32(rRegP dst, indOffset32 mem)
5146 %{
5147   match(Set dst mem);
5148 
5149   ins_cost(110);
5150   format %{ "leaq    $dst, $mem\t# ptr 32" %}
5151   opcode(0x8D);
5152   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5153   ins_pipe(ialu_reg_reg_fat);
5154 %}
5155 
5156 // instruct leaPIdx(rRegP dst, indIndex mem)
5157 // %{
5158 //   match(Set dst mem);
5159 
5160 //   ins_cost(110);
5161 //   format %{ "leaq    $dst, $mem\t# ptr idx" %}
5162 //   opcode(0x8D);
5163 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5164 //   ins_pipe(ialu_reg_reg_fat);
5165 // %}
5166 
5167 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
5168 %{
5169   match(Set dst mem);
5170 
5171   ins_cost(110);
5172   format %{ "leaq    $dst, $mem\t# ptr idxoff" %}
5173   opcode(0x8D);
5174   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5175   ins_pipe(ialu_reg_reg_fat);
5176 %}
5177 
5178 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
5179 %{
5180   match(Set dst mem);
5181 
5182   ins_cost(110);
5183   format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
5184   opcode(0x8D);
5185   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5186   ins_pipe(ialu_reg_reg_fat);
5187 %}
5188 
5189 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
5190 %{
5191   match(Set dst mem);
5192 
5193   ins_cost(110);
5194   format %{ "leaq    $dst, $mem\t# ptr idxscaleoff" %}
5195   opcode(0x8D);
5196   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5197   ins_pipe(ialu_reg_reg_fat);
5198 %}
5199 
5200 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
5201 %{
5202   match(Set dst mem);
5203 
5204   ins_cost(110);
5205   format %{ "leaq    $dst, $mem\t# ptr posidxoff" %}
5206   opcode(0x8D);
5207   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5208   ins_pipe(ialu_reg_reg_fat);
5209 %}
5210 
5211 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
5212 %{
5213   match(Set dst mem);
5214 
5215   ins_cost(110);
5216   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoff" %}
5217   opcode(0x8D);
5218   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5219   ins_pipe(ialu_reg_reg_fat);
5220 %}
5221 
5222 // Load Effective Address which uses Narrow (32-bits) oop
5223 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
5224 %{
5225   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));
5226   match(Set dst mem);
5227 
5228   ins_cost(110);
5229   format %{ "leaq    $dst, $mem\t# ptr compressedoopoff32" %}
5230   opcode(0x8D);
5231   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5232   ins_pipe(ialu_reg_reg_fat);
5233 %}
5234 
5235 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
5236 %{
5237   predicate(Universe::narrow_oop_shift() == 0);
5238   match(Set dst mem);
5239 
5240   ins_cost(110); // XXX
5241   format %{ "leaq    $dst, $mem\t# ptr off8narrow" %}
5242   opcode(0x8D);
5243   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5244   ins_pipe(ialu_reg_reg_fat);
5245 %}
5246 
5247 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
5248 %{
5249   predicate(Universe::narrow_oop_shift() == 0);
5250   match(Set dst mem);
5251 
5252   ins_cost(110);
5253   format %{ "leaq    $dst, $mem\t# ptr off32narrow" %}
5254   opcode(0x8D);
5255   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5256   ins_pipe(ialu_reg_reg_fat);
5257 %}
5258 
5259 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
5260 %{
5261   predicate(Universe::narrow_oop_shift() == 0);
5262   match(Set dst mem);
5263 
5264   ins_cost(110);
5265   format %{ "leaq    $dst, $mem\t# ptr idxoffnarrow" %}
5266   opcode(0x8D);
5267   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5268   ins_pipe(ialu_reg_reg_fat);
5269 %}
5270 
5271 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
5272 %{
5273   predicate(Universe::narrow_oop_shift() == 0);
5274   match(Set dst mem);
5275 
5276   ins_cost(110);
5277   format %{ "leaq    $dst, $mem\t# ptr idxscalenarrow" %}
5278   opcode(0x8D);
5279   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5280   ins_pipe(ialu_reg_reg_fat);
5281 %}
5282 
5283 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
5284 %{
5285   predicate(Universe::narrow_oop_shift() == 0);
5286   match(Set dst mem);
5287 
5288   ins_cost(110);
5289   format %{ "leaq    $dst, $mem\t# ptr idxscaleoffnarrow" %}
5290   opcode(0x8D);
5291   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5292   ins_pipe(ialu_reg_reg_fat);
5293 %}
5294 
5295 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
5296 %{
5297   predicate(Universe::narrow_oop_shift() == 0);
5298   match(Set dst mem);
5299 
5300   ins_cost(110);
5301   format %{ "leaq    $dst, $mem\t# ptr posidxoffnarrow" %}
5302   opcode(0x8D);
5303   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5304   ins_pipe(ialu_reg_reg_fat);
5305 %}
5306 
5307 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
5308 %{
5309   predicate(Universe::narrow_oop_shift() == 0);
5310   match(Set dst mem);
5311 
5312   ins_cost(110);
5313   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoffnarrow" %}
5314   opcode(0x8D);
5315   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5316   ins_pipe(ialu_reg_reg_fat);
5317 %}
5318 
5319 instruct loadConI(rRegI dst, immI src)
5320 %{
5321   match(Set dst src);
5322 
5323   format %{ "movl    $dst, $src\t# int" %}
5324   ins_encode(load_immI(dst, src));
5325   ins_pipe(ialu_reg_fat); // XXX
5326 %}
5327 
5328 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
5329 %{
5330   match(Set dst src);
5331   effect(KILL cr);
5332 
5333   ins_cost(50);
5334   format %{ "xorl    $dst, $dst\t# int" %}
5335   opcode(0x33); /* + rd */
5336   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5337   ins_pipe(ialu_reg);
5338 %}
5339 
5340 instruct loadConL(rRegL dst, immL src)
5341 %{
5342   match(Set dst src);
5343 
5344   ins_cost(150);
5345   format %{ "movq    $dst, $src\t# long" %}
5346   ins_encode(load_immL(dst, src));
5347   ins_pipe(ialu_reg);
5348 %}
5349 
5350 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
5351 %{
5352   match(Set dst src);
5353   effect(KILL cr);
5354 
5355   ins_cost(50);
5356   format %{ "xorl    $dst, $dst\t# long" %}
5357   opcode(0x33); /* + rd */
5358   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5359   ins_pipe(ialu_reg); // XXX
5360 %}
5361 
5362 instruct loadConUL32(rRegL dst, immUL32 src)
5363 %{
5364   match(Set dst src);
5365 
5366   ins_cost(60);
5367   format %{ "movl    $dst, $src\t# long (unsigned 32-bit)" %}
5368   ins_encode(load_immUL32(dst, src));
5369   ins_pipe(ialu_reg);
5370 %}
5371 
5372 instruct loadConL32(rRegL dst, immL32 src)
5373 %{
5374   match(Set dst src);
5375 
5376   ins_cost(70);
5377   format %{ "movq    $dst, $src\t# long (32-bit)" %}
5378   ins_encode(load_immL32(dst, src));
5379   ins_pipe(ialu_reg);
5380 %}
5381 
5382 instruct loadConP(rRegP dst, immP con) %{
5383   match(Set dst con);
5384 
5385   format %{ "movq    $dst, $con\t# ptr" %}
5386   ins_encode(load_immP(dst, con));
5387   ins_pipe(ialu_reg_fat); // XXX
5388 %}
5389 
5390 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
5391 %{
5392   match(Set dst src);
5393   effect(KILL cr);
5394 
5395   ins_cost(50);
5396   format %{ "xorl    $dst, $dst\t# ptr" %}
5397   opcode(0x33); /* + rd */
5398   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5399   ins_pipe(ialu_reg);
5400 %}
5401 
5402 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
5403 %{
5404   match(Set dst src);
5405   effect(KILL cr);
5406 
5407   ins_cost(60);
5408   format %{ "movl    $dst, $src\t# ptr (positive 32-bit)" %}
5409   ins_encode(load_immP31(dst, src));
5410   ins_pipe(ialu_reg);
5411 %}
5412 
5413 instruct loadConF(regF dst, immF con) %{
5414   match(Set dst con);
5415   ins_cost(125);
5416   format %{ "movss   $dst, [$constantaddress]\t# load from constant table: float=$con" %}
5417   ins_encode %{
5418     __ movflt($dst$$XMMRegister, $constantaddress($con));
5419   %}
5420   ins_pipe(pipe_slow);
5421 %}
5422 
5423 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
5424   match(Set dst src);
5425   effect(KILL cr);
5426   format %{ "xorq    $dst, $src\t# compressed NULL ptr" %}
5427   ins_encode %{
5428     __ xorq($dst$$Register, $dst$$Register);
5429   %}
5430   ins_pipe(ialu_reg);
5431 %}
5432 
5433 instruct loadConN(rRegN dst, immN src) %{
5434   match(Set dst src);
5435 
5436   ins_cost(125);
5437   format %{ "movl    $dst, $src\t# compressed ptr" %}
5438   ins_encode %{
5439     address con = (address)$src$$constant;
5440     if (con == NULL) {
5441       ShouldNotReachHere();
5442     } else {
5443       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
5444     }
5445   %}
5446   ins_pipe(ialu_reg_fat); // XXX
5447 %}
5448 
5449 instruct loadConNKlass(rRegN dst, immNKlass src) %{
5450   match(Set dst src);
5451 
5452   ins_cost(125);
5453   format %{ "movl    $dst, $src\t# compressed klass ptr" %}
5454   ins_encode %{
5455     address con = (address)$src$$constant;
5456     if (con == NULL) {
5457       ShouldNotReachHere();
5458     } else {
5459       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
5460     }
5461   %}
5462   ins_pipe(ialu_reg_fat); // XXX
5463 %}
5464 
5465 instruct loadConF0(regF dst, immF0 src)
5466 %{
5467   match(Set dst src);
5468   ins_cost(100);
5469 
5470   format %{ "xorps   $dst, $dst\t# float 0.0" %}
5471   ins_encode %{
5472     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
5473   %}
5474   ins_pipe(pipe_slow);
5475 %}
5476 
5477 // Use the same format since predicate() can not be used here.
5478 instruct loadConD(regD dst, immD con) %{
5479   match(Set dst con);
5480   ins_cost(125);
5481   format %{ "movsd   $dst, [$constantaddress]\t# load from constant table: double=$con" %}
5482   ins_encode %{
5483     __ movdbl($dst$$XMMRegister, $constantaddress($con));
5484   %}
5485   ins_pipe(pipe_slow);
5486 %}
5487 
5488 instruct loadConD0(regD dst, immD0 src)
5489 %{
5490   match(Set dst src);
5491   ins_cost(100);
5492 
5493   format %{ "xorpd   $dst, $dst\t# double 0.0" %}
5494   ins_encode %{
5495     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
5496   %}
5497   ins_pipe(pipe_slow);
5498 %}
5499 
5500 instruct loadSSI(rRegI dst, stackSlotI src)
5501 %{
5502   match(Set dst src);
5503 
5504   ins_cost(125);
5505   format %{ "movl    $dst, $src\t# int stk" %}
5506   opcode(0x8B);
5507   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
5508   ins_pipe(ialu_reg_mem);
5509 %}
5510 
5511 instruct loadSSL(rRegL dst, stackSlotL src)
5512 %{
5513   match(Set dst src);
5514 
5515   ins_cost(125);
5516   format %{ "movq    $dst, $src\t# long stk" %}
5517   opcode(0x8B);
5518   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5519   ins_pipe(ialu_reg_mem);
5520 %}
5521 
5522 instruct loadSSP(rRegP dst, stackSlotP src)
5523 %{
5524   match(Set dst src);
5525 
5526   ins_cost(125);
5527   format %{ "movq    $dst, $src\t# ptr stk" %}
5528   opcode(0x8B);
5529   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5530   ins_pipe(ialu_reg_mem);
5531 %}
5532 
5533 instruct loadSSF(regF dst, stackSlotF src)
5534 %{
5535   match(Set dst src);
5536 
5537   ins_cost(125);
5538   format %{ "movss   $dst, $src\t# float stk" %}
5539   ins_encode %{
5540     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
5541   %}
5542   ins_pipe(pipe_slow); // XXX
5543 %}
5544 
5545 // Use the same format since predicate() can not be used here.
5546 instruct loadSSD(regD dst, stackSlotD src)
5547 %{
5548   match(Set dst src);
5549 
5550   ins_cost(125);
5551   format %{ "movsd   $dst, $src\t# double stk" %}
5552   ins_encode  %{
5553     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
5554   %}
5555   ins_pipe(pipe_slow); // XXX
5556 %}
5557 
5558 // Prefetch instructions for allocation.
5559 // Must be safe to execute with invalid address (cannot fault).
5560 
5561 instruct prefetchAlloc( memory mem ) %{
5562   predicate(AllocatePrefetchInstr==3);
5563   match(PrefetchAllocation mem);
5564   ins_cost(125);
5565 
5566   format %{ "PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified" %}
5567   ins_encode %{
5568     __ prefetchw($mem$$Address);
5569   %}
5570   ins_pipe(ialu_mem);
5571 %}
5572 
5573 instruct prefetchAllocNTA( memory mem ) %{
5574   predicate(AllocatePrefetchInstr==0);
5575   match(PrefetchAllocation mem);
5576   ins_cost(125);
5577 
5578   format %{ "PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write" %}
5579   ins_encode %{
5580     __ prefetchnta($mem$$Address);
5581   %}
5582   ins_pipe(ialu_mem);
5583 %}
5584 
5585 instruct prefetchAllocT0( memory mem ) %{
5586   predicate(AllocatePrefetchInstr==1);
5587   match(PrefetchAllocation mem);
5588   ins_cost(125);
5589 
5590   format %{ "PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write" %}
5591   ins_encode %{
5592     __ prefetcht0($mem$$Address);
5593   %}
5594   ins_pipe(ialu_mem);
5595 %}
5596 
5597 instruct prefetchAllocT2( memory mem ) %{
5598   predicate(AllocatePrefetchInstr==2);
5599   match(PrefetchAllocation mem);
5600   ins_cost(125);
5601 
5602   format %{ "PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write" %}
5603   ins_encode %{
5604     __ prefetcht2($mem$$Address);
5605   %}
5606   ins_pipe(ialu_mem);
5607 %}
5608 
5609 //----------Store Instructions-------------------------------------------------
5610 
5611 // Store Byte
5612 instruct storeB(memory mem, rRegI src)
5613 %{
5614   match(Set mem (StoreB mem src));
5615 
5616   ins_cost(125); // XXX
5617   format %{ "movb    $mem, $src\t# byte" %}
5618   opcode(0x88);
5619   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
5620   ins_pipe(ialu_mem_reg);
5621 %}
5622 
5623 // Store Char/Short
5624 instruct storeC(memory mem, rRegI src)
5625 %{
5626   match(Set mem (StoreC mem src));
5627 
5628   ins_cost(125); // XXX
5629   format %{ "movw    $mem, $src\t# char/short" %}
5630   opcode(0x89);
5631   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5632   ins_pipe(ialu_mem_reg);
5633 %}
5634 
5635 // Store Integer
5636 instruct storeI(memory mem, rRegI src)
5637 %{
5638   match(Set mem (StoreI mem src));
5639 
5640   ins_cost(125); // XXX
5641   format %{ "movl    $mem, $src\t# int" %}
5642   opcode(0x89);
5643   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5644   ins_pipe(ialu_mem_reg);
5645 %}
5646 
5647 // Store Long
5648 instruct storeL(memory mem, rRegL src)
5649 %{
5650   match(Set mem (StoreL mem src));
5651 
5652   ins_cost(125); // XXX
5653   format %{ "movq    $mem, $src\t# long" %}
5654   opcode(0x89);
5655   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5656   ins_pipe(ialu_mem_reg); // XXX
5657 %}
5658 
5659 // Store Pointer
5660 instruct storeP(memory mem, any_RegP src)
5661 %{
5662   match(Set mem (StoreP mem src));
5663 
5664   ins_cost(125); // XXX
5665   format %{ "movq    $mem, $src\t# ptr" %}
5666   opcode(0x89);
5667   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5668   ins_pipe(ialu_mem_reg);
5669 %}
5670 
5671 instruct storeImmP0(memory mem, immP0 zero)
5672 %{
5673   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5674   match(Set mem (StoreP mem zero));
5675 
5676   ins_cost(125); // XXX
5677   format %{ "movq    $mem, R12\t# ptr (R12_heapbase==0)" %}
5678   ins_encode %{
5679     __ movq($mem$$Address, r12);
5680   %}
5681   ins_pipe(ialu_mem_reg);
5682 %}
5683 
5684 // Store NULL Pointer, mark word, or other simple pointer constant.
5685 instruct storeImmP(memory mem, immP31 src)
5686 %{
5687   match(Set mem (StoreP mem src));
5688 
5689   ins_cost(150); // XXX
5690   format %{ "movq    $mem, $src\t# ptr" %}
5691   opcode(0xC7); /* C7 /0 */
5692   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5693   ins_pipe(ialu_mem_imm);
5694 %}
5695 
5696 // Store Compressed Pointer
5697 instruct storeN(memory mem, rRegN src)
5698 %{
5699   match(Set mem (StoreN mem src));
5700 
5701   ins_cost(125); // XXX
5702   format %{ "movl    $mem, $src\t# compressed ptr" %}
5703   ins_encode %{
5704     __ movl($mem$$Address, $src$$Register);
5705   %}
5706   ins_pipe(ialu_mem_reg);
5707 %}
5708 
5709 instruct storeNKlass(memory mem, rRegN src)
5710 %{
5711   match(Set mem (StoreNKlass mem src));
5712 
5713   ins_cost(125); // XXX
5714   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5715   ins_encode %{
5716     __ movl($mem$$Address, $src$$Register);
5717   %}
5718   ins_pipe(ialu_mem_reg);
5719 %}
5720 
5721 instruct storeImmN0(memory mem, immN0 zero)
5722 %{
5723   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);
5724   match(Set mem (StoreN mem zero));
5725 
5726   ins_cost(125); // XXX
5727   format %{ "movl    $mem, R12\t# compressed ptr (R12_heapbase==0)" %}
5728   ins_encode %{
5729     __ movl($mem$$Address, r12);
5730   %}
5731   ins_pipe(ialu_mem_reg);
5732 %}
5733 
5734 instruct storeImmN(memory mem, immN src)
5735 %{
5736   match(Set mem (StoreN mem src));
5737 
5738   ins_cost(150); // XXX
5739   format %{ "movl    $mem, $src\t# compressed ptr" %}
5740   ins_encode %{
5741     address con = (address)$src$$constant;
5742     if (con == NULL) {
5743       __ movl($mem$$Address, (int32_t)0);
5744     } else {
5745       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
5746     }
5747   %}
5748   ins_pipe(ialu_mem_imm);
5749 %}
5750 
5751 instruct storeImmNKlass(memory mem, immNKlass src)
5752 %{
5753   match(Set mem (StoreNKlass mem src));
5754 
5755   ins_cost(150); // XXX
5756   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5757   ins_encode %{
5758     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
5759   %}
5760   ins_pipe(ialu_mem_imm);
5761 %}
5762 
5763 // Store Integer Immediate
5764 instruct storeImmI0(memory mem, immI0 zero)
5765 %{
5766   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5767   match(Set mem (StoreI mem zero));
5768 
5769   ins_cost(125); // XXX
5770   format %{ "movl    $mem, R12\t# int (R12_heapbase==0)" %}
5771   ins_encode %{
5772     __ movl($mem$$Address, r12);
5773   %}
5774   ins_pipe(ialu_mem_reg);
5775 %}
5776 
5777 instruct storeImmI(memory mem, immI src)
5778 %{
5779   match(Set mem (StoreI mem src));
5780 
5781   ins_cost(150);
5782   format %{ "movl    $mem, $src\t# int" %}
5783   opcode(0xC7); /* C7 /0 */
5784   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5785   ins_pipe(ialu_mem_imm);
5786 %}
5787 
5788 // Store Long Immediate
5789 instruct storeImmL0(memory mem, immL0 zero)
5790 %{
5791   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5792   match(Set mem (StoreL mem zero));
5793 
5794   ins_cost(125); // XXX
5795   format %{ "movq    $mem, R12\t# long (R12_heapbase==0)" %}
5796   ins_encode %{
5797     __ movq($mem$$Address, r12);
5798   %}
5799   ins_pipe(ialu_mem_reg);
5800 %}
5801 
5802 instruct storeImmL(memory mem, immL32 src)
5803 %{
5804   match(Set mem (StoreL mem src));
5805 
5806   ins_cost(150);
5807   format %{ "movq    $mem, $src\t# long" %}
5808   opcode(0xC7); /* C7 /0 */
5809   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5810   ins_pipe(ialu_mem_imm);
5811 %}
5812 
5813 // Store Short/Char Immediate
5814 instruct storeImmC0(memory mem, immI0 zero)
5815 %{
5816   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5817   match(Set mem (StoreC mem zero));
5818 
5819   ins_cost(125); // XXX
5820   format %{ "movw    $mem, R12\t# short/char (R12_heapbase==0)" %}
5821   ins_encode %{
5822     __ movw($mem$$Address, r12);
5823   %}
5824   ins_pipe(ialu_mem_reg);
5825 %}
5826 
5827 instruct storeImmI16(memory mem, immI16 src)
5828 %{
5829   predicate(UseStoreImmI16);
5830   match(Set mem (StoreC mem src));
5831 
5832   ins_cost(150);
5833   format %{ "movw    $mem, $src\t# short/char" %}
5834   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
5835   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
5836   ins_pipe(ialu_mem_imm);
5837 %}
5838 
5839 // Store Byte Immediate
5840 instruct storeImmB0(memory mem, immI0 zero)
5841 %{
5842   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5843   match(Set mem (StoreB mem zero));
5844 
5845   ins_cost(125); // XXX
5846   format %{ "movb    $mem, R12\t# short/char (R12_heapbase==0)" %}
5847   ins_encode %{
5848     __ movb($mem$$Address, r12);
5849   %}
5850   ins_pipe(ialu_mem_reg);
5851 %}
5852 
5853 instruct storeImmB(memory mem, immI8 src)
5854 %{
5855   match(Set mem (StoreB mem src));
5856 
5857   ins_cost(150); // XXX
5858   format %{ "movb    $mem, $src\t# byte" %}
5859   opcode(0xC6); /* C6 /0 */
5860   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5861   ins_pipe(ialu_mem_imm);
5862 %}
5863 
5864 // Store CMS card-mark Immediate
5865 instruct storeImmCM0_reg(memory mem, immI0 zero)
5866 %{
5867   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5868   match(Set mem (StoreCM mem zero));
5869 
5870   ins_cost(125); // XXX
5871   format %{ "movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)" %}
5872   ins_encode %{
5873     __ movb($mem$$Address, r12);
5874   %}
5875   ins_pipe(ialu_mem_reg);
5876 %}
5877 
5878 instruct storeImmCM0(memory mem, immI0 src)
5879 %{
5880   match(Set mem (StoreCM mem src));
5881 
5882   ins_cost(150); // XXX
5883   format %{ "movb    $mem, $src\t# CMS card-mark byte 0" %}
5884   opcode(0xC6); /* C6 /0 */
5885   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5886   ins_pipe(ialu_mem_imm);
5887 %}
5888 
5889 // Store Float
5890 instruct storeF(memory mem, regF src)
5891 %{
5892   match(Set mem (StoreF mem src));
5893 
5894   ins_cost(95); // XXX
5895   format %{ "movss   $mem, $src\t# float" %}
5896   ins_encode %{
5897     __ movflt($mem$$Address, $src$$XMMRegister);
5898   %}
5899   ins_pipe(pipe_slow); // XXX
5900 %}
5901 
5902 // Store immediate Float value (it is faster than store from XMM register)
5903 instruct storeF0(memory mem, immF0 zero)
5904 %{
5905   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5906   match(Set mem (StoreF mem zero));
5907 
5908   ins_cost(25); // XXX
5909   format %{ "movl    $mem, R12\t# float 0. (R12_heapbase==0)" %}
5910   ins_encode %{
5911     __ movl($mem$$Address, r12);
5912   %}
5913   ins_pipe(ialu_mem_reg);
5914 %}
5915 
5916 instruct storeF_imm(memory mem, immF src)
5917 %{
5918   match(Set mem (StoreF mem src));
5919 
5920   ins_cost(50);
5921   format %{ "movl    $mem, $src\t# float" %}
5922   opcode(0xC7); /* C7 /0 */
5923   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5924   ins_pipe(ialu_mem_imm);
5925 %}
5926 
5927 // Store Double
5928 instruct storeD(memory mem, regD src)
5929 %{
5930   match(Set mem (StoreD mem src));
5931 
5932   ins_cost(95); // XXX
5933   format %{ "movsd   $mem, $src\t# double" %}
5934   ins_encode %{
5935     __ movdbl($mem$$Address, $src$$XMMRegister);
5936   %}
5937   ins_pipe(pipe_slow); // XXX
5938 %}
5939 
5940 // Store immediate double 0.0 (it is faster than store from XMM register)
5941 instruct storeD0_imm(memory mem, immD0 src)
5942 %{
5943   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
5944   match(Set mem (StoreD mem src));
5945 
5946   ins_cost(50);
5947   format %{ "movq    $mem, $src\t# double 0." %}
5948   opcode(0xC7); /* C7 /0 */
5949   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5950   ins_pipe(ialu_mem_imm);
5951 %}
5952 
5953 instruct storeD0(memory mem, immD0 zero)
5954 %{
5955   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5956   match(Set mem (StoreD mem zero));
5957 
5958   ins_cost(25); // XXX
5959   format %{ "movq    $mem, R12\t# double 0. (R12_heapbase==0)" %}
5960   ins_encode %{
5961     __ movq($mem$$Address, r12);
5962   %}
5963   ins_pipe(ialu_mem_reg);
5964 %}
5965 
5966 instruct storeSSI(stackSlotI dst, rRegI src)
5967 %{
5968   match(Set dst src);
5969 
5970   ins_cost(100);
5971   format %{ "movl    $dst, $src\t# int stk" %}
5972   opcode(0x89);
5973   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
5974   ins_pipe( ialu_mem_reg );
5975 %}
5976 
5977 instruct storeSSL(stackSlotL dst, rRegL src)
5978 %{
5979   match(Set dst src);
5980 
5981   ins_cost(100);
5982   format %{ "movq    $dst, $src\t# long stk" %}
5983   opcode(0x89);
5984   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5985   ins_pipe(ialu_mem_reg);
5986 %}
5987 
5988 instruct storeSSP(stackSlotP dst, rRegP src)
5989 %{
5990   match(Set dst src);
5991 
5992   ins_cost(100);
5993   format %{ "movq    $dst, $src\t# ptr stk" %}
5994   opcode(0x89);
5995   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5996   ins_pipe(ialu_mem_reg);
5997 %}
5998 
5999 instruct storeSSF(stackSlotF dst, regF src)
6000 %{
6001   match(Set dst src);
6002 
6003   ins_cost(95); // XXX
6004   format %{ "movss   $dst, $src\t# float stk" %}
6005   ins_encode %{
6006     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
6007   %}
6008   ins_pipe(pipe_slow); // XXX
6009 %}
6010 
6011 instruct storeSSD(stackSlotD dst, regD src)
6012 %{
6013   match(Set dst src);
6014 
6015   ins_cost(95); // XXX
6016   format %{ "movsd   $dst, $src\t# double stk" %}
6017   ins_encode %{
6018     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
6019   %}
6020   ins_pipe(pipe_slow); // XXX
6021 %}
6022 
6023 //----------BSWAP Instructions-------------------------------------------------
6024 instruct bytes_reverse_int(rRegI dst) %{
6025   match(Set dst (ReverseBytesI dst));
6026 
6027   format %{ "bswapl  $dst" %}
6028   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
6029   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
6030   ins_pipe( ialu_reg );
6031 %}
6032 
6033 instruct bytes_reverse_long(rRegL dst) %{
6034   match(Set dst (ReverseBytesL dst));
6035 
6036   format %{ "bswapq  $dst" %}
6037   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
6038   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
6039   ins_pipe( ialu_reg);
6040 %}
6041 
6042 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
6043   match(Set dst (ReverseBytesUS dst));
6044   effect(KILL cr);
6045 
6046   format %{ "bswapl  $dst\n\t"
6047             "shrl    $dst,16\n\t" %}
6048   ins_encode %{
6049     __ bswapl($dst$$Register);
6050     __ shrl($dst$$Register, 16);
6051   %}
6052   ins_pipe( ialu_reg );
6053 %}
6054 
6055 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
6056   match(Set dst (ReverseBytesS dst));
6057   effect(KILL cr);
6058 
6059   format %{ "bswapl  $dst\n\t"
6060             "sar     $dst,16\n\t" %}
6061   ins_encode %{
6062     __ bswapl($dst$$Register);
6063     __ sarl($dst$$Register, 16);
6064   %}
6065   ins_pipe( ialu_reg );
6066 %}
6067 
6068 //---------- Zeros Count Instructions ------------------------------------------
6069 
6070 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6071   predicate(UseCountLeadingZerosInstruction);
6072   match(Set dst (CountLeadingZerosI src));
6073   effect(KILL cr);
6074 
6075   format %{ "lzcntl  $dst, $src\t# count leading zeros (int)" %}
6076   ins_encode %{
6077     __ lzcntl($dst$$Register, $src$$Register);
6078   %}
6079   ins_pipe(ialu_reg);
6080 %}
6081 
6082 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
6083   predicate(!UseCountLeadingZerosInstruction);
6084   match(Set dst (CountLeadingZerosI src));
6085   effect(KILL cr);
6086 
6087   format %{ "bsrl    $dst, $src\t# count leading zeros (int)\n\t"
6088             "jnz     skip\n\t"
6089             "movl    $dst, -1\n"
6090       "skip:\n\t"
6091             "negl    $dst\n\t"
6092             "addl    $dst, 31" %}
6093   ins_encode %{
6094     Register Rdst = $dst$$Register;
6095     Register Rsrc = $src$$Register;
6096     Label skip;
6097     __ bsrl(Rdst, Rsrc);
6098     __ jccb(Assembler::notZero, skip);
6099     __ movl(Rdst, -1);
6100     __ bind(skip);
6101     __ negl(Rdst);
6102     __ addl(Rdst, BitsPerInt - 1);
6103   %}
6104   ins_pipe(ialu_reg);
6105 %}
6106 
6107 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6108   predicate(UseCountLeadingZerosInstruction);
6109   match(Set dst (CountLeadingZerosL src));
6110   effect(KILL cr);
6111 
6112   format %{ "lzcntq  $dst, $src\t# count leading zeros (long)" %}
6113   ins_encode %{
6114     __ lzcntq($dst$$Register, $src$$Register);
6115   %}
6116   ins_pipe(ialu_reg);
6117 %}
6118 
6119 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
6120   predicate(!UseCountLeadingZerosInstruction);
6121   match(Set dst (CountLeadingZerosL src));
6122   effect(KILL cr);
6123 
6124   format %{ "bsrq    $dst, $src\t# count leading zeros (long)\n\t"
6125             "jnz     skip\n\t"
6126             "movl    $dst, -1\n"
6127       "skip:\n\t"
6128             "negl    $dst\n\t"
6129             "addl    $dst, 63" %}
6130   ins_encode %{
6131     Register Rdst = $dst$$Register;
6132     Register Rsrc = $src$$Register;
6133     Label skip;
6134     __ bsrq(Rdst, Rsrc);
6135     __ jccb(Assembler::notZero, skip);
6136     __ movl(Rdst, -1);
6137     __ bind(skip);
6138     __ negl(Rdst);
6139     __ addl(Rdst, BitsPerLong - 1);
6140   %}
6141   ins_pipe(ialu_reg);
6142 %}
6143 
6144 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6145   predicate(UseCountTrailingZerosInstruction);
6146   match(Set dst (CountTrailingZerosI src));
6147   effect(KILL cr);
6148 
6149   format %{ "tzcntl    $dst, $src\t# count trailing zeros (int)" %}
6150   ins_encode %{
6151     __ tzcntl($dst$$Register, $src$$Register);
6152   %}
6153   ins_pipe(ialu_reg);
6154 %}
6155 
6156 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
6157   predicate(!UseCountTrailingZerosInstruction);
6158   match(Set dst (CountTrailingZerosI src));
6159   effect(KILL cr);
6160 
6161   format %{ "bsfl    $dst, $src\t# count trailing zeros (int)\n\t"
6162             "jnz     done\n\t"
6163             "movl    $dst, 32\n"
6164       "done:" %}
6165   ins_encode %{
6166     Register Rdst = $dst$$Register;
6167     Label done;
6168     __ bsfl(Rdst, $src$$Register);
6169     __ jccb(Assembler::notZero, done);
6170     __ movl(Rdst, BitsPerInt);
6171     __ bind(done);
6172   %}
6173   ins_pipe(ialu_reg);
6174 %}
6175 
6176 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6177   predicate(UseCountTrailingZerosInstruction);
6178   match(Set dst (CountTrailingZerosL src));
6179   effect(KILL cr);
6180 
6181   format %{ "tzcntq    $dst, $src\t# count trailing zeros (long)" %}
6182   ins_encode %{
6183     __ tzcntq($dst$$Register, $src$$Register);
6184   %}
6185   ins_pipe(ialu_reg);
6186 %}
6187 
6188 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
6189   predicate(!UseCountTrailingZerosInstruction);
6190   match(Set dst (CountTrailingZerosL src));
6191   effect(KILL cr);
6192 
6193   format %{ "bsfq    $dst, $src\t# count trailing zeros (long)\n\t"
6194             "jnz     done\n\t"
6195             "movl    $dst, 64\n"
6196       "done:" %}
6197   ins_encode %{
6198     Register Rdst = $dst$$Register;
6199     Label done;
6200     __ bsfq(Rdst, $src$$Register);
6201     __ jccb(Assembler::notZero, done);
6202     __ movl(Rdst, BitsPerLong);
6203     __ bind(done);
6204   %}
6205   ins_pipe(ialu_reg);
6206 %}
6207 
6208 
6209 //---------- Population Count Instructions -------------------------------------
6210 
6211 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
6212   predicate(UsePopCountInstruction);
6213   match(Set dst (PopCountI src));
6214   effect(KILL cr);
6215 
6216   format %{ "popcnt  $dst, $src" %}
6217   ins_encode %{
6218     __ popcntl($dst$$Register, $src$$Register);
6219   %}
6220   ins_pipe(ialu_reg);
6221 %}
6222 
6223 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6224   predicate(UsePopCountInstruction);
6225   match(Set dst (PopCountI (LoadI mem)));
6226   effect(KILL cr);
6227 
6228   format %{ "popcnt  $dst, $mem" %}
6229   ins_encode %{
6230     __ popcntl($dst$$Register, $mem$$Address);
6231   %}
6232   ins_pipe(ialu_reg);
6233 %}
6234 
6235 // Note: Long.bitCount(long) returns an int.
6236 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
6237   predicate(UsePopCountInstruction);
6238   match(Set dst (PopCountL src));
6239   effect(KILL cr);
6240 
6241   format %{ "popcnt  $dst, $src" %}
6242   ins_encode %{
6243     __ popcntq($dst$$Register, $src$$Register);
6244   %}
6245   ins_pipe(ialu_reg);
6246 %}
6247 
6248 // Note: Long.bitCount(long) returns an int.
6249 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6250   predicate(UsePopCountInstruction);
6251   match(Set dst (PopCountL (LoadL mem)));
6252   effect(KILL cr);
6253 
6254   format %{ "popcnt  $dst, $mem" %}
6255   ins_encode %{
6256     __ popcntq($dst$$Register, $mem$$Address);
6257   %}
6258   ins_pipe(ialu_reg);
6259 %}
6260 
6261 
6262 //----------MemBar Instructions-----------------------------------------------
6263 // Memory barrier flavors
6264 
6265 instruct membar_acquire()
6266 %{
6267   match(MemBarAcquire);
6268   match(LoadFence);
6269   ins_cost(0);
6270 
6271   size(0);
6272   format %{ "MEMBAR-acquire ! (empty encoding)" %}
6273   ins_encode();
6274   ins_pipe(empty);
6275 %}
6276 
6277 instruct membar_acquire_lock()
6278 %{
6279   match(MemBarAcquireLock);
6280   ins_cost(0);
6281 
6282   size(0);
6283   format %{ "MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)" %}
6284   ins_encode();
6285   ins_pipe(empty);
6286 %}
6287 
6288 instruct membar_release()
6289 %{
6290   match(MemBarRelease);
6291   match(StoreFence);
6292   ins_cost(0);
6293 
6294   size(0);
6295   format %{ "MEMBAR-release ! (empty encoding)" %}
6296   ins_encode();
6297   ins_pipe(empty);
6298 %}
6299 
6300 instruct membar_release_lock()
6301 %{
6302   match(MemBarReleaseLock);
6303   ins_cost(0);
6304 
6305   size(0);
6306   format %{ "MEMBAR-release (a FastUnlock follows so empty encoding)" %}
6307   ins_encode();
6308   ins_pipe(empty);
6309 %}
6310 
6311 instruct membar_volatile(rFlagsReg cr) %{
6312   match(MemBarVolatile);
6313   effect(KILL cr);
6314   ins_cost(400);
6315 
6316   format %{
6317     $$template
6318     if (os::is_MP()) {
6319       $$emit$$"lock addl [rsp + #0], 0\t! membar_volatile"
6320     } else {
6321       $$emit$$"MEMBAR-volatile ! (empty encoding)"
6322     }
6323   %}
6324   ins_encode %{
6325     __ membar(Assembler::StoreLoad);
6326   %}
6327   ins_pipe(pipe_slow);
6328 %}
6329 
6330 instruct unnecessary_membar_volatile()
6331 %{
6332   match(MemBarVolatile);
6333   predicate(Matcher::post_store_load_barrier(n));
6334   ins_cost(0);
6335 
6336   size(0);
6337   format %{ "MEMBAR-volatile (unnecessary so empty encoding)" %}
6338   ins_encode();
6339   ins_pipe(empty);
6340 %}
6341 
6342 instruct membar_storestore() %{
6343   match(MemBarStoreStore);
6344   ins_cost(0);
6345 
6346   size(0);
6347   format %{ "MEMBAR-storestore (empty encoding)" %}
6348   ins_encode( );
6349   ins_pipe(empty);
6350 %}
6351 
6352 //----------Move Instructions--------------------------------------------------
6353 
6354 instruct castX2P(rRegP dst, rRegL src)
6355 %{
6356   match(Set dst (CastX2P src));
6357 
6358   format %{ "movq    $dst, $src\t# long-&gt;ptr" %}
6359   ins_encode %{
6360     if ($dst$$reg != $src$$reg) {
6361       __ movptr($dst$$Register, $src$$Register);
6362     }
6363   %}
6364   ins_pipe(ialu_reg_reg); // XXX
6365 %}
6366 
6367 instruct castP2X(rRegL dst, rRegP src)
6368 %{
6369   match(Set dst (CastP2X src));
6370 
6371   format %{ "movq    $dst, $src\t# ptr -&gt; long" %}
6372   ins_encode %{
6373     if ($dst$$reg != $src$$reg) {
6374       __ movptr($dst$$Register, $src$$Register);
6375     }
6376   %}
6377   ins_pipe(ialu_reg_reg); // XXX
6378 %}
6379 
6380 // Convert oop into int for vectors alignment masking
6381 instruct convP2I(rRegI dst, rRegP src)
6382 %{
6383   match(Set dst (ConvL2I (CastP2X src)));
6384 
6385   format %{ "movl    $dst, $src\t# ptr -&gt; int" %}
6386   ins_encode %{
6387     __ movl($dst$$Register, $src$$Register);
6388   %}
6389   ins_pipe(ialu_reg_reg); // XXX
6390 %}
6391 
6392 // Convert compressed oop into int for vectors alignment masking
6393 // in case of 32bit oops (heap &lt; 4Gb).
6394 instruct convN2I(rRegI dst, rRegN src)
6395 %{
6396   predicate(Universe::narrow_oop_shift() == 0);
6397   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6398 
6399   format %{ "movl    $dst, $src\t# compressed ptr -&gt; int" %}
6400   ins_encode %{
6401     __ movl($dst$$Register, $src$$Register);
6402   %}
6403   ins_pipe(ialu_reg_reg); // XXX
6404 %}
6405 
6406 // Convert oop pointer into compressed form
6407 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
6408   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
6409   match(Set dst (EncodeP src));
6410   effect(KILL cr);
6411   format %{ "encode_heap_oop $dst,$src" %}
6412   ins_encode %{
6413     Register s = $src$$Register;
6414     Register d = $dst$$Register;
6415     if (s != d) {
6416       __ movq(d, s);
6417     }
6418     __ encode_heap_oop(d);
6419   %}
6420   ins_pipe(ialu_reg_long);
6421 %}
6422 
6423 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6424   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
6425   match(Set dst (EncodeP src));
6426   effect(KILL cr);
6427   format %{ "encode_heap_oop_not_null $dst,$src" %}
6428   ins_encode %{
6429     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
6430   %}
6431   ins_pipe(ialu_reg_long);
6432 %}
6433 
6434 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
6435   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6436             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
6437   match(Set dst (DecodeN src));
6438   effect(KILL cr);
6439   format %{ "decode_heap_oop $dst,$src" %}
6440   ins_encode %{
6441     Register s = $src$$Register;
6442     Register d = $dst$$Register;
6443     if (s != d) {
6444       __ movq(d, s);
6445     }
6446     __ decode_heap_oop(d);
6447   %}
6448   ins_pipe(ialu_reg_long);
6449 %}
6450 
6451 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6452   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
6453             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
6454   match(Set dst (DecodeN src));
6455   effect(KILL cr);
6456   format %{ "decode_heap_oop_not_null $dst,$src" %}
6457   ins_encode %{
6458     Register s = $src$$Register;
6459     Register d = $dst$$Register;
6460     if (s != d) {
6461       __ decode_heap_oop_not_null(d, s);
6462     } else {
6463       __ decode_heap_oop_not_null(d);
6464     }
6465   %}
6466   ins_pipe(ialu_reg_long);
6467 %}
6468 
6469 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6470   match(Set dst (EncodePKlass src));
6471   effect(KILL cr);
6472   format %{ "encode_klass_not_null $dst,$src" %}
6473   ins_encode %{
6474     __ encode_klass_not_null($dst$$Register, $src$$Register);
6475   %}
6476   ins_pipe(ialu_reg_long);
6477 %}
6478 
6479 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6480   match(Set dst (DecodeNKlass src));
6481   effect(KILL cr);
6482   format %{ "decode_klass_not_null $dst,$src" %}
6483   ins_encode %{
6484     Register s = $src$$Register;
6485     Register d = $dst$$Register;
6486     if (s != d) {
6487       __ decode_klass_not_null(d, s);
6488     } else {
6489       __ decode_klass_not_null(d);
6490     }
6491   %}
6492   ins_pipe(ialu_reg_long);
6493 %}
6494 
6495 
6496 //----------Conditional Move---------------------------------------------------
6497 // Jump
6498 // dummy instruction for generating temp registers
6499 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
6500   match(Jump (LShiftL switch_val shift));
6501   ins_cost(350);
6502   predicate(false);
6503   effect(TEMP dest);
6504 
6505   format %{ "leaq    $dest, [$constantaddress]\n\t"
6506             "jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t" %}
6507   ins_encode %{
6508     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6509     // to do that and the compiler is using that register as one it can allocate.
6510     // So we build it all by hand.
6511     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
6512     // ArrayAddress dispatch(table, index);
6513     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
6514     __ lea($dest$$Register, $constantaddress);
6515     __ jmp(dispatch);
6516   %}
6517   ins_pipe(pipe_jmp);
6518 %}
6519 
6520 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
6521   match(Jump (AddL (LShiftL switch_val shift) offset));
6522   ins_cost(350);
6523   effect(TEMP dest);
6524 
6525   format %{ "leaq    $dest, [$constantaddress]\n\t"
6526             "jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t" %}
6527   ins_encode %{
6528     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6529     // to do that and the compiler is using that register as one it can allocate.
6530     // So we build it all by hand.
6531     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6532     // ArrayAddress dispatch(table, index);
6533     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6534     __ lea($dest$$Register, $constantaddress);
6535     __ jmp(dispatch);
6536   %}
6537   ins_pipe(pipe_jmp);
6538 %}
6539 
6540 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
6541   match(Jump switch_val);
6542   ins_cost(350);
6543   effect(TEMP dest);
6544 
6545   format %{ "leaq    $dest, [$constantaddress]\n\t"
6546             "jmp     [$dest + $switch_val]\n\t" %}
6547   ins_encode %{
6548     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6549     // to do that and the compiler is using that register as one it can allocate.
6550     // So we build it all by hand.
6551     // Address index(noreg, switch_reg, Address::times_1);
6552     // ArrayAddress dispatch(table, index);
6553     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
6554     __ lea($dest$$Register, $constantaddress);
6555     __ jmp(dispatch);
6556   %}
6557   ins_pipe(pipe_jmp);
6558 %}
6559 
6560 // Conditional move
6561 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
6562 %{
6563   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6564 
6565   ins_cost(200); // XXX
6566   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6567   opcode(0x0F, 0x40);
6568   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6569   ins_pipe(pipe_cmov_reg);
6570 %}
6571 
6572 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
6573   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6574 
6575   ins_cost(200); // XXX
6576   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6577   opcode(0x0F, 0x40);
6578   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6579   ins_pipe(pipe_cmov_reg);
6580 %}
6581 
6582 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
6583   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6584   ins_cost(200);
6585   expand %{
6586     cmovI_regU(cop, cr, dst, src);
6587   %}
6588 %}
6589 
6590 // Conditional move
6591 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
6592   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6593 
6594   ins_cost(250); // XXX
6595   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6596   opcode(0x0F, 0x40);
6597   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6598   ins_pipe(pipe_cmov_mem);
6599 %}
6600 
6601 // Conditional move
6602 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
6603 %{
6604   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6605 
6606   ins_cost(250); // XXX
6607   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6608   opcode(0x0F, 0x40);
6609   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6610   ins_pipe(pipe_cmov_mem);
6611 %}
6612 
6613 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
6614   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6615   ins_cost(250);
6616   expand %{
6617     cmovI_memU(cop, cr, dst, src);
6618   %}
6619 %}
6620 
6621 // Conditional move
6622 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
6623 %{
6624   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6625 
6626   ins_cost(200); // XXX
6627   format %{ "cmovl$cop $dst, $src\t# signed, compressed ptr" %}
6628   opcode(0x0F, 0x40);
6629   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6630   ins_pipe(pipe_cmov_reg);
6631 %}
6632 
6633 // Conditional move
6634 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
6635 %{
6636   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6637 
6638   ins_cost(200); // XXX
6639   format %{ "cmovl$cop $dst, $src\t# unsigned, compressed ptr" %}
6640   opcode(0x0F, 0x40);
6641   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6642   ins_pipe(pipe_cmov_reg);
6643 %}
6644 
6645 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
6646   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6647   ins_cost(200);
6648   expand %{
6649     cmovN_regU(cop, cr, dst, src);
6650   %}
6651 %}
6652 
6653 // Conditional move
6654 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
6655 %{
6656   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6657 
6658   ins_cost(200); // XXX
6659   format %{ "cmovq$cop $dst, $src\t# signed, ptr" %}
6660   opcode(0x0F, 0x40);
6661   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6662   ins_pipe(pipe_cmov_reg);  // XXX
6663 %}
6664 
6665 // Conditional move
6666 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
6667 %{
6668   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6669 
6670   ins_cost(200); // XXX
6671   format %{ "cmovq$cop $dst, $src\t# unsigned, ptr" %}
6672   opcode(0x0F, 0x40);
6673   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6674   ins_pipe(pipe_cmov_reg); // XXX
6675 %}
6676 
6677 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
6678   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6679   ins_cost(200);
6680   expand %{
6681     cmovP_regU(cop, cr, dst, src);
6682   %}
6683 %}
6684 
6685 // DISABLED: Requires the ADLC to emit a bottom_type call that
6686 // correctly meets the two pointer arguments; one is an incoming
6687 // register but the other is a memory operand.  ALSO appears to
6688 // be buggy with implicit null checks.
6689 //
6690 //// Conditional move
6691 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
6692 //%{
6693 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6694 //  ins_cost(250);
6695 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6696 //  opcode(0x0F,0x40);
6697 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6698 //  ins_pipe( pipe_cmov_mem );
6699 //%}
6700 //
6701 //// Conditional move
6702 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
6703 //%{
6704 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6705 //  ins_cost(250);
6706 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6707 //  opcode(0x0F,0x40);
6708 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6709 //  ins_pipe( pipe_cmov_mem );
6710 //%}
6711 
6712 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
6713 %{
6714   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6715 
6716   ins_cost(200); // XXX
6717   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6718   opcode(0x0F, 0x40);
6719   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6720   ins_pipe(pipe_cmov_reg);  // XXX
6721 %}
6722 
6723 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
6724 %{
6725   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6726 
6727   ins_cost(200); // XXX
6728   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6729   opcode(0x0F, 0x40);
6730   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6731   ins_pipe(pipe_cmov_mem);  // XXX
6732 %}
6733 
6734 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
6735 %{
6736   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6737 
6738   ins_cost(200); // XXX
6739   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6740   opcode(0x0F, 0x40);
6741   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6742   ins_pipe(pipe_cmov_reg); // XXX
6743 %}
6744 
6745 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
6746   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6747   ins_cost(200);
6748   expand %{
6749     cmovL_regU(cop, cr, dst, src);
6750   %}
6751 %}
6752 
6753 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
6754 %{
6755   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6756 
6757   ins_cost(200); // XXX
6758   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6759   opcode(0x0F, 0x40);
6760   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6761   ins_pipe(pipe_cmov_mem); // XXX
6762 %}
6763 
6764 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
6765   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6766   ins_cost(200);
6767   expand %{
6768     cmovL_memU(cop, cr, dst, src);
6769   %}
6770 %}
6771 
6772 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
6773 %{
6774   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6775 
6776   ins_cost(200); // XXX
6777   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6778             "movss     $dst, $src\n"
6779     "skip:" %}
6780   ins_encode %{
6781     Label Lskip;
6782     // Invert sense of branch from sense of CMOV
6783     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6784     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6785     __ bind(Lskip);
6786   %}
6787   ins_pipe(pipe_slow);
6788 %}
6789 
6790 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
6791 // %{
6792 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
6793 
6794 //   ins_cost(200); // XXX
6795 //   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6796 //             "movss     $dst, $src\n"
6797 //     "skip:" %}
6798 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
6799 //   ins_pipe(pipe_slow);
6800 // %}
6801 
6802 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
6803 %{
6804   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6805 
6806   ins_cost(200); // XXX
6807   format %{ "jn$cop    skip\t# unsigned cmove float\n\t"
6808             "movss     $dst, $src\n"
6809     "skip:" %}
6810   ins_encode %{
6811     Label Lskip;
6812     // Invert sense of branch from sense of CMOV
6813     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6814     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6815     __ bind(Lskip);
6816   %}
6817   ins_pipe(pipe_slow);
6818 %}
6819 
6820 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
6821   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6822   ins_cost(200);
6823   expand %{
6824     cmovF_regU(cop, cr, dst, src);
6825   %}
6826 %}
6827 
6828 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
6829 %{
6830   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6831 
6832   ins_cost(200); // XXX
6833   format %{ "jn$cop    skip\t# signed cmove double\n\t"
6834             "movsd     $dst, $src\n"
6835     "skip:" %}
6836   ins_encode %{
6837     Label Lskip;
6838     // Invert sense of branch from sense of CMOV
6839     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6840     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6841     __ bind(Lskip);
6842   %}
6843   ins_pipe(pipe_slow);
6844 %}
6845 
6846 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
6847 %{
6848   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6849 
6850   ins_cost(200); // XXX
6851   format %{ "jn$cop    skip\t# unsigned cmove double\n\t"
6852             "movsd     $dst, $src\n"
6853     "skip:" %}
6854   ins_encode %{
6855     Label Lskip;
6856     // Invert sense of branch from sense of CMOV
6857     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6858     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6859     __ bind(Lskip);
6860   %}
6861   ins_pipe(pipe_slow);
6862 %}
6863 
6864 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
6865   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6866   ins_cost(200);
6867   expand %{
6868     cmovD_regU(cop, cr, dst, src);
6869   %}
6870 %}
6871 
6872 //----------Arithmetic Instructions--------------------------------------------
6873 //----------Addition Instructions----------------------------------------------
6874 
6875 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
6876 %{
6877   match(Set dst (AddI dst src));
6878   effect(KILL cr);
6879 
6880   format %{ "addl    $dst, $src\t# int" %}
6881   opcode(0x03);
6882   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
6883   ins_pipe(ialu_reg_reg);
6884 %}
6885 
6886 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
6887 %{
6888   match(Set dst (AddI dst src));
6889   effect(KILL cr);
6890 
6891   format %{ "addl    $dst, $src\t# int" %}
6892   opcode(0x81, 0x00); /* /0 id */
6893   ins_encode(OpcSErm(dst, src), Con8or32(src));
6894   ins_pipe( ialu_reg );
6895 %}
6896 
6897 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
6898 %{
6899   match(Set dst (AddI dst (LoadI src)));
6900   effect(KILL cr);
6901 
6902   ins_cost(125); // XXX
6903   format %{ "addl    $dst, $src\t# int" %}
6904   opcode(0x03);
6905   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
6906   ins_pipe(ialu_reg_mem);
6907 %}
6908 
6909 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
6910 %{
6911   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6912   effect(KILL cr);
6913 
6914   ins_cost(150); // XXX
6915   format %{ "addl    $dst, $src\t# int" %}
6916   opcode(0x01); /* Opcode 01 /r */
6917   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
6918   ins_pipe(ialu_mem_reg);
6919 %}
6920 
6921 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
6922 %{
6923   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6924   effect(KILL cr);
6925 
6926   ins_cost(125); // XXX
6927   format %{ "addl    $dst, $src\t# int" %}
6928   opcode(0x81); /* Opcode 81 /0 id */
6929   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
6930   ins_pipe(ialu_mem_imm);
6931 %}
6932 
6933 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
6934 %{
6935   predicate(UseIncDec);
6936   match(Set dst (AddI dst src));
6937   effect(KILL cr);
6938 
6939   format %{ "incl    $dst\t# int" %}
6940   opcode(0xFF, 0x00); // FF /0
6941   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6942   ins_pipe(ialu_reg);
6943 %}
6944 
6945 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
6946 %{
6947   predicate(UseIncDec);
6948   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6949   effect(KILL cr);
6950 
6951   ins_cost(125); // XXX
6952   format %{ "incl    $dst\t# int" %}
6953   opcode(0xFF); /* Opcode FF /0 */
6954   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
6955   ins_pipe(ialu_mem_imm);
6956 %}
6957 
6958 // XXX why does that use AddI
6959 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
6960 %{
6961   predicate(UseIncDec);
6962   match(Set dst (AddI dst src));
6963   effect(KILL cr);
6964 
6965   format %{ "decl    $dst\t# int" %}
6966   opcode(0xFF, 0x01); // FF /1
6967   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6968   ins_pipe(ialu_reg);
6969 %}
6970 
6971 // XXX why does that use AddI
6972 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
6973 %{
6974   predicate(UseIncDec);
6975   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6976   effect(KILL cr);
6977 
6978   ins_cost(125); // XXX
6979   format %{ "decl    $dst\t# int" %}
6980   opcode(0xFF); /* Opcode FF /1 */
6981   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
6982   ins_pipe(ialu_mem_imm);
6983 %}
6984 
6985 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
6986 %{
6987   match(Set dst (AddI src0 src1));
6988 
6989   ins_cost(110);
6990   format %{ "addr32 leal $dst, [$src0 + $src1]\t# int" %}
6991   opcode(0x8D); /* 0x8D /r */
6992   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
6993   ins_pipe(ialu_reg_reg);
6994 %}
6995 
6996 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
6997 %{
6998   match(Set dst (AddL dst src));
6999   effect(KILL cr);
7000 
7001   format %{ "addq    $dst, $src\t# long" %}
7002   opcode(0x03);
7003   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7004   ins_pipe(ialu_reg_reg);
7005 %}
7006 
7007 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
7008 %{
7009   match(Set dst (AddL dst src));
7010   effect(KILL cr);
7011 
7012   format %{ "addq    $dst, $src\t# long" %}
7013   opcode(0x81, 0x00); /* /0 id */
7014   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7015   ins_pipe( ialu_reg );
7016 %}
7017 
7018 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7019 %{
7020   match(Set dst (AddL dst (LoadL src)));
7021   effect(KILL cr);
7022 
7023   ins_cost(125); // XXX
7024   format %{ "addq    $dst, $src\t# long" %}
7025   opcode(0x03);
7026   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7027   ins_pipe(ialu_reg_mem);
7028 %}
7029 
7030 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7031 %{
7032   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7033   effect(KILL cr);
7034 
7035   ins_cost(150); // XXX
7036   format %{ "addq    $dst, $src\t# long" %}
7037   opcode(0x01); /* Opcode 01 /r */
7038   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7039   ins_pipe(ialu_mem_reg);
7040 %}
7041 
7042 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7043 %{
7044   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7045   effect(KILL cr);
7046 
7047   ins_cost(125); // XXX
7048   format %{ "addq    $dst, $src\t# long" %}
7049   opcode(0x81); /* Opcode 81 /0 id */
7050   ins_encode(REX_mem_wide(dst),
7051              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
7052   ins_pipe(ialu_mem_imm);
7053 %}
7054 
7055 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
7056 %{
7057   predicate(UseIncDec);
7058   match(Set dst (AddL dst src));
7059   effect(KILL cr);
7060 
7061   format %{ "incq    $dst\t# long" %}
7062   opcode(0xFF, 0x00); // FF /0
7063   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7064   ins_pipe(ialu_reg);
7065 %}
7066 
7067 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
7068 %{
7069   predicate(UseIncDec);
7070   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7071   effect(KILL cr);
7072 
7073   ins_cost(125); // XXX
7074   format %{ "incq    $dst\t# long" %}
7075   opcode(0xFF); /* Opcode FF /0 */
7076   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
7077   ins_pipe(ialu_mem_imm);
7078 %}
7079 
7080 // XXX why does that use AddL
7081 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
7082 %{
7083   predicate(UseIncDec);
7084   match(Set dst (AddL dst src));
7085   effect(KILL cr);
7086 
7087   format %{ "decq    $dst\t# long" %}
7088   opcode(0xFF, 0x01); // FF /1
7089   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7090   ins_pipe(ialu_reg);
7091 %}
7092 
7093 // XXX why does that use AddL
7094 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
7095 %{
7096   predicate(UseIncDec);
7097   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7098   effect(KILL cr);
7099 
7100   ins_cost(125); // XXX
7101   format %{ "decq    $dst\t# long" %}
7102   opcode(0xFF); /* Opcode FF /1 */
7103   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
7104   ins_pipe(ialu_mem_imm);
7105 %}
7106 
7107 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
7108 %{
7109   match(Set dst (AddL src0 src1));
7110 
7111   ins_cost(110);
7112   format %{ "leaq    $dst, [$src0 + $src1]\t# long" %}
7113   opcode(0x8D); /* 0x8D /r */
7114   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7115   ins_pipe(ialu_reg_reg);
7116 %}
7117 
7118 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
7119 %{
7120   match(Set dst (AddP dst src));
7121   effect(KILL cr);
7122 
7123   format %{ "addq    $dst, $src\t# ptr" %}
7124   opcode(0x03);
7125   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7126   ins_pipe(ialu_reg_reg);
7127 %}
7128 
7129 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
7130 %{
7131   match(Set dst (AddP dst src));
7132   effect(KILL cr);
7133 
7134   format %{ "addq    $dst, $src\t# ptr" %}
7135   opcode(0x81, 0x00); /* /0 id */
7136   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7137   ins_pipe( ialu_reg );
7138 %}
7139 
7140 // XXX addP mem ops ????
7141 
7142 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
7143 %{
7144   match(Set dst (AddP src0 src1));
7145 
7146   ins_cost(110);
7147   format %{ "leaq    $dst, [$src0 + $src1]\t# ptr" %}
7148   opcode(0x8D); /* 0x8D /r */
7149   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
7150   ins_pipe(ialu_reg_reg);
7151 %}
7152 
7153 instruct checkCastPP(rRegP dst)
7154 %{
7155   match(Set dst (CheckCastPP dst));
7156 
7157   size(0);
7158   format %{ "# checkcastPP of $dst" %}
7159   ins_encode(/* empty encoding */);
7160   ins_pipe(empty);
7161 %}
7162 
7163 instruct castPP(rRegP dst)
7164 %{
7165   match(Set dst (CastPP dst));
7166 
7167   size(0);
7168   format %{ "# castPP of $dst" %}
7169   ins_encode(/* empty encoding */);
7170   ins_pipe(empty);
7171 %}
7172 
7173 instruct castII(rRegI dst)
7174 %{
7175   match(Set dst (CastII dst));
7176 
7177   size(0);
7178   format %{ "# castII of $dst" %}
7179   ins_encode(/* empty encoding */);
7180   ins_cost(0);
7181   ins_pipe(empty);
7182 %}
7183 
7184 // LoadP-locked same as a regular LoadP when used with compare-swap
7185 instruct loadPLocked(rRegP dst, memory mem)
7186 %{
7187   match(Set dst (LoadPLocked mem));
7188 
7189   ins_cost(125); // XXX
7190   format %{ "movq    $dst, $mem\t# ptr locked" %}
7191   opcode(0x8B);
7192   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
7193   ins_pipe(ialu_reg_mem); // XXX
7194 %}
7195 
7196 // Conditional-store of the updated heap-top.
7197 // Used during allocation of the shared heap.
7198 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
7199 
7200 instruct storePConditional(memory heap_top_ptr,
7201                            rax_RegP oldval, rRegP newval,
7202                            rFlagsReg cr)
7203 %{
7204   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
7205 
7206   format %{ "cmpxchgq $heap_top_ptr, $newval\t# (ptr) "
7207             "If rax == $heap_top_ptr then store $newval into $heap_top_ptr" %}
7208   opcode(0x0F, 0xB1);
7209   ins_encode(lock_prefix,
7210              REX_reg_mem_wide(newval, heap_top_ptr),
7211              OpcP, OpcS,
7212              reg_mem(newval, heap_top_ptr));
7213   ins_pipe(pipe_cmpxchg);
7214 %}
7215 
7216 // Conditional-store of an int value.
7217 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7218 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
7219 %{
7220   match(Set cr (StoreIConditional mem (Binary oldval newval)));
7221   effect(KILL oldval);
7222 
7223   format %{ "cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7224   opcode(0x0F, 0xB1);
7225   ins_encode(lock_prefix,
7226              REX_reg_mem(newval, mem),
7227              OpcP, OpcS,
7228              reg_mem(newval, mem));
7229   ins_pipe(pipe_cmpxchg);
7230 %}
7231 
7232 // Conditional-store of a long value.
7233 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7234 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
7235 %{
7236   match(Set cr (StoreLConditional mem (Binary oldval newval)));
7237   effect(KILL oldval);
7238 
7239   format %{ "cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7240   opcode(0x0F, 0xB1);
7241   ins_encode(lock_prefix,
7242              REX_reg_mem_wide(newval, mem),
7243              OpcP, OpcS,
7244              reg_mem(newval, mem));
7245   ins_pipe(pipe_cmpxchg);
7246 %}
7247 
7248 
7249 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
7250 instruct compareAndSwapP(rRegI res,
7251                          memory mem_ptr,
7252                          rax_RegP oldval, rRegP newval,
7253                          rFlagsReg cr)
7254 %{
7255   predicate(VM_Version::supports_cx8());
7256   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
7257   effect(KILL cr, KILL oldval);
7258 
7259   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7260             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7261             "sete    $res\n\t"
7262             "movzbl  $res, $res" %}
7263   opcode(0x0F, 0xB1);
7264   ins_encode(lock_prefix,
7265              REX_reg_mem_wide(newval, mem_ptr),
7266              OpcP, OpcS,
7267              reg_mem(newval, mem_ptr),
7268              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7269              REX_reg_breg(res, res), // movzbl
7270              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7271   ins_pipe( pipe_cmpxchg );
7272 %}
7273 
7274 instruct compareAndSwapL(rRegI res,
7275                          memory mem_ptr,
7276                          rax_RegL oldval, rRegL newval,
7277                          rFlagsReg cr)
7278 %{
7279   predicate(VM_Version::supports_cx8());
7280   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
7281   effect(KILL cr, KILL oldval);
7282 
7283   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7284             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7285             "sete    $res\n\t"
7286             "movzbl  $res, $res" %}
7287   opcode(0x0F, 0xB1);
7288   ins_encode(lock_prefix,
7289              REX_reg_mem_wide(newval, mem_ptr),
7290              OpcP, OpcS,
7291              reg_mem(newval, mem_ptr),
7292              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7293              REX_reg_breg(res, res), // movzbl
7294              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7295   ins_pipe( pipe_cmpxchg );
7296 %}
7297 
7298 instruct compareAndSwapI(rRegI res,
7299                          memory mem_ptr,
7300                          rax_RegI oldval, rRegI newval,
7301                          rFlagsReg cr)
7302 %{
7303   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
7304   effect(KILL cr, KILL oldval);
7305 
7306   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7307             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7308             "sete    $res\n\t"
7309             "movzbl  $res, $res" %}
7310   opcode(0x0F, 0xB1);
7311   ins_encode(lock_prefix,
7312              REX_reg_mem(newval, mem_ptr),
7313              OpcP, OpcS,
7314              reg_mem(newval, mem_ptr),
7315              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7316              REX_reg_breg(res, res), // movzbl
7317              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7318   ins_pipe( pipe_cmpxchg );
7319 %}
7320 
7321 
7322 instruct compareAndSwapN(rRegI res,
7323                           memory mem_ptr,
7324                           rax_RegN oldval, rRegN newval,
7325                           rFlagsReg cr) %{
7326   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
7327   effect(KILL cr, KILL oldval);
7328 
7329   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7330             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7331             "sete    $res\n\t"
7332             "movzbl  $res, $res" %}
7333   opcode(0x0F, 0xB1);
7334   ins_encode(lock_prefix,
7335              REX_reg_mem(newval, mem_ptr),
7336              OpcP, OpcS,
7337              reg_mem(newval, mem_ptr),
7338              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7339              REX_reg_breg(res, res), // movzbl
7340              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7341   ins_pipe( pipe_cmpxchg );
7342 %}
7343 
7344 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
7345   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7346   match(Set dummy (GetAndAddI mem add));
7347   effect(KILL cr);
7348   format %{ "ADDL  [$mem],$add" %}
7349   ins_encode %{
7350     if (os::is_MP()) { __ lock(); }
7351     __ addl($mem$$Address, $add$$constant);
7352   %}
7353   ins_pipe( pipe_cmpxchg );
7354 %}
7355 
7356 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
7357   match(Set newval (GetAndAddI mem newval));
7358   effect(KILL cr);
7359   format %{ "XADDL  [$mem],$newval" %}
7360   ins_encode %{
7361     if (os::is_MP()) { __ lock(); }
7362     __ xaddl($mem$$Address, $newval$$Register);
7363   %}
7364   ins_pipe( pipe_cmpxchg );
7365 %}
7366 
7367 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
7368   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7369   match(Set dummy (GetAndAddL mem add));
7370   effect(KILL cr);
7371   format %{ "ADDQ  [$mem],$add" %}
7372   ins_encode %{
7373     if (os::is_MP()) { __ lock(); }
7374     __ addq($mem$$Address, $add$$constant);
7375   %}
7376   ins_pipe( pipe_cmpxchg );
7377 %}
7378 
7379 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
7380   match(Set newval (GetAndAddL mem newval));
7381   effect(KILL cr);
7382   format %{ "XADDQ  [$mem],$newval" %}
7383   ins_encode %{
7384     if (os::is_MP()) { __ lock(); }
7385     __ xaddq($mem$$Address, $newval$$Register);
7386   %}
7387   ins_pipe( pipe_cmpxchg );
7388 %}
7389 
7390 instruct xchgI( memory mem, rRegI newval) %{
7391   match(Set newval (GetAndSetI mem newval));
7392   format %{ "XCHGL  $newval,[$mem]" %}
7393   ins_encode %{
7394     __ xchgl($newval$$Register, $mem$$Address);
7395   %}
7396   ins_pipe( pipe_cmpxchg );
7397 %}
7398 
7399 instruct xchgL( memory mem, rRegL newval) %{
7400   match(Set newval (GetAndSetL mem newval));
7401   format %{ "XCHGL  $newval,[$mem]" %}
7402   ins_encode %{
7403     __ xchgq($newval$$Register, $mem$$Address);
7404   %}
7405   ins_pipe( pipe_cmpxchg );
7406 %}
7407 
7408 instruct xchgP( memory mem, rRegP newval) %{
7409   match(Set newval (GetAndSetP mem newval));
7410   format %{ "XCHGQ  $newval,[$mem]" %}
7411   ins_encode %{
7412     __ xchgq($newval$$Register, $mem$$Address);
7413   %}
7414   ins_pipe( pipe_cmpxchg );
7415 %}
7416 
7417 instruct xchgN( memory mem, rRegN newval) %{
7418   match(Set newval (GetAndSetN mem newval));
7419   format %{ "XCHGL  $newval,$mem]" %}
7420   ins_encode %{
7421     __ xchgl($newval$$Register, $mem$$Address);
7422   %}
7423   ins_pipe( pipe_cmpxchg );
7424 %}
7425 
7426 //----------Subtraction Instructions-------------------------------------------
7427 
7428 // Integer Subtraction Instructions
7429 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7430 %{
7431   match(Set dst (SubI dst src));
7432   effect(KILL cr);
7433 
7434   format %{ "subl    $dst, $src\t# int" %}
7435   opcode(0x2B);
7436   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
7437   ins_pipe(ialu_reg_reg);
7438 %}
7439 
7440 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
7441 %{
7442   match(Set dst (SubI dst src));
7443   effect(KILL cr);
7444 
7445   format %{ "subl    $dst, $src\t# int" %}
7446   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7447   ins_encode(OpcSErm(dst, src), Con8or32(src));
7448   ins_pipe(ialu_reg);
7449 %}
7450 
7451 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
7452 %{
7453   match(Set dst (SubI dst (LoadI src)));
7454   effect(KILL cr);
7455 
7456   ins_cost(125);
7457   format %{ "subl    $dst, $src\t# int" %}
7458   opcode(0x2B);
7459   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
7460   ins_pipe(ialu_reg_mem);
7461 %}
7462 
7463 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
7464 %{
7465   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7466   effect(KILL cr);
7467 
7468   ins_cost(150);
7469   format %{ "subl    $dst, $src\t# int" %}
7470   opcode(0x29); /* Opcode 29 /r */
7471   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
7472   ins_pipe(ialu_mem_reg);
7473 %}
7474 
7475 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
7476 %{
7477   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7478   effect(KILL cr);
7479 
7480   ins_cost(125); // XXX
7481   format %{ "subl    $dst, $src\t# int" %}
7482   opcode(0x81); /* Opcode 81 /5 id */
7483   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7484   ins_pipe(ialu_mem_imm);
7485 %}
7486 
7487 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7488 %{
7489   match(Set dst (SubL dst src));
7490   effect(KILL cr);
7491 
7492   format %{ "subq    $dst, $src\t# long" %}
7493   opcode(0x2B);
7494   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7495   ins_pipe(ialu_reg_reg);
7496 %}
7497 
7498 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
7499 %{
7500   match(Set dst (SubL dst src));
7501   effect(KILL cr);
7502 
7503   format %{ "subq    $dst, $src\t# long" %}
7504   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7505   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7506   ins_pipe(ialu_reg);
7507 %}
7508 
7509 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7510 %{
7511   match(Set dst (SubL dst (LoadL src)));
7512   effect(KILL cr);
7513 
7514   ins_cost(125);
7515   format %{ "subq    $dst, $src\t# long" %}
7516   opcode(0x2B);
7517   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7518   ins_pipe(ialu_reg_mem);
7519 %}
7520 
7521 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7522 %{
7523   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7524   effect(KILL cr);
7525 
7526   ins_cost(150);
7527   format %{ "subq    $dst, $src\t# long" %}
7528   opcode(0x29); /* Opcode 29 /r */
7529   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7530   ins_pipe(ialu_mem_reg);
7531 %}
7532 
7533 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7534 %{
7535   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7536   effect(KILL cr);
7537 
7538   ins_cost(125); // XXX
7539   format %{ "subq    $dst, $src\t# long" %}
7540   opcode(0x81); /* Opcode 81 /5 id */
7541   ins_encode(REX_mem_wide(dst),
7542              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7543   ins_pipe(ialu_mem_imm);
7544 %}
7545 
7546 // Subtract from a pointer
7547 // XXX hmpf???
7548 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
7549 %{
7550   match(Set dst (AddP dst (SubI zero src)));
7551   effect(KILL cr);
7552 
7553   format %{ "subq    $dst, $src\t# ptr - int" %}
7554   opcode(0x2B);
7555   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7556   ins_pipe(ialu_reg_reg);
7557 %}
7558 
7559 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
7560 %{
7561   match(Set dst (SubI zero dst));
7562   effect(KILL cr);
7563 
7564   format %{ "negl    $dst\t# int" %}
7565   opcode(0xF7, 0x03);  // Opcode F7 /3
7566   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7567   ins_pipe(ialu_reg);
7568 %}
7569 
7570 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
7571 %{
7572   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
7573   effect(KILL cr);
7574 
7575   format %{ "negl    $dst\t# int" %}
7576   opcode(0xF7, 0x03);  // Opcode F7 /3
7577   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7578   ins_pipe(ialu_reg);
7579 %}
7580 
7581 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
7582 %{
7583   match(Set dst (SubL zero dst));
7584   effect(KILL cr);
7585 
7586   format %{ "negq    $dst\t# long" %}
7587   opcode(0xF7, 0x03);  // Opcode F7 /3
7588   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7589   ins_pipe(ialu_reg);
7590 %}
7591 
7592 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
7593 %{
7594   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
7595   effect(KILL cr);
7596 
7597   format %{ "negq    $dst\t# long" %}
7598   opcode(0xF7, 0x03);  // Opcode F7 /3
7599   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
7600   ins_pipe(ialu_reg);
7601 %}
7602 
7603 //----------Multiplication/Division Instructions-------------------------------
7604 // Integer Multiplication Instructions
7605 // Multiply Register
7606 
7607 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7608 %{
7609   match(Set dst (MulI dst src));
7610   effect(KILL cr);
7611 
7612   ins_cost(300);
7613   format %{ "imull   $dst, $src\t# int" %}
7614   opcode(0x0F, 0xAF);
7615   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
7616   ins_pipe(ialu_reg_reg_alu0);
7617 %}
7618 
7619 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
7620 %{
7621   match(Set dst (MulI src imm));
7622   effect(KILL cr);
7623 
7624   ins_cost(300);
7625   format %{ "imull   $dst, $src, $imm\t# int" %}
7626   opcode(0x69); /* 69 /r id */
7627   ins_encode(REX_reg_reg(dst, src),
7628              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7629   ins_pipe(ialu_reg_reg_alu0);
7630 %}
7631 
7632 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
7633 %{
7634   match(Set dst (MulI dst (LoadI src)));
7635   effect(KILL cr);
7636 
7637   ins_cost(350);
7638   format %{ "imull   $dst, $src\t# int" %}
7639   opcode(0x0F, 0xAF);
7640   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
7641   ins_pipe(ialu_reg_mem_alu0);
7642 %}
7643 
7644 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
7645 %{
7646   match(Set dst (MulI (LoadI src) imm));
7647   effect(KILL cr);
7648 
7649   ins_cost(300);
7650   format %{ "imull   $dst, $src, $imm\t# int" %}
7651   opcode(0x69); /* 69 /r id */
7652   ins_encode(REX_reg_mem(dst, src),
7653              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7654   ins_pipe(ialu_reg_mem_alu0);
7655 %}
7656 
7657 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7658 %{
7659   match(Set dst (MulL dst src));
7660   effect(KILL cr);
7661 
7662   ins_cost(300);
7663   format %{ "imulq   $dst, $src\t# long" %}
7664   opcode(0x0F, 0xAF);
7665   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
7666   ins_pipe(ialu_reg_reg_alu0);
7667 %}
7668 
7669 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
7670 %{
7671   match(Set dst (MulL src imm));
7672   effect(KILL cr);
7673 
7674   ins_cost(300);
7675   format %{ "imulq   $dst, $src, $imm\t# long" %}
7676   opcode(0x69); /* 69 /r id */
7677   ins_encode(REX_reg_reg_wide(dst, src),
7678              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7679   ins_pipe(ialu_reg_reg_alu0);
7680 %}
7681 
7682 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
7683 %{
7684   match(Set dst (MulL dst (LoadL src)));
7685   effect(KILL cr);
7686 
7687   ins_cost(350);
7688   format %{ "imulq   $dst, $src\t# long" %}
7689   opcode(0x0F, 0xAF);
7690   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
7691   ins_pipe(ialu_reg_mem_alu0);
7692 %}
7693 
7694 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
7695 %{
7696   match(Set dst (MulL (LoadL src) imm));
7697   effect(KILL cr);
7698 
7699   ins_cost(300);
7700   format %{ "imulq   $dst, $src, $imm\t# long" %}
7701   opcode(0x69); /* 69 /r id */
7702   ins_encode(REX_reg_mem_wide(dst, src),
7703              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7704   ins_pipe(ialu_reg_mem_alu0);
7705 %}
7706 
7707 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7708 %{
7709   match(Set dst (MulHiL src rax));
7710   effect(USE_KILL rax, KILL cr);
7711 
7712   ins_cost(300);
7713   format %{ "imulq   RDX:RAX, RAX, $src\t# mulhi" %}
7714   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7715   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7716   ins_pipe(ialu_reg_reg_alu0);
7717 %}
7718 
7719 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7720                    rFlagsReg cr)
7721 %{
7722   match(Set rax (DivI rax div));
7723   effect(KILL rdx, KILL cr);
7724 
7725   ins_cost(30*100+10*100); // XXX
7726   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7727             "jne,s   normal\n\t"
7728             "xorl    rdx, rdx\n\t"
7729             "cmpl    $div, -1\n\t"
7730             "je,s    done\n"
7731     "normal: cdql\n\t"
7732             "idivl   $div\n"
7733     "done:"        %}
7734   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7735   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7736   ins_pipe(ialu_reg_reg_alu0);
7737 %}
7738 
7739 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7740                    rFlagsReg cr)
7741 %{
7742   match(Set rax (DivL rax div));
7743   effect(KILL rdx, KILL cr);
7744 
7745   ins_cost(30*100+10*100); // XXX
7746   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7747             "cmpq    rax, rdx\n\t"
7748             "jne,s   normal\n\t"
7749             "xorl    rdx, rdx\n\t"
7750             "cmpq    $div, -1\n\t"
7751             "je,s    done\n"
7752     "normal: cdqq\n\t"
7753             "idivq   $div\n"
7754     "done:"        %}
7755   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7756   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7757   ins_pipe(ialu_reg_reg_alu0);
7758 %}
7759 
7760 // Integer DIVMOD with Register, both quotient and mod results
7761 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7762                              rFlagsReg cr)
7763 %{
7764   match(DivModI rax div);
7765   effect(KILL cr);
7766 
7767   ins_cost(30*100+10*100); // XXX
7768   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7769             "jne,s   normal\n\t"
7770             "xorl    rdx, rdx\n\t"
7771             "cmpl    $div, -1\n\t"
7772             "je,s    done\n"
7773     "normal: cdql\n\t"
7774             "idivl   $div\n"
7775     "done:"        %}
7776   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7777   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7778   ins_pipe(pipe_slow);
7779 %}
7780 
7781 // Long DIVMOD with Register, both quotient and mod results
7782 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7783                              rFlagsReg cr)
7784 %{
7785   match(DivModL rax div);
7786   effect(KILL cr);
7787 
7788   ins_cost(30*100+10*100); // XXX
7789   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7790             "cmpq    rax, rdx\n\t"
7791             "jne,s   normal\n\t"
7792             "xorl    rdx, rdx\n\t"
7793             "cmpq    $div, -1\n\t"
7794             "je,s    done\n"
7795     "normal: cdqq\n\t"
7796             "idivq   $div\n"
7797     "done:"        %}
7798   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7799   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7800   ins_pipe(pipe_slow);
7801 %}
7802 
7803 //----------- DivL-By-Constant-Expansions--------------------------------------
7804 // DivI cases are handled by the compiler
7805 
7806 // Magic constant, reciprocal of 10
7807 instruct loadConL_0x6666666666666667(rRegL dst)
7808 %{
7809   effect(DEF dst);
7810 
7811   format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
7812   ins_encode(load_immL(dst, 0x6666666666666667));
7813   ins_pipe(ialu_reg);
7814 %}
7815 
7816 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7817 %{
7818   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
7819 
7820   format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
7821   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7822   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7823   ins_pipe(ialu_reg_reg_alu0);
7824 %}
7825 
7826 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
7827 %{
7828   effect(USE_DEF dst, KILL cr);
7829 
7830   format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
7831   opcode(0xC1, 0x7); /* C1 /7 ib */
7832   ins_encode(reg_opc_imm_wide(dst, 0x3F));
7833   ins_pipe(ialu_reg);
7834 %}
7835 
7836 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
7837 %{
7838   effect(USE_DEF dst, KILL cr);
7839 
7840   format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
7841   opcode(0xC1, 0x7); /* C1 /7 ib */
7842   ins_encode(reg_opc_imm_wide(dst, 0x2));
7843   ins_pipe(ialu_reg);
7844 %}
7845 
7846 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
7847 %{
7848   match(Set dst (DivL src div));
7849 
7850   ins_cost((5+8)*100);
7851   expand %{
7852     rax_RegL rax;                     // Killed temp
7853     rFlagsReg cr;                     // Killed
7854     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
7855     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
7856     sarL_rReg_63(src, cr);            // sarq  src, 63
7857     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
7858     subL_rReg(dst, src, cr);          // subl  rdx, src
7859   %}
7860 %}
7861 
7862 //-----------------------------------------------------------------------------
7863 
7864 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
7865                    rFlagsReg cr)
7866 %{
7867   match(Set rdx (ModI rax div));
7868   effect(KILL rax, KILL cr);
7869 
7870   ins_cost(300); // XXX
7871   format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
7872             "jne,s   normal\n\t"
7873             "xorl    rdx, rdx\n\t"
7874             "cmpl    $div, -1\n\t"
7875             "je,s    done\n"
7876     "normal: cdql\n\t"
7877             "idivl   $div\n"
7878     "done:"        %}
7879   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7880   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7881   ins_pipe(ialu_reg_reg_alu0);
7882 %}
7883 
7884 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
7885                    rFlagsReg cr)
7886 %{
7887   match(Set rdx (ModL rax div));
7888   effect(KILL rax, KILL cr);
7889 
7890   ins_cost(300); // XXX
7891   format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
7892             "cmpq    rax, rdx\n\t"
7893             "jne,s   normal\n\t"
7894             "xorl    rdx, rdx\n\t"
7895             "cmpq    $div, -1\n\t"
7896             "je,s    done\n"
7897     "normal: cdqq\n\t"
7898             "idivq   $div\n"
7899     "done:"        %}
7900   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7901   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7902   ins_pipe(ialu_reg_reg_alu0);
7903 %}
7904 
7905 // Integer Shift Instructions
7906 // Shift Left by one
7907 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7908 %{
7909   match(Set dst (LShiftI dst shift));
7910   effect(KILL cr);
7911 
7912   format %{ "sall    $dst, $shift" %}
7913   opcode(0xD1, 0x4); /* D1 /4 */
7914   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7915   ins_pipe(ialu_reg);
7916 %}
7917 
7918 // Shift Left by one
7919 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7920 %{
7921   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7922   effect(KILL cr);
7923 
7924   format %{ "sall    $dst, $shift\t" %}
7925   opcode(0xD1, 0x4); /* D1 /4 */
7926   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7927   ins_pipe(ialu_mem_imm);
7928 %}
7929 
7930 // Shift Left by 8-bit immediate
7931 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7932 %{
7933   match(Set dst (LShiftI dst shift));
7934   effect(KILL cr);
7935 
7936   format %{ "sall    $dst, $shift" %}
7937   opcode(0xC1, 0x4); /* C1 /4 ib */
7938   ins_encode(reg_opc_imm(dst, shift));
7939   ins_pipe(ialu_reg);
7940 %}
7941 
7942 // Shift Left by 8-bit immediate
7943 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7944 %{
7945   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7946   effect(KILL cr);
7947 
7948   format %{ "sall    $dst, $shift" %}
7949   opcode(0xC1, 0x4); /* C1 /4 ib */
7950   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
7951   ins_pipe(ialu_mem_imm);
7952 %}
7953 
7954 // Shift Left by variable
7955 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
7956 %{
7957   match(Set dst (LShiftI dst shift));
7958   effect(KILL cr);
7959 
7960   format %{ "sall    $dst, $shift" %}
7961   opcode(0xD3, 0x4); /* D3 /4 */
7962   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7963   ins_pipe(ialu_reg_reg);
7964 %}
7965 
7966 // Shift Left by variable
7967 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
7968 %{
7969   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7970   effect(KILL cr);
7971 
7972   format %{ "sall    $dst, $shift" %}
7973   opcode(0xD3, 0x4); /* D3 /4 */
7974   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7975   ins_pipe(ialu_mem_reg);
7976 %}
7977 
7978 // Arithmetic shift right by one
7979 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7980 %{
7981   match(Set dst (RShiftI dst shift));
7982   effect(KILL cr);
7983 
7984   format %{ "sarl    $dst, $shift" %}
7985   opcode(0xD1, 0x7); /* D1 /7 */
7986   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7987   ins_pipe(ialu_reg);
7988 %}
7989 
7990 // Arithmetic shift right by one
7991 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7992 %{
7993   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
7994   effect(KILL cr);
7995 
7996   format %{ "sarl    $dst, $shift" %}
7997   opcode(0xD1, 0x7); /* D1 /7 */
7998   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7999   ins_pipe(ialu_mem_imm);
8000 %}
8001 
8002 // Arithmetic Shift Right by 8-bit immediate
8003 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8004 %{
8005   match(Set dst (RShiftI dst shift));
8006   effect(KILL cr);
8007 
8008   format %{ "sarl    $dst, $shift" %}
8009   opcode(0xC1, 0x7); /* C1 /7 ib */
8010   ins_encode(reg_opc_imm(dst, shift));
8011   ins_pipe(ialu_mem_imm);
8012 %}
8013 
8014 // Arithmetic Shift Right by 8-bit immediate
8015 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8016 %{
8017   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8018   effect(KILL cr);
8019 
8020   format %{ "sarl    $dst, $shift" %}
8021   opcode(0xC1, 0x7); /* C1 /7 ib */
8022   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8023   ins_pipe(ialu_mem_imm);
8024 %}
8025 
8026 // Arithmetic Shift Right by variable
8027 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8028 %{
8029   match(Set dst (RShiftI dst shift));
8030   effect(KILL cr);
8031 
8032   format %{ "sarl    $dst, $shift" %}
8033   opcode(0xD3, 0x7); /* D3 /7 */
8034   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8035   ins_pipe(ialu_reg_reg);
8036 %}
8037 
8038 // Arithmetic Shift Right by variable
8039 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8040 %{
8041   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8042   effect(KILL cr);
8043 
8044   format %{ "sarl    $dst, $shift" %}
8045   opcode(0xD3, 0x7); /* D3 /7 */
8046   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8047   ins_pipe(ialu_mem_reg);
8048 %}
8049 
8050 // Logical shift right by one
8051 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
8052 %{
8053   match(Set dst (URShiftI dst shift));
8054   effect(KILL cr);
8055 
8056   format %{ "shrl    $dst, $shift" %}
8057   opcode(0xD1, 0x5); /* D1 /5 */
8058   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8059   ins_pipe(ialu_reg);
8060 %}
8061 
8062 // Logical shift right by one
8063 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8064 %{
8065   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8066   effect(KILL cr);
8067 
8068   format %{ "shrl    $dst, $shift" %}
8069   opcode(0xD1, 0x5); /* D1 /5 */
8070   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8071   ins_pipe(ialu_mem_imm);
8072 %}
8073 
8074 // Logical Shift Right by 8-bit immediate
8075 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8076 %{
8077   match(Set dst (URShiftI dst shift));
8078   effect(KILL cr);
8079 
8080   format %{ "shrl    $dst, $shift" %}
8081   opcode(0xC1, 0x5); /* C1 /5 ib */
8082   ins_encode(reg_opc_imm(dst, shift));
8083   ins_pipe(ialu_reg);
8084 %}
8085 
8086 // Logical Shift Right by 8-bit immediate
8087 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8088 %{
8089   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8090   effect(KILL cr);
8091 
8092   format %{ "shrl    $dst, $shift" %}
8093   opcode(0xC1, 0x5); /* C1 /5 ib */
8094   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8095   ins_pipe(ialu_mem_imm);
8096 %}
8097 
8098 // Logical Shift Right by variable
8099 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8100 %{
8101   match(Set dst (URShiftI dst shift));
8102   effect(KILL cr);
8103 
8104   format %{ "shrl    $dst, $shift" %}
8105   opcode(0xD3, 0x5); /* D3 /5 */
8106   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8107   ins_pipe(ialu_reg_reg);
8108 %}
8109 
8110 // Logical Shift Right by variable
8111 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8112 %{
8113   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8114   effect(KILL cr);
8115 
8116   format %{ "shrl    $dst, $shift" %}
8117   opcode(0xD3, 0x5); /* D3 /5 */
8118   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8119   ins_pipe(ialu_mem_reg);
8120 %}
8121 
8122 // Long Shift Instructions
8123 // Shift Left by one
8124 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8125 %{
8126   match(Set dst (LShiftL dst shift));
8127   effect(KILL cr);
8128 
8129   format %{ "salq    $dst, $shift" %}
8130   opcode(0xD1, 0x4); /* D1 /4 */
8131   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8132   ins_pipe(ialu_reg);
8133 %}
8134 
8135 // Shift Left by one
8136 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8137 %{
8138   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8139   effect(KILL cr);
8140 
8141   format %{ "salq    $dst, $shift" %}
8142   opcode(0xD1, 0x4); /* D1 /4 */
8143   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8144   ins_pipe(ialu_mem_imm);
8145 %}
8146 
8147 // Shift Left by 8-bit immediate
8148 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8149 %{
8150   match(Set dst (LShiftL dst shift));
8151   effect(KILL cr);
8152 
8153   format %{ "salq    $dst, $shift" %}
8154   opcode(0xC1, 0x4); /* C1 /4 ib */
8155   ins_encode(reg_opc_imm_wide(dst, shift));
8156   ins_pipe(ialu_reg);
8157 %}
8158 
8159 // Shift Left by 8-bit immediate
8160 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8161 %{
8162   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8163   effect(KILL cr);
8164 
8165   format %{ "salq    $dst, $shift" %}
8166   opcode(0xC1, 0x4); /* C1 /4 ib */
8167   ins_encode(REX_mem_wide(dst), OpcP,
8168              RM_opc_mem(secondary, dst), Con8or32(shift));
8169   ins_pipe(ialu_mem_imm);
8170 %}
8171 
8172 // Shift Left by variable
8173 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8174 %{
8175   match(Set dst (LShiftL dst shift));
8176   effect(KILL cr);
8177 
8178   format %{ "salq    $dst, $shift" %}
8179   opcode(0xD3, 0x4); /* D3 /4 */
8180   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8181   ins_pipe(ialu_reg_reg);
8182 %}
8183 
8184 // Shift Left by variable
8185 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8186 %{
8187   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8188   effect(KILL cr);
8189 
8190   format %{ "salq    $dst, $shift" %}
8191   opcode(0xD3, 0x4); /* D3 /4 */
8192   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8193   ins_pipe(ialu_mem_reg);
8194 %}
8195 
8196 // Arithmetic shift right by one
8197 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8198 %{
8199   match(Set dst (RShiftL dst shift));
8200   effect(KILL cr);
8201 
8202   format %{ "sarq    $dst, $shift" %}
8203   opcode(0xD1, 0x7); /* D1 /7 */
8204   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8205   ins_pipe(ialu_reg);
8206 %}
8207 
8208 // Arithmetic shift right by one
8209 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8210 %{
8211   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8212   effect(KILL cr);
8213 
8214   format %{ "sarq    $dst, $shift" %}
8215   opcode(0xD1, 0x7); /* D1 /7 */
8216   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8217   ins_pipe(ialu_mem_imm);
8218 %}
8219 
8220 // Arithmetic Shift Right by 8-bit immediate
8221 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8222 %{
8223   match(Set dst (RShiftL dst shift));
8224   effect(KILL cr);
8225 
8226   format %{ "sarq    $dst, $shift" %}
8227   opcode(0xC1, 0x7); /* C1 /7 ib */
8228   ins_encode(reg_opc_imm_wide(dst, shift));
8229   ins_pipe(ialu_mem_imm);
8230 %}
8231 
8232 // Arithmetic Shift Right by 8-bit immediate
8233 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8234 %{
8235   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8236   effect(KILL cr);
8237 
8238   format %{ "sarq    $dst, $shift" %}
8239   opcode(0xC1, 0x7); /* C1 /7 ib */
8240   ins_encode(REX_mem_wide(dst), OpcP,
8241              RM_opc_mem(secondary, dst), Con8or32(shift));
8242   ins_pipe(ialu_mem_imm);
8243 %}
8244 
8245 // Arithmetic Shift Right by variable
8246 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8247 %{
8248   match(Set dst (RShiftL dst shift));
8249   effect(KILL cr);
8250 
8251   format %{ "sarq    $dst, $shift" %}
8252   opcode(0xD3, 0x7); /* D3 /7 */
8253   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8254   ins_pipe(ialu_reg_reg);
8255 %}
8256 
8257 // Arithmetic Shift Right by variable
8258 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8259 %{
8260   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8261   effect(KILL cr);
8262 
8263   format %{ "sarq    $dst, $shift" %}
8264   opcode(0xD3, 0x7); /* D3 /7 */
8265   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8266   ins_pipe(ialu_mem_reg);
8267 %}
8268 
8269 // Logical shift right by one
8270 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8271 %{
8272   match(Set dst (URShiftL dst shift));
8273   effect(KILL cr);
8274 
8275   format %{ "shrq    $dst, $shift" %}
8276   opcode(0xD1, 0x5); /* D1 /5 */
8277   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
8278   ins_pipe(ialu_reg);
8279 %}
8280 
8281 // Logical shift right by one
8282 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8283 %{
8284   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8285   effect(KILL cr);
8286 
8287   format %{ "shrq    $dst, $shift" %}
8288   opcode(0xD1, 0x5); /* D1 /5 */
8289   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8290   ins_pipe(ialu_mem_imm);
8291 %}
8292 
8293 // Logical Shift Right by 8-bit immediate
8294 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8295 %{
8296   match(Set dst (URShiftL dst shift));
8297   effect(KILL cr);
8298 
8299   format %{ "shrq    $dst, $shift" %}
8300   opcode(0xC1, 0x5); /* C1 /5 ib */
8301   ins_encode(reg_opc_imm_wide(dst, shift));
8302   ins_pipe(ialu_reg);
8303 %}
8304 
8305 
8306 // Logical Shift Right by 8-bit immediate
8307 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8308 %{
8309   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8310   effect(KILL cr);
8311 
8312   format %{ "shrq    $dst, $shift" %}
8313   opcode(0xC1, 0x5); /* C1 /5 ib */
8314   ins_encode(REX_mem_wide(dst), OpcP,
8315              RM_opc_mem(secondary, dst), Con8or32(shift));
8316   ins_pipe(ialu_mem_imm);
8317 %}
8318 
8319 // Logical Shift Right by variable
8320 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8321 %{
8322   match(Set dst (URShiftL dst shift));
8323   effect(KILL cr);
8324 
8325   format %{ "shrq    $dst, $shift" %}
8326   opcode(0xD3, 0x5); /* D3 /5 */
8327   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8328   ins_pipe(ialu_reg_reg);
8329 %}
8330 
8331 // Logical Shift Right by variable
8332 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8333 %{
8334   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8335   effect(KILL cr);
8336 
8337   format %{ "shrq    $dst, $shift" %}
8338   opcode(0xD3, 0x5); /* D3 /5 */
8339   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8340   ins_pipe(ialu_mem_reg);
8341 %}
8342 
8343 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
8344 // This idiom is used by the compiler for the i2b bytecode.
8345 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
8346 %{
8347   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
8348 
8349   format %{ "movsbl  $dst, $src\t# i2b" %}
8350   opcode(0x0F, 0xBE);
8351   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8352   ins_pipe(ialu_reg_reg);
8353 %}
8354 
8355 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
8356 // This idiom is used by the compiler the i2s bytecode.
8357 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
8358 %{
8359   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
8360 
8361   format %{ "movswl  $dst, $src\t# i2s" %}
8362   opcode(0x0F, 0xBF);
8363   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8364   ins_pipe(ialu_reg_reg);
8365 %}
8366 
8367 // ROL/ROR instructions
8368 
8369 // ROL expand
8370 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
8371   effect(KILL cr, USE_DEF dst);
8372 
8373   format %{ "roll    $dst" %}
8374   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8375   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8376   ins_pipe(ialu_reg);
8377 %}
8378 
8379 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
8380   effect(USE_DEF dst, USE shift, KILL cr);
8381 
8382   format %{ "roll    $dst, $shift" %}
8383   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8384   ins_encode( reg_opc_imm(dst, shift) );
8385   ins_pipe(ialu_reg);
8386 %}
8387 
8388 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8389 %{
8390   effect(USE_DEF dst, USE shift, KILL cr);
8391 
8392   format %{ "roll    $dst, $shift" %}
8393   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8394   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8395   ins_pipe(ialu_reg_reg);
8396 %}
8397 // end of ROL expand
8398 
8399 // Rotate Left by one
8400 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8401 %{
8402   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8403 
8404   expand %{
8405     rolI_rReg_imm1(dst, cr);
8406   %}
8407 %}
8408 
8409 // Rotate Left by 8-bit immediate
8410 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8411 %{
8412   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8413   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8414 
8415   expand %{
8416     rolI_rReg_imm8(dst, lshift, cr);
8417   %}
8418 %}
8419 
8420 // Rotate Left by variable
8421 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8422 %{
8423   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
8424 
8425   expand %{
8426     rolI_rReg_CL(dst, shift, cr);
8427   %}
8428 %}
8429 
8430 // Rotate Left by variable
8431 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8432 %{
8433   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
8434 
8435   expand %{
8436     rolI_rReg_CL(dst, shift, cr);
8437   %}
8438 %}
8439 
8440 // ROR expand
8441 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
8442 %{
8443   effect(USE_DEF dst, KILL cr);
8444 
8445   format %{ "rorl    $dst" %}
8446   opcode(0xD1, 0x1); /* D1 /1 */
8447   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8448   ins_pipe(ialu_reg);
8449 %}
8450 
8451 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
8452 %{
8453   effect(USE_DEF dst, USE shift, KILL cr);
8454 
8455   format %{ "rorl    $dst, $shift" %}
8456   opcode(0xC1, 0x1); /* C1 /1 ib */
8457   ins_encode(reg_opc_imm(dst, shift));
8458   ins_pipe(ialu_reg);
8459 %}
8460 
8461 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8462 %{
8463   effect(USE_DEF dst, USE shift, KILL cr);
8464 
8465   format %{ "rorl    $dst, $shift" %}
8466   opcode(0xD3, 0x1); /* D3 /1 */
8467   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8468   ins_pipe(ialu_reg_reg);
8469 %}
8470 // end of ROR expand
8471 
8472 // Rotate Right by one
8473 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8474 %{
8475   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8476 
8477   expand %{
8478     rorI_rReg_imm1(dst, cr);
8479   %}
8480 %}
8481 
8482 // Rotate Right by 8-bit immediate
8483 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8484 %{
8485   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8486   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8487 
8488   expand %{
8489     rorI_rReg_imm8(dst, rshift, cr);
8490   %}
8491 %}
8492 
8493 // Rotate Right by variable
8494 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8495 %{
8496   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
8497 
8498   expand %{
8499     rorI_rReg_CL(dst, shift, cr);
8500   %}
8501 %}
8502 
8503 // Rotate Right by variable
8504 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8505 %{
8506   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
8507 
8508   expand %{
8509     rorI_rReg_CL(dst, shift, cr);
8510   %}
8511 %}
8512 
8513 // for long rotate
8514 // ROL expand
8515 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
8516   effect(USE_DEF dst, KILL cr);
8517 
8518   format %{ "rolq    $dst" %}
8519   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8520   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8521   ins_pipe(ialu_reg);
8522 %}
8523 
8524 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
8525   effect(USE_DEF dst, USE shift, KILL cr);
8526 
8527   format %{ "rolq    $dst, $shift" %}
8528   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8529   ins_encode( reg_opc_imm_wide(dst, shift) );
8530   ins_pipe(ialu_reg);
8531 %}
8532 
8533 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8534 %{
8535   effect(USE_DEF dst, USE shift, KILL cr);
8536 
8537   format %{ "rolq    $dst, $shift" %}
8538   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8539   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8540   ins_pipe(ialu_reg_reg);
8541 %}
8542 // end of ROL expand
8543 
8544 // Rotate Left by one
8545 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8546 %{
8547   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8548 
8549   expand %{
8550     rolL_rReg_imm1(dst, cr);
8551   %}
8552 %}
8553 
8554 // Rotate Left by 8-bit immediate
8555 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8556 %{
8557   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8558   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8559 
8560   expand %{
8561     rolL_rReg_imm8(dst, lshift, cr);
8562   %}
8563 %}
8564 
8565 // Rotate Left by variable
8566 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8567 %{
8568   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
8569 
8570   expand %{
8571     rolL_rReg_CL(dst, shift, cr);
8572   %}
8573 %}
8574 
8575 // Rotate Left by variable
8576 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8577 %{
8578   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
8579 
8580   expand %{
8581     rolL_rReg_CL(dst, shift, cr);
8582   %}
8583 %}
8584 
8585 // ROR expand
8586 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
8587 %{
8588   effect(USE_DEF dst, KILL cr);
8589 
8590   format %{ "rorq    $dst" %}
8591   opcode(0xD1, 0x1); /* D1 /1 */
8592   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8593   ins_pipe(ialu_reg);
8594 %}
8595 
8596 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
8597 %{
8598   effect(USE_DEF dst, USE shift, KILL cr);
8599 
8600   format %{ "rorq    $dst, $shift" %}
8601   opcode(0xC1, 0x1); /* C1 /1 ib */
8602   ins_encode(reg_opc_imm_wide(dst, shift));
8603   ins_pipe(ialu_reg);
8604 %}
8605 
8606 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8607 %{
8608   effect(USE_DEF dst, USE shift, KILL cr);
8609 
8610   format %{ "rorq    $dst, $shift" %}
8611   opcode(0xD3, 0x1); /* D3 /1 */
8612   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8613   ins_pipe(ialu_reg_reg);
8614 %}
8615 // end of ROR expand
8616 
8617 // Rotate Right by one
8618 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8619 %{
8620   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8621 
8622   expand %{
8623     rorL_rReg_imm1(dst, cr);
8624   %}
8625 %}
8626 
8627 // Rotate Right by 8-bit immediate
8628 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8629 %{
8630   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8631   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8632 
8633   expand %{
8634     rorL_rReg_imm8(dst, rshift, cr);
8635   %}
8636 %}
8637 
8638 // Rotate Right by variable
8639 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8640 %{
8641   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
8642 
8643   expand %{
8644     rorL_rReg_CL(dst, shift, cr);
8645   %}
8646 %}
8647 
8648 // Rotate Right by variable
8649 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8650 %{
8651   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
8652 
8653   expand %{
8654     rorL_rReg_CL(dst, shift, cr);
8655   %}
8656 %}
8657 
8658 // Logical Instructions
8659 
8660 // Integer Logical Instructions
8661 
8662 // And Instructions
8663 // And Register with Register
8664 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8665 %{
8666   match(Set dst (AndI dst src));
8667   effect(KILL cr);
8668 
8669   format %{ "andl    $dst, $src\t# int" %}
8670   opcode(0x23);
8671   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8672   ins_pipe(ialu_reg_reg);
8673 %}
8674 
8675 // And Register with Immediate 255
8676 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
8677 %{
8678   match(Set dst (AndI dst src));
8679 
8680   format %{ "movzbl  $dst, $dst\t# int &amp; 0xFF" %}
8681   opcode(0x0F, 0xB6);
8682   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8683   ins_pipe(ialu_reg);
8684 %}
8685 
8686 // And Register with Immediate 255 and promote to long
8687 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
8688 %{
8689   match(Set dst (ConvI2L (AndI src mask)));
8690 
8691   format %{ "movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long" %}
8692   opcode(0x0F, 0xB6);
8693   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8694   ins_pipe(ialu_reg);
8695 %}
8696 
8697 // And Register with Immediate 65535
8698 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
8699 %{
8700   match(Set dst (AndI dst src));
8701 
8702   format %{ "movzwl  $dst, $dst\t# int &amp; 0xFFFF" %}
8703   opcode(0x0F, 0xB7);
8704   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8705   ins_pipe(ialu_reg);
8706 %}
8707 
8708 // And Register with Immediate 65535 and promote to long
8709 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
8710 %{
8711   match(Set dst (ConvI2L (AndI src mask)));
8712 
8713   format %{ "movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long" %}
8714   opcode(0x0F, 0xB7);
8715   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8716   ins_pipe(ialu_reg);
8717 %}
8718 
8719 // And Register with Immediate
8720 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8721 %{
8722   match(Set dst (AndI dst src));
8723   effect(KILL cr);
8724 
8725   format %{ "andl    $dst, $src\t# int" %}
8726   opcode(0x81, 0x04); /* Opcode 81 /4 */
8727   ins_encode(OpcSErm(dst, src), Con8or32(src));
8728   ins_pipe(ialu_reg);
8729 %}
8730 
8731 // And Register with Memory
8732 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8733 %{
8734   match(Set dst (AndI dst (LoadI src)));
8735   effect(KILL cr);
8736 
8737   ins_cost(125);
8738   format %{ "andl    $dst, $src\t# int" %}
8739   opcode(0x23);
8740   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8741   ins_pipe(ialu_reg_mem);
8742 %}
8743 
8744 // And Memory with Register
8745 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8746 %{
8747   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8748   effect(KILL cr);
8749 
8750   ins_cost(150);
8751   format %{ "andl    $dst, $src\t# int" %}
8752   opcode(0x21); /* Opcode 21 /r */
8753   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8754   ins_pipe(ialu_mem_reg);
8755 %}
8756 
8757 // And Memory with Immediate
8758 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
8759 %{
8760   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8761   effect(KILL cr);
8762 
8763   ins_cost(125);
8764   format %{ "andl    $dst, $src\t# int" %}
8765   opcode(0x81, 0x4); /* Opcode 81 /4 id */
8766   ins_encode(REX_mem(dst), OpcSE(src),
8767              RM_opc_mem(secondary, dst), Con8or32(src));
8768   ins_pipe(ialu_mem_imm);
8769 %}
8770 
8771 // BMI1 instructions
8772 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
8773   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
8774   predicate(UseBMI1Instructions);
8775   effect(KILL cr);
8776 
8777   ins_cost(125);
8778   format %{ "andnl  $dst, $src1, $src2" %}
8779 
8780   ins_encode %{
8781     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
8782   %}
8783   ins_pipe(ialu_reg_mem);
8784 %}
8785 
8786 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
8787   match(Set dst (AndI (XorI src1 minus_1) src2));
8788   predicate(UseBMI1Instructions);
8789   effect(KILL cr);
8790 
8791   format %{ "andnl  $dst, $src1, $src2" %}
8792 
8793   ins_encode %{
8794     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
8795   %}
8796   ins_pipe(ialu_reg);
8797 %}
8798 
8799 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
8800   match(Set dst (AndI (SubI imm_zero src) src));
8801   predicate(UseBMI1Instructions);
8802   effect(KILL cr);
8803 
8804   format %{ "blsil  $dst, $src" %}
8805 
8806   ins_encode %{
8807     __ blsil($dst$$Register, $src$$Register);
8808   %}
8809   ins_pipe(ialu_reg);
8810 %}
8811 
8812 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
8813   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
8814   predicate(UseBMI1Instructions);
8815   effect(KILL cr);
8816 
8817   ins_cost(125);
8818   format %{ "blsil  $dst, $src" %}
8819 
8820   ins_encode %{
8821     __ blsil($dst$$Register, $src$$Address);
8822   %}
8823   ins_pipe(ialu_reg_mem);
8824 %}
8825 
8826 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8827 %{
8828   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
8829   predicate(UseBMI1Instructions);
8830   effect(KILL cr);
8831 
8832   ins_cost(125);
8833   format %{ "blsmskl $dst, $src" %}
8834 
8835   ins_encode %{
8836     __ blsmskl($dst$$Register, $src$$Address);
8837   %}
8838   ins_pipe(ialu_reg_mem);
8839 %}
8840 
8841 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8842 %{
8843   match(Set dst (XorI (AddI src minus_1) src));
8844   predicate(UseBMI1Instructions);
8845   effect(KILL cr);
8846 
8847   format %{ "blsmskl $dst, $src" %}
8848 
8849   ins_encode %{
8850     __ blsmskl($dst$$Register, $src$$Register);
8851   %}
8852 
8853   ins_pipe(ialu_reg);
8854 %}
8855 
8856 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8857 %{
8858   match(Set dst (AndI (AddI src minus_1) src) );
8859   predicate(UseBMI1Instructions);
8860   effect(KILL cr);
8861 
8862   format %{ "blsrl  $dst, $src" %}
8863 
8864   ins_encode %{
8865     __ blsrl($dst$$Register, $src$$Register);
8866   %}
8867 
8868   ins_pipe(ialu_reg_mem);
8869 %}
8870 
8871 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8872 %{
8873   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
8874   predicate(UseBMI1Instructions);
8875   effect(KILL cr);
8876 
8877   ins_cost(125);
8878   format %{ "blsrl  $dst, $src" %}
8879 
8880   ins_encode %{
8881     __ blsrl($dst$$Register, $src$$Address);
8882   %}
8883 
8884   ins_pipe(ialu_reg);
8885 %}
8886 
8887 // Or Instructions
8888 // Or Register with Register
8889 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8890 %{
8891   match(Set dst (OrI dst src));
8892   effect(KILL cr);
8893 
8894   format %{ "orl     $dst, $src\t# int" %}
8895   opcode(0x0B);
8896   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8897   ins_pipe(ialu_reg_reg);
8898 %}
8899 
8900 // Or Register with Immediate
8901 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8902 %{
8903   match(Set dst (OrI dst src));
8904   effect(KILL cr);
8905 
8906   format %{ "orl     $dst, $src\t# int" %}
8907   opcode(0x81, 0x01); /* Opcode 81 /1 id */
8908   ins_encode(OpcSErm(dst, src), Con8or32(src));
8909   ins_pipe(ialu_reg);
8910 %}
8911 
8912 // Or Register with Memory
8913 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8914 %{
8915   match(Set dst (OrI dst (LoadI src)));
8916   effect(KILL cr);
8917 
8918   ins_cost(125);
8919   format %{ "orl     $dst, $src\t# int" %}
8920   opcode(0x0B);
8921   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8922   ins_pipe(ialu_reg_mem);
8923 %}
8924 
8925 // Or Memory with Register
8926 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8927 %{
8928   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8929   effect(KILL cr);
8930 
8931   ins_cost(150);
8932   format %{ "orl     $dst, $src\t# int" %}
8933   opcode(0x09); /* Opcode 09 /r */
8934   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8935   ins_pipe(ialu_mem_reg);
8936 %}
8937 
8938 // Or Memory with Immediate
8939 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
8940 %{
8941   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8942   effect(KILL cr);
8943 
8944   ins_cost(125);
8945   format %{ "orl     $dst, $src\t# int" %}
8946   opcode(0x81, 0x1); /* Opcode 81 /1 id */
8947   ins_encode(REX_mem(dst), OpcSE(src),
8948              RM_opc_mem(secondary, dst), Con8or32(src));
8949   ins_pipe(ialu_mem_imm);
8950 %}
8951 
8952 // Xor Instructions
8953 // Xor Register with Register
8954 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8955 %{
8956   match(Set dst (XorI dst src));
8957   effect(KILL cr);
8958 
8959   format %{ "xorl    $dst, $src\t# int" %}
8960   opcode(0x33);
8961   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8962   ins_pipe(ialu_reg_reg);
8963 %}
8964 
8965 // Xor Register with Immediate -1
8966 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
8967   match(Set dst (XorI dst imm));
8968 
8969   format %{ "not    $dst" %}
8970   ins_encode %{
8971      __ notl($dst$$Register);
8972   %}
8973   ins_pipe(ialu_reg);
8974 %}
8975 
8976 // Xor Register with Immediate
8977 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8978 %{
8979   match(Set dst (XorI dst src));
8980   effect(KILL cr);
8981 
8982   format %{ "xorl    $dst, $src\t# int" %}
8983   opcode(0x81, 0x06); /* Opcode 81 /6 id */
8984   ins_encode(OpcSErm(dst, src), Con8or32(src));
8985   ins_pipe(ialu_reg);
8986 %}
8987 
8988 // Xor Register with Memory
8989 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8990 %{
8991   match(Set dst (XorI dst (LoadI src)));
8992   effect(KILL cr);
8993 
8994   ins_cost(125);
8995   format %{ "xorl    $dst, $src\t# int" %}
8996   opcode(0x33);
8997   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8998   ins_pipe(ialu_reg_mem);
8999 %}
9000 
9001 // Xor Memory with Register
9002 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
9003 %{
9004   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9005   effect(KILL cr);
9006 
9007   ins_cost(150);
9008   format %{ "xorl    $dst, $src\t# int" %}
9009   opcode(0x31); /* Opcode 31 /r */
9010   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
9011   ins_pipe(ialu_mem_reg);
9012 %}
9013 
9014 // Xor Memory with Immediate
9015 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
9016 %{
9017   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9018   effect(KILL cr);
9019 
9020   ins_cost(125);
9021   format %{ "xorl    $dst, $src\t# int" %}
9022   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9023   ins_encode(REX_mem(dst), OpcSE(src),
9024              RM_opc_mem(secondary, dst), Con8or32(src));
9025   ins_pipe(ialu_mem_imm);
9026 %}
9027 
9028 
9029 // Long Logical Instructions
9030 
9031 // And Instructions
9032 // And Register with Register
9033 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9034 %{
9035   match(Set dst (AndL dst src));
9036   effect(KILL cr);
9037 
9038   format %{ "andq    $dst, $src\t# long" %}
9039   opcode(0x23);
9040   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9041   ins_pipe(ialu_reg_reg);
9042 %}
9043 
9044 // And Register with Immediate 255
9045 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
9046 %{
9047   match(Set dst (AndL dst src));
9048 
9049   format %{ "movzbq  $dst, $dst\t# long &amp; 0xFF" %}
9050   opcode(0x0F, 0xB6);
9051   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9052   ins_pipe(ialu_reg);
9053 %}
9054 
9055 // And Register with Immediate 65535
9056 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
9057 %{
9058   match(Set dst (AndL dst src));
9059 
9060   format %{ "movzwq  $dst, $dst\t# long &amp; 0xFFFF" %}
9061   opcode(0x0F, 0xB7);
9062   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9063   ins_pipe(ialu_reg);
9064 %}
9065 
9066 // And Register with Immediate
9067 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9068 %{
9069   match(Set dst (AndL dst src));
9070   effect(KILL cr);
9071 
9072   format %{ "andq    $dst, $src\t# long" %}
9073   opcode(0x81, 0x04); /* Opcode 81 /4 */
9074   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9075   ins_pipe(ialu_reg);
9076 %}
9077 
9078 // And Register with Memory
9079 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9080 %{
9081   match(Set dst (AndL dst (LoadL src)));
9082   effect(KILL cr);
9083 
9084   ins_cost(125);
9085   format %{ "andq    $dst, $src\t# long" %}
9086   opcode(0x23);
9087   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9088   ins_pipe(ialu_reg_mem);
9089 %}
9090 
9091 // And Memory with Register
9092 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9093 %{
9094   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9095   effect(KILL cr);
9096 
9097   ins_cost(150);
9098   format %{ "andq    $dst, $src\t# long" %}
9099   opcode(0x21); /* Opcode 21 /r */
9100   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9101   ins_pipe(ialu_mem_reg);
9102 %}
9103 
9104 // And Memory with Immediate
9105 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9106 %{
9107   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9108   effect(KILL cr);
9109 
9110   ins_cost(125);
9111   format %{ "andq    $dst, $src\t# long" %}
9112   opcode(0x81, 0x4); /* Opcode 81 /4 id */
9113   ins_encode(REX_mem_wide(dst), OpcSE(src),
9114              RM_opc_mem(secondary, dst), Con8or32(src));
9115   ins_pipe(ialu_mem_imm);
9116 %}
9117 
9118 // BMI1 instructions
9119 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
9120   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
9121   predicate(UseBMI1Instructions);
9122   effect(KILL cr);
9123 
9124   ins_cost(125);
9125   format %{ "andnq  $dst, $src1, $src2" %}
9126 
9127   ins_encode %{
9128     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
9129   %}
9130   ins_pipe(ialu_reg_mem);
9131 %}
9132 
9133 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
9134   match(Set dst (AndL (XorL src1 minus_1) src2));
9135   predicate(UseBMI1Instructions);
9136   effect(KILL cr);
9137 
9138   format %{ "andnq  $dst, $src1, $src2" %}
9139 
9140   ins_encode %{
9141   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
9142   %}
9143   ins_pipe(ialu_reg_mem);
9144 %}
9145 
9146 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
9147   match(Set dst (AndL (SubL imm_zero src) src));
9148   predicate(UseBMI1Instructions);
9149   effect(KILL cr);
9150 
9151   format %{ "blsiq  $dst, $src" %}
9152 
9153   ins_encode %{
9154     __ blsiq($dst$$Register, $src$$Register);
9155   %}
9156   ins_pipe(ialu_reg);
9157 %}
9158 
9159 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
9160   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
9161   predicate(UseBMI1Instructions);
9162   effect(KILL cr);
9163 
9164   ins_cost(125);
9165   format %{ "blsiq  $dst, $src" %}
9166 
9167   ins_encode %{
9168     __ blsiq($dst$$Register, $src$$Address);
9169   %}
9170   ins_pipe(ialu_reg_mem);
9171 %}
9172 
9173 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9174 %{
9175   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
9176   predicate(UseBMI1Instructions);
9177   effect(KILL cr);
9178 
9179   ins_cost(125);
9180   format %{ "blsmskq $dst, $src" %}
9181 
9182   ins_encode %{
9183     __ blsmskq($dst$$Register, $src$$Address);
9184   %}
9185   ins_pipe(ialu_reg_mem);
9186 %}
9187 
9188 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9189 %{
9190   match(Set dst (XorL (AddL src minus_1) src));
9191   predicate(UseBMI1Instructions);
9192   effect(KILL cr);
9193 
9194   format %{ "blsmskq $dst, $src" %}
9195 
9196   ins_encode %{
9197     __ blsmskq($dst$$Register, $src$$Register);
9198   %}
9199 
9200   ins_pipe(ialu_reg);
9201 %}
9202 
9203 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9204 %{
9205   match(Set dst (AndL (AddL src minus_1) src) );
9206   predicate(UseBMI1Instructions);
9207   effect(KILL cr);
9208 
9209   format %{ "blsrq  $dst, $src" %}
9210 
9211   ins_encode %{
9212     __ blsrq($dst$$Register, $src$$Register);
9213   %}
9214 
9215   ins_pipe(ialu_reg);
9216 %}
9217 
9218 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9219 %{
9220   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
9221   predicate(UseBMI1Instructions);
9222   effect(KILL cr);
9223 
9224   ins_cost(125);
9225   format %{ "blsrq  $dst, $src" %}
9226 
9227   ins_encode %{
9228     __ blsrq($dst$$Register, $src$$Address);
9229   %}
9230 
9231   ins_pipe(ialu_reg);
9232 %}
9233 
9234 // Or Instructions
9235 // Or Register with Register
9236 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9237 %{
9238   match(Set dst (OrL dst src));
9239   effect(KILL cr);
9240 
9241   format %{ "orq     $dst, $src\t# long" %}
9242   opcode(0x0B);
9243   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9244   ins_pipe(ialu_reg_reg);
9245 %}
9246 
9247 // Use any_RegP to match R15 (TLS register) without spilling.
9248 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
9249   match(Set dst (OrL dst (CastP2X src)));
9250   effect(KILL cr);
9251 
9252   format %{ "orq     $dst, $src\t# long" %}
9253   opcode(0x0B);
9254   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9255   ins_pipe(ialu_reg_reg);
9256 %}
9257 
9258 
9259 // Or Register with Immediate
9260 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9261 %{
9262   match(Set dst (OrL dst src));
9263   effect(KILL cr);
9264 
9265   format %{ "orq     $dst, $src\t# long" %}
9266   opcode(0x81, 0x01); /* Opcode 81 /1 id */
9267   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9268   ins_pipe(ialu_reg);
9269 %}
9270 
9271 // Or Register with Memory
9272 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9273 %{
9274   match(Set dst (OrL dst (LoadL src)));
9275   effect(KILL cr);
9276 
9277   ins_cost(125);
9278   format %{ "orq     $dst, $src\t# long" %}
9279   opcode(0x0B);
9280   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9281   ins_pipe(ialu_reg_mem);
9282 %}
9283 
9284 // Or Memory with Register
9285 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9286 %{
9287   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9288   effect(KILL cr);
9289 
9290   ins_cost(150);
9291   format %{ "orq     $dst, $src\t# long" %}
9292   opcode(0x09); /* Opcode 09 /r */
9293   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9294   ins_pipe(ialu_mem_reg);
9295 %}
9296 
9297 // Or Memory with Immediate
9298 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9299 %{
9300   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9301   effect(KILL cr);
9302 
9303   ins_cost(125);
9304   format %{ "orq     $dst, $src\t# long" %}
9305   opcode(0x81, 0x1); /* Opcode 81 /1 id */
9306   ins_encode(REX_mem_wide(dst), OpcSE(src),
9307              RM_opc_mem(secondary, dst), Con8or32(src));
9308   ins_pipe(ialu_mem_imm);
9309 %}
9310 
9311 // Xor Instructions
9312 // Xor Register with Register
9313 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9314 %{
9315   match(Set dst (XorL dst src));
9316   effect(KILL cr);
9317 
9318   format %{ "xorq    $dst, $src\t# long" %}
9319   opcode(0x33);
9320   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9321   ins_pipe(ialu_reg_reg);
9322 %}
9323 
9324 // Xor Register with Immediate -1
9325 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
9326   match(Set dst (XorL dst imm));
9327 
9328   format %{ "notq   $dst" %}
9329   ins_encode %{
9330      __ notq($dst$$Register);
9331   %}
9332   ins_pipe(ialu_reg);
9333 %}
9334 
9335 // Xor Register with Immediate
9336 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9337 %{
9338   match(Set dst (XorL dst src));
9339   effect(KILL cr);
9340 
9341   format %{ "xorq    $dst, $src\t# long" %}
9342   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9343   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9344   ins_pipe(ialu_reg);
9345 %}
9346 
9347 // Xor Register with Memory
9348 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9349 %{
9350   match(Set dst (XorL dst (LoadL src)));
9351   effect(KILL cr);
9352 
9353   ins_cost(125);
9354   format %{ "xorq    $dst, $src\t# long" %}
9355   opcode(0x33);
9356   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9357   ins_pipe(ialu_reg_mem);
9358 %}
9359 
9360 // Xor Memory with Register
9361 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9362 %{
9363   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9364   effect(KILL cr);
9365 
9366   ins_cost(150);
9367   format %{ "xorq    $dst, $src\t# long" %}
9368   opcode(0x31); /* Opcode 31 /r */
9369   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9370   ins_pipe(ialu_mem_reg);
9371 %}
9372 
9373 // Xor Memory with Immediate
9374 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9375 %{
9376   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9377   effect(KILL cr);
9378 
9379   ins_cost(125);
9380   format %{ "xorq    $dst, $src\t# long" %}
9381   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9382   ins_encode(REX_mem_wide(dst), OpcSE(src),
9383              RM_opc_mem(secondary, dst), Con8or32(src));
9384   ins_pipe(ialu_mem_imm);
9385 %}
9386 
9387 // Convert Int to Boolean
9388 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
9389 %{
9390   match(Set dst (Conv2B src));
9391   effect(KILL cr);
9392 
9393   format %{ "testl   $src, $src\t# ci2b\n\t"
9394             "setnz   $dst\n\t"
9395             "movzbl  $dst, $dst" %}
9396   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
9397              setNZ_reg(dst),
9398              REX_reg_breg(dst, dst), // movzbl
9399              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9400   ins_pipe(pipe_slow); // XXX
9401 %}
9402 
9403 // Convert Pointer to Boolean
9404 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
9405 %{
9406   match(Set dst (Conv2B src));
9407   effect(KILL cr);
9408 
9409   format %{ "testq   $src, $src\t# cp2b\n\t"
9410             "setnz   $dst\n\t"
9411             "movzbl  $dst, $dst" %}
9412   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
9413              setNZ_reg(dst),
9414              REX_reg_breg(dst, dst), // movzbl
9415              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9416   ins_pipe(pipe_slow); // XXX
9417 %}
9418 
9419 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
9420 %{
9421   match(Set dst (CmpLTMask p q));
9422   effect(KILL cr);
9423 
9424   ins_cost(400);
9425   format %{ "cmpl    $p, $q\t# cmpLTMask\n\t"
9426             "setlt   $dst\n\t"
9427             "movzbl  $dst, $dst\n\t"
9428             "negl    $dst" %}
9429   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
9430              setLT_reg(dst),
9431              REX_reg_breg(dst, dst), // movzbl
9432              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
9433              neg_reg(dst));
9434   ins_pipe(pipe_slow);
9435 %}
9436 
9437 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
9438 %{
9439   match(Set dst (CmpLTMask dst zero));
9440   effect(KILL cr);
9441 
9442   ins_cost(100);
9443   format %{ "sarl    $dst, #31\t# cmpLTMask0" %}
9444   ins_encode %{
9445   __ sarl($dst$$Register, 31);
9446   %}
9447   ins_pipe(ialu_reg);
9448 %}
9449 
9450 /* Better to save a register than avoid a branch */
9451 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9452 %{
9453   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
9454   effect(KILL cr);
9455   ins_cost(300);
9456   format %{ "subl   $p,$q\t# cadd_cmpLTMask\n\t"
9457             "jge    done\n\t"
9458             "addl   $p,$y\n"
9459             "done:  " %}
9460   ins_encode %{
9461     Register Rp = $p$$Register;
9462     Register Rq = $q$$Register;
9463     Register Ry = $y$$Register;
9464     Label done;
9465     __ subl(Rp, Rq);
9466     __ jccb(Assembler::greaterEqual, done);
9467     __ addl(Rp, Ry);
9468     __ bind(done);
9469   %}
9470   ins_pipe(pipe_cmplt);
9471 %}
9472 
9473 /* Better to save a register than avoid a branch */
9474 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9475 %{
9476   match(Set y (AndI (CmpLTMask p q) y));
9477   effect(KILL cr);
9478 
9479   ins_cost(300);
9480 
9481   format %{ "cmpl     $p, $q\t# and_cmpLTMask\n\t"
9482             "jlt      done\n\t"
9483             "xorl     $y, $y\n"
9484             "done:  " %}
9485   ins_encode %{
9486     Register Rp = $p$$Register;
9487     Register Rq = $q$$Register;
9488     Register Ry = $y$$Register;
9489     Label done;
9490     __ cmpl(Rp, Rq);
9491     __ jccb(Assembler::less, done);
9492     __ xorl(Ry, Ry);
9493     __ bind(done);
9494   %}
9495   ins_pipe(pipe_cmplt);
9496 %}
9497 
9498 
9499 //---------- FP Instructions------------------------------------------------
9500 
9501 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
9502 %{
9503   match(Set cr (CmpF src1 src2));
9504 
9505   ins_cost(145);
9506   format %{ "ucomiss $src1, $src2\n\t"
9507             "jnp,s   exit\n\t"
9508             "pushfq\t# saw NaN, set CF\n\t"
9509             "andq    [rsp], #0xffffff2b\n\t"
9510             "popfq\n"
9511     "exit:" %}
9512   ins_encode %{
9513     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9514     emit_cmpfp_fixup(_masm);
9515   %}
9516   ins_pipe(pipe_slow);
9517 %}
9518 
9519 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
9520   match(Set cr (CmpF src1 src2));
9521 
9522   ins_cost(100);
9523   format %{ "ucomiss $src1, $src2" %}
9524   ins_encode %{
9525     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9526   %}
9527   ins_pipe(pipe_slow);
9528 %}
9529 
9530 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
9531 %{
9532   match(Set cr (CmpF src1 (LoadF src2)));
9533 
9534   ins_cost(145);
9535   format %{ "ucomiss $src1, $src2\n\t"
9536             "jnp,s   exit\n\t"
9537             "pushfq\t# saw NaN, set CF\n\t"
9538             "andq    [rsp], #0xffffff2b\n\t"
9539             "popfq\n"
9540     "exit:" %}
9541   ins_encode %{
9542     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9543     emit_cmpfp_fixup(_masm);
9544   %}
9545   ins_pipe(pipe_slow);
9546 %}
9547 
9548 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
9549   match(Set cr (CmpF src1 (LoadF src2)));
9550 
9551   ins_cost(100);
9552   format %{ "ucomiss $src1, $src2" %}
9553   ins_encode %{
9554     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9555   %}
9556   ins_pipe(pipe_slow);
9557 %}
9558 
9559 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
9560   match(Set cr (CmpF src con));
9561 
9562   ins_cost(145);
9563   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9564             "jnp,s   exit\n\t"
9565             "pushfq\t# saw NaN, set CF\n\t"
9566             "andq    [rsp], #0xffffff2b\n\t"
9567             "popfq\n"
9568     "exit:" %}
9569   ins_encode %{
9570     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9571     emit_cmpfp_fixup(_masm);
9572   %}
9573   ins_pipe(pipe_slow);
9574 %}
9575 
9576 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
9577   match(Set cr (CmpF src con));
9578   ins_cost(100);
9579   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con" %}
9580   ins_encode %{
9581     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9582   %}
9583   ins_pipe(pipe_slow);
9584 %}
9585 
9586 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
9587 %{
9588   match(Set cr (CmpD src1 src2));
9589 
9590   ins_cost(145);
9591   format %{ "ucomisd $src1, $src2\n\t"
9592             "jnp,s   exit\n\t"
9593             "pushfq\t# saw NaN, set CF\n\t"
9594             "andq    [rsp], #0xffffff2b\n\t"
9595             "popfq\n"
9596     "exit:" %}
9597   ins_encode %{
9598     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9599     emit_cmpfp_fixup(_masm);
9600   %}
9601   ins_pipe(pipe_slow);
9602 %}
9603 
9604 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
9605   match(Set cr (CmpD src1 src2));
9606 
9607   ins_cost(100);
9608   format %{ "ucomisd $src1, $src2 test" %}
9609   ins_encode %{
9610     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9611   %}
9612   ins_pipe(pipe_slow);
9613 %}
9614 
9615 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
9616 %{
9617   match(Set cr (CmpD src1 (LoadD src2)));
9618 
9619   ins_cost(145);
9620   format %{ "ucomisd $src1, $src2\n\t"
9621             "jnp,s   exit\n\t"
9622             "pushfq\t# saw NaN, set CF\n\t"
9623             "andq    [rsp], #0xffffff2b\n\t"
9624             "popfq\n"
9625     "exit:" %}
9626   ins_encode %{
9627     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9628     emit_cmpfp_fixup(_masm);
9629   %}
9630   ins_pipe(pipe_slow);
9631 %}
9632 
9633 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
9634   match(Set cr (CmpD src1 (LoadD src2)));
9635 
9636   ins_cost(100);
9637   format %{ "ucomisd $src1, $src2" %}
9638   ins_encode %{
9639     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9640   %}
9641   ins_pipe(pipe_slow);
9642 %}
9643 
9644 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
9645   match(Set cr (CmpD src con));
9646 
9647   ins_cost(145);
9648   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9649             "jnp,s   exit\n\t"
9650             "pushfq\t# saw NaN, set CF\n\t"
9651             "andq    [rsp], #0xffffff2b\n\t"
9652             "popfq\n"
9653     "exit:" %}
9654   ins_encode %{
9655     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9656     emit_cmpfp_fixup(_masm);
9657   %}
9658   ins_pipe(pipe_slow);
9659 %}
9660 
9661 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
9662   match(Set cr (CmpD src con));
9663   ins_cost(100);
9664   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con" %}
9665   ins_encode %{
9666     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9667   %}
9668   ins_pipe(pipe_slow);
9669 %}
9670 
9671 // Compare into -1,0,1
9672 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
9673 %{
9674   match(Set dst (CmpF3 src1 src2));
9675   effect(KILL cr);
9676 
9677   ins_cost(275);
9678   format %{ "ucomiss $src1, $src2\n\t"
9679             "movl    $dst, #-1\n\t"
9680             "jp,s    done\n\t"
9681             "jb,s    done\n\t"
9682             "setne   $dst\n\t"
9683             "movzbl  $dst, $dst\n"
9684     "done:" %}
9685   ins_encode %{
9686     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9687     emit_cmpfp3(_masm, $dst$$Register);
9688   %}
9689   ins_pipe(pipe_slow);
9690 %}
9691 
9692 // Compare into -1,0,1
9693 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
9694 %{
9695   match(Set dst (CmpF3 src1 (LoadF src2)));
9696   effect(KILL cr);
9697 
9698   ins_cost(275);
9699   format %{ "ucomiss $src1, $src2\n\t"
9700             "movl    $dst, #-1\n\t"
9701             "jp,s    done\n\t"
9702             "jb,s    done\n\t"
9703             "setne   $dst\n\t"
9704             "movzbl  $dst, $dst\n"
9705     "done:" %}
9706   ins_encode %{
9707     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9708     emit_cmpfp3(_masm, $dst$$Register);
9709   %}
9710   ins_pipe(pipe_slow);
9711 %}
9712 
9713 // Compare into -1,0,1
9714 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
9715   match(Set dst (CmpF3 src con));
9716   effect(KILL cr);
9717 
9718   ins_cost(275);
9719   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9720             "movl    $dst, #-1\n\t"
9721             "jp,s    done\n\t"
9722             "jb,s    done\n\t"
9723             "setne   $dst\n\t"
9724             "movzbl  $dst, $dst\n"
9725     "done:" %}
9726   ins_encode %{
9727     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9728     emit_cmpfp3(_masm, $dst$$Register);
9729   %}
9730   ins_pipe(pipe_slow);
9731 %}
9732 
9733 // Compare into -1,0,1
9734 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
9735 %{
9736   match(Set dst (CmpD3 src1 src2));
9737   effect(KILL cr);
9738 
9739   ins_cost(275);
9740   format %{ "ucomisd $src1, $src2\n\t"
9741             "movl    $dst, #-1\n\t"
9742             "jp,s    done\n\t"
9743             "jb,s    done\n\t"
9744             "setne   $dst\n\t"
9745             "movzbl  $dst, $dst\n"
9746     "done:" %}
9747   ins_encode %{
9748     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9749     emit_cmpfp3(_masm, $dst$$Register);
9750   %}
9751   ins_pipe(pipe_slow);
9752 %}
9753 
9754 // Compare into -1,0,1
9755 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
9756 %{
9757   match(Set dst (CmpD3 src1 (LoadD src2)));
9758   effect(KILL cr);
9759 
9760   ins_cost(275);
9761   format %{ "ucomisd $src1, $src2\n\t"
9762             "movl    $dst, #-1\n\t"
9763             "jp,s    done\n\t"
9764             "jb,s    done\n\t"
9765             "setne   $dst\n\t"
9766             "movzbl  $dst, $dst\n"
9767     "done:" %}
9768   ins_encode %{
9769     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9770     emit_cmpfp3(_masm, $dst$$Register);
9771   %}
9772   ins_pipe(pipe_slow);
9773 %}
9774 
9775 // Compare into -1,0,1
9776 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
9777   match(Set dst (CmpD3 src con));
9778   effect(KILL cr);
9779 
9780   ins_cost(275);
9781   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9782             "movl    $dst, #-1\n\t"
9783             "jp,s    done\n\t"
9784             "jb,s    done\n\t"
9785             "setne   $dst\n\t"
9786             "movzbl  $dst, $dst\n"
9787     "done:" %}
9788   ins_encode %{
9789     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9790     emit_cmpfp3(_masm, $dst$$Register);
9791   %}
9792   ins_pipe(pipe_slow);
9793 %}
9794 
9795 // -----------Trig and Trancendental Instructions------------------------------
9796 instruct cosD_reg(regD dst) %{
9797   match(Set dst (CosD dst));
9798 
9799   format %{ "dcos   $dst\n\t" %}
9800   opcode(0xD9, 0xFF);
9801   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9802   ins_pipe( pipe_slow );
9803 %}
9804 
9805 instruct sinD_reg(regD dst) %{
9806   match(Set dst (SinD dst));
9807 
9808   format %{ "dsin   $dst\n\t" %}
9809   opcode(0xD9, 0xFE);
9810   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9811   ins_pipe( pipe_slow );
9812 %}
9813 
9814 instruct tanD_reg(regD dst) %{
9815   match(Set dst (TanD dst));
9816 
9817   format %{ "dtan   $dst\n\t" %}
9818   ins_encode( Push_SrcXD(dst),
9819               Opcode(0xD9), Opcode(0xF2),   //fptan
9820               Opcode(0xDD), Opcode(0xD8),   //fstp st
9821               Push_ResultXD(dst) );
9822   ins_pipe( pipe_slow );
9823 %}
9824 
9825 instruct log10D_reg(regD dst) %{
9826   // The source and result Double operands in XMM registers
9827   match(Set dst (Log10D dst));
9828   // fldlg2       ; push log_10(2) on the FPU stack; full 80-bit number
9829   // fyl2x        ; compute log_10(2) * log_2(x)
9830   format %{ "fldlg2\t\t\t#Log10\n\t"
9831             "fyl2x\t\t\t# Q=Log10*Log_2(x)\n\t"
9832          %}
9833    ins_encode(Opcode(0xD9), Opcode(0xEC),   // fldlg2
9834               Push_SrcXD(dst),
9835               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9836               Push_ResultXD(dst));
9837 
9838   ins_pipe( pipe_slow );
9839 %}
9840 
9841 instruct logD_reg(regD dst) %{
9842   // The source and result Double operands in XMM registers
9843   match(Set dst (LogD dst));
9844   // fldln2       ; push log_e(2) on the FPU stack; full 80-bit number
9845   // fyl2x        ; compute log_e(2) * log_2(x)
9846   format %{ "fldln2\t\t\t#Log_e\n\t"
9847             "fyl2x\t\t\t# Q=Log_e*Log_2(x)\n\t"
9848          %}
9849   ins_encode( Opcode(0xD9), Opcode(0xED),   // fldln2
9850               Push_SrcXD(dst),
9851               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9852               Push_ResultXD(dst));
9853   ins_pipe( pipe_slow );
9854 %}
9855 
9856 instruct powD_reg(regD dst, regD src0, regD src1, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9857   match(Set dst (PowD src0 src1));  // Raise src0 to the src1'th power
9858   effect(KILL rax, KILL rdx, KILL rcx, KILL cr);
9859   format %{ "fast_pow $src0 $src1 -&gt; $dst  // KILL $rax, $rcx, $rdx" %}
9860   ins_encode %{
9861     __ subptr(rsp, 8);
9862     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
9863     __ fld_d(Address(rsp, 0));
9864     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
9865     __ fld_d(Address(rsp, 0));
9866     __ fast_pow();
9867     __ fstp_d(Address(rsp, 0));
9868     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9869     __ addptr(rsp, 8);
9870   %}
9871   ins_pipe( pipe_slow );
9872 %}
9873 
9874 instruct expD_reg(regD dst, regD src, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9875   match(Set dst (ExpD src));
9876   effect(KILL rax, KILL rcx, KILL rdx, KILL cr);
9877   format %{ "fast_exp $dst -&gt; $src  // KILL $rax, $rcx, $rdx" %}
9878   ins_encode %{
9879     __ subptr(rsp, 8);
9880     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
9881     __ fld_d(Address(rsp, 0));
9882     __ fast_exp();
9883     __ fstp_d(Address(rsp, 0));
9884     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9885     __ addptr(rsp, 8);
9886   %}
9887   ins_pipe( pipe_slow );
9888 %}
9889 
9890 //----------Arithmetic Conversion Instructions---------------------------------
9891 
9892 instruct roundFloat_nop(regF dst)
9893 %{
9894   match(Set dst (RoundFloat dst));
9895 
9896   ins_cost(0);
9897   ins_encode();
9898   ins_pipe(empty);
9899 %}
9900 
9901 instruct roundDouble_nop(regD dst)
9902 %{
9903   match(Set dst (RoundDouble dst));
9904 
9905   ins_cost(0);
9906   ins_encode();
9907   ins_pipe(empty);
9908 %}
9909 
9910 instruct convF2D_reg_reg(regD dst, regF src)
9911 %{
9912   match(Set dst (ConvF2D src));
9913 
9914   format %{ "cvtss2sd $dst, $src" %}
9915   ins_encode %{
9916     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
9917   %}
9918   ins_pipe(pipe_slow); // XXX
9919 %}
9920 
9921 instruct convF2D_reg_mem(regD dst, memory src)
9922 %{
9923   match(Set dst (ConvF2D (LoadF src)));
9924 
9925   format %{ "cvtss2sd $dst, $src" %}
9926   ins_encode %{
9927     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
9928   %}
9929   ins_pipe(pipe_slow); // XXX
9930 %}
9931 
9932 instruct convD2F_reg_reg(regF dst, regD src)
9933 %{
9934   match(Set dst (ConvD2F src));
9935 
9936   format %{ "cvtsd2ss $dst, $src" %}
9937   ins_encode %{
9938     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
9939   %}
9940   ins_pipe(pipe_slow); // XXX
9941 %}
9942 
9943 instruct convD2F_reg_mem(regF dst, memory src)
9944 %{
9945   match(Set dst (ConvD2F (LoadD src)));
9946 
9947   format %{ "cvtsd2ss $dst, $src" %}
9948   ins_encode %{
9949     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
9950   %}
9951   ins_pipe(pipe_slow); // XXX
9952 %}
9953 
9954 // XXX do mem variants
9955 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
9956 %{
9957   match(Set dst (ConvF2I src));
9958   effect(KILL cr);
9959 
9960   format %{ "cvttss2sil $dst, $src\t# f2i\n\t"
9961             "cmpl    $dst, #0x80000000\n\t"
9962             "jne,s   done\n\t"
9963             "subq    rsp, #8\n\t"
9964             "movss   [rsp], $src\n\t"
9965             "call    f2i_fixup\n\t"
9966             "popq    $dst\n"
9967     "done:   "%}
9968   ins_encode %{
9969     Label done;
9970     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
9971     __ cmpl($dst$$Register, 0x80000000);
9972     __ jccb(Assembler::notEqual, done);
9973     __ subptr(rsp, 8);
9974     __ movflt(Address(rsp, 0), $src$$XMMRegister);
9975     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
9976     __ pop($dst$$Register);
9977     __ bind(done);
9978   %}
9979   ins_pipe(pipe_slow);
9980 %}
9981 
9982 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
9983 %{
9984   match(Set dst (ConvF2L src));
9985   effect(KILL cr);
9986 
9987   format %{ "cvttss2siq $dst, $src\t# f2l\n\t"
9988             "cmpq    $dst, [0x8000000000000000]\n\t"
9989             "jne,s   done\n\t"
9990             "subq    rsp, #8\n\t"
9991             "movss   [rsp], $src\n\t"
9992             "call    f2l_fixup\n\t"
9993             "popq    $dst\n"
9994     "done:   "%}
9995   ins_encode %{
9996     Label done;
9997     __ cvttss2siq($dst$$Register, $src$$XMMRegister);
9998     __ cmp64($dst$$Register,
9999              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10000     __ jccb(Assembler::notEqual, done);
10001     __ subptr(rsp, 8);
10002     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10003     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
10004     __ pop($dst$$Register);
10005     __ bind(done);
10006   %}
10007   ins_pipe(pipe_slow);
10008 %}
10009 
10010 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10011 %{
10012   match(Set dst (ConvD2I src));
10013   effect(KILL cr);
10014 
10015   format %{ "cvttsd2sil $dst, $src\t# d2i\n\t"
10016             "cmpl    $dst, #0x80000000\n\t"
10017             "jne,s   done\n\t"
10018             "subq    rsp, #8\n\t"
10019             "movsd   [rsp], $src\n\t"
10020             "call    d2i_fixup\n\t"
10021             "popq    $dst\n"
10022     "done:   "%}
10023   ins_encode %{
10024     Label done;
10025     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10026     __ cmpl($dst$$Register, 0x80000000);
10027     __ jccb(Assembler::notEqual, done);
10028     __ subptr(rsp, 8);
10029     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10030     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
10031     __ pop($dst$$Register);
10032     __ bind(done);
10033   %}
10034   ins_pipe(pipe_slow);
10035 %}
10036 
10037 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10038 %{
10039   match(Set dst (ConvD2L src));
10040   effect(KILL cr);
10041 
10042   format %{ "cvttsd2siq $dst, $src\t# d2l\n\t"
10043             "cmpq    $dst, [0x8000000000000000]\n\t"
10044             "jne,s   done\n\t"
10045             "subq    rsp, #8\n\t"
10046             "movsd   [rsp], $src\n\t"
10047             "call    d2l_fixup\n\t"
10048             "popq    $dst\n"
10049     "done:   "%}
10050   ins_encode %{
10051     Label done;
10052     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);
10053     __ cmp64($dst$$Register,
10054              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10055     __ jccb(Assembler::notEqual, done);
10056     __ subptr(rsp, 8);
10057     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10058     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
10059     __ pop($dst$$Register);
10060     __ bind(done);
10061   %}
10062   ins_pipe(pipe_slow);
10063 %}
10064 
10065 instruct convI2F_reg_reg(regF dst, rRegI src)
10066 %{
10067   predicate(!UseXmmI2F);
10068   match(Set dst (ConvI2F src));
10069 
10070   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10071   ins_encode %{
10072     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10073   %}
10074   ins_pipe(pipe_slow); // XXX
10075 %}
10076 
10077 instruct convI2F_reg_mem(regF dst, memory src)
10078 %{
10079   match(Set dst (ConvI2F (LoadI src)));
10080 
10081   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10082   ins_encode %{
10083     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10084   %}
10085   ins_pipe(pipe_slow); // XXX
10086 %}
10087 
10088 instruct convI2D_reg_reg(regD dst, rRegI src)
10089 %{
10090   predicate(!UseXmmI2D);
10091   match(Set dst (ConvI2D src));
10092 
10093   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10094   ins_encode %{
10095     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10096   %}
10097   ins_pipe(pipe_slow); // XXX
10098 %}
10099 
10100 instruct convI2D_reg_mem(regD dst, memory src)
10101 %{
10102   match(Set dst (ConvI2D (LoadI src)));
10103 
10104   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10105   ins_encode %{
10106     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10107   %}
10108   ins_pipe(pipe_slow); // XXX
10109 %}
10110 
10111 instruct convXI2F_reg(regF dst, rRegI src)
10112 %{
10113   predicate(UseXmmI2F);
10114   match(Set dst (ConvI2F src));
10115 
10116   format %{ "movdl $dst, $src\n\t"
10117             "cvtdq2psl $dst, $dst\t# i2f" %}
10118   ins_encode %{
10119     __ movdl($dst$$XMMRegister, $src$$Register);
10120     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10121   %}
10122   ins_pipe(pipe_slow); // XXX
10123 %}
10124 
10125 instruct convXI2D_reg(regD dst, rRegI src)
10126 %{
10127   predicate(UseXmmI2D);
10128   match(Set dst (ConvI2D src));
10129 
10130   format %{ "movdl $dst, $src\n\t"
10131             "cvtdq2pdl $dst, $dst\t# i2d" %}
10132   ins_encode %{
10133     __ movdl($dst$$XMMRegister, $src$$Register);
10134     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10135   %}
10136   ins_pipe(pipe_slow); // XXX
10137 %}
10138 
10139 instruct convL2F_reg_reg(regF dst, rRegL src)
10140 %{
10141   match(Set dst (ConvL2F src));
10142 
10143   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10144   ins_encode %{
10145     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10146   %}
10147   ins_pipe(pipe_slow); // XXX
10148 %}
10149 
10150 instruct convL2F_reg_mem(regF dst, memory src)
10151 %{
10152   match(Set dst (ConvL2F (LoadL src)));
10153 
10154   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10155   ins_encode %{
10156     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10157   %}
10158   ins_pipe(pipe_slow); // XXX
10159 %}
10160 
10161 instruct convL2D_reg_reg(regD dst, rRegL src)
10162 %{
10163   match(Set dst (ConvL2D src));
10164 
10165   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10166   ins_encode %{
10167     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10168   %}
10169   ins_pipe(pipe_slow); // XXX
10170 %}
10171 
10172 instruct convL2D_reg_mem(regD dst, memory src)
10173 %{
10174   match(Set dst (ConvL2D (LoadL src)));
10175 
10176   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10177   ins_encode %{
10178     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10179   %}
10180   ins_pipe(pipe_slow); // XXX
10181 %}
10182 
10183 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10184 %{
10185   match(Set dst (ConvI2L src));
10186 
10187   ins_cost(125);
10188   format %{ "movslq  $dst, $src\t# i2l" %}
10189   ins_encode %{
10190     __ movslq($dst$$Register, $src$$Register);
10191   %}
10192   ins_pipe(ialu_reg_reg);
10193 %}
10194 
10195 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10196 // %{
10197 //   match(Set dst (ConvI2L src));
10198 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10199 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10200 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10201 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10202 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10203 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10204 
10205 //   format %{ "movl    $dst, $src\t# unsigned i2l" %}
10206 //   ins_encode(enc_copy(dst, src));
10207 // //   opcode(0x63); // needs REX.W
10208 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10209 //   ins_pipe(ialu_reg_reg);
10210 // %}
10211 
10212 // Zero-extend convert int to long
10213 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10214 %{
10215   match(Set dst (AndL (ConvI2L src) mask));
10216 
10217   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10218   ins_encode %{
10219     if ($dst$$reg != $src$$reg) {
10220       __ movl($dst$$Register, $src$$Register);
10221     }
10222   %}
10223   ins_pipe(ialu_reg_reg);
10224 %}
10225 
10226 // Zero-extend convert int to long
10227 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10228 %{
10229   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10230 
10231   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10232   ins_encode %{
10233     __ movl($dst$$Register, $src$$Address);
10234   %}
10235   ins_pipe(ialu_reg_mem);
10236 %}
10237 
10238 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10239 %{
10240   match(Set dst (AndL src mask));
10241 
10242   format %{ "movl    $dst, $src\t# zero-extend long" %}
10243   ins_encode %{
10244     __ movl($dst$$Register, $src$$Register);
10245   %}
10246   ins_pipe(ialu_reg_reg);
10247 %}
10248 
10249 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10250 %{
10251   match(Set dst (ConvL2I src));
10252 
10253   format %{ "movl    $dst, $src\t# l2i" %}
10254   ins_encode %{
10255     __ movl($dst$$Register, $src$$Register);
10256   %}
10257   ins_pipe(ialu_reg_reg);
10258 %}
10259 
10260 
10261 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10262   match(Set dst (MoveF2I src));
10263   effect(DEF dst, USE src);
10264 
10265   ins_cost(125);
10266   format %{ "movl    $dst, $src\t# MoveF2I_stack_reg" %}
10267   ins_encode %{
10268     __ movl($dst$$Register, Address(rsp, $src$$disp));
10269   %}
10270   ins_pipe(ialu_reg_mem);
10271 %}
10272 
10273 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10274   match(Set dst (MoveI2F src));
10275   effect(DEF dst, USE src);
10276 
10277   ins_cost(125);
10278   format %{ "movss   $dst, $src\t# MoveI2F_stack_reg" %}
10279   ins_encode %{
10280     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10281   %}
10282   ins_pipe(pipe_slow);
10283 %}
10284 
10285 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10286   match(Set dst (MoveD2L src));
10287   effect(DEF dst, USE src);
10288 
10289   ins_cost(125);
10290   format %{ "movq    $dst, $src\t# MoveD2L_stack_reg" %}
10291   ins_encode %{
10292     __ movq($dst$$Register, Address(rsp, $src$$disp));
10293   %}
10294   ins_pipe(ialu_reg_mem);
10295 %}
10296 
10297 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10298   predicate(!UseXmmLoadAndClearUpper);
10299   match(Set dst (MoveL2D src));
10300   effect(DEF dst, USE src);
10301 
10302   ins_cost(125);
10303   format %{ "movlpd  $dst, $src\t# MoveL2D_stack_reg" %}
10304   ins_encode %{
10305     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10306   %}
10307   ins_pipe(pipe_slow);
10308 %}
10309 
10310 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10311   predicate(UseXmmLoadAndClearUpper);
10312   match(Set dst (MoveL2D src));
10313   effect(DEF dst, USE src);
10314 
10315   ins_cost(125);
10316   format %{ "movsd   $dst, $src\t# MoveL2D_stack_reg" %}
10317   ins_encode %{
10318     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10319   %}
10320   ins_pipe(pipe_slow);
10321 %}
10322 
10323 
10324 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10325   match(Set dst (MoveF2I src));
10326   effect(DEF dst, USE src);
10327 
10328   ins_cost(95); // XXX
10329   format %{ "movss   $dst, $src\t# MoveF2I_reg_stack" %}
10330   ins_encode %{
10331     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10332   %}
10333   ins_pipe(pipe_slow);
10334 %}
10335 
10336 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10337   match(Set dst (MoveI2F src));
10338   effect(DEF dst, USE src);
10339 
10340   ins_cost(100);
10341   format %{ "movl    $dst, $src\t# MoveI2F_reg_stack" %}
10342   ins_encode %{
10343     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10344   %}
10345   ins_pipe( ialu_mem_reg );
10346 %}
10347 
10348 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10349   match(Set dst (MoveD2L src));
10350   effect(DEF dst, USE src);
10351 
10352   ins_cost(95); // XXX
10353   format %{ "movsd   $dst, $src\t# MoveL2D_reg_stack" %}
10354   ins_encode %{
10355     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10356   %}
10357   ins_pipe(pipe_slow);
10358 %}
10359 
10360 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10361   match(Set dst (MoveL2D src));
10362   effect(DEF dst, USE src);
10363 
10364   ins_cost(100);
10365   format %{ "movq    $dst, $src\t# MoveL2D_reg_stack" %}
10366   ins_encode %{
10367     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10368   %}
10369   ins_pipe(ialu_mem_reg);
10370 %}
10371 
10372 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10373   match(Set dst (MoveF2I src));
10374   effect(DEF dst, USE src);
10375   ins_cost(85);
10376   format %{ "movd    $dst,$src\t# MoveF2I" %}
10377   ins_encode %{
10378     __ movdl($dst$$Register, $src$$XMMRegister);
10379   %}
10380   ins_pipe( pipe_slow );
10381 %}
10382 
10383 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10384   match(Set dst (MoveD2L src));
10385   effect(DEF dst, USE src);
10386   ins_cost(85);
10387   format %{ "movd    $dst,$src\t# MoveD2L" %}
10388   ins_encode %{
10389     __ movdq($dst$$Register, $src$$XMMRegister);
10390   %}
10391   ins_pipe( pipe_slow );
10392 %}
10393 
10394 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10395   match(Set dst (MoveI2F src));
10396   effect(DEF dst, USE src);
10397   ins_cost(100);
10398   format %{ "movd    $dst,$src\t# MoveI2F" %}
10399   ins_encode %{
10400     __ movdl($dst$$XMMRegister, $src$$Register);
10401   %}
10402   ins_pipe( pipe_slow );
10403 %}
10404 
10405 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10406   match(Set dst (MoveL2D src));
10407   effect(DEF dst, USE src);
10408   ins_cost(100);
10409   format %{ "movd    $dst,$src\t# MoveL2D" %}
10410   ins_encode %{
10411      __ movdq($dst$$XMMRegister, $src$$Register);
10412   %}
10413   ins_pipe( pipe_slow );
10414 %}
10415 
10416 
10417 // =======================================================================
10418 // fast clearing of an array
10419 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10420                   rFlagsReg cr)
10421 %{
10422   predicate(!UseFastStosb);
10423   match(Set dummy (ClearArray cnt base));
10424   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10425 
10426   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10427             "rep     stosq\t# Store rax to *rdi++ while rcx--" %}
10428   ins_encode %{
10429     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10430   %}
10431   ins_pipe(pipe_slow);
10432 %}
10433 
10434 instruct rep_fast_stosb(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10435                         rFlagsReg cr)
10436 %{
10437   predicate(UseFastStosb);
10438   match(Set dummy (ClearArray cnt base));
10439   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10440   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10441             "shlq    rcx,3\t# Convert doublewords to bytes\n\t"
10442             "rep     stosb\t# Store rax to *rdi++ while rcx--" %}
10443   ins_encode %{
10444     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10445   %}
10446   ins_pipe( pipe_slow );
10447 %}
10448 
10449 instruct string_compare(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10450                         rax_RegI result, regD tmp1, rFlagsReg cr)
10451 %{
10452   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10453   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10454 
10455   format %{ "String Compare $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10456   ins_encode %{
10457     __ string_compare($str1$$Register, $str2$$Register,
10458                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10459                       $tmp1$$XMMRegister);
10460   %}
10461   ins_pipe( pipe_slow );
10462 %}
10463 
10464 // fast search of substring with known size.
10465 instruct string_indexof_con(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10466                             rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10467 %{
10468   predicate(UseSSE42Intrinsics);
10469   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10470   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10471 
10472   format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10473   ins_encode %{
10474     int icnt2 = (int)$int_cnt2$$constant;
10475     if (icnt2 &gt;= 8) {
10476       // IndexOf for constant substrings with size &gt;= 8 elements
10477       // which don't need to be loaded through stack.
10478       __ string_indexofC8($str1$$Register, $str2$$Register,
10479                           $cnt1$$Register, $cnt2$$Register,
10480                           icnt2, $result$$Register,
10481                           $vec$$XMMRegister, $tmp$$Register);
10482     } else {
10483       // Small strings are loaded through stack if they cross page boundary.
10484       __ string_indexof($str1$$Register, $str2$$Register,
10485                         $cnt1$$Register, $cnt2$$Register,
10486                         icnt2, $result$$Register,
10487                         $vec$$XMMRegister, $tmp$$Register);
10488     }
10489   %}
10490   ins_pipe( pipe_slow );
10491 %}
10492 
10493 instruct string_indexof(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10494                         rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10495 %{
10496   predicate(UseSSE42Intrinsics);
10497   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10498   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10499 
10500   format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10501   ins_encode %{
10502     __ string_indexof($str1$$Register, $str2$$Register,
10503                       $cnt1$$Register, $cnt2$$Register,
10504                       (-1), $result$$Register,
10505                       $vec$$XMMRegister, $tmp$$Register);
10506   %}
10507   ins_pipe( pipe_slow );
10508 %}
10509 
10510 // fast string equals
10511 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
10512                        regD tmp1, regD tmp2, rbx_RegI tmp3, rFlagsReg cr)
10513 %{
10514   match(Set result (StrEquals (Binary str1 str2) cnt));
10515   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
10516 
10517   format %{ "String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3" %}
10518   ins_encode %{
10519     __ char_arrays_equals(false, $str1$$Register, $str2$$Register,
10520                           $cnt$$Register, $result$$Register, $tmp3$$Register,
10521                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10522   %}
10523   ins_pipe( pipe_slow );
10524 %}
10525 
10526 // fast array equals
10527 instruct array_equals(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
10528                       regD tmp1, regD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
10529 %{
10530   match(Set result (AryEq ary1 ary2));
10531   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
10532   //ins_cost(300);
10533 
10534   format %{ "Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4" %}
10535   ins_encode %{
10536     __ char_arrays_equals(true, $ary1$$Register, $ary2$$Register,
10537                           $tmp3$$Register, $result$$Register, $tmp4$$Register,
10538                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10539   %}
10540   ins_pipe( pipe_slow );
10541 %}
10542 
10543 // encode char[] to byte[] in ISO_8859_1
10544 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
10545                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
10546                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
10547   match(Set result (EncodeISOArray src (Binary dst len)));
10548   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
10549 
10550   format %{ "Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI " %}
10551   ins_encode %{
10552     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
10553                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
10554                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
10555   %}
10556   ins_pipe( pipe_slow );
10557 %}
10558 
10559 //----------Overflow Math Instructions-----------------------------------------
10560 
10561 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10562 %{
10563   match(Set cr (OverflowAddI op1 op2));
10564   effect(DEF cr, USE_KILL op1, USE op2);
10565 
10566   format %{ "addl    $op1, $op2\t# overflow check int" %}
10567 
10568   ins_encode %{
10569     __ addl($op1$$Register, $op2$$Register);
10570   %}
10571   ins_pipe(ialu_reg_reg);
10572 %}
10573 
10574 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
10575 %{
10576   match(Set cr (OverflowAddI op1 op2));
10577   effect(DEF cr, USE_KILL op1, USE op2);
10578 
10579   format %{ "addl    $op1, $op2\t# overflow check int" %}
10580 
10581   ins_encode %{
10582     __ addl($op1$$Register, $op2$$constant);
10583   %}
10584   ins_pipe(ialu_reg_reg);
10585 %}
10586 
10587 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10588 %{
10589   match(Set cr (OverflowAddL op1 op2));
10590   effect(DEF cr, USE_KILL op1, USE op2);
10591 
10592   format %{ "addq    $op1, $op2\t# overflow check long" %}
10593   ins_encode %{
10594     __ addq($op1$$Register, $op2$$Register);
10595   %}
10596   ins_pipe(ialu_reg_reg);
10597 %}
10598 
10599 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
10600 %{
10601   match(Set cr (OverflowAddL op1 op2));
10602   effect(DEF cr, USE_KILL op1, USE op2);
10603 
10604   format %{ "addq    $op1, $op2\t# overflow check long" %}
10605   ins_encode %{
10606     __ addq($op1$$Register, $op2$$constant);
10607   %}
10608   ins_pipe(ialu_reg_reg);
10609 %}
10610 
10611 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10612 %{
10613   match(Set cr (OverflowSubI op1 op2));
10614 
10615   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10616   ins_encode %{
10617     __ cmpl($op1$$Register, $op2$$Register);
10618   %}
10619   ins_pipe(ialu_reg_reg);
10620 %}
10621 
10622 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10623 %{
10624   match(Set cr (OverflowSubI op1 op2));
10625 
10626   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10627   ins_encode %{
10628     __ cmpl($op1$$Register, $op2$$constant);
10629   %}
10630   ins_pipe(ialu_reg_reg);
10631 %}
10632 
10633 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
10634 %{
10635   match(Set cr (OverflowSubL op1 op2));
10636 
10637   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10638   ins_encode %{
10639     __ cmpq($op1$$Register, $op2$$Register);
10640   %}
10641   ins_pipe(ialu_reg_reg);
10642 %}
10643 
10644 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
10645 %{
10646   match(Set cr (OverflowSubL op1 op2));
10647 
10648   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10649   ins_encode %{
10650     __ cmpq($op1$$Register, $op2$$constant);
10651   %}
10652   ins_pipe(ialu_reg_reg);
10653 %}
10654 
10655 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
10656 %{
10657   match(Set cr (OverflowSubI zero op2));
10658   effect(DEF cr, USE_KILL op2);
10659 
10660   format %{ "negl    $op2\t# overflow check int" %}
10661   ins_encode %{
10662     __ negl($op2$$Register);
10663   %}
10664   ins_pipe(ialu_reg_reg);
10665 %}
10666 
10667 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
10668 %{
10669   match(Set cr (OverflowSubL zero op2));
10670   effect(DEF cr, USE_KILL op2);
10671 
10672   format %{ "negq    $op2\t# overflow check long" %}
10673   ins_encode %{
10674     __ negq($op2$$Register);
10675   %}
10676   ins_pipe(ialu_reg_reg);
10677 %}
10678 
10679 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10680 %{
10681   match(Set cr (OverflowMulI op1 op2));
10682   effect(DEF cr, USE_KILL op1, USE op2);
10683 
10684   format %{ "imull    $op1, $op2\t# overflow check int" %}
10685   ins_encode %{
10686     __ imull($op1$$Register, $op2$$Register);
10687   %}
10688   ins_pipe(ialu_reg_reg_alu0);
10689 %}
10690 
10691 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
10692 %{
10693   match(Set cr (OverflowMulI op1 op2));
10694   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10695 
10696   format %{ "imull    $tmp, $op1, $op2\t# overflow check int" %}
10697   ins_encode %{
10698     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
10699   %}
10700   ins_pipe(ialu_reg_reg_alu0);
10701 %}
10702 
10703 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10704 %{
10705   match(Set cr (OverflowMulL op1 op2));
10706   effect(DEF cr, USE_KILL op1, USE op2);
10707 
10708   format %{ "imulq    $op1, $op2\t# overflow check long" %}
10709   ins_encode %{
10710     __ imulq($op1$$Register, $op2$$Register);
10711   %}
10712   ins_pipe(ialu_reg_reg_alu0);
10713 %}
10714 
10715 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
10716 %{
10717   match(Set cr (OverflowMulL op1 op2));
10718   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10719 
10720   format %{ "imulq    $tmp, $op1, $op2\t# overflow check long" %}
10721   ins_encode %{
10722     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
10723   %}
10724   ins_pipe(ialu_reg_reg_alu0);
10725 %}
10726 
10727 
10728 //----------Control Flow Instructions------------------------------------------
10729 // Signed compare Instructions
10730 
10731 // XXX more variants!!
10732 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10733 %{
10734   match(Set cr (CmpI op1 op2));
10735   effect(DEF cr, USE op1, USE op2);
10736 
10737   format %{ "cmpl    $op1, $op2" %}
10738   opcode(0x3B);  /* Opcode 3B /r */
10739   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10740   ins_pipe(ialu_cr_reg_reg);
10741 %}
10742 
10743 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10744 %{
10745   match(Set cr (CmpI op1 op2));
10746 
10747   format %{ "cmpl    $op1, $op2" %}
10748   opcode(0x81, 0x07); /* Opcode 81 /7 */
10749   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10750   ins_pipe(ialu_cr_reg_imm);
10751 %}
10752 
10753 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
10754 %{
10755   match(Set cr (CmpI op1 (LoadI op2)));
10756 
10757   ins_cost(500); // XXX
10758   format %{ "cmpl    $op1, $op2" %}
10759   opcode(0x3B); /* Opcode 3B /r */
10760   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10761   ins_pipe(ialu_cr_reg_mem);
10762 %}
10763 
10764 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
10765 %{
10766   match(Set cr (CmpI src zero));
10767 
10768   format %{ "testl   $src, $src" %}
10769   opcode(0x85);
10770   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10771   ins_pipe(ialu_cr_reg_imm);
10772 %}
10773 
10774 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
10775 %{
10776   match(Set cr (CmpI (AndI src con) zero));
10777 
10778   format %{ "testl   $src, $con" %}
10779   opcode(0xF7, 0x00);
10780   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
10781   ins_pipe(ialu_cr_reg_imm);
10782 %}
10783 
10784 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
10785 %{
10786   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
10787 
10788   format %{ "testl   $src, $mem" %}
10789   opcode(0x85);
10790   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
10791   ins_pipe(ialu_cr_reg_mem);
10792 %}
10793 
10794 // Unsigned compare Instructions; really, same as signed except they
10795 // produce an rFlagsRegU instead of rFlagsReg.
10796 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
10797 %{
10798   match(Set cr (CmpU op1 op2));
10799 
10800   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10801   opcode(0x3B); /* Opcode 3B /r */
10802   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10803   ins_pipe(ialu_cr_reg_reg);
10804 %}
10805 
10806 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
10807 %{
10808   match(Set cr (CmpU op1 op2));
10809 
10810   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10811   opcode(0x81,0x07); /* Opcode 81 /7 */
10812   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10813   ins_pipe(ialu_cr_reg_imm);
10814 %}
10815 
10816 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
10817 %{
10818   match(Set cr (CmpU op1 (LoadI op2)));
10819 
10820   ins_cost(500); // XXX
10821   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10822   opcode(0x3B); /* Opcode 3B /r */
10823   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10824   ins_pipe(ialu_cr_reg_mem);
10825 %}
10826 
10827 // // // Cisc-spilled version of cmpU_rReg
10828 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
10829 // //%{
10830 // //  match(Set cr (CmpU (LoadI op1) op2));
10831 // //
10832 // //  format %{ "CMPu   $op1,$op2" %}
10833 // //  ins_cost(500);
10834 // //  opcode(0x39);  /* Opcode 39 /r */
10835 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10836 // //%}
10837 
10838 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
10839 %{
10840   match(Set cr (CmpU src zero));
10841 
10842   format %{ "testl  $src, $src\t# unsigned" %}
10843   opcode(0x85);
10844   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10845   ins_pipe(ialu_cr_reg_imm);
10846 %}
10847 
10848 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
10849 %{
10850   match(Set cr (CmpP op1 op2));
10851 
10852   format %{ "cmpq    $op1, $op2\t# ptr" %}
10853   opcode(0x3B); /* Opcode 3B /r */
10854   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
10855   ins_pipe(ialu_cr_reg_reg);
10856 %}
10857 
10858 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
10859 %{
10860   match(Set cr (CmpP op1 (LoadP op2)));
10861 
10862   ins_cost(500); // XXX
10863   format %{ "cmpq    $op1, $op2\t# ptr" %}
10864   opcode(0x3B); /* Opcode 3B /r */
10865   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10866   ins_pipe(ialu_cr_reg_mem);
10867 %}
10868 
10869 // // // Cisc-spilled version of cmpP_rReg
10870 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
10871 // //%{
10872 // //  match(Set cr (CmpP (LoadP op1) op2));
10873 // //
10874 // //  format %{ "CMPu   $op1,$op2" %}
10875 // //  ins_cost(500);
10876 // //  opcode(0x39);  /* Opcode 39 /r */
10877 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10878 // //%}
10879 
10880 // XXX this is generalized by compP_rReg_mem???
10881 // Compare raw pointer (used in out-of-heap check).
10882 // Only works because non-oop pointers must be raw pointers
10883 // and raw pointers have no anti-dependencies.
10884 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
10885 %{
10886   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);
10887   match(Set cr (CmpP op1 (LoadP op2)));
10888 
10889   format %{ "cmpq    $op1, $op2\t# raw ptr" %}
10890   opcode(0x3B); /* Opcode 3B /r */
10891   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10892   ins_pipe(ialu_cr_reg_mem);
10893 %}
10894 
10895 // This will generate a signed flags result. This should be OK since
10896 // any compare to a zero should be eq/neq.
10897 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
10898 %{
10899   match(Set cr (CmpP src zero));
10900 
10901   format %{ "testq   $src, $src\t# ptr" %}
10902   opcode(0x85);
10903   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
10904   ins_pipe(ialu_cr_reg_imm);
10905 %}
10906 
10907 // This will generate a signed flags result. This should be OK since
10908 // any compare to a zero should be eq/neq.
10909 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
10910 %{
10911   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
10912   match(Set cr (CmpP (LoadP op) zero));
10913 
10914   ins_cost(500); // XXX
10915   format %{ "testq   $op, 0xffffffffffffffff\t# ptr" %}
10916   opcode(0xF7); /* Opcode F7 /0 */
10917   ins_encode(REX_mem_wide(op),
10918              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
10919   ins_pipe(ialu_cr_reg_imm);
10920 %}
10921 
10922 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
10923 %{
10924   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
10925   match(Set cr (CmpP (LoadP mem) zero));
10926 
10927   format %{ "cmpq    R12, $mem\t# ptr (R12_heapbase==0)" %}
10928   ins_encode %{
10929     __ cmpq(r12, $mem$$Address);
10930   %}
10931   ins_pipe(ialu_cr_reg_mem);
10932 %}
10933 
10934 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
10935 %{
10936   match(Set cr (CmpN op1 op2));
10937 
10938   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10939   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
10940   ins_pipe(ialu_cr_reg_reg);
10941 %}
10942 
10943 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
10944 %{
10945   match(Set cr (CmpN src (LoadN mem)));
10946 
10947   format %{ "cmpl    $src, $mem\t# compressed ptr" %}
10948   ins_encode %{
10949     __ cmpl($src$$Register, $mem$$Address);
10950   %}
10951   ins_pipe(ialu_cr_reg_mem);
10952 %}
10953 
10954 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
10955   match(Set cr (CmpN op1 op2));
10956 
10957   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10958   ins_encode %{
10959     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
10960   %}
10961   ins_pipe(ialu_cr_reg_imm);
10962 %}
10963 
10964 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
10965 %{
10966   match(Set cr (CmpN src (LoadN mem)));
10967 
10968   format %{ "cmpl    $mem, $src\t# compressed ptr" %}
10969   ins_encode %{
10970     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
10971   %}
10972   ins_pipe(ialu_cr_reg_mem);
10973 %}
10974 
10975 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
10976   match(Set cr (CmpN op1 op2));
10977 
10978   format %{ "cmpl    $op1, $op2\t# compressed klass ptr" %}
10979   ins_encode %{
10980     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
10981   %}
10982   ins_pipe(ialu_cr_reg_imm);
10983 %}
10984 
10985 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
10986 %{
10987   match(Set cr (CmpN src (LoadNKlass mem)));
10988 
10989   format %{ "cmpl    $mem, $src\t# compressed klass ptr" %}
10990   ins_encode %{
10991     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
10992   %}
10993   ins_pipe(ialu_cr_reg_mem);
10994 %}
10995 
10996 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
10997   match(Set cr (CmpN src zero));
10998 
10999   format %{ "testl   $src, $src\t# compressed ptr" %}
11000   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11001   ins_pipe(ialu_cr_reg_imm);
11002 %}
11003 
11004 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11005 %{
11006   predicate(Universe::narrow_oop_base() != NULL);
11007   match(Set cr (CmpN (LoadN mem) zero));
11008 
11009   ins_cost(500); // XXX
11010   format %{ "testl   $mem, 0xffffffff\t# compressed ptr" %}
11011   ins_encode %{
11012     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11013   %}
11014   ins_pipe(ialu_cr_reg_mem);
11015 %}
11016 
11017 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11018 %{
11019   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));
11020   match(Set cr (CmpN (LoadN mem) zero));
11021 
11022   format %{ "cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)" %}
11023   ins_encode %{
11024     __ cmpl(r12, $mem$$Address);
11025   %}
11026   ins_pipe(ialu_cr_reg_mem);
11027 %}
11028 
11029 // Yanked all unsigned pointer compare operations.
11030 // Pointer compares are done with CmpP which is already unsigned.
11031 
11032 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11033 %{
11034   match(Set cr (CmpL op1 op2));
11035 
11036   format %{ "cmpq    $op1, $op2" %}
11037   opcode(0x3B);  /* Opcode 3B /r */
11038   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11039   ins_pipe(ialu_cr_reg_reg);
11040 %}
11041 
11042 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11043 %{
11044   match(Set cr (CmpL op1 op2));
11045 
11046   format %{ "cmpq    $op1, $op2" %}
11047   opcode(0x81, 0x07); /* Opcode 81 /7 */
11048   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11049   ins_pipe(ialu_cr_reg_imm);
11050 %}
11051 
11052 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11053 %{
11054   match(Set cr (CmpL op1 (LoadL op2)));
11055 
11056   format %{ "cmpq    $op1, $op2" %}
11057   opcode(0x3B); /* Opcode 3B /r */
11058   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11059   ins_pipe(ialu_cr_reg_mem);
11060 %}
11061 
11062 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11063 %{
11064   match(Set cr (CmpL src zero));
11065 
11066   format %{ "testq   $src, $src" %}
11067   opcode(0x85);
11068   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11069   ins_pipe(ialu_cr_reg_imm);
11070 %}
11071 
11072 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11073 %{
11074   match(Set cr (CmpL (AndL src con) zero));
11075 
11076   format %{ "testq   $src, $con\t# long" %}
11077   opcode(0xF7, 0x00);
11078   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11079   ins_pipe(ialu_cr_reg_imm);
11080 %}
11081 
11082 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11083 %{
11084   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11085 
11086   format %{ "testq   $src, $mem" %}
11087   opcode(0x85);
11088   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11089   ins_pipe(ialu_cr_reg_mem);
11090 %}
11091 
11092 // Manifest a CmpL result in an integer register.  Very painful.
11093 // This is the test to avoid.
11094 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11095 %{
11096   match(Set dst (CmpL3 src1 src2));
11097   effect(KILL flags);
11098 
11099   ins_cost(275); // XXX
11100   format %{ "cmpq    $src1, $src2\t# CmpL3\n\t"
11101             "movl    $dst, -1\n\t"
11102             "jl,s    done\n\t"
11103             "setne   $dst\n\t"
11104             "movzbl  $dst, $dst\n\t"
11105     "done:" %}
11106   ins_encode(cmpl3_flag(src1, src2, dst));
11107   ins_pipe(pipe_slow);
11108 %}
11109 
11110 //----------Max and Min--------------------------------------------------------
11111 // Min Instructions
11112 
11113 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11114 %{
11115   effect(USE_DEF dst, USE src, USE cr);
11116 
11117   format %{ "cmovlgt $dst, $src\t# min" %}
11118   opcode(0x0F, 0x4F);
11119   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11120   ins_pipe(pipe_cmov_reg);
11121 %}
11122 
11123 
11124 instruct minI_rReg(rRegI dst, rRegI src)
11125 %{
11126   match(Set dst (MinI dst src));
11127 
11128   ins_cost(200);
11129   expand %{
11130     rFlagsReg cr;
11131     compI_rReg(cr, dst, src);
11132     cmovI_reg_g(dst, src, cr);
11133   %}
11134 %}
11135 
11136 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
11137 %{
11138   effect(USE_DEF dst, USE src, USE cr);
11139 
11140   format %{ "cmovllt $dst, $src\t# max" %}
11141   opcode(0x0F, 0x4C);
11142   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11143   ins_pipe(pipe_cmov_reg);
11144 %}
11145 
11146 
11147 instruct maxI_rReg(rRegI dst, rRegI src)
11148 %{
11149   match(Set dst (MaxI dst src));
11150 
11151   ins_cost(200);
11152   expand %{
11153     rFlagsReg cr;
11154     compI_rReg(cr, dst, src);
11155     cmovI_reg_l(dst, src, cr);
11156   %}
11157 %}
11158 
11159 // ============================================================================
11160 // Branch Instructions
11161 
11162 // Jump Direct - Label defines a relative address from JMP+1
11163 instruct jmpDir(label labl)
11164 %{
11165   match(Goto);
11166   effect(USE labl);
11167 
11168   ins_cost(300);
11169   format %{ "jmp     $labl" %}
11170   size(5);
11171   ins_encode %{
11172     Label* L = $labl$$label;
11173     __ jmp(*L, false); // Always long jump
11174   %}
11175   ins_pipe(pipe_jmp);
11176 %}
11177 
11178 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11179 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
11180 %{
11181   match(If cop cr);
11182   effect(USE labl);
11183 
11184   ins_cost(300);
11185   format %{ "j$cop     $labl" %}
11186   size(6);
11187   ins_encode %{
11188     Label* L = $labl$$label;
11189     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11190   %}
11191   ins_pipe(pipe_jcc);
11192 %}
11193 
11194 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11195 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
11196 %{
11197   match(CountedLoopEnd cop cr);
11198   effect(USE labl);
11199 
11200   ins_cost(300);
11201   format %{ "j$cop     $labl\t# loop end" %}
11202   size(6);
11203   ins_encode %{
11204     Label* L = $labl$$label;
11205     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11206   %}
11207   ins_pipe(pipe_jcc);
11208 %}
11209 
11210 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11211 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11212   match(CountedLoopEnd cop cmp);
11213   effect(USE labl);
11214 
11215   ins_cost(300);
11216   format %{ "j$cop,u   $labl\t# loop end" %}
11217   size(6);
11218   ins_encode %{
11219     Label* L = $labl$$label;
11220     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11221   %}
11222   ins_pipe(pipe_jcc);
11223 %}
11224 
11225 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11226   match(CountedLoopEnd cop cmp);
11227   effect(USE labl);
11228 
11229   ins_cost(200);
11230   format %{ "j$cop,u   $labl\t# loop end" %}
11231   size(6);
11232   ins_encode %{
11233     Label* L = $labl$$label;
11234     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11235   %}
11236   ins_pipe(pipe_jcc);
11237 %}
11238 
11239 // Jump Direct Conditional - using unsigned comparison
11240 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11241   match(If cop cmp);
11242   effect(USE labl);
11243 
11244   ins_cost(300);
11245   format %{ "j$cop,u  $labl" %}
11246   size(6);
11247   ins_encode %{
11248     Label* L = $labl$$label;
11249     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11250   %}
11251   ins_pipe(pipe_jcc);
11252 %}
11253 
11254 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11255   match(If cop cmp);
11256   effect(USE labl);
11257 
11258   ins_cost(200);
11259   format %{ "j$cop,u  $labl" %}
11260   size(6);
11261   ins_encode %{
11262     Label* L = $labl$$label;
11263     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11264   %}
11265   ins_pipe(pipe_jcc);
11266 %}
11267 
11268 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11269   match(If cop cmp);
11270   effect(USE labl);
11271 
11272   ins_cost(200);
11273   format %{ $$template
11274     if ($cop$$cmpcode == Assembler::notEqual) {
11275       $$emit$$"jp,u   $labl\n\t"
11276       $$emit$$"j$cop,u   $labl"
11277     } else {
11278       $$emit$$"jp,u   done\n\t"
11279       $$emit$$"j$cop,u   $labl\n\t"
11280       $$emit$$"done:"
11281     }
11282   %}
11283   ins_encode %{
11284     Label* l = $labl$$label;
11285     if ($cop$$cmpcode == Assembler::notEqual) {
11286       __ jcc(Assembler::parity, *l, false);
11287       __ jcc(Assembler::notEqual, *l, false);
11288     } else if ($cop$$cmpcode == Assembler::equal) {
11289       Label done;
11290       __ jccb(Assembler::parity, done);
11291       __ jcc(Assembler::equal, *l, false);
11292       __ bind(done);
11293     } else {
11294        ShouldNotReachHere();
11295     }
11296   %}
11297   ins_pipe(pipe_jcc);
11298 %}
11299 
11300 // ============================================================================
11301 // The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
11302 // superklass array for an instance of the superklass.  Set a hidden
11303 // internal cache on a hit (cache is checked with exposed code in
11304 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
11305 // encoding ALSO sets flags.
11306 
11307 instruct partialSubtypeCheck(rdi_RegP result,
11308                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11309                              rFlagsReg cr)
11310 %{
11311   match(Set result (PartialSubtypeCheck sub super));
11312   effect(KILL rcx, KILL cr);
11313 
11314   ins_cost(1100);  // slightly larger than the next version
11315   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11316             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11317             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11318             "repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t"
11319             "jne,s   miss\t\t# Missed: rdi not-zero\n\t"
11320             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11321             "xorq    $result, $result\t\t Hit: rdi zero\n\t"
11322     "miss:\t" %}
11323 
11324   opcode(0x1); // Force a XOR of RDI
11325   ins_encode(enc_PartialSubtypeCheck());
11326   ins_pipe(pipe_slow);
11327 %}
11328 
11329 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
11330                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11331                                      immP0 zero,
11332                                      rdi_RegP result)
11333 %{
11334   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
11335   effect(KILL rcx, KILL result);
11336 
11337   ins_cost(1000);
11338   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11339             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11340             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11341             "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
11342             "jne,s   miss\t\t# Missed: flags nz\n\t"
11343             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11344     "miss:\t" %}
11345 
11346   opcode(0x0); // No need to XOR RDI
11347   ins_encode(enc_PartialSubtypeCheck());
11348   ins_pipe(pipe_slow);
11349 %}
11350 
11351 // ============================================================================
11352 // Branch Instructions -- short offset versions
11353 //
11354 // These instructions are used to replace jumps of a long offset (the default
11355 // match) with jumps of a shorter offset.  These instructions are all tagged
11356 // with the ins_short_branch attribute, which causes the ADLC to suppress the
11357 // match rules in general matching.  Instead, the ADLC generates a conversion
11358 // method in the MachNode which can be used to do in-place replacement of the
11359 // long variant with the shorter variant.  The compiler will determine if a
11360 // branch can be taken by the is_short_branch_offset() predicate in the machine
11361 // specific code section of the file.
11362 
11363 // Jump Direct - Label defines a relative address from JMP+1
11364 instruct jmpDir_short(label labl) %{
11365   match(Goto);
11366   effect(USE labl);
11367 
11368   ins_cost(300);
11369   format %{ "jmp,s   $labl" %}
11370   size(2);
11371   ins_encode %{
11372     Label* L = $labl$$label;
11373     __ jmpb(*L);
11374   %}
11375   ins_pipe(pipe_jmp);
11376   ins_short_branch(1);
11377 %}
11378 
11379 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11380 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
11381   match(If cop cr);
11382   effect(USE labl);
11383 
11384   ins_cost(300);
11385   format %{ "j$cop,s   $labl" %}
11386   size(2);
11387   ins_encode %{
11388     Label* L = $labl$$label;
11389     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11390   %}
11391   ins_pipe(pipe_jcc);
11392   ins_short_branch(1);
11393 %}
11394 
11395 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11396 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
11397   match(CountedLoopEnd cop cr);
11398   effect(USE labl);
11399 
11400   ins_cost(300);
11401   format %{ "j$cop,s   $labl\t# loop end" %}
11402   size(2);
11403   ins_encode %{
11404     Label* L = $labl$$label;
11405     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11406   %}
11407   ins_pipe(pipe_jcc);
11408   ins_short_branch(1);
11409 %}
11410 
11411 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11412 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11413   match(CountedLoopEnd cop cmp);
11414   effect(USE labl);
11415 
11416   ins_cost(300);
11417   format %{ "j$cop,us  $labl\t# loop end" %}
11418   size(2);
11419   ins_encode %{
11420     Label* L = $labl$$label;
11421     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11422   %}
11423   ins_pipe(pipe_jcc);
11424   ins_short_branch(1);
11425 %}
11426 
11427 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11428   match(CountedLoopEnd cop cmp);
11429   effect(USE labl);
11430 
11431   ins_cost(300);
11432   format %{ "j$cop,us  $labl\t# loop end" %}
11433   size(2);
11434   ins_encode %{
11435     Label* L = $labl$$label;
11436     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11437   %}
11438   ins_pipe(pipe_jcc);
11439   ins_short_branch(1);
11440 %}
11441 
11442 // Jump Direct Conditional - using unsigned comparison
11443 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11444   match(If cop cmp);
11445   effect(USE labl);
11446 
11447   ins_cost(300);
11448   format %{ "j$cop,us  $labl" %}
11449   size(2);
11450   ins_encode %{
11451     Label* L = $labl$$label;
11452     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11453   %}
11454   ins_pipe(pipe_jcc);
11455   ins_short_branch(1);
11456 %}
11457 
11458 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11459   match(If cop cmp);
11460   effect(USE labl);
11461 
11462   ins_cost(300);
11463   format %{ "j$cop,us  $labl" %}
11464   size(2);
11465   ins_encode %{
11466     Label* L = $labl$$label;
11467     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11468   %}
11469   ins_pipe(pipe_jcc);
11470   ins_short_branch(1);
11471 %}
11472 
11473 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11474   match(If cop cmp);
11475   effect(USE labl);
11476 
11477   ins_cost(300);
11478   format %{ $$template
11479     if ($cop$$cmpcode == Assembler::notEqual) {
11480       $$emit$$"jp,u,s   $labl\n\t"
11481       $$emit$$"j$cop,u,s   $labl"
11482     } else {
11483       $$emit$$"jp,u,s   done\n\t"
11484       $$emit$$"j$cop,u,s  $labl\n\t"
11485       $$emit$$"done:"
11486     }
11487   %}
11488   size(4);
11489   ins_encode %{
11490     Label* l = $labl$$label;
11491     if ($cop$$cmpcode == Assembler::notEqual) {
11492       __ jccb(Assembler::parity, *l);
11493       __ jccb(Assembler::notEqual, *l);
11494     } else if ($cop$$cmpcode == Assembler::equal) {
11495       Label done;
11496       __ jccb(Assembler::parity, done);
11497       __ jccb(Assembler::equal, *l);
11498       __ bind(done);
11499     } else {
11500        ShouldNotReachHere();
11501     }
11502   %}
11503   ins_pipe(pipe_jcc);
11504   ins_short_branch(1);
11505 %}
11506 
11507 // ============================================================================
11508 // inlined locking and unlocking
11509 
11510 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
11511   predicate(Compile::current()-&gt;use_rtm());
11512   match(Set cr (FastLock object box));
11513   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
11514   ins_cost(300);
11515   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2" %}
11516   ins_encode %{
11517     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11518                  $scr$$Register, $cx1$$Register, $cx2$$Register,
11519                  _counters, _rtm_counters, _stack_rtm_counters,
11520                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11521                  true, ra_-&gt;C-&gt;profile_rtm());
11522   %}
11523   ins_pipe(pipe_slow);
11524 %}
11525 
11526 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
11527   predicate(!Compile::current()-&gt;use_rtm());
11528   match(Set cr (FastLock object box));
11529   effect(TEMP tmp, TEMP scr, USE_KILL box);
11530   ins_cost(300);
11531   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr" %}
11532   ins_encode %{
11533     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11534                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
11535   %}
11536   ins_pipe(pipe_slow);
11537 %}
11538 
11539 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
11540   match(Set cr (FastUnlock object box));
11541   effect(TEMP tmp, USE_KILL box);
11542   ins_cost(300);
11543   format %{ "fastunlock $object,$box\t! kills $box,$tmp" %}
11544   ins_encode %{
11545     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
11546   %}
11547   ins_pipe(pipe_slow);
11548 %}
11549 
11550 
11551 // ============================================================================
11552 // Safepoint Instructions
11553 instruct safePoint_poll(rFlagsReg cr)
11554 %{
11555   predicate(!Assembler::is_polling_page_far());
11556   match(SafePoint);
11557   effect(KILL cr);
11558 
11559   format %{ "testl  rax, [rip + #offset_to_poll_page]\t"
11560             "# Safepoint: poll for GC" %}
11561   ins_cost(125);
11562   ins_encode %{
11563     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
11564     __ testl(rax, addr);
11565   %}
11566   ins_pipe(ialu_reg_mem);
11567 %}
11568 
11569 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
11570 %{
11571   predicate(Assembler::is_polling_page_far());
11572   match(SafePoint poll);
11573   effect(KILL cr, USE poll);
11574 
11575   format %{ "testl  rax, [$poll]\t"
11576             "# Safepoint: poll for GC" %}
11577   ins_cost(125);
11578   ins_encode %{
11579     __ relocate(relocInfo::poll_type);
11580     __ testl(rax, Address($poll$$Register, 0));
11581   %}
11582   ins_pipe(ialu_reg_mem);
11583 %}
11584 
11585 // ============================================================================
11586 // Procedure Call/Return Instructions
11587 // Call Java Static Instruction
11588 // Note: If this code changes, the corresponding ret_addr_offset() and
11589 //       compute_padding() functions will have to be adjusted.
11590 instruct CallStaticJavaDirect(method meth) %{
11591   match(CallStaticJava);
11592   effect(USE meth);
11593 
11594   ins_cost(300);
11595   format %{ "call,static " %}
11596   opcode(0xE8); /* E8 cd */
11597   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
11598   ins_pipe(pipe_slow);
11599   ins_alignment(4);
11600 %}
11601 
11602 // Call Java Dynamic Instruction
11603 // Note: If this code changes, the corresponding ret_addr_offset() and
11604 //       compute_padding() functions will have to be adjusted.
11605 instruct CallDynamicJavaDirect(method meth)
11606 %{
11607   match(CallDynamicJava);
11608   effect(USE meth);
11609 
11610   ins_cost(300);
11611   format %{ "movq    rax, #Universe::non_oop_word()\n\t"
11612             "call,dynamic " %}
11613   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
11614   ins_pipe(pipe_slow);
11615   ins_alignment(4);
11616 %}
11617 
11618 // Call Runtime Instruction
11619 instruct CallRuntimeDirect(method meth)
11620 %{
11621   match(CallRuntime);
11622   effect(USE meth);
11623 
11624   ins_cost(300);
11625   format %{ "call,runtime " %}
11626   ins_encode(clear_avx, Java_To_Runtime(meth));
11627   ins_pipe(pipe_slow);
11628 %}
11629 
11630 // Call runtime without safepoint
11631 instruct CallLeafDirect(method meth)
11632 %{
11633   match(CallLeaf);
11634   effect(USE meth);
11635 
11636   ins_cost(300);
11637   format %{ "call_leaf,runtime " %}
11638   ins_encode(clear_avx, Java_To_Runtime(meth));
11639   ins_pipe(pipe_slow);
11640 %}
11641 
11642 // Call runtime without safepoint
11643 instruct CallLeafNoFPDirect(method meth)
11644 %{
11645   match(CallLeafNoFP);
11646   effect(USE meth);
11647 
11648   ins_cost(300);
11649   format %{ "call_leaf_nofp,runtime " %}
11650   ins_encode(Java_To_Runtime(meth));
11651   ins_pipe(pipe_slow);
11652 %}
11653 
11654 // Return Instruction
11655 // Remove the return address &amp; jump to it.
11656 // Notice: We always emit a nop after a ret to make sure there is room
11657 // for safepoint patching
11658 instruct Ret()
11659 %{
11660   match(Return);
11661 
11662   format %{ "ret" %}
11663   opcode(0xC3);
11664   ins_encode(OpcP);
11665   ins_pipe(pipe_jmp);
11666 %}
11667 
11668 // Tail Call; Jump from runtime stub to Java code.
11669 // Also known as an 'interprocedural jump'.
11670 // Target of jump will eventually return to caller.
11671 // TailJump below removes the return address.
11672 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
11673 %{
11674   match(TailCall jump_target method_oop);
11675 
11676   ins_cost(300);
11677   format %{ "jmp     $jump_target\t# rbx holds method oop" %}
11678   opcode(0xFF, 0x4); /* Opcode FF /4 */
11679   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
11680   ins_pipe(pipe_jmp);
11681 %}
11682 
11683 // Tail Jump; remove the return address; jump to target.
11684 // TailCall above leaves the return address around.
11685 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
11686 %{
11687   match(TailJump jump_target ex_oop);
11688 
11689   ins_cost(300);
11690   format %{ "popq    rdx\t# pop return address\n\t"
11691             "jmp     $jump_target" %}
11692   opcode(0xFF, 0x4); /* Opcode FF /4 */
11693   ins_encode(Opcode(0x5a), // popq rdx
11694              REX_reg(jump_target), OpcP, reg_opc(jump_target));
11695   ins_pipe(pipe_jmp);
11696 %}
11697 
11698 // Create exception oop: created by stack-crawling runtime code.
11699 // Created exception is now available to this handler, and is setup
11700 // just prior to jumping to this handler.  No code emitted.
11701 instruct CreateException(rax_RegP ex_oop)
11702 %{
11703   match(Set ex_oop (CreateEx));
11704 
11705   size(0);
11706   // use the following format syntax
11707   format %{ "# exception oop is in rax; no code emitted" %}
11708   ins_encode();
11709   ins_pipe(empty);
11710 %}
11711 
11712 // Rethrow exception:
11713 // The exception oop will come in the first argument position.
11714 // Then JUMP (not call) to the rethrow stub code.
11715 instruct RethrowException()
11716 %{
11717   match(Rethrow);
11718 
11719   // use the following format syntax
11720   format %{ "jmp     rethrow_stub" %}
11721   ins_encode(enc_rethrow);
11722   ins_pipe(pipe_jmp);
11723 %}
11724 
11725 
11726 // ============================================================================
11727 // This name is KNOWN by the ADLC and cannot be changed.
11728 // The ADLC forces a 'TypeRawPtr::BOTTOM' output type
11729 // for this guy.
11730 instruct tlsLoadP(r15_RegP dst) %{
11731   match(Set dst (ThreadLocal));
11732   effect(DEF dst);
11733 
11734   size(0);
11735   format %{ "# TLS is in R15" %}
11736   ins_encode( /*empty encoding*/ );
11737   ins_pipe(ialu_reg_reg);
11738 %}
11739 
11740 
11741 //----------PEEPHOLE RULES-----------------------------------------------------
11742 // These must follow all instruction definitions as they use the names
11743 // defined in the instructions definitions.
11744 //
11745 // peepmatch ( root_instr_name [preceding_instruction]* );
11746 //
11747 // peepconstraint %{
11748 // (instruction_number.operand_name relational_op instruction_number.operand_name
11749 //  [, ...] );
11750 // // instruction numbers are zero-based using left to right order in peepmatch
11751 //
11752 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
11753 // // provide an instruction_number.operand_name for each operand that appears
11754 // // in the replacement instruction's match rule
11755 //
11756 // ---------VM FLAGS---------------------------------------------------------
11757 //
11758 // All peephole optimizations can be turned off using -XX:-OptoPeephole
11759 //
11760 // Each peephole rule is given an identifying number starting with zero and
11761 // increasing by one in the order seen by the parser.  An individual peephole
11762 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
11763 // on the command-line.
11764 //
11765 // ---------CURRENT LIMITATIONS----------------------------------------------
11766 //
11767 // Only match adjacent instructions in same basic block
11768 // Only equality constraints
11769 // Only constraints between operands, not (0.dest_reg == RAX_enc)
11770 // Only one replacement instruction
11771 //
11772 // ---------EXAMPLE----------------------------------------------------------
11773 //
11774 // // pertinent parts of existing instructions in architecture description
11775 // instruct movI(rRegI dst, rRegI src)
11776 // %{
11777 //   match(Set dst (CopyI src));
11778 // %}
11779 //
11780 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
11781 // %{
11782 //   match(Set dst (AddI dst src));
11783 //   effect(KILL cr);
11784 // %}
11785 //
11786 // // Change (inc mov) to lea
11787 // peephole %{
11788 //   // increment preceeded by register-register move
11789 //   peepmatch ( incI_rReg movI );
11790 //   // require that the destination register of the increment
11791 //   // match the destination register of the move
11792 //   peepconstraint ( 0.dst == 1.dst );
11793 //   // construct a replacement instruction that sets
11794 //   // the destination to ( move's source register + one )
11795 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
11796 // %}
11797 //
11798 
11799 // Implementation no longer uses movX instructions since
11800 // machine-independent system no longer uses CopyX nodes.
11801 //
11802 // peephole
11803 // %{
11804 //   peepmatch (incI_rReg movI);
11805 //   peepconstraint (0.dst == 1.dst);
11806 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11807 // %}
11808 
11809 // peephole
11810 // %{
11811 //   peepmatch (decI_rReg movI);
11812 //   peepconstraint (0.dst == 1.dst);
11813 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11814 // %}
11815 
11816 // peephole
11817 // %{
11818 //   peepmatch (addI_rReg_imm movI);
11819 //   peepconstraint (0.dst == 1.dst);
11820 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11821 // %}
11822 
11823 // peephole
11824 // %{
11825 //   peepmatch (incL_rReg movL);
11826 //   peepconstraint (0.dst == 1.dst);
11827 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11828 // %}
11829 
11830 // peephole
11831 // %{
11832 //   peepmatch (decL_rReg movL);
11833 //   peepconstraint (0.dst == 1.dst);
11834 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11835 // %}
11836 
11837 // peephole
11838 // %{
11839 //   peepmatch (addL_rReg_imm movL);
11840 //   peepconstraint (0.dst == 1.dst);
11841 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11842 // %}
11843 
11844 // peephole
11845 // %{
11846 //   peepmatch (addP_rReg_imm movP);
11847 //   peepconstraint (0.dst == 1.dst);
11848 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
11849 // %}
11850 
11851 // // Change load of spilled value to only a spill
11852 // instruct storeI(memory mem, rRegI src)
11853 // %{
11854 //   match(Set mem (StoreI mem src));
11855 // %}
11856 //
11857 // instruct loadI(rRegI dst, memory mem)
11858 // %{
11859 //   match(Set dst (LoadI mem));
11860 // %}
11861 //
11862 
11863 peephole
11864 %{
11865   peepmatch (loadI storeI);
11866   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11867   peepreplace (storeI(1.mem 1.mem 1.src));
11868 %}
11869 
11870 peephole
11871 %{
11872   peepmatch (loadL storeL);
11873   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11874   peepreplace (storeL(1.mem 1.mem 1.src));
11875 %}
11876 
11877 //----------SMARTSPILL RULES---------------------------------------------------
11878 // These must follow all instruction definitions as they use the names
11879 // defined in the instructions definitions.
</pre></body></html>
