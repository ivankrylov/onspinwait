<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 //
   2 // Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 // AMD64 Architecture Description File
  26 
  27 //----------REGISTER DEFINITION BLOCK------------------------------------------
  28 // This information is used by the matcher and the register allocator to
  29 // describe individual registers and classes of registers within the target
  30 // archtecture.
  31 
  32 register %{
  33 //----------Architecture Description Register Definitions----------------------
  34 // General Registers
  35 // "reg_def"  name ( register save type, C convention save type,
  36 //                   ideal register type, encoding );
  37 // Register Save Types:
  38 //
  39 // NS  = No-Save:       The register allocator assumes that these registers
  40 //                      can be used without saving upon entry to the method, &amp;
  41 //                      that they do not need to be saved at call sites.
  42 //
  43 // SOC = Save-On-Call:  The register allocator assumes that these registers
  44 //                      can be used without saving upon entry to the method,
  45 //                      but that they must be saved at call sites.
  46 //
  47 // SOE = Save-On-Entry: The register allocator assumes that these registers
  48 //                      must be saved before using them upon entry to the
  49 //                      method, but they do not need to be saved at call
  50 //                      sites.
  51 //
  52 // AS  = Always-Save:   The register allocator assumes that these registers
  53 //                      must be saved before using them upon entry to the
  54 //                      method, &amp; that they must be saved at call sites.
  55 //
  56 // Ideal Register Type is used to determine how to save &amp; restore a
  57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
  59 //
  60 // The encoding number is the actual bit-pattern placed into the opcodes.
  61 
  62 // General Registers
  63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
  64 // used as byte registers)
  65 
  66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
  67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
  68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
  69 
  70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
  71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
  72 
  73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
  74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
  75 
  76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
  77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
  78 
  79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
  80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
  81 
  82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
  83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
  84 
  85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
  86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
  87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
  88 
  89 #ifdef _WIN64
  90 
  91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
  92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  93 
  94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
  95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  96 
  97 #else
  98 
  99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
 100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
 101 
 102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
 103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
 104 
 105 #endif
 106 
 107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
 108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
 109 
 110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
 111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
 112 
 113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
 114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
 115 
 116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
 117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
 118 
 119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
 120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
 121 
 122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
 123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
 124 
 125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
 126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
 127 
 128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
 129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
 130 
 131 
 132 // Floating Point Registers
 133 
 134 // Specify priority of register selection within phases of register
 135 // allocation.  Highest priority is first.  A useful heuristic is to
 136 // give registers a low priority when they are required by machine
 137 // instructions, like EAX and EDX on I486, and choose no-save registers
 138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
 139 // which participate in fixed calling sequences should come last.
 140 // Registers which are used as pairs must fall on an even boundary.
 141 
 142 alloc_class chunk0(R10,         R10_H,
 143                    R11,         R11_H,
 144                    R8,          R8_H,
 145                    R9,          R9_H,
 146                    R12,         R12_H,
 147                    RCX,         RCX_H,
 148                    RBX,         RBX_H,
 149                    RDI,         RDI_H,
 150                    RDX,         RDX_H,
 151                    RSI,         RSI_H,
 152                    RAX,         RAX_H,
 153                    RBP,         RBP_H,
 154                    R13,         R13_H,
 155                    R14,         R14_H,
 156                    R15,         R15_H,
 157                    RSP,         RSP_H);
 158 
 159 
 160 //----------Architecture Description Register Classes--------------------------
 161 // Several register classes are automatically defined based upon information in
 162 // this architecture description.
 163 // 1) reg_class inline_cache_reg           ( /* as def'd in frame section */ )
 164 // 2) reg_class compiler_method_oop_reg    ( /* as def'd in frame section */ )
 165 // 2) reg_class interpreter_method_oop_reg ( /* as def'd in frame section */ )
 166 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 167 //
 168 
 169 // Empty register class.
 170 reg_class no_reg();
 171 
 172 // Class for all pointer registers (including RSP and RBP)
 173 reg_class any_reg_with_rbp(RAX, RAX_H,
 174                            RDX, RDX_H,
 175                            RBP, RBP_H,
 176                            RDI, RDI_H,
 177                            RSI, RSI_H,
 178                            RCX, RCX_H,
 179                            RBX, RBX_H,
 180                            RSP, RSP_H,
 181                            R8,  R8_H,
 182                            R9,  R9_H,
 183                            R10, R10_H,
 184                            R11, R11_H,
 185                            R12, R12_H,
 186                            R13, R13_H,
 187                            R14, R14_H,
 188                            R15, R15_H);
 189 
 190 // Class for all pointer registers (including RSP, but excluding RBP)
 191 reg_class any_reg_no_rbp(RAX, RAX_H,
 192                          RDX, RDX_H,
 193                          RDI, RDI_H,
 194                          RSI, RSI_H,
 195                          RCX, RCX_H,
 196                          RBX, RBX_H,
 197                          RSP, RSP_H,
 198                          R8,  R8_H,
 199                          R9,  R9_H,
 200                          R10, R10_H,
 201                          R11, R11_H,
 202                          R12, R12_H,
 203                          R13, R13_H,
 204                          R14, R14_H,
 205                          R15, R15_H);
 206 
 207 // Dynamic register class that selects at runtime between register classes
 208 // any_reg_no_rbp and any_reg_with_rbp (depending on the value of the flag PreserveFramePointer).
 209 // Equivalent to: return PreserveFramePointer ? any_reg_no_rbp : any_reg_with_rbp;
 210 reg_class_dynamic any_reg(any_reg_no_rbp, any_reg_with_rbp, %{ PreserveFramePointer %});
 211 
 212 // Class for all pointer registers (excluding RSP)
 213 reg_class ptr_reg_with_rbp(RAX, RAX_H,
 214                            RDX, RDX_H,
 215                            RBP, RBP_H,
 216                            RDI, RDI_H,
 217                            RSI, RSI_H,
 218                            RCX, RCX_H,
 219                            RBX, RBX_H,
 220                            R8,  R8_H,
 221                            R9,  R9_H,
 222                            R10, R10_H,
 223                            R11, R11_H,
 224                            R13, R13_H,
 225                            R14, R14_H);
 226 
 227 // Class for all pointer registers (excluding RSP and RBP)
 228 reg_class ptr_reg_no_rbp(RAX, RAX_H,
 229                          RDX, RDX_H,
 230                          RDI, RDI_H,
 231                          RSI, RSI_H,
 232                          RCX, RCX_H,
 233                          RBX, RBX_H,
 234                          R8,  R8_H,
 235                          R9,  R9_H,
 236                          R10, R10_H,
 237                          R11, R11_H,
 238                          R13, R13_H,
 239                          R14, R14_H);
 240 
 241 // Dynamic register class that selects between ptr_reg_no_rbp and ptr_reg_with_rbp.
 242 reg_class_dynamic ptr_reg(ptr_reg_no_rbp, ptr_reg_with_rbp, %{ PreserveFramePointer %});
 243 
 244 // Class for all pointer registers (excluding RAX and RSP)
 245 reg_class ptr_no_rax_reg_with_rbp(RDX, RDX_H,
 246                                   RBP, RBP_H,
 247                                   RDI, RDI_H,
 248                                   RSI, RSI_H,
 249                                   RCX, RCX_H,
 250                                   RBX, RBX_H,
 251                                   R8,  R8_H,
 252                                   R9,  R9_H,
 253                                   R10, R10_H,
 254                                   R11, R11_H,
 255                                   R13, R13_H,
 256                                   R14, R14_H);
 257 
 258 // Class for all pointer registers (excluding RAX, RSP, and RBP)
 259 reg_class ptr_no_rax_reg_no_rbp(RDX, RDX_H,
 260                                 RDI, RDI_H,
 261                                 RSI, RSI_H,
 262                                 RCX, RCX_H,
 263                                 RBX, RBX_H,
 264                                 R8,  R8_H,
 265                                 R9,  R9_H,
 266                                 R10, R10_H,
 267                                 R11, R11_H,
 268                                 R13, R13_H,
 269                                 R14, R14_H);
 270 
 271 // Dynamic register class that selects between ptr_no_rax_reg_no_rbp and ptr_no_rax_reg_with_rbp.
 272 reg_class_dynamic ptr_no_rax_reg(ptr_no_rax_reg_no_rbp, ptr_no_rax_reg_with_rbp, %{ PreserveFramePointer %});
 273 
 274 // Class for all pointer registers (excluding RAX, RBX, and RSP)
 275 reg_class ptr_no_rax_rbx_reg_with_rbp(RDX, RDX_H,
 276                                       RBP, RBP_H,
 277                                       RDI, RDI_H,
 278                                       RSI, RSI_H,
 279                                       RCX, RCX_H,
 280                                       R8,  R8_H,
 281                                       R9,  R9_H,
 282                                       R10, R10_H,
 283                                       R11, R11_H,
 284                                       R13, R13_H,
 285                                       R14, R14_H);
 286 
 287 // Class for all pointer registers (excluding RAX, RBX, RSP, and RBP)
 288 reg_class ptr_no_rax_rbx_reg_no_rbp(RDX, RDX_H,
 289                                     RDI, RDI_H,
 290                                     RSI, RSI_H,
 291                                     RCX, RCX_H,
 292                                     R8,  R8_H,
 293                                     R9,  R9_H,
 294                                     R10, R10_H,
 295                                     R11, R11_H,
 296                                     R13, R13_H,
 297                                     R14, R14_H);
 298 
 299 // Dynamic register class that selects between ptr_no_rax_rbx_reg_no_rbp and ptr_no_rax_rbx_reg_with_rbp.
 300 reg_class_dynamic ptr_no_rax_rbx_reg(ptr_no_rax_rbx_reg_no_rbp, ptr_no_rax_rbx_reg_with_rbp, %{ PreserveFramePointer %});
 301 
 302 // Singleton class for RAX pointer register
 303 reg_class ptr_rax_reg(RAX, RAX_H);
 304 
 305 // Singleton class for RBX pointer register
 306 reg_class ptr_rbx_reg(RBX, RBX_H);
 307 
 308 // Singleton class for RSI pointer register
 309 reg_class ptr_rsi_reg(RSI, RSI_H);
 310 
 311 // Singleton class for RDI pointer register
 312 reg_class ptr_rdi_reg(RDI, RDI_H);
 313 
 314 // Singleton class for stack pointer
 315 reg_class ptr_rsp_reg(RSP, RSP_H);
 316 
 317 // Singleton class for TLS pointer
 318 reg_class ptr_r15_reg(R15, R15_H);
 319 
 320 // Class for all long registers (excluding RSP)
 321 reg_class long_reg_with_rbp(RAX, RAX_H,
 322                             RDX, RDX_H,
 323                             RBP, RBP_H,
 324                             RDI, RDI_H,
 325                             RSI, RSI_H,
 326                             RCX, RCX_H,
 327                             RBX, RBX_H,
 328                             R8,  R8_H,
 329                             R9,  R9_H,
 330                             R10, R10_H,
 331                             R11, R11_H,
 332                             R13, R13_H,
 333                             R14, R14_H);
 334 
 335 // Class for all long registers (excluding RSP and RBP)
 336 reg_class long_reg_no_rbp(RAX, RAX_H,
 337                           RDX, RDX_H,
 338                           RDI, RDI_H,
 339                           RSI, RSI_H,
 340                           RCX, RCX_H,
 341                           RBX, RBX_H,
 342                           R8,  R8_H,
 343                           R9,  R9_H,
 344                           R10, R10_H,
 345                           R11, R11_H,
 346                           R13, R13_H,
 347                           R14, R14_H);
 348 
 349 // Dynamic register class that selects between long_reg_no_rbp and long_reg_with_rbp.
 350 reg_class_dynamic long_reg(long_reg_no_rbp, long_reg_with_rbp, %{ PreserveFramePointer %});
 351 
 352 // Class for all long registers (excluding RAX, RDX and RSP)
 353 reg_class long_no_rax_rdx_reg_with_rbp(RBP, RBP_H,
 354                                        RDI, RDI_H,
 355                                        RSI, RSI_H,
 356                                        RCX, RCX_H,
 357                                        RBX, RBX_H,
 358                                        R8,  R8_H,
 359                                        R9,  R9_H,
 360                                        R10, R10_H,
 361                                        R11, R11_H,
 362                                        R13, R13_H,
 363                                        R14, R14_H);
 364 
 365 // Class for all long registers (excluding RAX, RDX, RSP, and RBP)
 366 reg_class long_no_rax_rdx_reg_no_rbp(RDI, RDI_H,
 367                                      RSI, RSI_H,
 368                                      RCX, RCX_H,
 369                                      RBX, RBX_H,
 370                                      R8,  R8_H,
 371                                      R9,  R9_H,
 372                                      R10, R10_H,
 373                                      R11, R11_H,
 374                                      R13, R13_H,
 375                                      R14, R14_H);
 376 
 377 // Dynamic register class that selects between long_no_rax_rdx_reg_no_rbp and long_no_rax_rdx_reg_with_rbp.
 378 reg_class_dynamic long_no_rax_rdx_reg(long_no_rax_rdx_reg_no_rbp, long_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 379 
 380 // Class for all long registers (excluding RCX and RSP)
 381 reg_class long_no_rcx_reg_with_rbp(RBP, RBP_H,
 382                                    RDI, RDI_H,
 383                                    RSI, RSI_H,
 384                                    RAX, RAX_H,
 385                                    RDX, RDX_H,
 386                                    RBX, RBX_H,
 387                                    R8,  R8_H,
 388                                    R9,  R9_H,
 389                                    R10, R10_H,
 390                                    R11, R11_H,
 391                                    R13, R13_H,
 392                                    R14, R14_H);
 393 
 394 // Class for all long registers (excluding RCX, RSP, and RBP)
 395 reg_class long_no_rcx_reg_no_rbp(RDI, RDI_H,
 396                                  RSI, RSI_H,
 397                                  RAX, RAX_H,
 398                                  RDX, RDX_H,
 399                                  RBX, RBX_H,
 400                                  R8,  R8_H,
 401                                  R9,  R9_H,
 402                                  R10, R10_H,
 403                                  R11, R11_H,
 404                                  R13, R13_H,
 405                                  R14, R14_H);
 406 
 407 // Dynamic register class that selects between long_no_rcx_reg_no_rbp and long_no_rcx_reg_with_rbp.
 408 reg_class_dynamic long_no_rcx_reg(long_no_rcx_reg_no_rbp, long_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 409 
 410 // Singleton class for RAX long register
 411 reg_class long_rax_reg(RAX, RAX_H);
 412 
 413 // Singleton class for RCX long register
 414 reg_class long_rcx_reg(RCX, RCX_H);
 415 
 416 // Singleton class for RDX long register
 417 reg_class long_rdx_reg(RDX, RDX_H);
 418 
 419 // Class for all int registers (excluding RSP)
 420 reg_class int_reg_with_rbp(RAX,
 421                            RDX,
 422                            RBP,
 423                            RDI,
 424                            RSI,
 425                            RCX,
 426                            RBX,
 427                            R8,
 428                            R9,
 429                            R10,
 430                            R11,
 431                            R13,
 432                            R14);
 433 
 434 // Class for all int registers (excluding RSP and RBP)
 435 reg_class int_reg_no_rbp(RAX,
 436                          RDX,
 437                          RDI,
 438                          RSI,
 439                          RCX,
 440                          RBX,
 441                          R8,
 442                          R9,
 443                          R10,
 444                          R11,
 445                          R13,
 446                          R14);
 447 
 448 // Dynamic register class that selects between int_reg_no_rbp and int_reg_with_rbp.
 449 reg_class_dynamic int_reg(int_reg_no_rbp, int_reg_with_rbp, %{ PreserveFramePointer %});
 450 
 451 // Class for all int registers (excluding RCX and RSP)
 452 reg_class int_no_rcx_reg_with_rbp(RAX,
 453                                   RDX,
 454                                   RBP,
 455                                   RDI,
 456                                   RSI,
 457                                   RBX,
 458                                   R8,
 459                                   R9,
 460                                   R10,
 461                                   R11,
 462                                   R13,
 463                                   R14);
 464 
 465 // Class for all int registers (excluding RCX, RSP, and RBP)
 466 reg_class int_no_rcx_reg_no_rbp(RAX,
 467                                 RDX,
 468                                 RDI,
 469                                 RSI,
 470                                 RBX,
 471                                 R8,
 472                                 R9,
 473                                 R10,
 474                                 R11,
 475                                 R13,
 476                                 R14);
 477 
 478 // Dynamic register class that selects between int_no_rcx_reg_no_rbp and int_no_rcx_reg_with_rbp.
 479 reg_class_dynamic int_no_rcx_reg(int_no_rcx_reg_no_rbp, int_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 480 
 481 // Class for all int registers (excluding RAX, RDX, and RSP)
 482 reg_class int_no_rax_rdx_reg_with_rbp(RBP,
 483                                       RDI,
 484                                       RSI,
 485                                       RCX,
 486                                       RBX,
 487                                       R8,
 488                                       R9,
 489                                       R10,
 490                                       R11,
 491                                       R13,
 492                                       R14);
 493 
 494 // Class for all int registers (excluding RAX, RDX, RSP, and RBP)
 495 reg_class int_no_rax_rdx_reg_no_rbp(RDI,
 496                                     RSI,
 497                                     RCX,
 498                                     RBX,
 499                                     R8,
 500                                     R9,
 501                                     R10,
 502                                     R11,
 503                                     R13,
 504                                     R14);
 505 
 506 // Dynamic register class that selects between int_no_rax_rdx_reg_no_rbp and int_no_rax_rdx_reg_with_rbp.
 507 reg_class_dynamic int_no_rax_rdx_reg(int_no_rax_rdx_reg_no_rbp, int_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 508 
 509 // Singleton class for RAX int register
 510 reg_class int_rax_reg(RAX);
 511 
 512 // Singleton class for RBX int register
 513 reg_class int_rbx_reg(RBX);
 514 
 515 // Singleton class for RCX int register
 516 reg_class int_rcx_reg(RCX);
 517 
 518 // Singleton class for RCX int register
 519 reg_class int_rdx_reg(RDX);
 520 
 521 // Singleton class for RCX int register
 522 reg_class int_rdi_reg(RDI);
 523 
 524 // Singleton class for instruction pointer
 525 // reg_class ip_reg(RIP);
 526 
 527 %}
 528 
 529 //----------SOURCE BLOCK-------------------------------------------------------
 530 // This is a block of C++ code which provides values, functions, and
 531 // definitions necessary in the rest of the architecture description
 532 source %{
 533 #define   RELOC_IMM64    Assembler::imm_operand
 534 #define   RELOC_DISP32   Assembler::disp32_operand
 535 
 536 #define __ _masm.
 537 
 538 static int clear_avx_size() {
 539   if(UseAVX &gt; 2) {
 540     return 0; // vzeroupper is ignored
 541   } else {
 542     return (Compile::current()-&gt;max_vector_size() &gt; 16) ? 3 : 0;  // vzeroupper
 543   }
 544 }
 545 
 546 // !!!!! Special hack to get all types of calls to specify the byte offset
 547 //       from the start of the call to the point where the return address
 548 //       will point.
 549 int MachCallStaticJavaNode::ret_addr_offset()
 550 {
 551   int offset = 5; // 5 bytes from start of call to where return address points
 552   offset += clear_avx_size();
 553   return offset;
 554 }
 555 
 556 int MachCallDynamicJavaNode::ret_addr_offset()
 557 {
 558   int offset = 15; // 15 bytes from start of call to where return address points
 559   offset += clear_avx_size();
 560   return offset;
 561 }
 562 
 563 int MachCallRuntimeNode::ret_addr_offset() {
 564   int offset = 13; // movq r10,#addr; callq (r10)
 565   offset += clear_avx_size();
 566   return offset;
 567 }
 568 
 569 // Indicate if the safepoint node needs the polling page as an input,
 570 // it does if the polling page is more than disp32 away.
 571 bool SafePointNode::needs_polling_address_input()
 572 {
 573   return Assembler::is_polling_page_far();
 574 }
 575 
 576 //
 577 // Compute padding required for nodes which need alignment
 578 //
 579 
 580 // The address of the call instruction needs to be 4-byte aligned to
 581 // ensure that it does not span a cache line so that it can be patched.
 582 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
 583 {
 584   current_offset += clear_avx_size(); // skip vzeroupper
 585   current_offset += 1; // skip call opcode byte
 586   return round_to(current_offset, alignment_required()) - current_offset;
 587 }
 588 
 589 // The address of the call instruction needs to be 4-byte aligned to
 590 // ensure that it does not span a cache line so that it can be patched.
 591 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
 592 {
 593   current_offset += clear_avx_size(); // skip vzeroupper
 594   current_offset += 11; // skip movq instruction + call opcode byte
 595   return round_to(current_offset, alignment_required()) - current_offset;
 596 }
 597 
 598 // EMIT_RM()
 599 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
 600   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
 601   cbuf.insts()-&gt;emit_int8(c);
 602 }
 603 
 604 // EMIT_CC()
 605 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
 606   unsigned char c = (unsigned char) (f1 | f2);
 607   cbuf.insts()-&gt;emit_int8(c);
 608 }
 609 
 610 // EMIT_OPCODE()
 611 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
 612   cbuf.insts()-&gt;emit_int8((unsigned char) code);
 613 }
 614 
 615 // EMIT_OPCODE() w/ relocation information
 616 void emit_opcode(CodeBuffer &amp;cbuf,
 617                  int code, relocInfo::relocType reloc, int offset, int format)
 618 {
 619   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
 620   emit_opcode(cbuf, code);
 621 }
 622 
 623 // EMIT_D8()
 624 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
 625   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
 626 }
 627 
 628 // EMIT_D16()
 629 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
 630   cbuf.insts()-&gt;emit_int16(d16);
 631 }
 632 
 633 // EMIT_D32()
 634 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
 635   cbuf.insts()-&gt;emit_int32(d32);
 636 }
 637 
 638 // EMIT_D64()
 639 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
 640   cbuf.insts()-&gt;emit_int64(d64);
 641 }
 642 
 643 // emit 32 bit value and construct relocation entry from relocInfo::relocType
 644 void emit_d32_reloc(CodeBuffer&amp; cbuf,
 645                     int d32,
 646                     relocInfo::relocType reloc,
 647                     int format)
 648 {
 649   assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
 650   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 651   cbuf.insts()-&gt;emit_int32(d32);
 652 }
 653 
 654 // emit 32 bit value and construct relocation entry from RelocationHolder
 655 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
 656 #ifdef ASSERT
 657   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 658       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
 659     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), "should be real oop");
 660     assert(cast_to_oop((intptr_t)d32)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop((intptr_t)d32)-&gt;is_scavengable()), "cannot embed scavengable oops in code");
 661   }
 662 #endif
 663   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 664   cbuf.insts()-&gt;emit_int32(d32);
 665 }
 666 
 667 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
 668   address next_ip = cbuf.insts_end() + 4;
 669   emit_d32_reloc(cbuf, (int) (addr - next_ip),
 670                  external_word_Relocation::spec(addr),
 671                  RELOC_DISP32);
 672 }
 673 
 674 
 675 // emit 64 bit value and construct relocation entry from relocInfo::relocType
 676 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
 677   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 678   cbuf.insts()-&gt;emit_int64(d64);
 679 }
 680 
 681 // emit 64 bit value and construct relocation entry from RelocationHolder
 682 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
 683 #ifdef ASSERT
 684   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 685       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
 686     assert(Universe::heap()-&gt;is_in_reserved((address)d64), "should be real oop");
 687     assert(cast_to_oop(d64)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop(d64)-&gt;is_scavengable()),
 688            "cannot embed scavengable oops in code");
 689   }
 690 #endif
 691   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 692   cbuf.insts()-&gt;emit_int64(d64);
 693 }
 694 
 695 // Access stack slot for load or store
 696 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
 697 {
 698   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
 699   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
 700     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
 701     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 702     emit_d8(cbuf, disp);     // Displacement  // R/M byte
 703   } else {
 704     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
 705     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 706     emit_d32(cbuf, disp);     // Displacement // R/M byte
 707   }
 708 }
 709 
 710    // rRegI ereg, memory mem) %{    // emit_reg_mem
 711 void encode_RegMem(CodeBuffer &amp;cbuf,
 712                    int reg,
 713                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
 714 {
 715   assert(disp_reloc == relocInfo::none, "cannot have disp");
 716   int regenc = reg &amp; 7;
 717   int baseenc = base &amp; 7;
 718   int indexenc = index &amp; 7;
 719 
 720   // There is no index &amp; no scale, use form without SIB byte
 721   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
 722     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 723     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 724       emit_rm(cbuf, 0x0, regenc, baseenc); // *
 725     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 726       // If 8-bit displacement, mode 0x1
 727       emit_rm(cbuf, 0x1, regenc, baseenc); // *
 728       emit_d8(cbuf, disp);
 729     } else {
 730       // If 32-bit displacement
 731       if (base == -1) { // Special flag for absolute address
 732         emit_rm(cbuf, 0x0, regenc, 0x5); // *
 733         if (disp_reloc != relocInfo::none) {
 734           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 735         } else {
 736           emit_d32(cbuf, disp);
 737         }
 738       } else {
 739         // Normal base + offset
 740         emit_rm(cbuf, 0x2, regenc, baseenc); // *
 741         if (disp_reloc != relocInfo::none) {
 742           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 743         } else {
 744           emit_d32(cbuf, disp);
 745         }
 746       }
 747     }
 748   } else {
 749     // Else, encode with the SIB byte
 750     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 751     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 752       // If no displacement
 753       emit_rm(cbuf, 0x0, regenc, 0x4); // *
 754       emit_rm(cbuf, scale, indexenc, baseenc);
 755     } else {
 756       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 757         // If 8-bit displacement, mode 0x1
 758         emit_rm(cbuf, 0x1, regenc, 0x4); // *
 759         emit_rm(cbuf, scale, indexenc, baseenc);
 760         emit_d8(cbuf, disp);
 761       } else {
 762         // If 32-bit displacement
 763         if (base == 0x04 ) {
 764           emit_rm(cbuf, 0x2, regenc, 0x4);
 765           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
 766         } else {
 767           emit_rm(cbuf, 0x2, regenc, 0x4);
 768           emit_rm(cbuf, scale, indexenc, baseenc); // *
 769         }
 770         if (disp_reloc != relocInfo::none) {
 771           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 772         } else {
 773           emit_d32(cbuf, disp);
 774         }
 775       }
 776     }
 777   }
 778 }
 779 
 780 // This could be in MacroAssembler but it's fairly C2 specific
 781 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
 782   Label exit;
 783   __ jccb(Assembler::noParity, exit);
 784   __ pushf();
 785   //
 786   // comiss/ucomiss instructions set ZF,PF,CF flags and
 787   // zero OF,AF,SF for NaN values.
 788   // Fixup flags by zeroing ZF,PF so that compare of NaN
 789   // values returns 'less than' result (CF is set).
 790   // Leave the rest of flags unchanged.
 791   //
 792   //    7 6 5 4 3 2 1 0
 793   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
 794   //    0 0 1 0 1 0 1 1   (0x2B)
 795   //
 796   __ andq(Address(rsp, 0), 0xffffff2b);
 797   __ popf();
 798   __ bind(exit);
 799 }
 800 
 801 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
 802   Label done;
 803   __ movl(dst, -1);
 804   __ jcc(Assembler::parity, done);
 805   __ jcc(Assembler::below, done);
 806   __ setb(Assembler::notEqual, dst);
 807   __ movzbl(dst, dst);
 808   __ bind(done);
 809 }
 810 
 811 
 812 //=============================================================================
 813 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 814 
 815 int Compile::ConstantTable::calculate_table_base_offset() const {
 816   return 0;  // absolute addressing, no offset
 817 }
 818 
 819 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 820 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 821   ShouldNotReachHere();
 822 }
 823 
 824 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 825   // Empty encoding
 826 }
 827 
 828 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 829   return 0;
 830 }
 831 
 832 #ifndef PRODUCT
 833 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 834   st-&gt;print("# MachConstantBaseNode (empty encoding)");
 835 }
 836 #endif
 837 
 838 
 839 //=============================================================================
 840 #ifndef PRODUCT
 841 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 842   Compile* C = ra_-&gt;C;
 843 
 844   int framesize = C-&gt;frame_size_in_bytes();
 845   int bangsize = C-&gt;bang_size_in_bytes();
 846   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 847   // Remove wordSize for return addr which is already pushed.
 848   framesize -= wordSize;
 849 
 850   if (C-&gt;need_stack_bang(bangsize)) {
 851     framesize -= wordSize;
 852     st-&gt;print("# stack bang (%d bytes)", bangsize);
 853     st-&gt;print("\n\t");
 854     st-&gt;print("pushq   rbp\t# Save rbp");
 855     if (PreserveFramePointer) {
 856         st-&gt;print("\n\t");
 857         st-&gt;print("movq    rbp, rsp\t# Save the caller's SP into rbp");
 858     }
 859     if (framesize) {
 860       st-&gt;print("\n\t");
 861       st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 862     }
 863   } else {
 864     st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 865     st-&gt;print("\n\t");
 866     framesize -= wordSize;
 867     st-&gt;print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
 868     if (PreserveFramePointer) {
 869       st-&gt;print("\n\t");
 870       st-&gt;print("movq    rbp, [rsp + #%d]\t# Save the caller's SP into rbp", (framesize + wordSize));
 871     }
 872   }
 873 
 874   if (VerifyStackAtCalls) {
 875     st-&gt;print("\n\t");
 876     framesize -= wordSize;
 877     st-&gt;print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
 878 #ifdef ASSERT
 879     st-&gt;print("\n\t");
 880     st-&gt;print("# stack alignment check");
 881 #endif
 882   }
 883   st-&gt;cr();
 884 }
 885 #endif
 886 
 887 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 888   Compile* C = ra_-&gt;C;
 889   MacroAssembler _masm(&amp;cbuf);
 890 
 891   int framesize = C-&gt;frame_size_in_bytes();
 892   int bangsize = C-&gt;bang_size_in_bytes();
 893 
 894   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false);
 895 
 896   C-&gt;set_frame_complete(cbuf.insts_size());
 897 
 898   if (C-&gt;has_mach_constant_base_node()) {
 899     // NOTE: We set the table base offset here because users might be
 900     // emitted before MachConstantBaseNode.
 901     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 902     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 903   }
 904 }
 905 
 906 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 907 {
 908   return MachNode::size(ra_); // too many variables; just compute it
 909                               // the hard way
 910 }
 911 
 912 int MachPrologNode::reloc() const
 913 {
 914   return 0; // a large enough number
 915 }
 916 
 917 //=============================================================================
 918 #ifndef PRODUCT
 919 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 920 {
 921   Compile* C = ra_-&gt;C;
 922   if (C-&gt;max_vector_size() &gt; 16) {
 923     st-&gt;print("vzeroupper");
 924     st-&gt;cr(); st-&gt;print("\t");
 925   }
 926 
 927   int framesize = C-&gt;frame_size_in_bytes();
 928   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 929   // Remove word for return adr already pushed
 930   // and RBP
 931   framesize -= 2*wordSize;
 932 
 933   if (framesize) {
 934     st-&gt;print_cr("addq    rsp, %d\t# Destroy frame", framesize);
 935     st-&gt;print("\t");
 936   }
 937 
 938   st-&gt;print_cr("popq   rbp");
 939   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 940     st-&gt;print("\t");
 941     if (Assembler::is_polling_page_far()) {
 942       st-&gt;print_cr("movq   rscratch1, #polling_page_address\n\t"
 943                    "testl  rax, [rscratch1]\t"
 944                    "# Safepoint: poll for GC");
 945     } else {
 946       st-&gt;print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
 947                    "# Safepoint: poll for GC");
 948     }
 949   }
 950 }
 951 #endif
 952 
 953 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 954 {
 955   Compile* C = ra_-&gt;C;
 956   if (C-&gt;max_vector_size() &gt; 16) {
 957     // Clear upper bits of YMM registers when current compiled code uses
 958     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 959     MacroAssembler _masm(&amp;cbuf);
 960     __ vzeroupper();
 961   }
 962 
 963   int framesize = C-&gt;frame_size_in_bytes();
 964   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 965   // Remove word for return adr already pushed
 966   // and RBP
 967   framesize -= 2*wordSize;
 968 
 969   // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here
 970 
 971   if (framesize) {
 972     emit_opcode(cbuf, Assembler::REX_W);
 973     if (framesize &lt; 0x80) {
 974       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
 975       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 976       emit_d8(cbuf, framesize);
 977     } else {
 978       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
 979       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 980       emit_d32(cbuf, framesize);
 981     }
 982   }
 983 
 984   // popq rbp
 985   emit_opcode(cbuf, 0x58 | RBP_enc);
 986 
 987   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 988     MacroAssembler _masm(&amp;cbuf);
 989     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 990     if (Assembler::is_polling_page_far()) {
 991       __ lea(rscratch1, polling_page);
 992       __ relocate(relocInfo::poll_return_type);
 993       __ testl(rax, Address(rscratch1, 0));
 994     } else {
 995       __ testl(rax, polling_page);
 996     }
 997   }
 998 }
 999 
1000 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
1001 {
1002   return MachNode::size(ra_); // too many variables; just compute it
1003                               // the hard way
1004 }
1005 
1006 int MachEpilogNode::reloc() const
1007 {
1008   return 2; // a large enough number
1009 }
1010 
1011 const Pipeline* MachEpilogNode::pipeline() const
1012 {
1013   return MachNode::pipeline_class();
1014 }
1015 
1016 int MachEpilogNode::safepoint_offset() const
1017 {
1018   return 0;
1019 }
1020 
1021 //=============================================================================
1022 
1023 enum RC {
1024   rc_bad,
1025   rc_int,
1026   rc_float,
1027   rc_stack
1028 };
1029 
1030 static enum RC rc_class(OptoReg::Name reg)
1031 {
1032   if( !OptoReg::is_valid(reg)  ) return rc_bad;
1033 
1034   if (OptoReg::is_stack(reg)) return rc_stack;
1035 
1036   VMReg r = OptoReg::as_VMReg(reg);
1037 
1038   if (r-&gt;is_Register()) return rc_int;
1039 
1040   assert(r-&gt;is_XMMRegister(), "must be");
1041   return rc_float;
1042 }
1043 
1044 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
1045 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
1046                           int src_hi, int dst_hi, uint ireg, outputStream* st);
1047 
1048 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
1049                             int stack_offset, int reg, uint ireg, outputStream* st);
1050 
1051 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
1052                                       int dst_offset, uint ireg, outputStream* st) {
1053   if (cbuf) {
1054     MacroAssembler _masm(cbuf);
1055     switch (ireg) {
1056     case Op_VecS:
1057       __ movq(Address(rsp, -8), rax);
1058       __ movl(rax, Address(rsp, src_offset));
1059       __ movl(Address(rsp, dst_offset), rax);
1060       __ movq(rax, Address(rsp, -8));
1061       break;
1062     case Op_VecD:
1063       __ pushq(Address(rsp, src_offset));
1064       __ popq (Address(rsp, dst_offset));
1065       break;
1066     case Op_VecX:
1067       __ pushq(Address(rsp, src_offset));
1068       __ popq (Address(rsp, dst_offset));
1069       __ pushq(Address(rsp, src_offset+8));
1070       __ popq (Address(rsp, dst_offset+8));
1071       break;
1072     case Op_VecY:
1073       __ vmovdqu(Address(rsp, -32), xmm0);
1074       __ vmovdqu(xmm0, Address(rsp, src_offset));
1075       __ vmovdqu(Address(rsp, dst_offset), xmm0);
1076       __ vmovdqu(xmm0, Address(rsp, -32));
1077     case Op_VecZ:
1078       __ evmovdqu(Address(rsp, -64), xmm0, 2);
1079       __ evmovdqu(xmm0, Address(rsp, src_offset), 2);
1080       __ evmovdqu(Address(rsp, dst_offset), xmm0, 2);
1081       __ evmovdqu(xmm0, Address(rsp, -64), 2);
1082       break;
1083     default:
1084       ShouldNotReachHere();
1085     }
1086 #ifndef PRODUCT
1087   } else {
1088     switch (ireg) {
1089     case Op_VecS:
1090       st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1091                 "movl    rax, [rsp + #%d]\n\t"
1092                 "movl    [rsp + #%d], rax\n\t"
1093                 "movq    rax, [rsp - #8]",
1094                 src_offset, dst_offset);
1095       break;
1096     case Op_VecD:
1097       st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1098                 "popq    [rsp + #%d]",
1099                 src_offset, dst_offset);
1100       break;
1101      case Op_VecX:
1102       st-&gt;print("pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t"
1103                 "popq    [rsp + #%d]\n\t"
1104                 "pushq   [rsp + #%d]\n\t"
1105                 "popq    [rsp + #%d]",
1106                 src_offset, dst_offset, src_offset+8, dst_offset+8);
1107       break;
1108     case Op_VecY:
1109       st-&gt;print("vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t"
1110                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1111                 "vmovdqu [rsp + #%d], xmm0\n\t"
1112                 "vmovdqu xmm0, [rsp - #32]",
1113                 src_offset, dst_offset);
1114       break;
1115     case Op_VecZ:
1116       st-&gt;print("vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t"
1117                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1118                 "vmovdqu [rsp + #%d], xmm0\n\t"
1119                 "vmovdqu xmm0, [rsp - #64]",
1120                 src_offset, dst_offset);
1121       break;
1122     default:
1123       ShouldNotReachHere();
1124     }
1125 #endif
1126   }
1127 }
1128 
1129 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
1130                                        PhaseRegAlloc* ra_,
1131                                        bool do_size,
1132                                        outputStream* st) const {
1133   assert(cbuf != NULL || st  != NULL, "sanity");
1134   // Get registers to move
1135   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
1136   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
1137   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
1138   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
1139 
1140   enum RC src_second_rc = rc_class(src_second);
1141   enum RC src_first_rc = rc_class(src_first);
1142   enum RC dst_second_rc = rc_class(dst_second);
1143   enum RC dst_first_rc = rc_class(dst_first);
1144 
1145   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
1146          "must move at least 1 register" );
1147 
1148   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
1149     // Self copy, no move
1150     return 0;
1151   }
1152   if (bottom_type()-&gt;isa_vect() != NULL) {
1153     uint ireg = ideal_reg();
1154     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), "sanity");
1155     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), "sanity");
1156     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
1157       // mem -&gt; mem
1158       int src_offset = ra_-&gt;reg2offset(src_first);
1159       int dst_offset = ra_-&gt;reg2offset(dst_first);
1160       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
1161     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
1162       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
1163     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
1164       int stack_offset = ra_-&gt;reg2offset(dst_first);
1165       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
1166     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
1167       int stack_offset = ra_-&gt;reg2offset(src_first);
1168       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
1169     } else {
1170       ShouldNotReachHere();
1171     }
1172     return 0;
1173   }
1174   if (src_first_rc == rc_stack) {
1175     // mem -&gt;
1176     if (dst_first_rc == rc_stack) {
1177       // mem -&gt; mem
1178       assert(src_second != dst_first, "overlap");
1179       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1180           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1181         // 64-bit
1182         int src_offset = ra_-&gt;reg2offset(src_first);
1183         int dst_offset = ra_-&gt;reg2offset(dst_first);
1184         if (cbuf) {
1185           MacroAssembler _masm(cbuf);
1186           __ pushq(Address(rsp, src_offset));
1187           __ popq (Address(rsp, dst_offset));
1188 #ifndef PRODUCT
1189         } else {
1190           st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1191                     "popq    [rsp + #%d]",
1192                      src_offset, dst_offset);
1193 #endif
1194         }
1195       } else {
1196         // 32-bit
1197         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1198         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1199         // No pushl/popl, so:
1200         int src_offset = ra_-&gt;reg2offset(src_first);
1201         int dst_offset = ra_-&gt;reg2offset(dst_first);
1202         if (cbuf) {
1203           MacroAssembler _masm(cbuf);
1204           __ movq(Address(rsp, -8), rax);
1205           __ movl(rax, Address(rsp, src_offset));
1206           __ movl(Address(rsp, dst_offset), rax);
1207           __ movq(rax, Address(rsp, -8));
1208 #ifndef PRODUCT
1209         } else {
1210           st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1211                     "movl    rax, [rsp + #%d]\n\t"
1212                     "movl    [rsp + #%d], rax\n\t"
1213                     "movq    rax, [rsp - #8]",
1214                      src_offset, dst_offset);
1215 #endif
1216         }
1217       }
1218       return 0;
1219     } else if (dst_first_rc == rc_int) {
1220       // mem -&gt; gpr
1221       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1222           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1223         // 64-bit
1224         int offset = ra_-&gt;reg2offset(src_first);
1225         if (cbuf) {
1226           MacroAssembler _masm(cbuf);
1227           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1228 #ifndef PRODUCT
1229         } else {
1230           st-&gt;print("movq    %s, [rsp + #%d]\t# spill",
1231                      Matcher::regName[dst_first],
1232                      offset);
1233 #endif
1234         }
1235       } else {
1236         // 32-bit
1237         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1238         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1239         int offset = ra_-&gt;reg2offset(src_first);
1240         if (cbuf) {
1241           MacroAssembler _masm(cbuf);
1242           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1243 #ifndef PRODUCT
1244         } else {
1245           st-&gt;print("movl    %s, [rsp + #%d]\t# spill",
1246                      Matcher::regName[dst_first],
1247                      offset);
1248 #endif
1249         }
1250       }
1251       return 0;
1252     } else if (dst_first_rc == rc_float) {
1253       // mem-&gt; xmm
1254       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1255           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1256         // 64-bit
1257         int offset = ra_-&gt;reg2offset(src_first);
1258         if (cbuf) {
1259           MacroAssembler _masm(cbuf);
1260           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1261 #ifndef PRODUCT
1262         } else {
1263           st-&gt;print("%s  %s, [rsp + #%d]\t# spill",
1264                      UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
1265                      Matcher::regName[dst_first],
1266                      offset);
1267 #endif
1268         }
1269       } else {
1270         // 32-bit
1271         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1272         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1273         int offset = ra_-&gt;reg2offset(src_first);
1274         if (cbuf) {
1275           MacroAssembler _masm(cbuf);
1276           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1277 #ifndef PRODUCT
1278         } else {
1279           st-&gt;print("movss   %s, [rsp + #%d]\t# spill",
1280                      Matcher::regName[dst_first],
1281                      offset);
1282 #endif
1283         }
1284       }
1285       return 0;
1286     }
1287   } else if (src_first_rc == rc_int) {
1288     // gpr -&gt;
1289     if (dst_first_rc == rc_stack) {
1290       // gpr -&gt; mem
1291       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1292           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1293         // 64-bit
1294         int offset = ra_-&gt;reg2offset(dst_first);
1295         if (cbuf) {
1296           MacroAssembler _masm(cbuf);
1297           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1298 #ifndef PRODUCT
1299         } else {
1300           st-&gt;print("movq    [rsp + #%d], %s\t# spill",
1301                      offset,
1302                      Matcher::regName[src_first]);
1303 #endif
1304         }
1305       } else {
1306         // 32-bit
1307         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1308         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1309         int offset = ra_-&gt;reg2offset(dst_first);
1310         if (cbuf) {
1311           MacroAssembler _masm(cbuf);
1312           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1313 #ifndef PRODUCT
1314         } else {
1315           st-&gt;print("movl    [rsp + #%d], %s\t# spill",
1316                      offset,
1317                      Matcher::regName[src_first]);
1318 #endif
1319         }
1320       }
1321       return 0;
1322     } else if (dst_first_rc == rc_int) {
1323       // gpr -&gt; gpr
1324       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1325           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1326         // 64-bit
1327         if (cbuf) {
1328           MacroAssembler _masm(cbuf);
1329           __ movq(as_Register(Matcher::_regEncode[dst_first]),
1330                   as_Register(Matcher::_regEncode[src_first]));
1331 #ifndef PRODUCT
1332         } else {
1333           st-&gt;print("movq    %s, %s\t# spill",
1334                      Matcher::regName[dst_first],
1335                      Matcher::regName[src_first]);
1336 #endif
1337         }
1338         return 0;
1339       } else {
1340         // 32-bit
1341         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1342         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1343         if (cbuf) {
1344           MacroAssembler _masm(cbuf);
1345           __ movl(as_Register(Matcher::_regEncode[dst_first]),
1346                   as_Register(Matcher::_regEncode[src_first]));
1347 #ifndef PRODUCT
1348         } else {
1349           st-&gt;print("movl    %s, %s\t# spill",
1350                      Matcher::regName[dst_first],
1351                      Matcher::regName[src_first]);
1352 #endif
1353         }
1354         return 0;
1355       }
1356     } else if (dst_first_rc == rc_float) {
1357       // gpr -&gt; xmm
1358       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1359           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1360         // 64-bit
1361         if (cbuf) {
1362           MacroAssembler _masm(cbuf);
1363           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1364 #ifndef PRODUCT
1365         } else {
1366           st-&gt;print("movdq   %s, %s\t# spill",
1367                      Matcher::regName[dst_first],
1368                      Matcher::regName[src_first]);
1369 #endif
1370         }
1371       } else {
1372         // 32-bit
1373         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1374         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1375         if (cbuf) {
1376           MacroAssembler _masm(cbuf);
1377           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1378 #ifndef PRODUCT
1379         } else {
1380           st-&gt;print("movdl   %s, %s\t# spill",
1381                      Matcher::regName[dst_first],
1382                      Matcher::regName[src_first]);
1383 #endif
1384         }
1385       }
1386       return 0;
1387     }
1388   } else if (src_first_rc == rc_float) {
1389     // xmm -&gt;
1390     if (dst_first_rc == rc_stack) {
1391       // xmm -&gt; mem
1392       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1393           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1394         // 64-bit
1395         int offset = ra_-&gt;reg2offset(dst_first);
1396         if (cbuf) {
1397           MacroAssembler _masm(cbuf);
1398           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1399 #ifndef PRODUCT
1400         } else {
1401           st-&gt;print("movsd   [rsp + #%d], %s\t# spill",
1402                      offset,
1403                      Matcher::regName[src_first]);
1404 #endif
1405         }
1406       } else {
1407         // 32-bit
1408         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1409         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1410         int offset = ra_-&gt;reg2offset(dst_first);
1411         if (cbuf) {
1412           MacroAssembler _masm(cbuf);
1413           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1414 #ifndef PRODUCT
1415         } else {
1416           st-&gt;print("movss   [rsp + #%d], %s\t# spill",
1417                      offset,
1418                      Matcher::regName[src_first]);
1419 #endif
1420         }
1421       }
1422       return 0;
1423     } else if (dst_first_rc == rc_int) {
1424       // xmm -&gt; gpr
1425       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1426           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1427         // 64-bit
1428         if (cbuf) {
1429           MacroAssembler _masm(cbuf);
1430           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1431 #ifndef PRODUCT
1432         } else {
1433           st-&gt;print("movdq   %s, %s\t# spill",
1434                      Matcher::regName[dst_first],
1435                      Matcher::regName[src_first]);
1436 #endif
1437         }
1438       } else {
1439         // 32-bit
1440         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1441         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1442         if (cbuf) {
1443           MacroAssembler _masm(cbuf);
1444           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1445 #ifndef PRODUCT
1446         } else {
1447           st-&gt;print("movdl   %s, %s\t# spill",
1448                      Matcher::regName[dst_first],
1449                      Matcher::regName[src_first]);
1450 #endif
1451         }
1452       }
1453       return 0;
1454     } else if (dst_first_rc == rc_float) {
1455       // xmm -&gt; xmm
1456       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1457           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1458         // 64-bit
1459         if (cbuf) {
1460           MacroAssembler _masm(cbuf);
1461           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1462 #ifndef PRODUCT
1463         } else {
1464           st-&gt;print("%s  %s, %s\t# spill",
1465                      UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
1466                      Matcher::regName[dst_first],
1467                      Matcher::regName[src_first]);
1468 #endif
1469         }
1470       } else {
1471         // 32-bit
1472         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1473         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1474         if (cbuf) {
1475           MacroAssembler _masm(cbuf);
1476           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1477 #ifndef PRODUCT
1478         } else {
1479           st-&gt;print("%s  %s, %s\t# spill",
1480                      UseXmmRegToRegMoveAll ? "movaps" : "movss ",
1481                      Matcher::regName[dst_first],
1482                      Matcher::regName[src_first]);
1483 #endif
1484         }
1485       }
1486       return 0;
1487     }
1488   }
1489 
1490   assert(0," foo ");
1491   Unimplemented();
1492   return 0;
1493 }
1494 
1495 #ifndef PRODUCT
1496 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
1497   implementation(NULL, ra_, false, st);
1498 }
1499 #endif
1500 
1501 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1502   implementation(&amp;cbuf, ra_, false, NULL);
1503 }
1504 
1505 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1506   return MachNode::size(ra_);
1507 }
1508 
1509 //=============================================================================
1510 #ifndef PRODUCT
1511 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1512 {
1513   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1514   int reg = ra_-&gt;get_reg_first(this);
1515   st-&gt;print("leaq    %s, [rsp + #%d]\t# box lock",
1516             Matcher::regName[reg], offset);
1517 }
1518 #endif
1519 
1520 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1521 {
1522   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1523   int reg = ra_-&gt;get_encode(this);
1524   if (offset &gt;= 0x80) {
1525     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1526     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1527     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
1528     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1529     emit_d32(cbuf, offset);
1530   } else {
1531     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1532     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1533     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
1534     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1535     emit_d8(cbuf, offset);
1536   }
1537 }
1538 
1539 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
1540 {
1541   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1542   return (offset &lt; 0x80) ? 5 : 8; // REX
1543 }
1544 
1545 //=============================================================================
1546 #ifndef PRODUCT
1547 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1548 {
1549   if (UseCompressedClassPointers) {
1550     st-&gt;print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
1551     st-&gt;print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
1552     st-&gt;print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
1553   } else {
1554     st-&gt;print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
1555                  "# Inline cache check");
1556   }
1557   st-&gt;print_cr("\tjne     SharedRuntime::_ic_miss_stub");
1558   st-&gt;print_cr("\tnop\t# nops to align entry point");
1559 }
1560 #endif
1561 
1562 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1563 {
1564   MacroAssembler masm(&amp;cbuf);
1565   uint insts_size = cbuf.insts_size();
1566   if (UseCompressedClassPointers) {
1567     masm.load_klass(rscratch1, j_rarg0);
1568     masm.cmpptr(rax, rscratch1);
1569   } else {
1570     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
1571   }
1572 
1573   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1574 
1575   /* WARNING these NOPs are critical so that verified entry point is properly
1576      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
1577   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
1578   if (OptoBreakpoint) {
1579     // Leave space for int3
1580     nops_cnt -= 1;
1581   }
1582   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
1583   if (nops_cnt &gt; 0)
1584     masm.nop(nops_cnt);
1585 }
1586 
1587 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
1588 {
1589   return MachNode::size(ra_); // too many variables; just compute it
1590                               // the hard way
1591 }
1592 
1593 
1594 //=============================================================================
1595 
1596 int Matcher::regnum_to_fpu_offset(int regnum)
1597 {
1598   return regnum - 32; // The FP registers are in the second chunk
1599 }
1600 
1601 // This is UltraSparc specific, true just means we have fast l2f conversion
1602 const bool Matcher::convL2FSupported(void) {
1603   return true;
1604 }
1605 
1606 // Is this branch offset short enough that a short branch can be used?
1607 //
1608 // NOTE: If the platform does not provide any short branch variants, then
1609 //       this method should return false for offset 0.
1610 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
1611   // The passed offset is relative to address of the branch.
1612   // On 86 a branch displacement is calculated relative to address
1613   // of a next instruction.
1614   offset -= br_size;
1615 
1616   // the short version of jmpConUCF2 contains multiple branches,
1617   // making the reach slightly less
1618   if (rule == jmpConUCF2_rule)
1619     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
1620   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
1621 }
1622 
1623 const bool Matcher::isSimpleConstant64(jlong value) {
1624   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
1625   //return value == (int) value;  // Cf. storeImmL and immL32.
1626 
1627   // Probably always true, even if a temp register is required.
1628   return true;
1629 }
1630 
1631 // The ecx parameter to rep stosq for the ClearArray node is in words.
1632 const bool Matcher::init_array_count_is_in_bytes = false;
1633 
1634 // Threshold size for cleararray.
1635 const int Matcher::init_array_short_size = 8 * BytesPerLong;
1636 
1637 // No additional cost for CMOVL.
1638 const int Matcher::long_cmove_cost() { return 0; }
1639 
1640 // No CMOVF/CMOVD with SSE2
1641 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
1642 
1643 // Does the CPU require late expand (see block.cpp for description of late expand)?
1644 const bool Matcher::require_postalloc_expand = false;
1645 
1646 // Should the Matcher clone shifts on addressing modes, expecting them
1647 // to be subsumed into complex addressing expressions or compute them
1648 // into registers?  True for Intel but false for most RISCs
1649 const bool Matcher::clone_shift_expressions = true;
1650 
1651 // Do we need to mask the count passed to shift instructions or does
1652 // the cpu only look at the lower 5/6 bits anyway?
1653 const bool Matcher::need_masked_shift_count = false;
1654 
1655 bool Matcher::narrow_oop_use_complex_address() {
1656   assert(UseCompressedOops, "only for compressed oops code");
1657   return (LogMinObjAlignmentInBytes &lt;= 3);
1658 }
1659 
1660 bool Matcher::narrow_klass_use_complex_address() {
1661   assert(UseCompressedClassPointers, "only for compressed klass code");
1662   return (LogKlassAlignmentInBytes &lt;= 3);
1663 }
1664 
1665 // Is it better to copy float constants, or load them directly from
1666 // memory?  Intel can load a float constant from a direct address,
1667 // requiring no extra registers.  Most RISCs will have to materialize
1668 // an address into a register first, so they would do better to copy
1669 // the constant from stack.
1670 const bool Matcher::rematerialize_float_constants = true; // XXX
1671 
1672 // If CPU can load and store mis-aligned doubles directly then no
1673 // fixup is needed.  Else we split the double into 2 integer pieces
1674 // and move it piece-by-piece.  Only happens when passing doubles into
1675 // C code as the Java calling convention forces doubles to be aligned.
1676 const bool Matcher::misaligned_doubles_ok = true;
1677 
1678 // No-op on amd64
1679 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
1680 
1681 // Advertise here if the CPU requires explicit rounding operations to
1682 // implement the UseStrictFP mode.
1683 const bool Matcher::strict_fp_requires_explicit_rounding = true;
1684 
1685 // Are floats conerted to double when stored to stack during deoptimization?
1686 // On x64 it is stored without convertion so we can use normal access.
1687 bool Matcher::float_in_double() { return false; }
1688 
1689 // Do ints take an entire long register or just half?
1690 const bool Matcher::int_in_long = true;
1691 
1692 // Return whether or not this register is ever used as an argument.
1693 // This function is used on startup to build the trampoline stubs in
1694 // generateOptoStub.  Registers not mentioned will be killed by the VM
1695 // call in the trampoline, and arguments in those registers not be
1696 // available to the callee.
1697 bool Matcher::can_be_java_arg(int reg)
1698 {
1699   return
1700     reg ==  RDI_num || reg == RDI_H_num ||
1701     reg ==  RSI_num || reg == RSI_H_num ||
1702     reg ==  RDX_num || reg == RDX_H_num ||
1703     reg ==  RCX_num || reg == RCX_H_num ||
1704     reg ==   R8_num || reg ==  R8_H_num ||
1705     reg ==   R9_num || reg ==  R9_H_num ||
1706     reg ==  R12_num || reg == R12_H_num ||
1707     reg == XMM0_num || reg == XMM0b_num ||
1708     reg == XMM1_num || reg == XMM1b_num ||
1709     reg == XMM2_num || reg == XMM2b_num ||
1710     reg == XMM3_num || reg == XMM3b_num ||
1711     reg == XMM4_num || reg == XMM4b_num ||
1712     reg == XMM5_num || reg == XMM5b_num ||
1713     reg == XMM6_num || reg == XMM6b_num ||
1714     reg == XMM7_num || reg == XMM7b_num;
1715 }
1716 
1717 bool Matcher::is_spillable_arg(int reg)
1718 {
1719   return can_be_java_arg(reg);
1720 }
1721 
1722 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
1723   // In 64 bit mode a code which use multiply when
1724   // devisor is constant is faster than hardware
1725   // DIV instruction (it uses MulHiL).
1726   return false;
1727 }
1728 
1729 // Register for DIVI projection of divmodI
1730 RegMask Matcher::divI_proj_mask() {
1731   return INT_RAX_REG_mask();
1732 }
1733 
1734 // Register for MODI projection of divmodI
1735 RegMask Matcher::modI_proj_mask() {
1736   return INT_RDX_REG_mask();
1737 }
1738 
1739 // Register for DIVL projection of divmodL
1740 RegMask Matcher::divL_proj_mask() {
1741   return LONG_RAX_REG_mask();
1742 }
1743 
1744 // Register for MODL projection of divmodL
1745 RegMask Matcher::modL_proj_mask() {
1746   return LONG_RDX_REG_mask();
1747 }
1748 
1749 // Register for saving SP into on method handle invokes. Not used on x86_64.
1750 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
1751     return NO_REG_mask();
1752 }
1753 
1754 %}
1755 
1756 //----------ENCODING BLOCK-----------------------------------------------------
1757 // This block specifies the encoding classes used by the compiler to
1758 // output byte streams.  Encoding classes are parameterized macros
1759 // used by Machine Instruction Nodes in order to generate the bit
1760 // encoding of the instruction.  Operands specify their base encoding
1761 // interface with the interface keyword.  There are currently
1762 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
1763 // COND_INTER.  REG_INTER causes an operand to generate a function
1764 // which returns its register number when queried.  CONST_INTER causes
1765 // an operand to generate a function which returns the value of the
1766 // constant when queried.  MEMORY_INTER causes an operand to generate
1767 // four functions which return the Base Register, the Index Register,
1768 // the Scale Value, and the Offset Value of the operand when queried.
1769 // COND_INTER causes an operand to generate six functions which return
1770 // the encoding code (ie - encoding bits for the instruction)
1771 // associated with each basic boolean condition for a conditional
1772 // instruction.
1773 //
1774 // Instructions specify two basic values for encoding.  Again, a
1775 // function is available to check if the constant displacement is an
1776 // oop. They use the ins_encode keyword to specify their encoding
1777 // classes (which must be a sequence of enc_class names, and their
1778 // parameters, specified in the encoding block), and they use the
1779 // opcode keyword to specify, in order, their primary, secondary, and
1780 // tertiary opcode.  Only the opcode sections which a particular
1781 // instruction needs for encoding need to be specified.
1782 encode %{
1783   // Build emit functions for each basic byte or larger field in the
1784   // intel encoding scheme (opcode, rm, sib, immediate), and call them
1785   // from C++ code in the enc_class source block.  Emit functions will
1786   // live in the main source block for now.  In future, we can
1787   // generalize this by adding a syntax that specifies the sizes of
1788   // fields in an order, so that the adlc can build the emit functions
1789   // automagically
1790 
1791   // Emit primary opcode
1792   enc_class OpcP
1793   %{
1794     emit_opcode(cbuf, $primary);
1795   %}
1796 
1797   // Emit secondary opcode
1798   enc_class OpcS
1799   %{
1800     emit_opcode(cbuf, $secondary);
1801   %}
1802 
1803   // Emit tertiary opcode
1804   enc_class OpcT
1805   %{
1806     emit_opcode(cbuf, $tertiary);
1807   %}
1808 
1809   // Emit opcode directly
1810   enc_class Opcode(immI d8)
1811   %{
1812     emit_opcode(cbuf, $d8$$constant);
1813   %}
1814 
1815   // Emit size prefix
1816   enc_class SizePrefix
1817   %{
1818     emit_opcode(cbuf, 0x66);
1819   %}
1820 
1821   enc_class reg(rRegI reg)
1822   %{
1823     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
1824   %}
1825 
1826   enc_class reg_reg(rRegI dst, rRegI src)
1827   %{
1828     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1829   %}
1830 
1831   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
1832   %{
1833     emit_opcode(cbuf, $opcode$$constant);
1834     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1835   %}
1836 
1837   enc_class cdql_enc(no_rax_rdx_RegI div)
1838   %{
1839     // Full implementation of Java idiv and irem; checks for
1840     // special case as described in JVM spec., p.243 &amp; p.271.
1841     //
1842     //         normal case                           special case
1843     //
1844     // input : rax: dividend                         min_int
1845     //         reg: divisor                          -1
1846     //
1847     // output: rax: quotient  (= rax idiv reg)       min_int
1848     //         rdx: remainder (= rax irem reg)       0
1849     //
1850     //  Code sequnce:
1851     //
1852     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
1853     //    5:   75 07/08                jne    e &lt;normal&gt;
1854     //    7:   33 d2                   xor    %edx,%edx
1855     //  [div &gt;= 8 -&gt; offset + 1]
1856     //  [REX_B]
1857     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
1858     //    c:   74 03/04                je     11 &lt;done&gt;
1859     // 000000000000000e &lt;normal&gt;:
1860     //    e:   99                      cltd
1861     //  [div &gt;= 8 -&gt; offset + 1]
1862     //  [REX_B]
1863     //    f:   f7 f9                   idiv   $div
1864     // 0000000000000011 &lt;done&gt;:
1865 
1866     // cmp    $0x80000000,%eax
1867     emit_opcode(cbuf, 0x3d);
1868     emit_d8(cbuf, 0x00);
1869     emit_d8(cbuf, 0x00);
1870     emit_d8(cbuf, 0x00);
1871     emit_d8(cbuf, 0x80);
1872 
1873     // jne    e &lt;normal&gt;
1874     emit_opcode(cbuf, 0x75);
1875     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
1876 
1877     // xor    %edx,%edx
1878     emit_opcode(cbuf, 0x33);
1879     emit_d8(cbuf, 0xD2);
1880 
1881     // cmp    $0xffffffffffffffff,%ecx
1882     if ($div$$reg &gt;= 8) {
1883       emit_opcode(cbuf, Assembler::REX_B);
1884     }
1885     emit_opcode(cbuf, 0x83);
1886     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1887     emit_d8(cbuf, 0xFF);
1888 
1889     // je     11 &lt;done&gt;
1890     emit_opcode(cbuf, 0x74);
1891     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
1892 
1893     // &lt;normal&gt;
1894     // cltd
1895     emit_opcode(cbuf, 0x99);
1896 
1897     // idivl (note: must be emitted by the user of this rule)
1898     // &lt;done&gt;
1899   %}
1900 
1901   enc_class cdqq_enc(no_rax_rdx_RegL div)
1902   %{
1903     // Full implementation of Java ldiv and lrem; checks for
1904     // special case as described in JVM spec., p.243 &amp; p.271.
1905     //
1906     //         normal case                           special case
1907     //
1908     // input : rax: dividend                         min_long
1909     //         reg: divisor                          -1
1910     //
1911     // output: rax: quotient  (= rax idiv reg)       min_long
1912     //         rdx: remainder (= rax irem reg)       0
1913     //
1914     //  Code sequnce:
1915     //
1916     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
1917     //    7:   00 00 80
1918     //    a:   48 39 d0                cmp    %rdx,%rax
1919     //    d:   75 08                   jne    17 &lt;normal&gt;
1920     //    f:   33 d2                   xor    %edx,%edx
1921     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
1922     //   15:   74 05                   je     1c &lt;done&gt;
1923     // 0000000000000017 &lt;normal&gt;:
1924     //   17:   48 99                   cqto
1925     //   19:   48 f7 f9                idiv   $div
1926     // 000000000000001c &lt;done&gt;:
1927 
1928     // mov    $0x8000000000000000,%rdx
1929     emit_opcode(cbuf, Assembler::REX_W);
1930     emit_opcode(cbuf, 0xBA);
1931     emit_d8(cbuf, 0x00);
1932     emit_d8(cbuf, 0x00);
1933     emit_d8(cbuf, 0x00);
1934     emit_d8(cbuf, 0x00);
1935     emit_d8(cbuf, 0x00);
1936     emit_d8(cbuf, 0x00);
1937     emit_d8(cbuf, 0x00);
1938     emit_d8(cbuf, 0x80);
1939 
1940     // cmp    %rdx,%rax
1941     emit_opcode(cbuf, Assembler::REX_W);
1942     emit_opcode(cbuf, 0x39);
1943     emit_d8(cbuf, 0xD0);
1944 
1945     // jne    17 &lt;normal&gt;
1946     emit_opcode(cbuf, 0x75);
1947     emit_d8(cbuf, 0x08);
1948 
1949     // xor    %edx,%edx
1950     emit_opcode(cbuf, 0x33);
1951     emit_d8(cbuf, 0xD2);
1952 
1953     // cmp    $0xffffffffffffffff,$div
1954     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
1955     emit_opcode(cbuf, 0x83);
1956     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1957     emit_d8(cbuf, 0xFF);
1958 
1959     // je     1e &lt;done&gt;
1960     emit_opcode(cbuf, 0x74);
1961     emit_d8(cbuf, 0x05);
1962 
1963     // &lt;normal&gt;
1964     // cqto
1965     emit_opcode(cbuf, Assembler::REX_W);
1966     emit_opcode(cbuf, 0x99);
1967 
1968     // idivq (note: must be emitted by the user of this rule)
1969     // &lt;done&gt;
1970   %}
1971 
1972   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
1973   enc_class OpcSE(immI imm)
1974   %{
1975     // Emit primary opcode and set sign-extend bit
1976     // Check for 8-bit immediate, and set sign extend bit in opcode
1977     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1978       emit_opcode(cbuf, $primary | 0x02);
1979     } else {
1980       // 32-bit immediate
1981       emit_opcode(cbuf, $primary);
1982     }
1983   %}
1984 
1985   enc_class OpcSErm(rRegI dst, immI imm)
1986   %{
1987     // OpcSEr/m
1988     int dstenc = $dst$$reg;
1989     if (dstenc &gt;= 8) {
1990       emit_opcode(cbuf, Assembler::REX_B);
1991       dstenc -= 8;
1992     }
1993     // Emit primary opcode and set sign-extend bit
1994     // Check for 8-bit immediate, and set sign extend bit in opcode
1995     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1996       emit_opcode(cbuf, $primary | 0x02);
1997     } else {
1998       // 32-bit immediate
1999       emit_opcode(cbuf, $primary);
2000     }
2001     // Emit r/m byte with secondary opcode, after primary opcode.
2002     emit_rm(cbuf, 0x3, $secondary, dstenc);
2003   %}
2004 
2005   enc_class OpcSErm_wide(rRegL dst, immI imm)
2006   %{
2007     // OpcSEr/m
2008     int dstenc = $dst$$reg;
2009     if (dstenc &lt; 8) {
2010       emit_opcode(cbuf, Assembler::REX_W);
2011     } else {
2012       emit_opcode(cbuf, Assembler::REX_WB);
2013       dstenc -= 8;
2014     }
2015     // Emit primary opcode and set sign-extend bit
2016     // Check for 8-bit immediate, and set sign extend bit in opcode
2017     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2018       emit_opcode(cbuf, $primary | 0x02);
2019     } else {
2020       // 32-bit immediate
2021       emit_opcode(cbuf, $primary);
2022     }
2023     // Emit r/m byte with secondary opcode, after primary opcode.
2024     emit_rm(cbuf, 0x3, $secondary, dstenc);
2025   %}
2026 
2027   enc_class Con8or32(immI imm)
2028   %{
2029     // Check for 8-bit immediate, and set sign extend bit in opcode
2030     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2031       $$$emit8$imm$$constant;
2032     } else {
2033       // 32-bit immediate
2034       $$$emit32$imm$$constant;
2035     }
2036   %}
2037 
2038   enc_class opc2_reg(rRegI dst)
2039   %{
2040     // BSWAP
2041     emit_cc(cbuf, $secondary, $dst$$reg);
2042   %}
2043 
2044   enc_class opc3_reg(rRegI dst)
2045   %{
2046     // BSWAP
2047     emit_cc(cbuf, $tertiary, $dst$$reg);
2048   %}
2049 
2050   enc_class reg_opc(rRegI div)
2051   %{
2052     // INC, DEC, IDIV, IMOD, JMP indirect, ...
2053     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
2054   %}
2055 
2056   enc_class enc_cmov(cmpOp cop)
2057   %{
2058     // CMOV
2059     $$$emit8$primary;
2060     emit_cc(cbuf, $secondary, $cop$$cmpcode);
2061   %}
2062 
2063   enc_class enc_PartialSubtypeCheck()
2064   %{
2065     Register Rrdi = as_Register(RDI_enc); // result register
2066     Register Rrax = as_Register(RAX_enc); // super class
2067     Register Rrcx = as_Register(RCX_enc); // killed
2068     Register Rrsi = as_Register(RSI_enc); // sub class
2069     Label miss;
2070     const bool set_cond_codes = true;
2071 
2072     MacroAssembler _masm(&amp;cbuf);
2073     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
2074                                      NULL, &amp;miss,
2075                                      /*set_cond_codes:*/ true);
2076     if ($primary) {
2077       __ xorptr(Rrdi, Rrdi);
2078     }
2079     __ bind(miss);
2080   %}
2081 
2082   enc_class clear_avx %{
2083     debug_only(int off0 = cbuf.insts_size());
2084     if (ra_-&gt;C-&gt;max_vector_size() &gt; 16) {
2085       // Clear upper bits of YMM registers when current compiled code uses
2086       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
2087       MacroAssembler _masm(&amp;cbuf);
2088       __ vzeroupper();
2089     }
2090     debug_only(int off1 = cbuf.insts_size());
2091     assert(off1 - off0 == clear_avx_size(), "correct size prediction");
2092   %}
2093 
2094   enc_class Java_To_Runtime(method meth) %{
2095     // No relocation needed
2096     MacroAssembler _masm(&amp;cbuf);
2097     __ mov64(r10, (int64_t) $meth$$method);
2098     __ call(r10);
2099   %}
2100 
2101   enc_class Java_To_Interpreter(method meth)
2102   %{
2103     // CALL Java_To_Interpreter
2104     // This is the instruction starting address for relocation info.
2105     cbuf.set_insts_mark();
2106     $$$emit8$primary;
2107     // CALL directly to the runtime
2108     emit_d32_reloc(cbuf,
2109                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2110                    runtime_call_Relocation::spec(),
2111                    RELOC_DISP32);
2112   %}
2113 
2114   enc_class Java_Static_Call(method meth)
2115   %{
2116     // JAVA STATIC CALL
2117     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
2118     // determine who we intended to call.
2119     cbuf.set_insts_mark();
2120     $$$emit8$primary;
2121 
2122     if (!_method) {
2123       emit_d32_reloc(cbuf,
2124                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2125                      runtime_call_Relocation::spec(),
2126                      RELOC_DISP32);
2127     } else if (_optimized_virtual) {
2128       emit_d32_reloc(cbuf,
2129                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2130                      opt_virtual_call_Relocation::spec(),
2131                      RELOC_DISP32);
2132     } else {
2133       emit_d32_reloc(cbuf,
2134                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2135                      static_call_Relocation::spec(),
2136                      RELOC_DISP32);
2137     }
2138     if (_method) {
2139       // Emit stub for static call.
2140       CompiledStaticCall::emit_to_interp_stub(cbuf);
2141     }
2142   %}
2143 
2144   enc_class Java_Dynamic_Call(method meth) %{
2145     MacroAssembler _masm(&amp;cbuf);
2146     __ ic_call((address)$meth$$method);
2147   %}
2148 
2149   enc_class Java_Compiled_Call(method meth)
2150   %{
2151     // JAVA COMPILED CALL
2152     int disp = in_bytes(Method:: from_compiled_offset());
2153 
2154     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
2155     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, "compiled_code_offset isn't small");
2156 
2157     // callq *disp(%rax)
2158     cbuf.set_insts_mark();
2159     $$$emit8$primary;
2160     if (disp &lt; 0x80) {
2161       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
2162       emit_d8(cbuf, disp); // Displacement
2163     } else {
2164       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
2165       emit_d32(cbuf, disp); // Displacement
2166     }
2167   %}
2168 
2169   enc_class reg_opc_imm(rRegI dst, immI8 shift)
2170   %{
2171     // SAL, SAR, SHR
2172     int dstenc = $dst$$reg;
2173     if (dstenc &gt;= 8) {
2174       emit_opcode(cbuf, Assembler::REX_B);
2175       dstenc -= 8;
2176     }
2177     $$$emit8$primary;
2178     emit_rm(cbuf, 0x3, $secondary, dstenc);
2179     $$$emit8$shift$$constant;
2180   %}
2181 
2182   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
2183   %{
2184     // SAL, SAR, SHR
2185     int dstenc = $dst$$reg;
2186     if (dstenc &lt; 8) {
2187       emit_opcode(cbuf, Assembler::REX_W);
2188     } else {
2189       emit_opcode(cbuf, Assembler::REX_WB);
2190       dstenc -= 8;
2191     }
2192     $$$emit8$primary;
2193     emit_rm(cbuf, 0x3, $secondary, dstenc);
2194     $$$emit8$shift$$constant;
2195   %}
2196 
2197   enc_class load_immI(rRegI dst, immI src)
2198   %{
2199     int dstenc = $dst$$reg;
2200     if (dstenc &gt;= 8) {
2201       emit_opcode(cbuf, Assembler::REX_B);
2202       dstenc -= 8;
2203     }
2204     emit_opcode(cbuf, 0xB8 | dstenc);
2205     $$$emit32$src$$constant;
2206   %}
2207 
2208   enc_class load_immL(rRegL dst, immL src)
2209   %{
2210     int dstenc = $dst$$reg;
2211     if (dstenc &lt; 8) {
2212       emit_opcode(cbuf, Assembler::REX_W);
2213     } else {
2214       emit_opcode(cbuf, Assembler::REX_WB);
2215       dstenc -= 8;
2216     }
2217     emit_opcode(cbuf, 0xB8 | dstenc);
2218     emit_d64(cbuf, $src$$constant);
2219   %}
2220 
2221   enc_class load_immUL32(rRegL dst, immUL32 src)
2222   %{
2223     // same as load_immI, but this time we care about zeroes in the high word
2224     int dstenc = $dst$$reg;
2225     if (dstenc &gt;= 8) {
2226       emit_opcode(cbuf, Assembler::REX_B);
2227       dstenc -= 8;
2228     }
2229     emit_opcode(cbuf, 0xB8 | dstenc);
2230     $$$emit32$src$$constant;
2231   %}
2232 
2233   enc_class load_immL32(rRegL dst, immL32 src)
2234   %{
2235     int dstenc = $dst$$reg;
2236     if (dstenc &lt; 8) {
2237       emit_opcode(cbuf, Assembler::REX_W);
2238     } else {
2239       emit_opcode(cbuf, Assembler::REX_WB);
2240       dstenc -= 8;
2241     }
2242     emit_opcode(cbuf, 0xC7);
2243     emit_rm(cbuf, 0x03, 0x00, dstenc);
2244     $$$emit32$src$$constant;
2245   %}
2246 
2247   enc_class load_immP31(rRegP dst, immP32 src)
2248   %{
2249     // same as load_immI, but this time we care about zeroes in the high word
2250     int dstenc = $dst$$reg;
2251     if (dstenc &gt;= 8) {
2252       emit_opcode(cbuf, Assembler::REX_B);
2253       dstenc -= 8;
2254     }
2255     emit_opcode(cbuf, 0xB8 | dstenc);
2256     $$$emit32$src$$constant;
2257   %}
2258 
2259   enc_class load_immP(rRegP dst, immP src)
2260   %{
2261     int dstenc = $dst$$reg;
2262     if (dstenc &lt; 8) {
2263       emit_opcode(cbuf, Assembler::REX_W);
2264     } else {
2265       emit_opcode(cbuf, Assembler::REX_WB);
2266       dstenc -= 8;
2267     }
2268     emit_opcode(cbuf, 0xB8 | dstenc);
2269     // This next line should be generated from ADLC
2270     if ($src-&gt;constant_reloc() != relocInfo::none) {
2271       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
2272     } else {
2273       emit_d64(cbuf, $src$$constant);
2274     }
2275   %}
2276 
2277   enc_class Con32(immI src)
2278   %{
2279     // Output immediate
2280     $$$emit32$src$$constant;
2281   %}
2282 
2283   enc_class Con32F_as_bits(immF src)
2284   %{
2285     // Output Float immediate bits
2286     jfloat jf = $src$$constant;
2287     jint jf_as_bits = jint_cast(jf);
2288     emit_d32(cbuf, jf_as_bits);
2289   %}
2290 
2291   enc_class Con16(immI src)
2292   %{
2293     // Output immediate
2294     $$$emit16$src$$constant;
2295   %}
2296 
2297   // How is this different from Con32??? XXX
2298   enc_class Con_d32(immI src)
2299   %{
2300     emit_d32(cbuf,$src$$constant);
2301   %}
2302 
2303   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
2304     // Output immediate memory reference
2305     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
2306     emit_d32(cbuf, 0x00);
2307   %}
2308 
2309   enc_class lock_prefix()
2310   %{
2311     if (os::is_MP()) {
2312       emit_opcode(cbuf, 0xF0); // lock
2313     }
2314   %}
2315 
2316   enc_class REX_mem(memory mem)
2317   %{
2318     if ($mem$$base &gt;= 8) {
2319       if ($mem$$index &lt; 8) {
2320         emit_opcode(cbuf, Assembler::REX_B);
2321       } else {
2322         emit_opcode(cbuf, Assembler::REX_XB);
2323       }
2324     } else {
2325       if ($mem$$index &gt;= 8) {
2326         emit_opcode(cbuf, Assembler::REX_X);
2327       }
2328     }
2329   %}
2330 
2331   enc_class REX_mem_wide(memory mem)
2332   %{
2333     if ($mem$$base &gt;= 8) {
2334       if ($mem$$index &lt; 8) {
2335         emit_opcode(cbuf, Assembler::REX_WB);
2336       } else {
2337         emit_opcode(cbuf, Assembler::REX_WXB);
2338       }
2339     } else {
2340       if ($mem$$index &lt; 8) {
2341         emit_opcode(cbuf, Assembler::REX_W);
2342       } else {
2343         emit_opcode(cbuf, Assembler::REX_WX);
2344       }
2345     }
2346   %}
2347 
2348   // for byte regs
2349   enc_class REX_breg(rRegI reg)
2350   %{
2351     if ($reg$$reg &gt;= 4) {
2352       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2353     }
2354   %}
2355 
2356   // for byte regs
2357   enc_class REX_reg_breg(rRegI dst, rRegI src)
2358   %{
2359     if ($dst$$reg &lt; 8) {
2360       if ($src$$reg &gt;= 4) {
2361         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2362       }
2363     } else {
2364       if ($src$$reg &lt; 8) {
2365         emit_opcode(cbuf, Assembler::REX_R);
2366       } else {
2367         emit_opcode(cbuf, Assembler::REX_RB);
2368       }
2369     }
2370   %}
2371 
2372   // for byte regs
2373   enc_class REX_breg_mem(rRegI reg, memory mem)
2374   %{
2375     if ($reg$$reg &lt; 8) {
2376       if ($mem$$base &lt; 8) {
2377         if ($mem$$index &gt;= 8) {
2378           emit_opcode(cbuf, Assembler::REX_X);
2379         } else if ($reg$$reg &gt;= 4) {
2380           emit_opcode(cbuf, Assembler::REX);
2381         }
2382       } else {
2383         if ($mem$$index &lt; 8) {
2384           emit_opcode(cbuf, Assembler::REX_B);
2385         } else {
2386           emit_opcode(cbuf, Assembler::REX_XB);
2387         }
2388       }
2389     } else {
2390       if ($mem$$base &lt; 8) {
2391         if ($mem$$index &lt; 8) {
2392           emit_opcode(cbuf, Assembler::REX_R);
2393         } else {
2394           emit_opcode(cbuf, Assembler::REX_RX);
2395         }
2396       } else {
2397         if ($mem$$index &lt; 8) {
2398           emit_opcode(cbuf, Assembler::REX_RB);
2399         } else {
2400           emit_opcode(cbuf, Assembler::REX_RXB);
2401         }
2402       }
2403     }
2404   %}
2405 
2406   enc_class REX_reg(rRegI reg)
2407   %{
2408     if ($reg$$reg &gt;= 8) {
2409       emit_opcode(cbuf, Assembler::REX_B);
2410     }
2411   %}
2412 
2413   enc_class REX_reg_wide(rRegI reg)
2414   %{
2415     if ($reg$$reg &lt; 8) {
2416       emit_opcode(cbuf, Assembler::REX_W);
2417     } else {
2418       emit_opcode(cbuf, Assembler::REX_WB);
2419     }
2420   %}
2421 
2422   enc_class REX_reg_reg(rRegI dst, rRegI src)
2423   %{
2424     if ($dst$$reg &lt; 8) {
2425       if ($src$$reg &gt;= 8) {
2426         emit_opcode(cbuf, Assembler::REX_B);
2427       }
2428     } else {
2429       if ($src$$reg &lt; 8) {
2430         emit_opcode(cbuf, Assembler::REX_R);
2431       } else {
2432         emit_opcode(cbuf, Assembler::REX_RB);
2433       }
2434     }
2435   %}
2436 
2437   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
2438   %{
2439     if ($dst$$reg &lt; 8) {
2440       if ($src$$reg &lt; 8) {
2441         emit_opcode(cbuf, Assembler::REX_W);
2442       } else {
2443         emit_opcode(cbuf, Assembler::REX_WB);
2444       }
2445     } else {
2446       if ($src$$reg &lt; 8) {
2447         emit_opcode(cbuf, Assembler::REX_WR);
2448       } else {
2449         emit_opcode(cbuf, Assembler::REX_WRB);
2450       }
2451     }
2452   %}
2453 
2454   enc_class REX_reg_mem(rRegI reg, memory mem)
2455   %{
2456     if ($reg$$reg &lt; 8) {
2457       if ($mem$$base &lt; 8) {
2458         if ($mem$$index &gt;= 8) {
2459           emit_opcode(cbuf, Assembler::REX_X);
2460         }
2461       } else {
2462         if ($mem$$index &lt; 8) {
2463           emit_opcode(cbuf, Assembler::REX_B);
2464         } else {
2465           emit_opcode(cbuf, Assembler::REX_XB);
2466         }
2467       }
2468     } else {
2469       if ($mem$$base &lt; 8) {
2470         if ($mem$$index &lt; 8) {
2471           emit_opcode(cbuf, Assembler::REX_R);
2472         } else {
2473           emit_opcode(cbuf, Assembler::REX_RX);
2474         }
2475       } else {
2476         if ($mem$$index &lt; 8) {
2477           emit_opcode(cbuf, Assembler::REX_RB);
2478         } else {
2479           emit_opcode(cbuf, Assembler::REX_RXB);
2480         }
2481       }
2482     }
2483   %}
2484 
2485   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
2486   %{
2487     if ($reg$$reg &lt; 8) {
2488       if ($mem$$base &lt; 8) {
2489         if ($mem$$index &lt; 8) {
2490           emit_opcode(cbuf, Assembler::REX_W);
2491         } else {
2492           emit_opcode(cbuf, Assembler::REX_WX);
2493         }
2494       } else {
2495         if ($mem$$index &lt; 8) {
2496           emit_opcode(cbuf, Assembler::REX_WB);
2497         } else {
2498           emit_opcode(cbuf, Assembler::REX_WXB);
2499         }
2500       }
2501     } else {
2502       if ($mem$$base &lt; 8) {
2503         if ($mem$$index &lt; 8) {
2504           emit_opcode(cbuf, Assembler::REX_WR);
2505         } else {
2506           emit_opcode(cbuf, Assembler::REX_WRX);
2507         }
2508       } else {
2509         if ($mem$$index &lt; 8) {
2510           emit_opcode(cbuf, Assembler::REX_WRB);
2511         } else {
2512           emit_opcode(cbuf, Assembler::REX_WRXB);
2513         }
2514       }
2515     }
2516   %}
2517 
2518   enc_class reg_mem(rRegI ereg, memory mem)
2519   %{
2520     // High registers handle in encode_RegMem
2521     int reg = $ereg$$reg;
2522     int base = $mem$$base;
2523     int index = $mem$$index;
2524     int scale = $mem$$scale;
2525     int disp = $mem$$disp;
2526     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
2527 
2528     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
2529   %}
2530 
2531   enc_class RM_opc_mem(immI rm_opcode, memory mem)
2532   %{
2533     int rm_byte_opcode = $rm_opcode$$constant;
2534 
2535     // High registers handle in encode_RegMem
2536     int base = $mem$$base;
2537     int index = $mem$$index;
2538     int scale = $mem$$scale;
2539     int displace = $mem$$disp;
2540 
2541     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
2542                                             // working with static
2543                                             // globals
2544     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
2545                   disp_reloc);
2546   %}
2547 
2548   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
2549   %{
2550     int reg_encoding = $dst$$reg;
2551     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
2552     int index        = 0x04;            // 0x04 indicates no index
2553     int scale        = 0x00;            // 0x00 indicates no scale
2554     int displace     = $src1$$constant; // 0x00 indicates no displacement
2555     relocInfo::relocType disp_reloc = relocInfo::none;
2556     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
2557                   disp_reloc);
2558   %}
2559 
2560   enc_class neg_reg(rRegI dst)
2561   %{
2562     int dstenc = $dst$$reg;
2563     if (dstenc &gt;= 8) {
2564       emit_opcode(cbuf, Assembler::REX_B);
2565       dstenc -= 8;
2566     }
2567     // NEG $dst
2568     emit_opcode(cbuf, 0xF7);
2569     emit_rm(cbuf, 0x3, 0x03, dstenc);
2570   %}
2571 
2572   enc_class neg_reg_wide(rRegI dst)
2573   %{
2574     int dstenc = $dst$$reg;
2575     if (dstenc &lt; 8) {
2576       emit_opcode(cbuf, Assembler::REX_W);
2577     } else {
2578       emit_opcode(cbuf, Assembler::REX_WB);
2579       dstenc -= 8;
2580     }
2581     // NEG $dst
2582     emit_opcode(cbuf, 0xF7);
2583     emit_rm(cbuf, 0x3, 0x03, dstenc);
2584   %}
2585 
2586   enc_class setLT_reg(rRegI dst)
2587   %{
2588     int dstenc = $dst$$reg;
2589     if (dstenc &gt;= 8) {
2590       emit_opcode(cbuf, Assembler::REX_B);
2591       dstenc -= 8;
2592     } else if (dstenc &gt;= 4) {
2593       emit_opcode(cbuf, Assembler::REX);
2594     }
2595     // SETLT $dst
2596     emit_opcode(cbuf, 0x0F);
2597     emit_opcode(cbuf, 0x9C);
2598     emit_rm(cbuf, 0x3, 0x0, dstenc);
2599   %}
2600 
2601   enc_class setNZ_reg(rRegI dst)
2602   %{
2603     int dstenc = $dst$$reg;
2604     if (dstenc &gt;= 8) {
2605       emit_opcode(cbuf, Assembler::REX_B);
2606       dstenc -= 8;
2607     } else if (dstenc &gt;= 4) {
2608       emit_opcode(cbuf, Assembler::REX);
2609     }
2610     // SETNZ $dst
2611     emit_opcode(cbuf, 0x0F);
2612     emit_opcode(cbuf, 0x95);
2613     emit_rm(cbuf, 0x3, 0x0, dstenc);
2614   %}
2615 
2616 
2617   // Compare the lonogs and set -1, 0, or 1 into dst
2618   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
2619   %{
2620     int src1enc = $src1$$reg;
2621     int src2enc = $src2$$reg;
2622     int dstenc = $dst$$reg;
2623 
2624     // cmpq $src1, $src2
2625     if (src1enc &lt; 8) {
2626       if (src2enc &lt; 8) {
2627         emit_opcode(cbuf, Assembler::REX_W);
2628       } else {
2629         emit_opcode(cbuf, Assembler::REX_WB);
2630       }
2631     } else {
2632       if (src2enc &lt; 8) {
2633         emit_opcode(cbuf, Assembler::REX_WR);
2634       } else {
2635         emit_opcode(cbuf, Assembler::REX_WRB);
2636       }
2637     }
2638     emit_opcode(cbuf, 0x3B);
2639     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
2640 
2641     // movl $dst, -1
2642     if (dstenc &gt;= 8) {
2643       emit_opcode(cbuf, Assembler::REX_B);
2644     }
2645     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
2646     emit_d32(cbuf, -1);
2647 
2648     // jl,s done
2649     emit_opcode(cbuf, 0x7C);
2650     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
2651 
2652     // setne $dst
2653     if (dstenc &gt;= 4) {
2654       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
2655     }
2656     emit_opcode(cbuf, 0x0F);
2657     emit_opcode(cbuf, 0x95);
2658     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
2659 
2660     // movzbl $dst, $dst
2661     if (dstenc &gt;= 4) {
2662       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
2663     }
2664     emit_opcode(cbuf, 0x0F);
2665     emit_opcode(cbuf, 0xB6);
2666     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
2667   %}
2668 
2669   enc_class Push_ResultXD(regD dst) %{
2670     MacroAssembler _masm(&amp;cbuf);
2671     __ fstp_d(Address(rsp, 0));
2672     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
2673     __ addptr(rsp, 8);
2674   %}
2675 
2676   enc_class Push_SrcXD(regD src) %{
2677     MacroAssembler _masm(&amp;cbuf);
2678     __ subptr(rsp, 8);
2679     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
2680     __ fld_d(Address(rsp, 0));
2681   %}
2682 
2683 
2684   enc_class enc_rethrow()
2685   %{
2686     cbuf.set_insts_mark();
2687     emit_opcode(cbuf, 0xE9); // jmp entry
2688     emit_d32_reloc(cbuf,
2689                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
2690                    runtime_call_Relocation::spec(),
2691                    RELOC_DISP32);
2692   %}
2693 
2694 %}
2695 
2696 
2697 
2698 //----------FRAME--------------------------------------------------------------
2699 // Definition of frame structure and management information.
2700 //
2701 //  S T A C K   L A Y O U T    Allocators stack-slot number
2702 //                             |   (to get allocators register number
2703 //  G  Owned by    |        |  v    add OptoReg::stack0())
2704 //  r   CALLER     |        |
2705 //  o     |        +--------+      pad to even-align allocators stack-slot
2706 //  w     V        |  pad0  |        numbers; owned by CALLER
2707 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
2708 //  h     ^        |   in   |  5
2709 //        |        |  args  |  4   Holes in incoming args owned by SELF
2710 //  |     |        |        |  3
2711 //  |     |        +--------+
2712 //  V     |        | old out|      Empty on Intel, window on Sparc
2713 //        |    old |preserve|      Must be even aligned.
2714 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
2715 //        |        |   in   |  3   area for Intel ret address
2716 //     Owned by    |preserve|      Empty on Sparc.
2717 //       SELF      +--------+
2718 //        |        |  pad2  |  2   pad to align old SP
2719 //        |        +--------+  1
2720 //        |        | locks  |  0
2721 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
2722 //        |        |  pad1  | 11   pad to align new SP
2723 //        |        +--------+
2724 //        |        |        | 10
2725 //        |        | spills |  9   spills
2726 //        V        |        |  8   (pad0 slot for callee)
2727 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
2728 //        ^        |  out   |  7
2729 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
2730 //     Owned by    +--------+
2731 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
2732 //        |    new |preserve|      Must be even-aligned.
2733 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
2734 //        |        |        |
2735 //
2736 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
2737 //         known from SELF's arguments and the Java calling convention.
2738 //         Region 6-7 is determined per call site.
2739 // Note 2: If the calling convention leaves holes in the incoming argument
2740 //         area, those holes are owned by SELF.  Holes in the outgoing area
2741 //         are owned by the CALLEE.  Holes should not be nessecary in the
2742 //         incoming area, as the Java calling convention is completely under
2743 //         the control of the AD file.  Doubles can be sorted and packed to
2744 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
2745 //         varargs C calling conventions.
2746 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
2747 //         even aligned with pad0 as needed.
2748 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
2749 //         region 6-11 is even aligned; it may be padded out more so that
2750 //         the region from SP to FP meets the minimum stack alignment.
2751 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
2752 //         alignment.  Region 11, pad1, may be dynamically extended so that
2753 //         SP meets the minimum alignment.
2754 
2755 frame
2756 %{
2757   // What direction does stack grow in (assumed to be same for C &amp; Java)
2758   stack_direction(TOWARDS_LOW);
2759 
2760   // These three registers define part of the calling convention
2761   // between compiled code and the interpreter.
2762   inline_cache_reg(RAX);                // Inline Cache Register
2763   interpreter_method_oop_reg(RBX);      // Method Oop Register when
2764                                         // calling interpreter
2765 
2766   // Optional: name the operand used by cisc-spilling to access
2767   // [stack_pointer + offset]
2768   cisc_spilling_operand_name(indOffset32);
2769 
2770   // Number of stack slots consumed by locking an object
2771   sync_stack_slots(2);
2772 
2773   // Compiled code's Frame Pointer
2774   frame_pointer(RSP);
2775 
2776   // Interpreter stores its frame pointer in a register which is
2777   // stored to the stack by I2CAdaptors.
2778   // I2CAdaptors convert from interpreted java to compiled java.
2779   interpreter_frame_pointer(RBP);
2780 
2781   // Stack alignment requirement
2782   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
2783 
2784   // Number of stack slots between incoming argument block and the start of
2785   // a new frame.  The PROLOG must add this many slots to the stack.  The
2786   // EPILOG must remove this many slots.  amd64 needs two slots for
2787   // return address.
2788   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
2789 
2790   // Number of outgoing stack slots killed above the out_preserve_stack_slots
2791   // for calls to C.  Supports the var-args backing area for register parms.
2792   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
2793 
2794   // The after-PROLOG location of the return address.  Location of
2795   // return address specifies a type (REG or STACK) and a number
2796   // representing the register number (i.e. - use a register name) or
2797   // stack slot.
2798   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
2799   // Otherwise, it is above the locks and verification slot and alignment word
2800   return_addr(STACK - 2 +
2801               round_to((Compile::current()-&gt;in_preserve_stack_slots() +
2802                         Compile::current()-&gt;fixed_slots()),
2803                        stack_alignment_in_slots()));
2804 
2805   // Body of function which returns an integer array locating
2806   // arguments either in registers or in stack slots.  Passed an array
2807   // of ideal registers called "sig" and a "length" count.  Stack-slot
2808   // offsets are based on outgoing arguments, i.e. a CALLER setting up
2809   // arguments for a CALLEE.  Incoming stack arguments are
2810   // automatically biased by the preserve_stack_slots field above.
2811 
2812   calling_convention
2813   %{
2814     // No difference between ingoing/outgoing just pass false
2815     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
2816   %}
2817 
2818   c_calling_convention
2819   %{
2820     // This is obviously always outgoing
2821     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
2822   %}
2823 
2824   // Location of compiled Java return values.  Same as C for now.
2825   return_value
2826   %{
2827     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
2828            "only return normal values");
2829 
2830     static const int lo[Op_RegL + 1] = {
2831       0,
2832       0,
2833       RAX_num,  // Op_RegN
2834       RAX_num,  // Op_RegI
2835       RAX_num,  // Op_RegP
2836       XMM0_num, // Op_RegF
2837       XMM0_num, // Op_RegD
2838       RAX_num   // Op_RegL
2839     };
2840     static const int hi[Op_RegL + 1] = {
2841       0,
2842       0,
2843       OptoReg::Bad, // Op_RegN
2844       OptoReg::Bad, // Op_RegI
2845       RAX_H_num,    // Op_RegP
2846       OptoReg::Bad, // Op_RegF
2847       XMM0b_num,    // Op_RegD
2848       RAX_H_num     // Op_RegL
2849     };
2850     // Excluded flags and vector registers.
2851     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, "missing type");
2852     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
2853   %}
2854 %}
2855 
2856 //----------ATTRIBUTES---------------------------------------------------------
2857 //----------Operand Attributes-------------------------------------------------
2858 op_attrib op_cost(0);        // Required cost attribute
2859 
2860 //----------Instruction Attributes---------------------------------------------
2861 ins_attrib ins_cost(100);       // Required cost attribute
2862 ins_attrib ins_size(8);         // Required size attribute (in bits)
2863 ins_attrib ins_short_branch(0); // Required flag: is this instruction
2864                                 // a non-matching short branch variant
2865                                 // of some long branch?
2866 ins_attrib ins_alignment(1);    // Required alignment attribute (must
2867                                 // be a power of 2) specifies the
2868                                 // alignment that some part of the
2869                                 // instruction (not necessarily the
2870                                 // start) requires.  If &gt; 1, a
2871                                 // compute_padding() function must be
2872                                 // provided for the instruction
2873 
2874 //----------OPERANDS-----------------------------------------------------------
2875 // Operand definitions must precede instruction definitions for correct parsing
2876 // in the ADLC because operands constitute user defined types which are used in
2877 // instruction definitions.
2878 
2879 //----------Simple Operands----------------------------------------------------
2880 // Immediate Operands
2881 // Integer Immediate
2882 operand immI()
2883 %{
2884   match(ConI);
2885 
2886   op_cost(10);
2887   format %{ %}
2888   interface(CONST_INTER);
2889 %}
2890 
2891 // Constant for test vs zero
2892 operand immI0()
2893 %{
2894   predicate(n-&gt;get_int() == 0);
2895   match(ConI);
2896 
2897   op_cost(0);
2898   format %{ %}
2899   interface(CONST_INTER);
2900 %}
2901 
2902 // Constant for increment
2903 operand immI1()
2904 %{
2905   predicate(n-&gt;get_int() == 1);
2906   match(ConI);
2907 
2908   op_cost(0);
2909   format %{ %}
2910   interface(CONST_INTER);
2911 %}
2912 
2913 // Constant for decrement
2914 operand immI_M1()
2915 %{
2916   predicate(n-&gt;get_int() == -1);
2917   match(ConI);
2918 
2919   op_cost(0);
2920   format %{ %}
2921   interface(CONST_INTER);
2922 %}
2923 
2924 // Valid scale values for addressing modes
2925 operand immI2()
2926 %{
2927   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
2928   match(ConI);
2929 
2930   format %{ %}
2931   interface(CONST_INTER);
2932 %}
2933 
2934 operand immI8()
2935 %{
2936   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
2937   match(ConI);
2938 
2939   op_cost(5);
2940   format %{ %}
2941   interface(CONST_INTER);
2942 %}
2943 
2944 operand immI16()
2945 %{
2946   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
2947   match(ConI);
2948 
2949   op_cost(10);
2950   format %{ %}
2951   interface(CONST_INTER);
2952 %}
2953 
2954 // Int Immediate non-negative
2955 operand immU31()
2956 %{
2957   predicate(n-&gt;get_int() &gt;= 0);
2958   match(ConI);
2959 
2960   op_cost(0);
2961   format %{ %}
2962   interface(CONST_INTER);
2963 %}
2964 
2965 // Constant for long shifts
2966 operand immI_32()
2967 %{
2968   predicate( n-&gt;get_int() == 32 );
2969   match(ConI);
2970 
2971   op_cost(0);
2972   format %{ %}
2973   interface(CONST_INTER);
2974 %}
2975 
2976 // Constant for long shifts
2977 operand immI_64()
2978 %{
2979   predicate( n-&gt;get_int() == 64 );
2980   match(ConI);
2981 
2982   op_cost(0);
2983   format %{ %}
2984   interface(CONST_INTER);
2985 %}
2986 
2987 // Pointer Immediate
2988 operand immP()
2989 %{
2990   match(ConP);
2991 
2992   op_cost(10);
2993   format %{ %}
2994   interface(CONST_INTER);
2995 %}
2996 
2997 // NULL Pointer Immediate
2998 operand immP0()
2999 %{
3000   predicate(n-&gt;get_ptr() == 0);
3001   match(ConP);
3002 
3003   op_cost(5);
3004   format %{ %}
3005   interface(CONST_INTER);
3006 %}
3007 
3008 // Pointer Immediate
3009 operand immN() %{
3010   match(ConN);
3011 
3012   op_cost(10);
3013   format %{ %}
3014   interface(CONST_INTER);
3015 %}
3016 
3017 operand immNKlass() %{
3018   match(ConNKlass);
3019 
3020   op_cost(10);
3021   format %{ %}
3022   interface(CONST_INTER);
3023 %}
3024 
3025 // NULL Pointer Immediate
3026 operand immN0() %{
3027   predicate(n-&gt;get_narrowcon() == 0);
3028   match(ConN);
3029 
3030   op_cost(5);
3031   format %{ %}
3032   interface(CONST_INTER);
3033 %}
3034 
3035 operand immP31()
3036 %{
3037   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
3038             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
3039   match(ConP);
3040 
3041   op_cost(5);
3042   format %{ %}
3043   interface(CONST_INTER);
3044 %}
3045 
3046 
3047 // Long Immediate
3048 operand immL()
3049 %{
3050   match(ConL);
3051 
3052   op_cost(20);
3053   format %{ %}
3054   interface(CONST_INTER);
3055 %}
3056 
3057 // Long Immediate 8-bit
3058 operand immL8()
3059 %{
3060   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
3061   match(ConL);
3062 
3063   op_cost(5);
3064   format %{ %}
3065   interface(CONST_INTER);
3066 %}
3067 
3068 // Long Immediate 32-bit unsigned
3069 operand immUL32()
3070 %{
3071   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
3072   match(ConL);
3073 
3074   op_cost(10);
3075   format %{ %}
3076   interface(CONST_INTER);
3077 %}
3078 
3079 // Long Immediate 32-bit signed
3080 operand immL32()
3081 %{
3082   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
3083   match(ConL);
3084 
3085   op_cost(15);
3086   format %{ %}
3087   interface(CONST_INTER);
3088 %}
3089 
3090 // Long Immediate zero
3091 operand immL0()
3092 %{
3093   predicate(n-&gt;get_long() == 0L);
3094   match(ConL);
3095 
3096   op_cost(10);
3097   format %{ %}
3098   interface(CONST_INTER);
3099 %}
3100 
3101 // Constant for increment
3102 operand immL1()
3103 %{
3104   predicate(n-&gt;get_long() == 1);
3105   match(ConL);
3106 
3107   format %{ %}
3108   interface(CONST_INTER);
3109 %}
3110 
3111 // Constant for decrement
3112 operand immL_M1()
3113 %{
3114   predicate(n-&gt;get_long() == -1);
3115   match(ConL);
3116 
3117   format %{ %}
3118   interface(CONST_INTER);
3119 %}
3120 
3121 // Long Immediate: the value 10
3122 operand immL10()
3123 %{
3124   predicate(n-&gt;get_long() == 10);
3125   match(ConL);
3126 
3127   format %{ %}
3128   interface(CONST_INTER);
3129 %}
3130 
3131 // Long immediate from 0 to 127.
3132 // Used for a shorter form of long mul by 10.
3133 operand immL_127()
3134 %{
3135   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
3136   match(ConL);
3137 
3138   op_cost(10);
3139   format %{ %}
3140   interface(CONST_INTER);
3141 %}
3142 
3143 // Long Immediate: low 32-bit mask
3144 operand immL_32bits()
3145 %{
3146   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
3147   match(ConL);
3148   op_cost(20);
3149 
3150   format %{ %}
3151   interface(CONST_INTER);
3152 %}
3153 
3154 // Float Immediate zero
3155 operand immF0()
3156 %{
3157   predicate(jint_cast(n-&gt;getf()) == 0);
3158   match(ConF);
3159 
3160   op_cost(5);
3161   format %{ %}
3162   interface(CONST_INTER);
3163 %}
3164 
3165 // Float Immediate
3166 operand immF()
3167 %{
3168   match(ConF);
3169 
3170   op_cost(15);
3171   format %{ %}
3172   interface(CONST_INTER);
3173 %}
3174 
3175 // Double Immediate zero
3176 operand immD0()
3177 %{
3178   predicate(jlong_cast(n-&gt;getd()) == 0);
3179   match(ConD);
3180 
3181   op_cost(5);
3182   format %{ %}
3183   interface(CONST_INTER);
3184 %}
3185 
3186 // Double Immediate
3187 operand immD()
3188 %{
3189   match(ConD);
3190 
3191   op_cost(15);
3192   format %{ %}
3193   interface(CONST_INTER);
3194 %}
3195 
3196 // Immediates for special shifts (sign extend)
3197 
3198 // Constants for increment
3199 operand immI_16()
3200 %{
3201   predicate(n-&gt;get_int() == 16);
3202   match(ConI);
3203 
3204   format %{ %}
3205   interface(CONST_INTER);
3206 %}
3207 
3208 operand immI_24()
3209 %{
3210   predicate(n-&gt;get_int() == 24);
3211   match(ConI);
3212 
3213   format %{ %}
3214   interface(CONST_INTER);
3215 %}
3216 
3217 // Constant for byte-wide masking
3218 operand immI_255()
3219 %{
3220   predicate(n-&gt;get_int() == 255);
3221   match(ConI);
3222 
3223   format %{ %}
3224   interface(CONST_INTER);
3225 %}
3226 
3227 // Constant for short-wide masking
3228 operand immI_65535()
3229 %{
3230   predicate(n-&gt;get_int() == 65535);
3231   match(ConI);
3232 
3233   format %{ %}
3234   interface(CONST_INTER);
3235 %}
3236 
3237 // Constant for byte-wide masking
3238 operand immL_255()
3239 %{
3240   predicate(n-&gt;get_long() == 255);
3241   match(ConL);
3242 
3243   format %{ %}
3244   interface(CONST_INTER);
3245 %}
3246 
3247 // Constant for short-wide masking
3248 operand immL_65535()
3249 %{
3250   predicate(n-&gt;get_long() == 65535);
3251   match(ConL);
3252 
3253   format %{ %}
3254   interface(CONST_INTER);
3255 %}
3256 
3257 // Register Operands
3258 // Integer Register
3259 operand rRegI()
3260 %{
3261   constraint(ALLOC_IN_RC(int_reg));
3262   match(RegI);
3263 
3264   match(rax_RegI);
3265   match(rbx_RegI);
3266   match(rcx_RegI);
3267   match(rdx_RegI);
3268   match(rdi_RegI);
3269 
3270   format %{ %}
3271   interface(REG_INTER);
3272 %}
3273 
3274 // Special Registers
3275 operand rax_RegI()
3276 %{
3277   constraint(ALLOC_IN_RC(int_rax_reg));
3278   match(RegI);
3279   match(rRegI);
3280 
3281   format %{ "RAX" %}
3282   interface(REG_INTER);
3283 %}
3284 
3285 // Special Registers
3286 operand rbx_RegI()
3287 %{
3288   constraint(ALLOC_IN_RC(int_rbx_reg));
3289   match(RegI);
3290   match(rRegI);
3291 
3292   format %{ "RBX" %}
3293   interface(REG_INTER);
3294 %}
3295 
3296 operand rcx_RegI()
3297 %{
3298   constraint(ALLOC_IN_RC(int_rcx_reg));
3299   match(RegI);
3300   match(rRegI);
3301 
3302   format %{ "RCX" %}
3303   interface(REG_INTER);
3304 %}
3305 
3306 operand rdx_RegI()
3307 %{
3308   constraint(ALLOC_IN_RC(int_rdx_reg));
3309   match(RegI);
3310   match(rRegI);
3311 
3312   format %{ "RDX" %}
3313   interface(REG_INTER);
3314 %}
3315 
3316 operand rdi_RegI()
3317 %{
3318   constraint(ALLOC_IN_RC(int_rdi_reg));
3319   match(RegI);
3320   match(rRegI);
3321 
3322   format %{ "RDI" %}
3323   interface(REG_INTER);
3324 %}
3325 
3326 operand no_rcx_RegI()
3327 %{
3328   constraint(ALLOC_IN_RC(int_no_rcx_reg));
3329   match(RegI);
3330   match(rax_RegI);
3331   match(rbx_RegI);
3332   match(rdx_RegI);
3333   match(rdi_RegI);
3334 
3335   format %{ %}
3336   interface(REG_INTER);
3337 %}
3338 
3339 operand no_rax_rdx_RegI()
3340 %{
3341   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
3342   match(RegI);
3343   match(rbx_RegI);
3344   match(rcx_RegI);
3345   match(rdi_RegI);
3346 
3347   format %{ %}
3348   interface(REG_INTER);
3349 %}
3350 
3351 // Pointer Register
3352 operand any_RegP()
3353 %{
3354   constraint(ALLOC_IN_RC(any_reg));
3355   match(RegP);
3356   match(rax_RegP);
3357   match(rbx_RegP);
3358   match(rdi_RegP);
3359   match(rsi_RegP);
3360   match(rbp_RegP);
3361   match(r15_RegP);
3362   match(rRegP);
3363 
3364   format %{ %}
3365   interface(REG_INTER);
3366 %}
3367 
3368 operand rRegP()
3369 %{
3370   constraint(ALLOC_IN_RC(ptr_reg));
3371   match(RegP);
3372   match(rax_RegP);
3373   match(rbx_RegP);
3374   match(rdi_RegP);
3375   match(rsi_RegP);
3376   match(rbp_RegP);  // See Q&amp;A below about
3377   match(r15_RegP);  // r15_RegP and rbp_RegP.
3378 
3379   format %{ %}
3380   interface(REG_INTER);
3381 %}
3382 
3383 operand rRegN() %{
3384   constraint(ALLOC_IN_RC(int_reg));
3385   match(RegN);
3386 
3387   format %{ %}
3388   interface(REG_INTER);
3389 %}
3390 
3391 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
3392 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
3393 // It's fine for an instruction input that expects rRegP to match a r15_RegP.
3394 // The output of an instruction is controlled by the allocator, which respects
3395 // register class masks, not match rules.  Unless an instruction mentions
3396 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
3397 // by the allocator as an input.
3398 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
3399 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
3400 // result, RBP is not included in the output of the instruction either.
3401 
3402 operand no_rax_RegP()
3403 %{
3404   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
3405   match(RegP);
3406   match(rbx_RegP);
3407   match(rsi_RegP);
3408   match(rdi_RegP);
3409 
3410   format %{ %}
3411   interface(REG_INTER);
3412 %}
3413 
3414 // This operand is not allowed to use RBP even if
3415 // RBP is not used to hold the frame pointer.
3416 operand no_rbp_RegP()
3417 %{
3418   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
3419   match(RegP);
3420   match(rbx_RegP);
3421   match(rsi_RegP);
3422   match(rdi_RegP);
3423 
3424   format %{ %}
3425   interface(REG_INTER);
3426 %}
3427 
3428 operand no_rax_rbx_RegP()
3429 %{
3430   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
3431   match(RegP);
3432   match(rsi_RegP);
3433   match(rdi_RegP);
3434 
3435   format %{ %}
3436   interface(REG_INTER);
3437 %}
3438 
3439 // Special Registers
3440 // Return a pointer value
3441 operand rax_RegP()
3442 %{
3443   constraint(ALLOC_IN_RC(ptr_rax_reg));
3444   match(RegP);
3445   match(rRegP);
3446 
3447   format %{ %}
3448   interface(REG_INTER);
3449 %}
3450 
3451 // Special Registers
3452 // Return a compressed pointer value
3453 operand rax_RegN()
3454 %{
3455   constraint(ALLOC_IN_RC(int_rax_reg));
3456   match(RegN);
3457   match(rRegN);
3458 
3459   format %{ %}
3460   interface(REG_INTER);
3461 %}
3462 
3463 // Used in AtomicAdd
3464 operand rbx_RegP()
3465 %{
3466   constraint(ALLOC_IN_RC(ptr_rbx_reg));
3467   match(RegP);
3468   match(rRegP);
3469 
3470   format %{ %}
3471   interface(REG_INTER);
3472 %}
3473 
3474 operand rsi_RegP()
3475 %{
3476   constraint(ALLOC_IN_RC(ptr_rsi_reg));
3477   match(RegP);
3478   match(rRegP);
3479 
3480   format %{ %}
3481   interface(REG_INTER);
3482 %}
3483 
3484 // Used in rep stosq
3485 operand rdi_RegP()
3486 %{
3487   constraint(ALLOC_IN_RC(ptr_rdi_reg));
3488   match(RegP);
3489   match(rRegP);
3490 
3491   format %{ %}
3492   interface(REG_INTER);
3493 %}
3494 
3495 operand r15_RegP()
3496 %{
3497   constraint(ALLOC_IN_RC(ptr_r15_reg));
3498   match(RegP);
3499   match(rRegP);
3500 
3501   format %{ %}
3502   interface(REG_INTER);
3503 %}
3504 
3505 operand rRegL()
3506 %{
3507   constraint(ALLOC_IN_RC(long_reg));
3508   match(RegL);
3509   match(rax_RegL);
3510   match(rdx_RegL);
3511 
3512   format %{ %}
3513   interface(REG_INTER);
3514 %}
3515 
3516 // Special Registers
3517 operand no_rax_rdx_RegL()
3518 %{
3519   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3520   match(RegL);
3521   match(rRegL);
3522 
3523   format %{ %}
3524   interface(REG_INTER);
3525 %}
3526 
3527 operand no_rax_RegL()
3528 %{
3529   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3530   match(RegL);
3531   match(rRegL);
3532   match(rdx_RegL);
3533 
3534   format %{ %}
3535   interface(REG_INTER);
3536 %}
3537 
3538 operand no_rcx_RegL()
3539 %{
3540   constraint(ALLOC_IN_RC(long_no_rcx_reg));
3541   match(RegL);
3542   match(rRegL);
3543 
3544   format %{ %}
3545   interface(REG_INTER);
3546 %}
3547 
3548 operand rax_RegL()
3549 %{
3550   constraint(ALLOC_IN_RC(long_rax_reg));
3551   match(RegL);
3552   match(rRegL);
3553 
3554   format %{ "RAX" %}
3555   interface(REG_INTER);
3556 %}
3557 
3558 operand rcx_RegL()
3559 %{
3560   constraint(ALLOC_IN_RC(long_rcx_reg));
3561   match(RegL);
3562   match(rRegL);
3563 
3564   format %{ %}
3565   interface(REG_INTER);
3566 %}
3567 
3568 operand rdx_RegL()
3569 %{
3570   constraint(ALLOC_IN_RC(long_rdx_reg));
3571   match(RegL);
3572   match(rRegL);
3573 
3574   format %{ %}
3575   interface(REG_INTER);
3576 %}
3577 
3578 // Flags register, used as output of compare instructions
3579 operand rFlagsReg()
3580 %{
3581   constraint(ALLOC_IN_RC(int_flags));
3582   match(RegFlags);
3583 
3584   format %{ "RFLAGS" %}
3585   interface(REG_INTER);
3586 %}
3587 
3588 // Flags register, used as output of FLOATING POINT compare instructions
3589 operand rFlagsRegU()
3590 %{
3591   constraint(ALLOC_IN_RC(int_flags));
3592   match(RegFlags);
3593 
3594   format %{ "RFLAGS_U" %}
3595   interface(REG_INTER);
3596 %}
3597 
3598 operand rFlagsRegUCF() %{
3599   constraint(ALLOC_IN_RC(int_flags));
3600   match(RegFlags);
3601   predicate(false);
3602 
3603   format %{ "RFLAGS_U_CF" %}
3604   interface(REG_INTER);
3605 %}
3606 
3607 // Float register operands
3608 operand regF() %{
3609    constraint(ALLOC_IN_RC(float_reg));
3610    match(RegF);
3611 
3612    format %{ %}
3613    interface(REG_INTER);
3614 %}
3615 
3616 // Double register operands
3617 operand regD() %{
3618    constraint(ALLOC_IN_RC(double_reg));
3619    match(RegD);
3620 
3621    format %{ %}
3622    interface(REG_INTER);
3623 %}
3624 
3625 // Vectors
3626 operand vecS() %{
3627   constraint(ALLOC_IN_RC(vectors_reg));
3628   match(VecS);
3629 
3630   format %{ %}
3631   interface(REG_INTER);
3632 %}
3633 
3634 operand vecD() %{
3635   constraint(ALLOC_IN_RC(vectord_reg));
3636   match(VecD);
3637 
3638   format %{ %}
3639   interface(REG_INTER);
3640 %}
3641 
3642 operand vecX() %{
3643   constraint(ALLOC_IN_RC(vectorx_reg));
3644   match(VecX);
3645 
3646   format %{ %}
3647   interface(REG_INTER);
3648 %}
3649 
3650 operand vecY() %{
3651   constraint(ALLOC_IN_RC(vectory_reg));
3652   match(VecY);
3653 
3654   format %{ %}
3655   interface(REG_INTER);
3656 %}
3657 
3658 //----------Memory Operands----------------------------------------------------
3659 // Direct Memory Operand
3660 // operand direct(immP addr)
3661 // %{
3662 //   match(addr);
3663 
3664 //   format %{ "[$addr]" %}
3665 //   interface(MEMORY_INTER) %{
3666 //     base(0xFFFFFFFF);
3667 //     index(0x4);
3668 //     scale(0x0);
3669 //     disp($addr);
3670 //   %}
3671 // %}
3672 
3673 // Indirect Memory Operand
3674 operand indirect(any_RegP reg)
3675 %{
3676   constraint(ALLOC_IN_RC(ptr_reg));
3677   match(reg);
3678 
3679   format %{ "[$reg]" %}
3680   interface(MEMORY_INTER) %{
3681     base($reg);
3682     index(0x4);
3683     scale(0x0);
3684     disp(0x0);
3685   %}
3686 %}
3687 
3688 // Indirect Memory Plus Short Offset Operand
3689 operand indOffset8(any_RegP reg, immL8 off)
3690 %{
3691   constraint(ALLOC_IN_RC(ptr_reg));
3692   match(AddP reg off);
3693 
3694   format %{ "[$reg + $off (8-bit)]" %}
3695   interface(MEMORY_INTER) %{
3696     base($reg);
3697     index(0x4);
3698     scale(0x0);
3699     disp($off);
3700   %}
3701 %}
3702 
3703 // Indirect Memory Plus Long Offset Operand
3704 operand indOffset32(any_RegP reg, immL32 off)
3705 %{
3706   constraint(ALLOC_IN_RC(ptr_reg));
3707   match(AddP reg off);
3708 
3709   format %{ "[$reg + $off (32-bit)]" %}
3710   interface(MEMORY_INTER) %{
3711     base($reg);
3712     index(0x4);
3713     scale(0x0);
3714     disp($off);
3715   %}
3716 %}
3717 
3718 // Indirect Memory Plus Index Register Plus Offset Operand
3719 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
3720 %{
3721   constraint(ALLOC_IN_RC(ptr_reg));
3722   match(AddP (AddP reg lreg) off);
3723 
3724   op_cost(10);
3725   format %{"[$reg + $off + $lreg]" %}
3726   interface(MEMORY_INTER) %{
3727     base($reg);
3728     index($lreg);
3729     scale(0x0);
3730     disp($off);
3731   %}
3732 %}
3733 
3734 // Indirect Memory Plus Index Register Plus Offset Operand
3735 operand indIndex(any_RegP reg, rRegL lreg)
3736 %{
3737   constraint(ALLOC_IN_RC(ptr_reg));
3738   match(AddP reg lreg);
3739 
3740   op_cost(10);
3741   format %{"[$reg + $lreg]" %}
3742   interface(MEMORY_INTER) %{
3743     base($reg);
3744     index($lreg);
3745     scale(0x0);
3746     disp(0x0);
3747   %}
3748 %}
3749 
3750 // Indirect Memory Times Scale Plus Index Register
3751 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
3752 %{
3753   constraint(ALLOC_IN_RC(ptr_reg));
3754   match(AddP reg (LShiftL lreg scale));
3755 
3756   op_cost(10);
3757   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3758   interface(MEMORY_INTER) %{
3759     base($reg);
3760     index($lreg);
3761     scale($scale);
3762     disp(0x0);
3763   %}
3764 %}
3765 
3766 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3767 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
3768 %{
3769   constraint(ALLOC_IN_RC(ptr_reg));
3770   match(AddP (AddP reg (LShiftL lreg scale)) off);
3771 
3772   op_cost(10);
3773   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3774   interface(MEMORY_INTER) %{
3775     base($reg);
3776     index($lreg);
3777     scale($scale);
3778     disp($off);
3779   %}
3780 %}
3781 
3782 // Indirect Memory Plus Positive Index Register Plus Offset Operand
3783 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
3784 %{
3785   constraint(ALLOC_IN_RC(ptr_reg));
3786   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3787   match(AddP (AddP reg (ConvI2L idx)) off);
3788 
3789   op_cost(10);
3790   format %{"[$reg + $off + $idx]" %}
3791   interface(MEMORY_INTER) %{
3792     base($reg);
3793     index($idx);
3794     scale(0x0);
3795     disp($off);
3796   %}
3797 %}
3798 
3799 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3800 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
3801 %{
3802   constraint(ALLOC_IN_RC(ptr_reg));
3803   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3804   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
3805 
3806   op_cost(10);
3807   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3808   interface(MEMORY_INTER) %{
3809     base($reg);
3810     index($idx);
3811     scale($scale);
3812     disp($off);
3813   %}
3814 %}
3815 
3816 // Indirect Narrow Oop Plus Offset Operand
3817 // Note: x86 architecture doesn't support "scale * index + offset" without a base
3818 // we can't free r12 even with Universe::narrow_oop_base() == NULL.
3819 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
3820   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));
3821   constraint(ALLOC_IN_RC(ptr_reg));
3822   match(AddP (DecodeN reg) off);
3823 
3824   op_cost(10);
3825   format %{"[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)" %}
3826   interface(MEMORY_INTER) %{
3827     base(0xc); // R12
3828     index($reg);
3829     scale(0x3);
3830     disp($off);
3831   %}
3832 %}
3833 
3834 // Indirect Memory Operand
3835 operand indirectNarrow(rRegN reg)
3836 %{
3837   predicate(Universe::narrow_oop_shift() == 0);
3838   constraint(ALLOC_IN_RC(ptr_reg));
3839   match(DecodeN reg);
3840 
3841   format %{ "[$reg]" %}
3842   interface(MEMORY_INTER) %{
3843     base($reg);
3844     index(0x4);
3845     scale(0x0);
3846     disp(0x0);
3847   %}
3848 %}
3849 
3850 // Indirect Memory Plus Short Offset Operand
3851 operand indOffset8Narrow(rRegN reg, immL8 off)
3852 %{
3853   predicate(Universe::narrow_oop_shift() == 0);
3854   constraint(ALLOC_IN_RC(ptr_reg));
3855   match(AddP (DecodeN reg) off);
3856 
3857   format %{ "[$reg + $off (8-bit)]" %}
3858   interface(MEMORY_INTER) %{
3859     base($reg);
3860     index(0x4);
3861     scale(0x0);
3862     disp($off);
3863   %}
3864 %}
3865 
3866 // Indirect Memory Plus Long Offset Operand
3867 operand indOffset32Narrow(rRegN reg, immL32 off)
3868 %{
3869   predicate(Universe::narrow_oop_shift() == 0);
3870   constraint(ALLOC_IN_RC(ptr_reg));
3871   match(AddP (DecodeN reg) off);
3872 
3873   format %{ "[$reg + $off (32-bit)]" %}
3874   interface(MEMORY_INTER) %{
3875     base($reg);
3876     index(0x4);
3877     scale(0x0);
3878     disp($off);
3879   %}
3880 %}
3881 
3882 // Indirect Memory Plus Index Register Plus Offset Operand
3883 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
3884 %{
3885   predicate(Universe::narrow_oop_shift() == 0);
3886   constraint(ALLOC_IN_RC(ptr_reg));
3887   match(AddP (AddP (DecodeN reg) lreg) off);
3888 
3889   op_cost(10);
3890   format %{"[$reg + $off + $lreg]" %}
3891   interface(MEMORY_INTER) %{
3892     base($reg);
3893     index($lreg);
3894     scale(0x0);
3895     disp($off);
3896   %}
3897 %}
3898 
3899 // Indirect Memory Plus Index Register Plus Offset Operand
3900 operand indIndexNarrow(rRegN reg, rRegL lreg)
3901 %{
3902   predicate(Universe::narrow_oop_shift() == 0);
3903   constraint(ALLOC_IN_RC(ptr_reg));
3904   match(AddP (DecodeN reg) lreg);
3905 
3906   op_cost(10);
3907   format %{"[$reg + $lreg]" %}
3908   interface(MEMORY_INTER) %{
3909     base($reg);
3910     index($lreg);
3911     scale(0x0);
3912     disp(0x0);
3913   %}
3914 %}
3915 
3916 // Indirect Memory Times Scale Plus Index Register
3917 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
3918 %{
3919   predicate(Universe::narrow_oop_shift() == 0);
3920   constraint(ALLOC_IN_RC(ptr_reg));
3921   match(AddP (DecodeN reg) (LShiftL lreg scale));
3922 
3923   op_cost(10);
3924   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3925   interface(MEMORY_INTER) %{
3926     base($reg);
3927     index($lreg);
3928     scale($scale);
3929     disp(0x0);
3930   %}
3931 %}
3932 
3933 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3934 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
3935 %{
3936   predicate(Universe::narrow_oop_shift() == 0);
3937   constraint(ALLOC_IN_RC(ptr_reg));
3938   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
3939 
3940   op_cost(10);
3941   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3942   interface(MEMORY_INTER) %{
3943     base($reg);
3944     index($lreg);
3945     scale($scale);
3946     disp($off);
3947   %}
3948 %}
3949 
3950 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
3951 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
3952 %{
3953   constraint(ALLOC_IN_RC(ptr_reg));
3954   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3955   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
3956 
3957   op_cost(10);
3958   format %{"[$reg + $off + $idx]" %}
3959   interface(MEMORY_INTER) %{
3960     base($reg);
3961     index($idx);
3962     scale(0x0);
3963     disp($off);
3964   %}
3965 %}
3966 
3967 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3968 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
3969 %{
3970   constraint(ALLOC_IN_RC(ptr_reg));
3971   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3972   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
3973 
3974   op_cost(10);
3975   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3976   interface(MEMORY_INTER) %{
3977     base($reg);
3978     index($idx);
3979     scale($scale);
3980     disp($off);
3981   %}
3982 %}
3983 
3984 //----------Special Memory Operands--------------------------------------------
3985 // Stack Slot Operand - This operand is used for loading and storing temporary
3986 //                      values on the stack where a match requires a value to
3987 //                      flow through memory.
3988 operand stackSlotP(sRegP reg)
3989 %{
3990   constraint(ALLOC_IN_RC(stack_slots));
3991   // No match rule because this operand is only generated in matching
3992 
3993   format %{ "[$reg]" %}
3994   interface(MEMORY_INTER) %{
3995     base(0x4);   // RSP
3996     index(0x4);  // No Index
3997     scale(0x0);  // No Scale
3998     disp($reg);  // Stack Offset
3999   %}
4000 %}
4001 
4002 operand stackSlotI(sRegI reg)
4003 %{
4004   constraint(ALLOC_IN_RC(stack_slots));
4005   // No match rule because this operand is only generated in matching
4006 
4007   format %{ "[$reg]" %}
4008   interface(MEMORY_INTER) %{
4009     base(0x4);   // RSP
4010     index(0x4);  // No Index
4011     scale(0x0);  // No Scale
4012     disp($reg);  // Stack Offset
4013   %}
4014 %}
4015 
4016 operand stackSlotF(sRegF reg)
4017 %{
4018   constraint(ALLOC_IN_RC(stack_slots));
4019   // No match rule because this operand is only generated in matching
4020 
4021   format %{ "[$reg]" %}
4022   interface(MEMORY_INTER) %{
4023     base(0x4);   // RSP
4024     index(0x4);  // No Index
4025     scale(0x0);  // No Scale
4026     disp($reg);  // Stack Offset
4027   %}
4028 %}
4029 
4030 operand stackSlotD(sRegD reg)
4031 %{
4032   constraint(ALLOC_IN_RC(stack_slots));
4033   // No match rule because this operand is only generated in matching
4034 
4035   format %{ "[$reg]" %}
4036   interface(MEMORY_INTER) %{
4037     base(0x4);   // RSP
4038     index(0x4);  // No Index
4039     scale(0x0);  // No Scale
4040     disp($reg);  // Stack Offset
4041   %}
4042 %}
4043 operand stackSlotL(sRegL reg)
4044 %{
4045   constraint(ALLOC_IN_RC(stack_slots));
4046   // No match rule because this operand is only generated in matching
4047 
4048   format %{ "[$reg]" %}
4049   interface(MEMORY_INTER) %{
4050     base(0x4);   // RSP
4051     index(0x4);  // No Index
4052     scale(0x0);  // No Scale
4053     disp($reg);  // Stack Offset
4054   %}
4055 %}
4056 
4057 //----------Conditional Branch Operands----------------------------------------
4058 // Comparison Op  - This is the operation of the comparison, and is limited to
4059 //                  the following set of codes:
4060 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
4061 //
4062 // Other attributes of the comparison, such as unsignedness, are specified
4063 // by the comparison instruction that sets a condition code flags register.
4064 // That result is represented by a flags operand whose subtype is appropriate
4065 // to the unsignedness (etc.) of the comparison.
4066 //
4067 // Later, the instruction which matches both the Comparison Op (a Bool) and
4068 // the flags (produced by the Cmp) specifies the coding of the comparison op
4069 // by matching a specific subtype of Bool operand below, such as cmpOpU.
4070 
4071 // Comparision Code
4072 operand cmpOp()
4073 %{
4074   match(Bool);
4075 
4076   format %{ "" %}
4077   interface(COND_INTER) %{
4078     equal(0x4, "e");
4079     not_equal(0x5, "ne");
4080     less(0xC, "l");
4081     greater_equal(0xD, "ge");
4082     less_equal(0xE, "le");
4083     greater(0xF, "g");
4084     overflow(0x0, "o");
4085     no_overflow(0x1, "no");
4086   %}
4087 %}
4088 
4089 // Comparison Code, unsigned compare.  Used by FP also, with
4090 // C2 (unordered) turned into GT or LT already.  The other bits
4091 // C0 and C3 are turned into Carry &amp; Zero flags.
4092 operand cmpOpU()
4093 %{
4094   match(Bool);
4095 
4096   format %{ "" %}
4097   interface(COND_INTER) %{
4098     equal(0x4, "e");
4099     not_equal(0x5, "ne");
4100     less(0x2, "b");
4101     greater_equal(0x3, "nb");
4102     less_equal(0x6, "be");
4103     greater(0x7, "nbe");
4104     overflow(0x0, "o");
4105     no_overflow(0x1, "no");
4106   %}
4107 %}
4108 
4109 
4110 // Floating comparisons that don't require any fixup for the unordered case
4111 operand cmpOpUCF() %{
4112   match(Bool);
4113   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
4114             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
4115             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
4116             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
4117   format %{ "" %}
4118   interface(COND_INTER) %{
4119     equal(0x4, "e");
4120     not_equal(0x5, "ne");
4121     less(0x2, "b");
4122     greater_equal(0x3, "nb");
4123     less_equal(0x6, "be");
4124     greater(0x7, "nbe");
4125     overflow(0x0, "o");
4126     no_overflow(0x1, "no");
4127   %}
4128 %}
4129 
4130 
4131 // Floating comparisons that can be fixed up with extra conditional jumps
4132 operand cmpOpUCF2() %{
4133   match(Bool);
4134   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
4135             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
4136   format %{ "" %}
4137   interface(COND_INTER) %{
4138     equal(0x4, "e");
4139     not_equal(0x5, "ne");
4140     less(0x2, "b");
4141     greater_equal(0x3, "nb");
4142     less_equal(0x6, "be");
4143     greater(0x7, "nbe");
4144     overflow(0x0, "o");
4145     no_overflow(0x1, "no");
4146   %}
4147 %}
4148 
4149 
4150 //----------OPERAND CLASSES----------------------------------------------------
4151 // Operand Classes are groups of operands that are used as to simplify
4152 // instruction definitions by not requiring the AD writer to specify separate
4153 // instructions for every form of operand when the instruction accepts
4154 // multiple operand types with the same basic encoding and format.  The classic
4155 // case of this is memory operands.
4156 
4157 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
4158                indIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
4159                indCompressedOopOffset,
4160                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
4161                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
4162                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
4163 
4164 //----------PIPELINE-----------------------------------------------------------
4165 // Rules which define the behavior of the target architectures pipeline.
4166 pipeline %{
4167 
4168 //----------ATTRIBUTES---------------------------------------------------------
4169 attributes %{
4170   variable_size_instructions;        // Fixed size instructions
4171   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
4172   instruction_unit_size = 1;         // An instruction is 1 bytes long
4173   instruction_fetch_unit_size = 16;  // The processor fetches one line
4174   instruction_fetch_units = 1;       // of 16 bytes
4175 
4176   // List of nop instructions
4177   nops( MachNop );
4178 %}
4179 
4180 //----------RESOURCES----------------------------------------------------------
4181 // Resources are the functional units available to the machine
4182 
4183 // Generic P2/P3 pipeline
4184 // 3 decoders, only D0 handles big operands; a "bundle" is the limit of
4185 // 3 instructions decoded per cycle.
4186 // 2 load/store ops per cycle, 1 branch, 1 FPU,
4187 // 3 ALU op, only ALU0 handles mul instructions.
4188 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
4189            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
4190            BR, FPU,
4191            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
4192 
4193 //----------PIPELINE DESCRIPTION-----------------------------------------------
4194 // Pipeline Description specifies the stages in the machine's pipeline
4195 
4196 // Generic P2/P3 pipeline
4197 pipe_desc(S0, S1, S2, S3, S4, S5);
4198 
4199 //----------PIPELINE CLASSES---------------------------------------------------
4200 // Pipeline Classes describe the stages in which input and output are
4201 // referenced by the hardware pipeline.
4202 
4203 // Naming convention: ialu or fpu
4204 // Then: _reg
4205 // Then: _reg if there is a 2nd register
4206 // Then: _long if it's a pair of instructions implementing a long
4207 // Then: _fat if it requires the big decoder
4208 //   Or: _mem if it requires the big decoder and a memory unit.
4209 
4210 // Integer ALU reg operation
4211 pipe_class ialu_reg(rRegI dst)
4212 %{
4213     single_instruction;
4214     dst    : S4(write);
4215     dst    : S3(read);
4216     DECODE : S0;        // any decoder
4217     ALU    : S3;        // any alu
4218 %}
4219 
4220 // Long ALU reg operation
4221 pipe_class ialu_reg_long(rRegL dst)
4222 %{
4223     instruction_count(2);
4224     dst    : S4(write);
4225     dst    : S3(read);
4226     DECODE : S0(2);     // any 2 decoders
4227     ALU    : S3(2);     // both alus
4228 %}
4229 
4230 // Integer ALU reg operation using big decoder
4231 pipe_class ialu_reg_fat(rRegI dst)
4232 %{
4233     single_instruction;
4234     dst    : S4(write);
4235     dst    : S3(read);
4236     D0     : S0;        // big decoder only
4237     ALU    : S3;        // any alu
4238 %}
4239 
4240 // Long ALU reg operation using big decoder
4241 pipe_class ialu_reg_long_fat(rRegL dst)
4242 %{
4243     instruction_count(2);
4244     dst    : S4(write);
4245     dst    : S3(read);
4246     D0     : S0(2);     // big decoder only; twice
4247     ALU    : S3(2);     // any 2 alus
4248 %}
4249 
4250 // Integer ALU reg-reg operation
4251 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
4252 %{
4253     single_instruction;
4254     dst    : S4(write);
4255     src    : S3(read);
4256     DECODE : S0;        // any decoder
4257     ALU    : S3;        // any alu
4258 %}
4259 
4260 // Long ALU reg-reg operation
4261 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
4262 %{
4263     instruction_count(2);
4264     dst    : S4(write);
4265     src    : S3(read);
4266     DECODE : S0(2);     // any 2 decoders
4267     ALU    : S3(2);     // both alus
4268 %}
4269 
4270 // Integer ALU reg-reg operation
4271 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
4272 %{
4273     single_instruction;
4274     dst    : S4(write);
4275     src    : S3(read);
4276     D0     : S0;        // big decoder only
4277     ALU    : S3;        // any alu
4278 %}
4279 
4280 // Long ALU reg-reg operation
4281 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
4282 %{
4283     instruction_count(2);
4284     dst    : S4(write);
4285     src    : S3(read);
4286     D0     : S0(2);     // big decoder only; twice
4287     ALU    : S3(2);     // both alus
4288 %}
4289 
4290 // Integer ALU reg-mem operation
4291 pipe_class ialu_reg_mem(rRegI dst, memory mem)
4292 %{
4293     single_instruction;
4294     dst    : S5(write);
4295     mem    : S3(read);
4296     D0     : S0;        // big decoder only
4297     ALU    : S4;        // any alu
4298     MEM    : S3;        // any mem
4299 %}
4300 
4301 // Integer mem operation (prefetch)
4302 pipe_class ialu_mem(memory mem)
4303 %{
4304     single_instruction;
4305     mem    : S3(read);
4306     D0     : S0;        // big decoder only
4307     MEM    : S3;        // any mem
4308 %}
4309 
4310 // Integer Store to Memory
4311 pipe_class ialu_mem_reg(memory mem, rRegI src)
4312 %{
4313     single_instruction;
4314     mem    : S3(read);
4315     src    : S5(read);
4316     D0     : S0;        // big decoder only
4317     ALU    : S4;        // any alu
4318     MEM    : S3;
4319 %}
4320 
4321 // // Long Store to Memory
4322 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
4323 // %{
4324 //     instruction_count(2);
4325 //     mem    : S3(read);
4326 //     src    : S5(read);
4327 //     D0     : S0(2);          // big decoder only; twice
4328 //     ALU    : S4(2);     // any 2 alus
4329 //     MEM    : S3(2);  // Both mems
4330 // %}
4331 
4332 // Integer Store to Memory
4333 pipe_class ialu_mem_imm(memory mem)
4334 %{
4335     single_instruction;
4336     mem    : S3(read);
4337     D0     : S0;        // big decoder only
4338     ALU    : S4;        // any alu
4339     MEM    : S3;
4340 %}
4341 
4342 // Integer ALU0 reg-reg operation
4343 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
4344 %{
4345     single_instruction;
4346     dst    : S4(write);
4347     src    : S3(read);
4348     D0     : S0;        // Big decoder only
4349     ALU0   : S3;        // only alu0
4350 %}
4351 
4352 // Integer ALU0 reg-mem operation
4353 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
4354 %{
4355     single_instruction;
4356     dst    : S5(write);
4357     mem    : S3(read);
4358     D0     : S0;        // big decoder only
4359     ALU0   : S4;        // ALU0 only
4360     MEM    : S3;        // any mem
4361 %}
4362 
4363 // Integer ALU reg-reg operation
4364 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
4365 %{
4366     single_instruction;
4367     cr     : S4(write);
4368     src1   : S3(read);
4369     src2   : S3(read);
4370     DECODE : S0;        // any decoder
4371     ALU    : S3;        // any alu
4372 %}
4373 
4374 // Integer ALU reg-imm operation
4375 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
4376 %{
4377     single_instruction;
4378     cr     : S4(write);
4379     src1   : S3(read);
4380     DECODE : S0;        // any decoder
4381     ALU    : S3;        // any alu
4382 %}
4383 
4384 // Integer ALU reg-mem operation
4385 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
4386 %{
4387     single_instruction;
4388     cr     : S4(write);
4389     src1   : S3(read);
4390     src2   : S3(read);
4391     D0     : S0;        // big decoder only
4392     ALU    : S4;        // any alu
4393     MEM    : S3;
4394 %}
4395 
4396 // Conditional move reg-reg
4397 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
4398 %{
4399     instruction_count(4);
4400     y      : S4(read);
4401     q      : S3(read);
4402     p      : S3(read);
4403     DECODE : S0(4);     // any decoder
4404 %}
4405 
4406 // Conditional move reg-reg
4407 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
4408 %{
4409     single_instruction;
4410     dst    : S4(write);
4411     src    : S3(read);
4412     cr     : S3(read);
4413     DECODE : S0;        // any decoder
4414 %}
4415 
4416 // Conditional move reg-mem
4417 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
4418 %{
4419     single_instruction;
4420     dst    : S4(write);
4421     src    : S3(read);
4422     cr     : S3(read);
4423     DECODE : S0;        // any decoder
4424     MEM    : S3;
4425 %}
4426 
4427 // Conditional move reg-reg long
4428 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
4429 %{
4430     single_instruction;
4431     dst    : S4(write);
4432     src    : S3(read);
4433     cr     : S3(read);
4434     DECODE : S0(2);     // any 2 decoders
4435 %}
4436 
4437 // XXX
4438 // // Conditional move double reg-reg
4439 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
4440 // %{
4441 //     single_instruction;
4442 //     dst    : S4(write);
4443 //     src    : S3(read);
4444 //     cr     : S3(read);
4445 //     DECODE : S0;     // any decoder
4446 // %}
4447 
4448 // Float reg-reg operation
4449 pipe_class fpu_reg(regD dst)
4450 %{
4451     instruction_count(2);
4452     dst    : S3(read);
4453     DECODE : S0(2);     // any 2 decoders
4454     FPU    : S3;
4455 %}
4456 
4457 // Float reg-reg operation
4458 pipe_class fpu_reg_reg(regD dst, regD src)
4459 %{
4460     instruction_count(2);
4461     dst    : S4(write);
4462     src    : S3(read);
4463     DECODE : S0(2);     // any 2 decoders
4464     FPU    : S3;
4465 %}
4466 
4467 // Float reg-reg operation
4468 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
4469 %{
4470     instruction_count(3);
4471     dst    : S4(write);
4472     src1   : S3(read);
4473     src2   : S3(read);
4474     DECODE : S0(3);     // any 3 decoders
4475     FPU    : S3(2);
4476 %}
4477 
4478 // Float reg-reg operation
4479 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
4480 %{
4481     instruction_count(4);
4482     dst    : S4(write);
4483     src1   : S3(read);
4484     src2   : S3(read);
4485     src3   : S3(read);
4486     DECODE : S0(4);     // any 3 decoders
4487     FPU    : S3(2);
4488 %}
4489 
4490 // Float reg-reg operation
4491 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
4492 %{
4493     instruction_count(4);
4494     dst    : S4(write);
4495     src1   : S3(read);
4496     src2   : S3(read);
4497     src3   : S3(read);
4498     DECODE : S1(3);     // any 3 decoders
4499     D0     : S0;        // Big decoder only
4500     FPU    : S3(2);
4501     MEM    : S3;
4502 %}
4503 
4504 // Float reg-mem operation
4505 pipe_class fpu_reg_mem(regD dst, memory mem)
4506 %{
4507     instruction_count(2);
4508     dst    : S5(write);
4509     mem    : S3(read);
4510     D0     : S0;        // big decoder only
4511     DECODE : S1;        // any decoder for FPU POP
4512     FPU    : S4;
4513     MEM    : S3;        // any mem
4514 %}
4515 
4516 // Float reg-mem operation
4517 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
4518 %{
4519     instruction_count(3);
4520     dst    : S5(write);
4521     src1   : S3(read);
4522     mem    : S3(read);
4523     D0     : S0;        // big decoder only
4524     DECODE : S1(2);     // any decoder for FPU POP
4525     FPU    : S4;
4526     MEM    : S3;        // any mem
4527 %}
4528 
4529 // Float mem-reg operation
4530 pipe_class fpu_mem_reg(memory mem, regD src)
4531 %{
4532     instruction_count(2);
4533     src    : S5(read);
4534     mem    : S3(read);
4535     DECODE : S0;        // any decoder for FPU PUSH
4536     D0     : S1;        // big decoder only
4537     FPU    : S4;
4538     MEM    : S3;        // any mem
4539 %}
4540 
4541 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
4542 %{
4543     instruction_count(3);
4544     src1   : S3(read);
4545     src2   : S3(read);
4546     mem    : S3(read);
4547     DECODE : S0(2);     // any decoder for FPU PUSH
4548     D0     : S1;        // big decoder only
4549     FPU    : S4;
4550     MEM    : S3;        // any mem
4551 %}
4552 
4553 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
4554 %{
4555     instruction_count(3);
4556     src1   : S3(read);
4557     src2   : S3(read);
4558     mem    : S4(read);
4559     DECODE : S0;        // any decoder for FPU PUSH
4560     D0     : S0(2);     // big decoder only
4561     FPU    : S4;
4562     MEM    : S3(2);     // any mem
4563 %}
4564 
4565 pipe_class fpu_mem_mem(memory dst, memory src1)
4566 %{
4567     instruction_count(2);
4568     src1   : S3(read);
4569     dst    : S4(read);
4570     D0     : S0(2);     // big decoder only
4571     MEM    : S3(2);     // any mem
4572 %}
4573 
4574 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
4575 %{
4576     instruction_count(3);
4577     src1   : S3(read);
4578     src2   : S3(read);
4579     dst    : S4(read);
4580     D0     : S0(3);     // big decoder only
4581     FPU    : S4;
4582     MEM    : S3(3);     // any mem
4583 %}
4584 
4585 pipe_class fpu_mem_reg_con(memory mem, regD src1)
4586 %{
4587     instruction_count(3);
4588     src1   : S4(read);
4589     mem    : S4(read);
4590     DECODE : S0;        // any decoder for FPU PUSH
4591     D0     : S0(2);     // big decoder only
4592     FPU    : S4;
4593     MEM    : S3(2);     // any mem
4594 %}
4595 
4596 // Float load constant
4597 pipe_class fpu_reg_con(regD dst)
4598 %{
4599     instruction_count(2);
4600     dst    : S5(write);
4601     D0     : S0;        // big decoder only for the load
4602     DECODE : S1;        // any decoder for FPU POP
4603     FPU    : S4;
4604     MEM    : S3;        // any mem
4605 %}
4606 
4607 // Float load constant
4608 pipe_class fpu_reg_reg_con(regD dst, regD src)
4609 %{
4610     instruction_count(3);
4611     dst    : S5(write);
4612     src    : S3(read);
4613     D0     : S0;        // big decoder only for the load
4614     DECODE : S1(2);     // any decoder for FPU POP
4615     FPU    : S4;
4616     MEM    : S3;        // any mem
4617 %}
4618 
4619 // UnConditional branch
4620 pipe_class pipe_jmp(label labl)
4621 %{
4622     single_instruction;
4623     BR   : S3;
4624 %}
4625 
4626 // Conditional branch
4627 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
4628 %{
4629     single_instruction;
4630     cr    : S1(read);
4631     BR    : S3;
4632 %}
4633 
4634 // Allocation idiom
4635 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
4636 %{
4637     instruction_count(1); force_serialization;
4638     fixed_latency(6);
4639     heap_ptr : S3(read);
4640     DECODE   : S0(3);
4641     D0       : S2;
4642     MEM      : S3;
4643     ALU      : S3(2);
4644     dst      : S5(write);
4645     BR       : S5;
4646 %}
4647 
4648 // Generic big/slow expanded idiom
4649 pipe_class pipe_slow()
4650 %{
4651     instruction_count(10); multiple_bundles; force_serialization;
4652     fixed_latency(100);
4653     D0  : S0(2);
4654     MEM : S3(2);
4655 %}
4656 
4657 // The real do-nothing guy
4658 pipe_class empty()
4659 %{
4660     instruction_count(0);
4661 %}
4662 
4663 // Define the class for the Nop node
4664 define
4665 %{
4666    MachNop = empty;
4667 %}
4668 
4669 %}
4670 
4671 //----------INSTRUCTIONS-------------------------------------------------------
4672 //
4673 // match      -- States which machine-independent subtree may be replaced
4674 //               by this instruction.
4675 // ins_cost   -- The estimated cost of this instruction is used by instruction
4676 //               selection to identify a minimum cost tree of machine
4677 //               instructions that matches a tree of machine-independent
4678 //               instructions.
4679 // format     -- A string providing the disassembly for this instruction.
4680 //               The value of an instruction's operand may be inserted
4681 //               by referring to it with a '$' prefix.
4682 // opcode     -- Three instruction opcodes may be provided.  These are referred
4683 //               to within an encode class as $primary, $secondary, and $tertiary
4684 //               rrspectively.  The primary opcode is commonly used to
4685 //               indicate the type of machine instruction, while secondary
4686 //               and tertiary are often used for prefix options or addressing
4687 //               modes.
4688 // ins_encode -- A list of encode classes with parameters. The encode class
4689 //               name must have been defined in an 'enc_class' specification
4690 //               in the encode section of the architecture description.
4691 
4692 
4693 //----------Load/Store/Move Instructions---------------------------------------
4694 //----------Load Instructions--------------------------------------------------
4695 
4696 // Load Byte (8 bit signed)
4697 instruct loadB(rRegI dst, memory mem)
4698 %{
4699   match(Set dst (LoadB mem));
4700 
4701   ins_cost(125);
4702   format %{ "movsbl  $dst, $mem\t# byte" %}
4703 
4704   ins_encode %{
4705     __ movsbl($dst$$Register, $mem$$Address);
4706   %}
4707 
4708   ins_pipe(ialu_reg_mem);
4709 %}
4710 
4711 // Load Byte (8 bit signed) into Long Register
4712 instruct loadB2L(rRegL dst, memory mem)
4713 %{
4714   match(Set dst (ConvI2L (LoadB mem)));
4715 
4716   ins_cost(125);
4717   format %{ "movsbq  $dst, $mem\t# byte -&gt; long" %}
4718 
4719   ins_encode %{
4720     __ movsbq($dst$$Register, $mem$$Address);
4721   %}
4722 
4723   ins_pipe(ialu_reg_mem);
4724 %}
4725 
4726 // Load Unsigned Byte (8 bit UNsigned)
4727 instruct loadUB(rRegI dst, memory mem)
4728 %{
4729   match(Set dst (LoadUB mem));
4730 
4731   ins_cost(125);
4732   format %{ "movzbl  $dst, $mem\t# ubyte" %}
4733 
4734   ins_encode %{
4735     __ movzbl($dst$$Register, $mem$$Address);
4736   %}
4737 
4738   ins_pipe(ialu_reg_mem);
4739 %}
4740 
4741 // Load Unsigned Byte (8 bit UNsigned) into Long Register
4742 instruct loadUB2L(rRegL dst, memory mem)
4743 %{
4744   match(Set dst (ConvI2L (LoadUB mem)));
4745 
4746   ins_cost(125);
4747   format %{ "movzbq  $dst, $mem\t# ubyte -&gt; long" %}
4748 
4749   ins_encode %{
4750     __ movzbq($dst$$Register, $mem$$Address);
4751   %}
4752 
4753   ins_pipe(ialu_reg_mem);
4754 %}
4755 
4756 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
4757 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4758   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
4759   effect(KILL cr);
4760 
4761   format %{ "movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t"
4762             "andl    $dst, right_n_bits($mask, 8)" %}
4763   ins_encode %{
4764     Register Rdst = $dst$$Register;
4765     __ movzbq(Rdst, $mem$$Address);
4766     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
4767   %}
4768   ins_pipe(ialu_reg_mem);
4769 %}
4770 
4771 // Load Short (16 bit signed)
4772 instruct loadS(rRegI dst, memory mem)
4773 %{
4774   match(Set dst (LoadS mem));
4775 
4776   ins_cost(125);
4777   format %{ "movswl $dst, $mem\t# short" %}
4778 
4779   ins_encode %{
4780     __ movswl($dst$$Register, $mem$$Address);
4781   %}
4782 
4783   ins_pipe(ialu_reg_mem);
4784 %}
4785 
4786 // Load Short (16 bit signed) to Byte (8 bit signed)
4787 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4788   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
4789 
4790   ins_cost(125);
4791   format %{ "movsbl $dst, $mem\t# short -&gt; byte" %}
4792   ins_encode %{
4793     __ movsbl($dst$$Register, $mem$$Address);
4794   %}
4795   ins_pipe(ialu_reg_mem);
4796 %}
4797 
4798 // Load Short (16 bit signed) into Long Register
4799 instruct loadS2L(rRegL dst, memory mem)
4800 %{
4801   match(Set dst (ConvI2L (LoadS mem)));
4802 
4803   ins_cost(125);
4804   format %{ "movswq $dst, $mem\t# short -&gt; long" %}
4805 
4806   ins_encode %{
4807     __ movswq($dst$$Register, $mem$$Address);
4808   %}
4809 
4810   ins_pipe(ialu_reg_mem);
4811 %}
4812 
4813 // Load Unsigned Short/Char (16 bit UNsigned)
4814 instruct loadUS(rRegI dst, memory mem)
4815 %{
4816   match(Set dst (LoadUS mem));
4817 
4818   ins_cost(125);
4819   format %{ "movzwl  $dst, $mem\t# ushort/char" %}
4820 
4821   ins_encode %{
4822     __ movzwl($dst$$Register, $mem$$Address);
4823   %}
4824 
4825   ins_pipe(ialu_reg_mem);
4826 %}
4827 
4828 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
4829 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4830   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
4831 
4832   ins_cost(125);
4833   format %{ "movsbl $dst, $mem\t# ushort -&gt; byte" %}
4834   ins_encode %{
4835     __ movsbl($dst$$Register, $mem$$Address);
4836   %}
4837   ins_pipe(ialu_reg_mem);
4838 %}
4839 
4840 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
4841 instruct loadUS2L(rRegL dst, memory mem)
4842 %{
4843   match(Set dst (ConvI2L (LoadUS mem)));
4844 
4845   ins_cost(125);
4846   format %{ "movzwq  $dst, $mem\t# ushort/char -&gt; long" %}
4847 
4848   ins_encode %{
4849     __ movzwq($dst$$Register, $mem$$Address);
4850   %}
4851 
4852   ins_pipe(ialu_reg_mem);
4853 %}
4854 
4855 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
4856 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4857   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4858 
4859   format %{ "movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long" %}
4860   ins_encode %{
4861     __ movzbq($dst$$Register, $mem$$Address);
4862   %}
4863   ins_pipe(ialu_reg_mem);
4864 %}
4865 
4866 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
4867 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4868   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4869   effect(KILL cr);
4870 
4871   format %{ "movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t"
4872             "andl    $dst, right_n_bits($mask, 16)" %}
4873   ins_encode %{
4874     Register Rdst = $dst$$Register;
4875     __ movzwq(Rdst, $mem$$Address);
4876     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
4877   %}
4878   ins_pipe(ialu_reg_mem);
4879 %}
4880 
4881 // Load Integer
4882 instruct loadI(rRegI dst, memory mem)
4883 %{
4884   match(Set dst (LoadI mem));
4885 
4886   ins_cost(125);
4887   format %{ "movl    $dst, $mem\t# int" %}
4888 
4889   ins_encode %{
4890     __ movl($dst$$Register, $mem$$Address);
4891   %}
4892 
4893   ins_pipe(ialu_reg_mem);
4894 %}
4895 
4896 // Load Integer (32 bit signed) to Byte (8 bit signed)
4897 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4898   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
4899 
4900   ins_cost(125);
4901   format %{ "movsbl  $dst, $mem\t# int -&gt; byte" %}
4902   ins_encode %{
4903     __ movsbl($dst$$Register, $mem$$Address);
4904   %}
4905   ins_pipe(ialu_reg_mem);
4906 %}
4907 
4908 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
4909 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
4910   match(Set dst (AndI (LoadI mem) mask));
4911 
4912   ins_cost(125);
4913   format %{ "movzbl  $dst, $mem\t# int -&gt; ubyte" %}
4914   ins_encode %{
4915     __ movzbl($dst$$Register, $mem$$Address);
4916   %}
4917   ins_pipe(ialu_reg_mem);
4918 %}
4919 
4920 // Load Integer (32 bit signed) to Short (16 bit signed)
4921 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
4922   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
4923 
4924   ins_cost(125);
4925   format %{ "movswl  $dst, $mem\t# int -&gt; short" %}
4926   ins_encode %{
4927     __ movswl($dst$$Register, $mem$$Address);
4928   %}
4929   ins_pipe(ialu_reg_mem);
4930 %}
4931 
4932 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
4933 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
4934   match(Set dst (AndI (LoadI mem) mask));
4935 
4936   ins_cost(125);
4937   format %{ "movzwl  $dst, $mem\t# int -&gt; ushort/char" %}
4938   ins_encode %{
4939     __ movzwl($dst$$Register, $mem$$Address);
4940   %}
4941   ins_pipe(ialu_reg_mem);
4942 %}
4943 
4944 // Load Integer into Long Register
4945 instruct loadI2L(rRegL dst, memory mem)
4946 %{
4947   match(Set dst (ConvI2L (LoadI mem)));
4948 
4949   ins_cost(125);
4950   format %{ "movslq  $dst, $mem\t# int -&gt; long" %}
4951 
4952   ins_encode %{
4953     __ movslq($dst$$Register, $mem$$Address);
4954   %}
4955 
4956   ins_pipe(ialu_reg_mem);
4957 %}
4958 
4959 // Load Integer with mask 0xFF into Long Register
4960 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4961   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4962 
4963   format %{ "movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long" %}
4964   ins_encode %{
4965     __ movzbq($dst$$Register, $mem$$Address);
4966   %}
4967   ins_pipe(ialu_reg_mem);
4968 %}
4969 
4970 // Load Integer with mask 0xFFFF into Long Register
4971 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
4972   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4973 
4974   format %{ "movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long" %}
4975   ins_encode %{
4976     __ movzwq($dst$$Register, $mem$$Address);
4977   %}
4978   ins_pipe(ialu_reg_mem);
4979 %}
4980 
4981 // Load Integer with a 31-bit mask into Long Register
4982 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
4983   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4984   effect(KILL cr);
4985 
4986   format %{ "movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t"
4987             "andl    $dst, $mask" %}
4988   ins_encode %{
4989     Register Rdst = $dst$$Register;
4990     __ movl(Rdst, $mem$$Address);
4991     __ andl(Rdst, $mask$$constant);
4992   %}
4993   ins_pipe(ialu_reg_mem);
4994 %}
4995 
4996 // Load Unsigned Integer into Long Register
4997 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
4998 %{
4999   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
5000 
5001   ins_cost(125);
5002   format %{ "movl    $dst, $mem\t# uint -&gt; long" %}
5003 
5004   ins_encode %{
5005     __ movl($dst$$Register, $mem$$Address);
5006   %}
5007 
5008   ins_pipe(ialu_reg_mem);
5009 %}
5010 
5011 // Load Long
5012 instruct loadL(rRegL dst, memory mem)
5013 %{
5014   match(Set dst (LoadL mem));
5015 
5016   ins_cost(125);
5017   format %{ "movq    $dst, $mem\t# long" %}
5018 
5019   ins_encode %{
5020     __ movq($dst$$Register, $mem$$Address);
5021   %}
5022 
5023   ins_pipe(ialu_reg_mem); // XXX
5024 %}
5025 
5026 // Load Range
5027 instruct loadRange(rRegI dst, memory mem)
5028 %{
5029   match(Set dst (LoadRange mem));
5030 
5031   ins_cost(125); // XXX
5032   format %{ "movl    $dst, $mem\t# range" %}
5033   opcode(0x8B);
5034   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
5035   ins_pipe(ialu_reg_mem);
5036 %}
5037 
5038 // Load Pointer
5039 instruct loadP(rRegP dst, memory mem)
5040 %{
5041   match(Set dst (LoadP mem));
5042 
5043   ins_cost(125); // XXX
5044   format %{ "movq    $dst, $mem\t# ptr" %}
5045   opcode(0x8B);
5046   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5047   ins_pipe(ialu_reg_mem); // XXX
5048 %}
5049 
5050 // Load Compressed Pointer
5051 instruct loadN(rRegN dst, memory mem)
5052 %{
5053    match(Set dst (LoadN mem));
5054 
5055    ins_cost(125); // XXX
5056    format %{ "movl    $dst, $mem\t# compressed ptr" %}
5057    ins_encode %{
5058      __ movl($dst$$Register, $mem$$Address);
5059    %}
5060    ins_pipe(ialu_reg_mem); // XXX
5061 %}
5062 
5063 
5064 // Load Klass Pointer
5065 instruct loadKlass(rRegP dst, memory mem)
5066 %{
5067   match(Set dst (LoadKlass mem));
5068 
5069   ins_cost(125); // XXX
5070   format %{ "movq    $dst, $mem\t# class" %}
5071   opcode(0x8B);
5072   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5073   ins_pipe(ialu_reg_mem); // XXX
5074 %}
5075 
5076 // Load narrow Klass Pointer
5077 instruct loadNKlass(rRegN dst, memory mem)
5078 %{
5079   match(Set dst (LoadNKlass mem));
5080 
5081   ins_cost(125); // XXX
5082   format %{ "movl    $dst, $mem\t# compressed klass ptr" %}
5083   ins_encode %{
5084     __ movl($dst$$Register, $mem$$Address);
5085   %}
5086   ins_pipe(ialu_reg_mem); // XXX
5087 %}
5088 
5089 // Load Float
5090 instruct loadF(regF dst, memory mem)
5091 %{
5092   match(Set dst (LoadF mem));
5093 
5094   ins_cost(145); // XXX
5095   format %{ "movss   $dst, $mem\t# float" %}
5096   ins_encode %{
5097     __ movflt($dst$$XMMRegister, $mem$$Address);
5098   %}
5099   ins_pipe(pipe_slow); // XXX
5100 %}
5101 
5102 // Load Double
5103 instruct loadD_partial(regD dst, memory mem)
5104 %{
5105   predicate(!UseXmmLoadAndClearUpper);
5106   match(Set dst (LoadD mem));
5107 
5108   ins_cost(145); // XXX
5109   format %{ "movlpd  $dst, $mem\t# double" %}
5110   ins_encode %{
5111     __ movdbl($dst$$XMMRegister, $mem$$Address);
5112   %}
5113   ins_pipe(pipe_slow); // XXX
5114 %}
5115 
5116 instruct loadD(regD dst, memory mem)
5117 %{
5118   predicate(UseXmmLoadAndClearUpper);
5119   match(Set dst (LoadD mem));
5120 
5121   ins_cost(145); // XXX
5122   format %{ "movsd   $dst, $mem\t# double" %}
5123   ins_encode %{
5124     __ movdbl($dst$$XMMRegister, $mem$$Address);
5125   %}
5126   ins_pipe(pipe_slow); // XXX
5127 %}
5128 
5129 // Load Effective Address
5130 instruct leaP8(rRegP dst, indOffset8 mem)
5131 %{
5132   match(Set dst mem);
5133 
5134   ins_cost(110); // XXX
5135   format %{ "leaq    $dst, $mem\t# ptr 8" %}
5136   opcode(0x8D);
5137   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5138   ins_pipe(ialu_reg_reg_fat);
5139 %}
5140 
5141 instruct leaP32(rRegP dst, indOffset32 mem)
5142 %{
5143   match(Set dst mem);
5144 
5145   ins_cost(110);
5146   format %{ "leaq    $dst, $mem\t# ptr 32" %}
5147   opcode(0x8D);
5148   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5149   ins_pipe(ialu_reg_reg_fat);
5150 %}
5151 
5152 // instruct leaPIdx(rRegP dst, indIndex mem)
5153 // %{
5154 //   match(Set dst mem);
5155 
5156 //   ins_cost(110);
5157 //   format %{ "leaq    $dst, $mem\t# ptr idx" %}
5158 //   opcode(0x8D);
5159 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5160 //   ins_pipe(ialu_reg_reg_fat);
5161 // %}
5162 
5163 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
5164 %{
5165   match(Set dst mem);
5166 
5167   ins_cost(110);
5168   format %{ "leaq    $dst, $mem\t# ptr idxoff" %}
5169   opcode(0x8D);
5170   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5171   ins_pipe(ialu_reg_reg_fat);
5172 %}
5173 
5174 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
5175 %{
5176   match(Set dst mem);
5177 
5178   ins_cost(110);
5179   format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
5180   opcode(0x8D);
5181   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5182   ins_pipe(ialu_reg_reg_fat);
5183 %}
5184 
5185 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
5186 %{
5187   match(Set dst mem);
5188 
5189   ins_cost(110);
5190   format %{ "leaq    $dst, $mem\t# ptr idxscaleoff" %}
5191   opcode(0x8D);
5192   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5193   ins_pipe(ialu_reg_reg_fat);
5194 %}
5195 
5196 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
5197 %{
5198   match(Set dst mem);
5199 
5200   ins_cost(110);
5201   format %{ "leaq    $dst, $mem\t# ptr posidxoff" %}
5202   opcode(0x8D);
5203   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5204   ins_pipe(ialu_reg_reg_fat);
5205 %}
5206 
5207 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
5208 %{
5209   match(Set dst mem);
5210 
5211   ins_cost(110);
5212   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoff" %}
5213   opcode(0x8D);
5214   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5215   ins_pipe(ialu_reg_reg_fat);
5216 %}
5217 
5218 // Load Effective Address which uses Narrow (32-bits) oop
5219 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
5220 %{
5221   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));
5222   match(Set dst mem);
5223 
5224   ins_cost(110);
5225   format %{ "leaq    $dst, $mem\t# ptr compressedoopoff32" %}
5226   opcode(0x8D);
5227   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5228   ins_pipe(ialu_reg_reg_fat);
5229 %}
5230 
5231 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
5232 %{
5233   predicate(Universe::narrow_oop_shift() == 0);
5234   match(Set dst mem);
5235 
5236   ins_cost(110); // XXX
5237   format %{ "leaq    $dst, $mem\t# ptr off8narrow" %}
5238   opcode(0x8D);
5239   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5240   ins_pipe(ialu_reg_reg_fat);
5241 %}
5242 
5243 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
5244 %{
5245   predicate(Universe::narrow_oop_shift() == 0);
5246   match(Set dst mem);
5247 
5248   ins_cost(110);
5249   format %{ "leaq    $dst, $mem\t# ptr off32narrow" %}
5250   opcode(0x8D);
5251   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5252   ins_pipe(ialu_reg_reg_fat);
5253 %}
5254 
5255 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
5256 %{
5257   predicate(Universe::narrow_oop_shift() == 0);
5258   match(Set dst mem);
5259 
5260   ins_cost(110);
5261   format %{ "leaq    $dst, $mem\t# ptr idxoffnarrow" %}
5262   opcode(0x8D);
5263   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5264   ins_pipe(ialu_reg_reg_fat);
5265 %}
5266 
5267 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
5268 %{
5269   predicate(Universe::narrow_oop_shift() == 0);
5270   match(Set dst mem);
5271 
5272   ins_cost(110);
5273   format %{ "leaq    $dst, $mem\t# ptr idxscalenarrow" %}
5274   opcode(0x8D);
5275   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5276   ins_pipe(ialu_reg_reg_fat);
5277 %}
5278 
5279 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
5280 %{
5281   predicate(Universe::narrow_oop_shift() == 0);
5282   match(Set dst mem);
5283 
5284   ins_cost(110);
5285   format %{ "leaq    $dst, $mem\t# ptr idxscaleoffnarrow" %}
5286   opcode(0x8D);
5287   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5288   ins_pipe(ialu_reg_reg_fat);
5289 %}
5290 
5291 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
5292 %{
5293   predicate(Universe::narrow_oop_shift() == 0);
5294   match(Set dst mem);
5295 
5296   ins_cost(110);
5297   format %{ "leaq    $dst, $mem\t# ptr posidxoffnarrow" %}
5298   opcode(0x8D);
5299   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5300   ins_pipe(ialu_reg_reg_fat);
5301 %}
5302 
5303 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
5304 %{
5305   predicate(Universe::narrow_oop_shift() == 0);
5306   match(Set dst mem);
5307 
5308   ins_cost(110);
5309   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoffnarrow" %}
5310   opcode(0x8D);
5311   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5312   ins_pipe(ialu_reg_reg_fat);
5313 %}
5314 
5315 instruct loadConI(rRegI dst, immI src)
5316 %{
5317   match(Set dst src);
5318 
5319   format %{ "movl    $dst, $src\t# int" %}
5320   ins_encode(load_immI(dst, src));
5321   ins_pipe(ialu_reg_fat); // XXX
5322 %}
5323 
5324 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
5325 %{
5326   match(Set dst src);
5327   effect(KILL cr);
5328 
5329   ins_cost(50);
5330   format %{ "xorl    $dst, $dst\t# int" %}
5331   opcode(0x33); /* + rd */
5332   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5333   ins_pipe(ialu_reg);
5334 %}
5335 
5336 instruct loadConL(rRegL dst, immL src)
5337 %{
5338   match(Set dst src);
5339 
5340   ins_cost(150);
5341   format %{ "movq    $dst, $src\t# long" %}
5342   ins_encode(load_immL(dst, src));
5343   ins_pipe(ialu_reg);
5344 %}
5345 
5346 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
5347 %{
5348   match(Set dst src);
5349   effect(KILL cr);
5350 
5351   ins_cost(50);
5352   format %{ "xorl    $dst, $dst\t# long" %}
5353   opcode(0x33); /* + rd */
5354   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5355   ins_pipe(ialu_reg); // XXX
5356 %}
5357 
5358 instruct loadConUL32(rRegL dst, immUL32 src)
5359 %{
5360   match(Set dst src);
5361 
5362   ins_cost(60);
5363   format %{ "movl    $dst, $src\t# long (unsigned 32-bit)" %}
5364   ins_encode(load_immUL32(dst, src));
5365   ins_pipe(ialu_reg);
5366 %}
5367 
5368 instruct loadConL32(rRegL dst, immL32 src)
5369 %{
5370   match(Set dst src);
5371 
5372   ins_cost(70);
5373   format %{ "movq    $dst, $src\t# long (32-bit)" %}
5374   ins_encode(load_immL32(dst, src));
5375   ins_pipe(ialu_reg);
5376 %}
5377 
5378 instruct loadConP(rRegP dst, immP con) %{
5379   match(Set dst con);
5380 
5381   format %{ "movq    $dst, $con\t# ptr" %}
5382   ins_encode(load_immP(dst, con));
5383   ins_pipe(ialu_reg_fat); // XXX
5384 %}
5385 
5386 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
5387 %{
5388   match(Set dst src);
5389   effect(KILL cr);
5390 
5391   ins_cost(50);
5392   format %{ "xorl    $dst, $dst\t# ptr" %}
5393   opcode(0x33); /* + rd */
5394   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5395   ins_pipe(ialu_reg);
5396 %}
5397 
5398 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
5399 %{
5400   match(Set dst src);
5401   effect(KILL cr);
5402 
5403   ins_cost(60);
5404   format %{ "movl    $dst, $src\t# ptr (positive 32-bit)" %}
5405   ins_encode(load_immP31(dst, src));
5406   ins_pipe(ialu_reg);
5407 %}
5408 
5409 instruct loadConF(regF dst, immF con) %{
5410   match(Set dst con);
5411   ins_cost(125);
5412   format %{ "movss   $dst, [$constantaddress]\t# load from constant table: float=$con" %}
5413   ins_encode %{
5414     __ movflt($dst$$XMMRegister, $constantaddress($con));
5415   %}
5416   ins_pipe(pipe_slow);
5417 %}
5418 
5419 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
5420   match(Set dst src);
5421   effect(KILL cr);
5422   format %{ "xorq    $dst, $src\t# compressed NULL ptr" %}
5423   ins_encode %{
5424     __ xorq($dst$$Register, $dst$$Register);
5425   %}
5426   ins_pipe(ialu_reg);
5427 %}
5428 
5429 instruct loadConN(rRegN dst, immN src) %{
5430   match(Set dst src);
5431 
5432   ins_cost(125);
5433   format %{ "movl    $dst, $src\t# compressed ptr" %}
5434   ins_encode %{
5435     address con = (address)$src$$constant;
5436     if (con == NULL) {
5437       ShouldNotReachHere();
5438     } else {
5439       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
5440     }
5441   %}
5442   ins_pipe(ialu_reg_fat); // XXX
5443 %}
5444 
5445 instruct loadConNKlass(rRegN dst, immNKlass src) %{
5446   match(Set dst src);
5447 
5448   ins_cost(125);
5449   format %{ "movl    $dst, $src\t# compressed klass ptr" %}
5450   ins_encode %{
5451     address con = (address)$src$$constant;
5452     if (con == NULL) {
5453       ShouldNotReachHere();
5454     } else {
5455       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
5456     }
5457   %}
5458   ins_pipe(ialu_reg_fat); // XXX
5459 %}
5460 
5461 instruct loadConF0(regF dst, immF0 src)
5462 %{
5463   match(Set dst src);
5464   ins_cost(100);
5465 
5466   format %{ "xorps   $dst, $dst\t# float 0.0" %}
5467   ins_encode %{
5468     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
5469   %}
5470   ins_pipe(pipe_slow);
5471 %}
5472 
5473 // Use the same format since predicate() can not be used here.
5474 instruct loadConD(regD dst, immD con) %{
5475   match(Set dst con);
5476   ins_cost(125);
5477   format %{ "movsd   $dst, [$constantaddress]\t# load from constant table: double=$con" %}
5478   ins_encode %{
5479     __ movdbl($dst$$XMMRegister, $constantaddress($con));
5480   %}
5481   ins_pipe(pipe_slow);
5482 %}
5483 
5484 instruct loadConD0(regD dst, immD0 src)
5485 %{
5486   match(Set dst src);
5487   ins_cost(100);
5488 
5489   format %{ "xorpd   $dst, $dst\t# double 0.0" %}
5490   ins_encode %{
5491     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
5492   %}
5493   ins_pipe(pipe_slow);
5494 %}
5495 
5496 instruct loadSSI(rRegI dst, stackSlotI src)
5497 %{
5498   match(Set dst src);
5499 
5500   ins_cost(125);
5501   format %{ "movl    $dst, $src\t# int stk" %}
5502   opcode(0x8B);
5503   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
5504   ins_pipe(ialu_reg_mem);
5505 %}
5506 
5507 instruct loadSSL(rRegL dst, stackSlotL src)
5508 %{
5509   match(Set dst src);
5510 
5511   ins_cost(125);
5512   format %{ "movq    $dst, $src\t# long stk" %}
5513   opcode(0x8B);
5514   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5515   ins_pipe(ialu_reg_mem);
5516 %}
5517 
5518 instruct loadSSP(rRegP dst, stackSlotP src)
5519 %{
5520   match(Set dst src);
5521 
5522   ins_cost(125);
5523   format %{ "movq    $dst, $src\t# ptr stk" %}
5524   opcode(0x8B);
5525   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5526   ins_pipe(ialu_reg_mem);
5527 %}
5528 
5529 instruct loadSSF(regF dst, stackSlotF src)
5530 %{
5531   match(Set dst src);
5532 
5533   ins_cost(125);
5534   format %{ "movss   $dst, $src\t# float stk" %}
5535   ins_encode %{
5536     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
5537   %}
5538   ins_pipe(pipe_slow); // XXX
5539 %}
5540 
5541 // Use the same format since predicate() can not be used here.
5542 instruct loadSSD(regD dst, stackSlotD src)
5543 %{
5544   match(Set dst src);
5545 
5546   ins_cost(125);
5547   format %{ "movsd   $dst, $src\t# double stk" %}
5548   ins_encode  %{
5549     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
5550   %}
5551   ins_pipe(pipe_slow); // XXX
5552 %}
5553 
5554 // Prefetch instructions for allocation.
5555 // Must be safe to execute with invalid address (cannot fault).
5556 
5557 instruct prefetchAlloc( memory mem ) %{
5558   predicate(AllocatePrefetchInstr==3);
5559   match(PrefetchAllocation mem);
5560   ins_cost(125);
5561 
5562   format %{ "PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified" %}
5563   ins_encode %{
5564     __ prefetchw($mem$$Address);
5565   %}
5566   ins_pipe(ialu_mem);
5567 %}
5568 
5569 instruct prefetchAllocNTA( memory mem ) %{
5570   predicate(AllocatePrefetchInstr==0);
5571   match(PrefetchAllocation mem);
5572   ins_cost(125);
5573 
5574   format %{ "PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write" %}
5575   ins_encode %{
5576     __ prefetchnta($mem$$Address);
5577   %}
5578   ins_pipe(ialu_mem);
5579 %}
5580 
5581 instruct prefetchAllocT0( memory mem ) %{
5582   predicate(AllocatePrefetchInstr==1);
5583   match(PrefetchAllocation mem);
5584   ins_cost(125);
5585 
5586   format %{ "PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write" %}
5587   ins_encode %{
5588     __ prefetcht0($mem$$Address);
5589   %}
5590   ins_pipe(ialu_mem);
5591 %}
5592 
5593 instruct prefetchAllocT2( memory mem ) %{
5594   predicate(AllocatePrefetchInstr==2);
5595   match(PrefetchAllocation mem);
5596   ins_cost(125);
5597 
5598   format %{ "PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write" %}
5599   ins_encode %{
5600     __ prefetcht2($mem$$Address);
5601   %}
5602   ins_pipe(ialu_mem);
5603 %}
5604 
5605 //----------Store Instructions-------------------------------------------------
5606 
5607 // Store Byte
5608 instruct storeB(memory mem, rRegI src)
5609 %{
5610   match(Set mem (StoreB mem src));
5611 
5612   ins_cost(125); // XXX
5613   format %{ "movb    $mem, $src\t# byte" %}
5614   opcode(0x88);
5615   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
5616   ins_pipe(ialu_mem_reg);
5617 %}
5618 
5619 // Store Char/Short
5620 instruct storeC(memory mem, rRegI src)
5621 %{
5622   match(Set mem (StoreC mem src));
5623 
5624   ins_cost(125); // XXX
5625   format %{ "movw    $mem, $src\t# char/short" %}
5626   opcode(0x89);
5627   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5628   ins_pipe(ialu_mem_reg);
5629 %}
5630 
5631 // Store Integer
5632 instruct storeI(memory mem, rRegI src)
5633 %{
5634   match(Set mem (StoreI mem src));
5635 
5636   ins_cost(125); // XXX
5637   format %{ "movl    $mem, $src\t# int" %}
5638   opcode(0x89);
5639   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5640   ins_pipe(ialu_mem_reg);
5641 %}
5642 
5643 // Store Long
5644 instruct storeL(memory mem, rRegL src)
5645 %{
5646   match(Set mem (StoreL mem src));
5647 
5648   ins_cost(125); // XXX
5649   format %{ "movq    $mem, $src\t# long" %}
5650   opcode(0x89);
5651   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5652   ins_pipe(ialu_mem_reg); // XXX
5653 %}
5654 
5655 // Store Pointer
5656 instruct storeP(memory mem, any_RegP src)
5657 %{
5658   match(Set mem (StoreP mem src));
5659 
5660   ins_cost(125); // XXX
5661   format %{ "movq    $mem, $src\t# ptr" %}
5662   opcode(0x89);
5663   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5664   ins_pipe(ialu_mem_reg);
5665 %}
5666 
5667 instruct storeImmP0(memory mem, immP0 zero)
5668 %{
5669   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5670   match(Set mem (StoreP mem zero));
5671 
5672   ins_cost(125); // XXX
5673   format %{ "movq    $mem, R12\t# ptr (R12_heapbase==0)" %}
5674   ins_encode %{
5675     __ movq($mem$$Address, r12);
5676   %}
5677   ins_pipe(ialu_mem_reg);
5678 %}
5679 
5680 // Store NULL Pointer, mark word, or other simple pointer constant.
5681 instruct storeImmP(memory mem, immP31 src)
5682 %{
5683   match(Set mem (StoreP mem src));
5684 
5685   ins_cost(150); // XXX
5686   format %{ "movq    $mem, $src\t# ptr" %}
5687   opcode(0xC7); /* C7 /0 */
5688   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5689   ins_pipe(ialu_mem_imm);
5690 %}
5691 
5692 // Store Compressed Pointer
5693 instruct storeN(memory mem, rRegN src)
5694 %{
5695   match(Set mem (StoreN mem src));
5696 
5697   ins_cost(125); // XXX
5698   format %{ "movl    $mem, $src\t# compressed ptr" %}
5699   ins_encode %{
5700     __ movl($mem$$Address, $src$$Register);
5701   %}
5702   ins_pipe(ialu_mem_reg);
5703 %}
5704 
5705 instruct storeNKlass(memory mem, rRegN src)
5706 %{
5707   match(Set mem (StoreNKlass mem src));
5708 
5709   ins_cost(125); // XXX
5710   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5711   ins_encode %{
5712     __ movl($mem$$Address, $src$$Register);
5713   %}
5714   ins_pipe(ialu_mem_reg);
5715 %}
5716 
5717 instruct storeImmN0(memory mem, immN0 zero)
5718 %{
5719   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);
5720   match(Set mem (StoreN mem zero));
5721 
5722   ins_cost(125); // XXX
5723   format %{ "movl    $mem, R12\t# compressed ptr (R12_heapbase==0)" %}
5724   ins_encode %{
5725     __ movl($mem$$Address, r12);
5726   %}
5727   ins_pipe(ialu_mem_reg);
5728 %}
5729 
5730 instruct storeImmN(memory mem, immN src)
5731 %{
5732   match(Set mem (StoreN mem src));
5733 
5734   ins_cost(150); // XXX
5735   format %{ "movl    $mem, $src\t# compressed ptr" %}
5736   ins_encode %{
5737     address con = (address)$src$$constant;
5738     if (con == NULL) {
5739       __ movl($mem$$Address, (int32_t)0);
5740     } else {
5741       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
5742     }
5743   %}
5744   ins_pipe(ialu_mem_imm);
5745 %}
5746 
5747 instruct storeImmNKlass(memory mem, immNKlass src)
5748 %{
5749   match(Set mem (StoreNKlass mem src));
5750 
5751   ins_cost(150); // XXX
5752   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5753   ins_encode %{
5754     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
5755   %}
5756   ins_pipe(ialu_mem_imm);
5757 %}
5758 
5759 // Store Integer Immediate
5760 instruct storeImmI0(memory mem, immI0 zero)
5761 %{
5762   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5763   match(Set mem (StoreI mem zero));
5764 
5765   ins_cost(125); // XXX
5766   format %{ "movl    $mem, R12\t# int (R12_heapbase==0)" %}
5767   ins_encode %{
5768     __ movl($mem$$Address, r12);
5769   %}
5770   ins_pipe(ialu_mem_reg);
5771 %}
5772 
5773 instruct storeImmI(memory mem, immI src)
5774 %{
5775   match(Set mem (StoreI mem src));
5776 
5777   ins_cost(150);
5778   format %{ "movl    $mem, $src\t# int" %}
5779   opcode(0xC7); /* C7 /0 */
5780   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5781   ins_pipe(ialu_mem_imm);
5782 %}
5783 
5784 // Store Long Immediate
5785 instruct storeImmL0(memory mem, immL0 zero)
5786 %{
5787   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5788   match(Set mem (StoreL mem zero));
5789 
5790   ins_cost(125); // XXX
5791   format %{ "movq    $mem, R12\t# long (R12_heapbase==0)" %}
5792   ins_encode %{
5793     __ movq($mem$$Address, r12);
5794   %}
5795   ins_pipe(ialu_mem_reg);
5796 %}
5797 
5798 instruct storeImmL(memory mem, immL32 src)
5799 %{
5800   match(Set mem (StoreL mem src));
5801 
5802   ins_cost(150);
5803   format %{ "movq    $mem, $src\t# long" %}
5804   opcode(0xC7); /* C7 /0 */
5805   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5806   ins_pipe(ialu_mem_imm);
5807 %}
5808 
5809 // Store Short/Char Immediate
5810 instruct storeImmC0(memory mem, immI0 zero)
5811 %{
5812   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5813   match(Set mem (StoreC mem zero));
5814 
5815   ins_cost(125); // XXX
5816   format %{ "movw    $mem, R12\t# short/char (R12_heapbase==0)" %}
5817   ins_encode %{
5818     __ movw($mem$$Address, r12);
5819   %}
5820   ins_pipe(ialu_mem_reg);
5821 %}
5822 
5823 instruct storeImmI16(memory mem, immI16 src)
5824 %{
5825   predicate(UseStoreImmI16);
5826   match(Set mem (StoreC mem src));
5827 
5828   ins_cost(150);
5829   format %{ "movw    $mem, $src\t# short/char" %}
5830   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
5831   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
5832   ins_pipe(ialu_mem_imm);
5833 %}
5834 
5835 // Store Byte Immediate
5836 instruct storeImmB0(memory mem, immI0 zero)
5837 %{
5838   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5839   match(Set mem (StoreB mem zero));
5840 
5841   ins_cost(125); // XXX
5842   format %{ "movb    $mem, R12\t# short/char (R12_heapbase==0)" %}
5843   ins_encode %{
5844     __ movb($mem$$Address, r12);
5845   %}
5846   ins_pipe(ialu_mem_reg);
5847 %}
5848 
5849 instruct storeImmB(memory mem, immI8 src)
5850 %{
5851   match(Set mem (StoreB mem src));
5852 
5853   ins_cost(150); // XXX
5854   format %{ "movb    $mem, $src\t# byte" %}
5855   opcode(0xC6); /* C6 /0 */
5856   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5857   ins_pipe(ialu_mem_imm);
5858 %}
5859 
5860 // Store CMS card-mark Immediate
5861 instruct storeImmCM0_reg(memory mem, immI0 zero)
5862 %{
5863   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5864   match(Set mem (StoreCM mem zero));
5865 
5866   ins_cost(125); // XXX
5867   format %{ "movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)" %}
5868   ins_encode %{
5869     __ movb($mem$$Address, r12);
5870   %}
5871   ins_pipe(ialu_mem_reg);
5872 %}
5873 
5874 instruct storeImmCM0(memory mem, immI0 src)
5875 %{
5876   match(Set mem (StoreCM mem src));
5877 
5878   ins_cost(150); // XXX
5879   format %{ "movb    $mem, $src\t# CMS card-mark byte 0" %}
5880   opcode(0xC6); /* C6 /0 */
5881   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5882   ins_pipe(ialu_mem_imm);
5883 %}
5884 
5885 // Store Float
5886 instruct storeF(memory mem, regF src)
5887 %{
5888   match(Set mem (StoreF mem src));
5889 
5890   ins_cost(95); // XXX
5891   format %{ "movss   $mem, $src\t# float" %}
5892   ins_encode %{
5893     __ movflt($mem$$Address, $src$$XMMRegister);
5894   %}
5895   ins_pipe(pipe_slow); // XXX
5896 %}
5897 
5898 // Store immediate Float value (it is faster than store from XMM register)
5899 instruct storeF0(memory mem, immF0 zero)
5900 %{
5901   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5902   match(Set mem (StoreF mem zero));
5903 
5904   ins_cost(25); // XXX
5905   format %{ "movl    $mem, R12\t# float 0. (R12_heapbase==0)" %}
5906   ins_encode %{
5907     __ movl($mem$$Address, r12);
5908   %}
5909   ins_pipe(ialu_mem_reg);
5910 %}
5911 
5912 instruct storeF_imm(memory mem, immF src)
5913 %{
5914   match(Set mem (StoreF mem src));
5915 
5916   ins_cost(50);
5917   format %{ "movl    $mem, $src\t# float" %}
5918   opcode(0xC7); /* C7 /0 */
5919   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5920   ins_pipe(ialu_mem_imm);
5921 %}
5922 
5923 // Store Double
5924 instruct storeD(memory mem, regD src)
5925 %{
5926   match(Set mem (StoreD mem src));
5927 
5928   ins_cost(95); // XXX
5929   format %{ "movsd   $mem, $src\t# double" %}
5930   ins_encode %{
5931     __ movdbl($mem$$Address, $src$$XMMRegister);
5932   %}
5933   ins_pipe(pipe_slow); // XXX
5934 %}
5935 
5936 // Store immediate double 0.0 (it is faster than store from XMM register)
5937 instruct storeD0_imm(memory mem, immD0 src)
5938 %{
5939   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
5940   match(Set mem (StoreD mem src));
5941 
5942   ins_cost(50);
5943   format %{ "movq    $mem, $src\t# double 0." %}
5944   opcode(0xC7); /* C7 /0 */
5945   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5946   ins_pipe(ialu_mem_imm);
5947 %}
5948 
5949 instruct storeD0(memory mem, immD0 zero)
5950 %{
5951   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5952   match(Set mem (StoreD mem zero));
5953 
5954   ins_cost(25); // XXX
5955   format %{ "movq    $mem, R12\t# double 0. (R12_heapbase==0)" %}
5956   ins_encode %{
5957     __ movq($mem$$Address, r12);
5958   %}
5959   ins_pipe(ialu_mem_reg);
5960 %}
5961 
5962 instruct storeSSI(stackSlotI dst, rRegI src)
5963 %{
5964   match(Set dst src);
5965 
5966   ins_cost(100);
5967   format %{ "movl    $dst, $src\t# int stk" %}
5968   opcode(0x89);
5969   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
5970   ins_pipe( ialu_mem_reg );
5971 %}
5972 
5973 instruct storeSSL(stackSlotL dst, rRegL src)
5974 %{
5975   match(Set dst src);
5976 
5977   ins_cost(100);
5978   format %{ "movq    $dst, $src\t# long stk" %}
5979   opcode(0x89);
5980   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5981   ins_pipe(ialu_mem_reg);
5982 %}
5983 
5984 instruct storeSSP(stackSlotP dst, rRegP src)
5985 %{
5986   match(Set dst src);
5987 
5988   ins_cost(100);
5989   format %{ "movq    $dst, $src\t# ptr stk" %}
5990   opcode(0x89);
5991   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5992   ins_pipe(ialu_mem_reg);
5993 %}
5994 
5995 instruct storeSSF(stackSlotF dst, regF src)
5996 %{
5997   match(Set dst src);
5998 
5999   ins_cost(95); // XXX
6000   format %{ "movss   $dst, $src\t# float stk" %}
6001   ins_encode %{
6002     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
6003   %}
6004   ins_pipe(pipe_slow); // XXX
6005 %}
6006 
6007 instruct storeSSD(stackSlotD dst, regD src)
6008 %{
6009   match(Set dst src);
6010 
6011   ins_cost(95); // XXX
6012   format %{ "movsd   $dst, $src\t# double stk" %}
6013   ins_encode %{
6014     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
6015   %}
6016   ins_pipe(pipe_slow); // XXX
6017 %}
6018 
6019 //----------BSWAP Instructions-------------------------------------------------
6020 instruct bytes_reverse_int(rRegI dst) %{
6021   match(Set dst (ReverseBytesI dst));
6022 
6023   format %{ "bswapl  $dst" %}
6024   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
6025   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
6026   ins_pipe( ialu_reg );
6027 %}
6028 
6029 instruct bytes_reverse_long(rRegL dst) %{
6030   match(Set dst (ReverseBytesL dst));
6031 
6032   format %{ "bswapq  $dst" %}
6033   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
6034   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
6035   ins_pipe( ialu_reg);
6036 %}
6037 
6038 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
6039   match(Set dst (ReverseBytesUS dst));
6040   effect(KILL cr);
6041 
6042   format %{ "bswapl  $dst\n\t"
6043             "shrl    $dst,16\n\t" %}
6044   ins_encode %{
6045     __ bswapl($dst$$Register);
6046     __ shrl($dst$$Register, 16);
6047   %}
6048   ins_pipe( ialu_reg );
6049 %}
6050 
6051 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
6052   match(Set dst (ReverseBytesS dst));
6053   effect(KILL cr);
6054 
6055   format %{ "bswapl  $dst\n\t"
6056             "sar     $dst,16\n\t" %}
6057   ins_encode %{
6058     __ bswapl($dst$$Register);
6059     __ sarl($dst$$Register, 16);
6060   %}
6061   ins_pipe( ialu_reg );
6062 %}
6063 
6064 //---------- Zeros Count Instructions ------------------------------------------
6065 
6066 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6067   predicate(UseCountLeadingZerosInstruction);
6068   match(Set dst (CountLeadingZerosI src));
6069   effect(KILL cr);
6070 
6071   format %{ "lzcntl  $dst, $src\t# count leading zeros (int)" %}
6072   ins_encode %{
6073     __ lzcntl($dst$$Register, $src$$Register);
6074   %}
6075   ins_pipe(ialu_reg);
6076 %}
6077 
6078 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
6079   predicate(!UseCountLeadingZerosInstruction);
6080   match(Set dst (CountLeadingZerosI src));
6081   effect(KILL cr);
6082 
6083   format %{ "bsrl    $dst, $src\t# count leading zeros (int)\n\t"
6084             "jnz     skip\n\t"
6085             "movl    $dst, -1\n"
6086       "skip:\n\t"
6087             "negl    $dst\n\t"
6088             "addl    $dst, 31" %}
6089   ins_encode %{
6090     Register Rdst = $dst$$Register;
6091     Register Rsrc = $src$$Register;
6092     Label skip;
6093     __ bsrl(Rdst, Rsrc);
6094     __ jccb(Assembler::notZero, skip);
6095     __ movl(Rdst, -1);
6096     __ bind(skip);
6097     __ negl(Rdst);
6098     __ addl(Rdst, BitsPerInt - 1);
6099   %}
6100   ins_pipe(ialu_reg);
6101 %}
6102 
6103 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6104   predicate(UseCountLeadingZerosInstruction);
6105   match(Set dst (CountLeadingZerosL src));
6106   effect(KILL cr);
6107 
6108   format %{ "lzcntq  $dst, $src\t# count leading zeros (long)" %}
6109   ins_encode %{
6110     __ lzcntq($dst$$Register, $src$$Register);
6111   %}
6112   ins_pipe(ialu_reg);
6113 %}
6114 
6115 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
6116   predicate(!UseCountLeadingZerosInstruction);
6117   match(Set dst (CountLeadingZerosL src));
6118   effect(KILL cr);
6119 
6120   format %{ "bsrq    $dst, $src\t# count leading zeros (long)\n\t"
6121             "jnz     skip\n\t"
6122             "movl    $dst, -1\n"
6123       "skip:\n\t"
6124             "negl    $dst\n\t"
6125             "addl    $dst, 63" %}
6126   ins_encode %{
6127     Register Rdst = $dst$$Register;
6128     Register Rsrc = $src$$Register;
6129     Label skip;
6130     __ bsrq(Rdst, Rsrc);
6131     __ jccb(Assembler::notZero, skip);
6132     __ movl(Rdst, -1);
6133     __ bind(skip);
6134     __ negl(Rdst);
6135     __ addl(Rdst, BitsPerLong - 1);
6136   %}
6137   ins_pipe(ialu_reg);
6138 %}
6139 
6140 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6141   predicate(UseCountTrailingZerosInstruction);
6142   match(Set dst (CountTrailingZerosI src));
6143   effect(KILL cr);
6144 
6145   format %{ "tzcntl    $dst, $src\t# count trailing zeros (int)" %}
6146   ins_encode %{
6147     __ tzcntl($dst$$Register, $src$$Register);
6148   %}
6149   ins_pipe(ialu_reg);
6150 %}
6151 
6152 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
6153   predicate(!UseCountTrailingZerosInstruction);
6154   match(Set dst (CountTrailingZerosI src));
6155   effect(KILL cr);
6156 
6157   format %{ "bsfl    $dst, $src\t# count trailing zeros (int)\n\t"
6158             "jnz     done\n\t"
6159             "movl    $dst, 32\n"
6160       "done:" %}
6161   ins_encode %{
6162     Register Rdst = $dst$$Register;
6163     Label done;
6164     __ bsfl(Rdst, $src$$Register);
6165     __ jccb(Assembler::notZero, done);
6166     __ movl(Rdst, BitsPerInt);
6167     __ bind(done);
6168   %}
6169   ins_pipe(ialu_reg);
6170 %}
6171 
6172 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6173   predicate(UseCountTrailingZerosInstruction);
6174   match(Set dst (CountTrailingZerosL src));
6175   effect(KILL cr);
6176 
6177   format %{ "tzcntq    $dst, $src\t# count trailing zeros (long)" %}
6178   ins_encode %{
6179     __ tzcntq($dst$$Register, $src$$Register);
6180   %}
6181   ins_pipe(ialu_reg);
6182 %}
6183 
6184 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
6185   predicate(!UseCountTrailingZerosInstruction);
6186   match(Set dst (CountTrailingZerosL src));
6187   effect(KILL cr);
6188 
6189   format %{ "bsfq    $dst, $src\t# count trailing zeros (long)\n\t"
6190             "jnz     done\n\t"
6191             "movl    $dst, 64\n"
6192       "done:" %}
6193   ins_encode %{
6194     Register Rdst = $dst$$Register;
6195     Label done;
6196     __ bsfq(Rdst, $src$$Register);
6197     __ jccb(Assembler::notZero, done);
6198     __ movl(Rdst, BitsPerLong);
6199     __ bind(done);
6200   %}
6201   ins_pipe(ialu_reg);
6202 %}
6203 
6204 
6205 //---------- Population Count Instructions -------------------------------------
6206 
6207 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
6208   predicate(UsePopCountInstruction);
6209   match(Set dst (PopCountI src));
6210   effect(KILL cr);
6211 
6212   format %{ "popcnt  $dst, $src" %}
6213   ins_encode %{
6214     __ popcntl($dst$$Register, $src$$Register);
6215   %}
6216   ins_pipe(ialu_reg);
6217 %}
6218 
6219 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6220   predicate(UsePopCountInstruction);
6221   match(Set dst (PopCountI (LoadI mem)));
6222   effect(KILL cr);
6223 
6224   format %{ "popcnt  $dst, $mem" %}
6225   ins_encode %{
6226     __ popcntl($dst$$Register, $mem$$Address);
6227   %}
6228   ins_pipe(ialu_reg);
6229 %}
6230 
6231 // Note: Long.bitCount(long) returns an int.
6232 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
6233   predicate(UsePopCountInstruction);
6234   match(Set dst (PopCountL src));
6235   effect(KILL cr);
6236 
6237   format %{ "popcnt  $dst, $src" %}
6238   ins_encode %{
6239     __ popcntq($dst$$Register, $src$$Register);
6240   %}
6241   ins_pipe(ialu_reg);
6242 %}
6243 
6244 // Note: Long.bitCount(long) returns an int.
6245 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6246   predicate(UsePopCountInstruction);
6247   match(Set dst (PopCountL (LoadL mem)));
6248   effect(KILL cr);
6249 
6250   format %{ "popcnt  $dst, $mem" %}
6251   ins_encode %{
6252     __ popcntq($dst$$Register, $mem$$Address);
6253   %}
6254   ins_pipe(ialu_reg);
6255 %}
6256 
6257 
6258 //----------MemBar Instructions-----------------------------------------------
6259 // Memory barrier flavors
6260 
6261 instruct membar_acquire()
6262 %{
6263   match(MemBarAcquire);
6264   match(LoadFence);
6265   ins_cost(0);
6266 
6267   size(0);
6268   format %{ "MEMBAR-acquire ! (empty encoding)" %}
6269   ins_encode();
6270   ins_pipe(empty);
6271 %}
6272 
6273 instruct membar_acquire_lock()
6274 %{
6275   match(MemBarAcquireLock);
6276   ins_cost(0);
6277 
6278   size(0);
6279   format %{ "MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)" %}
6280   ins_encode();
6281   ins_pipe(empty);
6282 %}
6283 
6284 instruct membar_release()
6285 %{
6286   match(MemBarRelease);
6287   match(StoreFence);
6288   ins_cost(0);
6289 
6290   size(0);
6291   format %{ "MEMBAR-release ! (empty encoding)" %}
6292   ins_encode();
6293   ins_pipe(empty);
6294 %}
6295 
6296 instruct membar_release_lock()
6297 %{
6298   match(MemBarReleaseLock);
6299   ins_cost(0);
6300 
6301   size(0);
6302   format %{ "MEMBAR-release (a FastUnlock follows so empty encoding)" %}
6303   ins_encode();
6304   ins_pipe(empty);
6305 %}
6306 
<a name="1" id="anc1"></a><span class="new">6307 instruct spinloophint()</span>
<span class="new">6308 %{</span>
<span class="new">6309   match(SpinLoopHint);</span>
<span class="new">6310   ins_cost(200);</span>
<span class="new">6311 </span>
<span class="new">6312   format %{</span>
<span class="new">6313     $$template</span>
<span class="new">6314     if (os::is_MP()) {</span>
<span class="new">6315       $$emit$$"pause\t! membar_spinloophint"</span>
<span class="new">6316     } else {</span>
<span class="new">6317       $$emit$$"MEMBAR-spinloophint ! (empty encoding)"</span>
<span class="new">6318     }</span>
<span class="new">6319   %}</span>
<span class="new">6320   ins_encode %{</span>
<span class="new">6321     __ pause();</span>
<span class="new">6322   %}</span>
<span class="new">6323   ins_pipe(pipe_slow);</span>
<span class="new">6324 %}</span>
<span class="new">6325 </span>
6326 instruct membar_volatile(rFlagsReg cr) %{
6327   match(MemBarVolatile);
6328   effect(KILL cr);
6329   ins_cost(400);
6330 
6331   format %{
6332     $$template
6333     if (os::is_MP()) {
6334       $$emit$$"lock addl [rsp + #0], 0\t! membar_volatile"
6335     } else {
6336       $$emit$$"MEMBAR-volatile ! (empty encoding)"
6337     }
6338   %}
6339   ins_encode %{
6340     __ membar(Assembler::StoreLoad);
6341   %}
6342   ins_pipe(pipe_slow);
6343 %}
6344 
6345 instruct unnecessary_membar_volatile()
6346 %{
6347   match(MemBarVolatile);
6348   predicate(Matcher::post_store_load_barrier(n));
6349   ins_cost(0);
6350 
6351   size(0);
6352   format %{ "MEMBAR-volatile (unnecessary so empty encoding)" %}
6353   ins_encode();
6354   ins_pipe(empty);
6355 %}
6356 
6357 instruct membar_storestore() %{
6358   match(MemBarStoreStore);
6359   ins_cost(0);
6360 
6361   size(0);
6362   format %{ "MEMBAR-storestore (empty encoding)" %}
6363   ins_encode( );
6364   ins_pipe(empty);
6365 %}
6366 
6367 //----------Move Instructions--------------------------------------------------
6368 
6369 instruct castX2P(rRegP dst, rRegL src)
6370 %{
6371   match(Set dst (CastX2P src));
6372 
6373   format %{ "movq    $dst, $src\t# long-&gt;ptr" %}
6374   ins_encode %{
6375     if ($dst$$reg != $src$$reg) {
6376       __ movptr($dst$$Register, $src$$Register);
6377     }
6378   %}
6379   ins_pipe(ialu_reg_reg); // XXX
6380 %}
6381 
6382 instruct castP2X(rRegL dst, rRegP src)
6383 %{
6384   match(Set dst (CastP2X src));
6385 
6386   format %{ "movq    $dst, $src\t# ptr -&gt; long" %}
6387   ins_encode %{
6388     if ($dst$$reg != $src$$reg) {
6389       __ movptr($dst$$Register, $src$$Register);
6390     }
6391   %}
6392   ins_pipe(ialu_reg_reg); // XXX
6393 %}
6394 
6395 // Convert oop into int for vectors alignment masking
6396 instruct convP2I(rRegI dst, rRegP src)
6397 %{
6398   match(Set dst (ConvL2I (CastP2X src)));
6399 
6400   format %{ "movl    $dst, $src\t# ptr -&gt; int" %}
6401   ins_encode %{
6402     __ movl($dst$$Register, $src$$Register);
6403   %}
6404   ins_pipe(ialu_reg_reg); // XXX
6405 %}
6406 
6407 // Convert compressed oop into int for vectors alignment masking
6408 // in case of 32bit oops (heap &lt; 4Gb).
6409 instruct convN2I(rRegI dst, rRegN src)
6410 %{
6411   predicate(Universe::narrow_oop_shift() == 0);
6412   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6413 
6414   format %{ "movl    $dst, $src\t# compressed ptr -&gt; int" %}
6415   ins_encode %{
6416     __ movl($dst$$Register, $src$$Register);
6417   %}
6418   ins_pipe(ialu_reg_reg); // XXX
6419 %}
6420 
6421 // Convert oop pointer into compressed form
6422 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
6423   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
6424   match(Set dst (EncodeP src));
6425   effect(KILL cr);
6426   format %{ "encode_heap_oop $dst,$src" %}
6427   ins_encode %{
6428     Register s = $src$$Register;
6429     Register d = $dst$$Register;
6430     if (s != d) {
6431       __ movq(d, s);
6432     }
6433     __ encode_heap_oop(d);
6434   %}
6435   ins_pipe(ialu_reg_long);
6436 %}
6437 
6438 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6439   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
6440   match(Set dst (EncodeP src));
6441   effect(KILL cr);
6442   format %{ "encode_heap_oop_not_null $dst,$src" %}
6443   ins_encode %{
6444     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
6445   %}
6446   ins_pipe(ialu_reg_long);
6447 %}
6448 
6449 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
6450   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6451             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
6452   match(Set dst (DecodeN src));
6453   effect(KILL cr);
6454   format %{ "decode_heap_oop $dst,$src" %}
6455   ins_encode %{
6456     Register s = $src$$Register;
6457     Register d = $dst$$Register;
6458     if (s != d) {
6459       __ movq(d, s);
6460     }
6461     __ decode_heap_oop(d);
6462   %}
6463   ins_pipe(ialu_reg_long);
6464 %}
6465 
6466 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6467   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
6468             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
6469   match(Set dst (DecodeN src));
6470   effect(KILL cr);
6471   format %{ "decode_heap_oop_not_null $dst,$src" %}
6472   ins_encode %{
6473     Register s = $src$$Register;
6474     Register d = $dst$$Register;
6475     if (s != d) {
6476       __ decode_heap_oop_not_null(d, s);
6477     } else {
6478       __ decode_heap_oop_not_null(d);
6479     }
6480   %}
6481   ins_pipe(ialu_reg_long);
6482 %}
6483 
6484 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6485   match(Set dst (EncodePKlass src));
6486   effect(KILL cr);
6487   format %{ "encode_klass_not_null $dst,$src" %}
6488   ins_encode %{
6489     __ encode_klass_not_null($dst$$Register, $src$$Register);
6490   %}
6491   ins_pipe(ialu_reg_long);
6492 %}
6493 
6494 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6495   match(Set dst (DecodeNKlass src));
6496   effect(KILL cr);
6497   format %{ "decode_klass_not_null $dst,$src" %}
6498   ins_encode %{
6499     Register s = $src$$Register;
6500     Register d = $dst$$Register;
6501     if (s != d) {
6502       __ decode_klass_not_null(d, s);
6503     } else {
6504       __ decode_klass_not_null(d);
6505     }
6506   %}
6507   ins_pipe(ialu_reg_long);
6508 %}
6509 
6510 
6511 //----------Conditional Move---------------------------------------------------
6512 // Jump
6513 // dummy instruction for generating temp registers
6514 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
6515   match(Jump (LShiftL switch_val shift));
6516   ins_cost(350);
6517   predicate(false);
6518   effect(TEMP dest);
6519 
6520   format %{ "leaq    $dest, [$constantaddress]\n\t"
6521             "jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t" %}
6522   ins_encode %{
6523     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6524     // to do that and the compiler is using that register as one it can allocate.
6525     // So we build it all by hand.
6526     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
6527     // ArrayAddress dispatch(table, index);
6528     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
6529     __ lea($dest$$Register, $constantaddress);
6530     __ jmp(dispatch);
6531   %}
6532   ins_pipe(pipe_jmp);
6533 %}
6534 
6535 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
6536   match(Jump (AddL (LShiftL switch_val shift) offset));
6537   ins_cost(350);
6538   effect(TEMP dest);
6539 
6540   format %{ "leaq    $dest, [$constantaddress]\n\t"
6541             "jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t" %}
6542   ins_encode %{
6543     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6544     // to do that and the compiler is using that register as one it can allocate.
6545     // So we build it all by hand.
6546     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6547     // ArrayAddress dispatch(table, index);
6548     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6549     __ lea($dest$$Register, $constantaddress);
6550     __ jmp(dispatch);
6551   %}
6552   ins_pipe(pipe_jmp);
6553 %}
6554 
6555 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
6556   match(Jump switch_val);
6557   ins_cost(350);
6558   effect(TEMP dest);
6559 
6560   format %{ "leaq    $dest, [$constantaddress]\n\t"
6561             "jmp     [$dest + $switch_val]\n\t" %}
6562   ins_encode %{
6563     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6564     // to do that and the compiler is using that register as one it can allocate.
6565     // So we build it all by hand.
6566     // Address index(noreg, switch_reg, Address::times_1);
6567     // ArrayAddress dispatch(table, index);
6568     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
6569     __ lea($dest$$Register, $constantaddress);
6570     __ jmp(dispatch);
6571   %}
6572   ins_pipe(pipe_jmp);
6573 %}
6574 
6575 // Conditional move
6576 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
6577 %{
6578   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6579 
6580   ins_cost(200); // XXX
6581   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6582   opcode(0x0F, 0x40);
6583   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6584   ins_pipe(pipe_cmov_reg);
6585 %}
6586 
6587 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
6588   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6589 
6590   ins_cost(200); // XXX
6591   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6592   opcode(0x0F, 0x40);
6593   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6594   ins_pipe(pipe_cmov_reg);
6595 %}
6596 
6597 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
6598   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6599   ins_cost(200);
6600   expand %{
6601     cmovI_regU(cop, cr, dst, src);
6602   %}
6603 %}
6604 
6605 // Conditional move
6606 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
6607   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6608 
6609   ins_cost(250); // XXX
6610   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6611   opcode(0x0F, 0x40);
6612   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6613   ins_pipe(pipe_cmov_mem);
6614 %}
6615 
6616 // Conditional move
6617 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
6618 %{
6619   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6620 
6621   ins_cost(250); // XXX
6622   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6623   opcode(0x0F, 0x40);
6624   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6625   ins_pipe(pipe_cmov_mem);
6626 %}
6627 
6628 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
6629   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6630   ins_cost(250);
6631   expand %{
6632     cmovI_memU(cop, cr, dst, src);
6633   %}
6634 %}
6635 
6636 // Conditional move
6637 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
6638 %{
6639   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6640 
6641   ins_cost(200); // XXX
6642   format %{ "cmovl$cop $dst, $src\t# signed, compressed ptr" %}
6643   opcode(0x0F, 0x40);
6644   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6645   ins_pipe(pipe_cmov_reg);
6646 %}
6647 
6648 // Conditional move
6649 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
6650 %{
6651   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6652 
6653   ins_cost(200); // XXX
6654   format %{ "cmovl$cop $dst, $src\t# unsigned, compressed ptr" %}
6655   opcode(0x0F, 0x40);
6656   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6657   ins_pipe(pipe_cmov_reg);
6658 %}
6659 
6660 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
6661   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6662   ins_cost(200);
6663   expand %{
6664     cmovN_regU(cop, cr, dst, src);
6665   %}
6666 %}
6667 
6668 // Conditional move
6669 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
6670 %{
6671   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6672 
6673   ins_cost(200); // XXX
6674   format %{ "cmovq$cop $dst, $src\t# signed, ptr" %}
6675   opcode(0x0F, 0x40);
6676   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6677   ins_pipe(pipe_cmov_reg);  // XXX
6678 %}
6679 
6680 // Conditional move
6681 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
6682 %{
6683   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6684 
6685   ins_cost(200); // XXX
6686   format %{ "cmovq$cop $dst, $src\t# unsigned, ptr" %}
6687   opcode(0x0F, 0x40);
6688   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6689   ins_pipe(pipe_cmov_reg); // XXX
6690 %}
6691 
6692 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
6693   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6694   ins_cost(200);
6695   expand %{
6696     cmovP_regU(cop, cr, dst, src);
6697   %}
6698 %}
6699 
6700 // DISABLED: Requires the ADLC to emit a bottom_type call that
6701 // correctly meets the two pointer arguments; one is an incoming
6702 // register but the other is a memory operand.  ALSO appears to
6703 // be buggy with implicit null checks.
6704 //
6705 //// Conditional move
6706 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
6707 //%{
6708 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6709 //  ins_cost(250);
6710 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6711 //  opcode(0x0F,0x40);
6712 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6713 //  ins_pipe( pipe_cmov_mem );
6714 //%}
6715 //
6716 //// Conditional move
6717 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
6718 //%{
6719 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6720 //  ins_cost(250);
6721 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6722 //  opcode(0x0F,0x40);
6723 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6724 //  ins_pipe( pipe_cmov_mem );
6725 //%}
6726 
6727 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
6728 %{
6729   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6730 
6731   ins_cost(200); // XXX
6732   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6733   opcode(0x0F, 0x40);
6734   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6735   ins_pipe(pipe_cmov_reg);  // XXX
6736 %}
6737 
6738 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
6739 %{
6740   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6741 
6742   ins_cost(200); // XXX
6743   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6744   opcode(0x0F, 0x40);
6745   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6746   ins_pipe(pipe_cmov_mem);  // XXX
6747 %}
6748 
6749 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
6750 %{
6751   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6752 
6753   ins_cost(200); // XXX
6754   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6755   opcode(0x0F, 0x40);
6756   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6757   ins_pipe(pipe_cmov_reg); // XXX
6758 %}
6759 
6760 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
6761   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6762   ins_cost(200);
6763   expand %{
6764     cmovL_regU(cop, cr, dst, src);
6765   %}
6766 %}
6767 
6768 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
6769 %{
6770   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6771 
6772   ins_cost(200); // XXX
6773   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6774   opcode(0x0F, 0x40);
6775   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6776   ins_pipe(pipe_cmov_mem); // XXX
6777 %}
6778 
6779 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
6780   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6781   ins_cost(200);
6782   expand %{
6783     cmovL_memU(cop, cr, dst, src);
6784   %}
6785 %}
6786 
6787 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
6788 %{
6789   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6790 
6791   ins_cost(200); // XXX
6792   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6793             "movss     $dst, $src\n"
6794     "skip:" %}
6795   ins_encode %{
6796     Label Lskip;
6797     // Invert sense of branch from sense of CMOV
6798     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6799     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6800     __ bind(Lskip);
6801   %}
6802   ins_pipe(pipe_slow);
6803 %}
6804 
6805 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
6806 // %{
6807 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
6808 
6809 //   ins_cost(200); // XXX
6810 //   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6811 //             "movss     $dst, $src\n"
6812 //     "skip:" %}
6813 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
6814 //   ins_pipe(pipe_slow);
6815 // %}
6816 
6817 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
6818 %{
6819   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6820 
6821   ins_cost(200); // XXX
6822   format %{ "jn$cop    skip\t# unsigned cmove float\n\t"
6823             "movss     $dst, $src\n"
6824     "skip:" %}
6825   ins_encode %{
6826     Label Lskip;
6827     // Invert sense of branch from sense of CMOV
6828     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6829     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6830     __ bind(Lskip);
6831   %}
6832   ins_pipe(pipe_slow);
6833 %}
6834 
6835 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
6836   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6837   ins_cost(200);
6838   expand %{
6839     cmovF_regU(cop, cr, dst, src);
6840   %}
6841 %}
6842 
6843 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
6844 %{
6845   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6846 
6847   ins_cost(200); // XXX
6848   format %{ "jn$cop    skip\t# signed cmove double\n\t"
6849             "movsd     $dst, $src\n"
6850     "skip:" %}
6851   ins_encode %{
6852     Label Lskip;
6853     // Invert sense of branch from sense of CMOV
6854     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6855     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6856     __ bind(Lskip);
6857   %}
6858   ins_pipe(pipe_slow);
6859 %}
6860 
6861 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
6862 %{
6863   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6864 
6865   ins_cost(200); // XXX
6866   format %{ "jn$cop    skip\t# unsigned cmove double\n\t"
6867             "movsd     $dst, $src\n"
6868     "skip:" %}
6869   ins_encode %{
6870     Label Lskip;
6871     // Invert sense of branch from sense of CMOV
6872     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6873     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6874     __ bind(Lskip);
6875   %}
6876   ins_pipe(pipe_slow);
6877 %}
6878 
6879 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
6880   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6881   ins_cost(200);
6882   expand %{
6883     cmovD_regU(cop, cr, dst, src);
6884   %}
6885 %}
6886 
6887 //----------Arithmetic Instructions--------------------------------------------
6888 //----------Addition Instructions----------------------------------------------
6889 
6890 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
6891 %{
6892   match(Set dst (AddI dst src));
6893   effect(KILL cr);
6894 
6895   format %{ "addl    $dst, $src\t# int" %}
6896   opcode(0x03);
6897   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
6898   ins_pipe(ialu_reg_reg);
6899 %}
6900 
6901 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
6902 %{
6903   match(Set dst (AddI dst src));
6904   effect(KILL cr);
6905 
6906   format %{ "addl    $dst, $src\t# int" %}
6907   opcode(0x81, 0x00); /* /0 id */
6908   ins_encode(OpcSErm(dst, src), Con8or32(src));
6909   ins_pipe( ialu_reg );
6910 %}
6911 
6912 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
6913 %{
6914   match(Set dst (AddI dst (LoadI src)));
6915   effect(KILL cr);
6916 
6917   ins_cost(125); // XXX
6918   format %{ "addl    $dst, $src\t# int" %}
6919   opcode(0x03);
6920   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
6921   ins_pipe(ialu_reg_mem);
6922 %}
6923 
6924 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
6925 %{
6926   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6927   effect(KILL cr);
6928 
6929   ins_cost(150); // XXX
6930   format %{ "addl    $dst, $src\t# int" %}
6931   opcode(0x01); /* Opcode 01 /r */
6932   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
6933   ins_pipe(ialu_mem_reg);
6934 %}
6935 
6936 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
6937 %{
6938   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6939   effect(KILL cr);
6940 
6941   ins_cost(125); // XXX
6942   format %{ "addl    $dst, $src\t# int" %}
6943   opcode(0x81); /* Opcode 81 /0 id */
6944   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
6945   ins_pipe(ialu_mem_imm);
6946 %}
6947 
6948 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
6949 %{
6950   predicate(UseIncDec);
6951   match(Set dst (AddI dst src));
6952   effect(KILL cr);
6953 
6954   format %{ "incl    $dst\t# int" %}
6955   opcode(0xFF, 0x00); // FF /0
6956   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6957   ins_pipe(ialu_reg);
6958 %}
6959 
6960 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
6961 %{
6962   predicate(UseIncDec);
6963   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6964   effect(KILL cr);
6965 
6966   ins_cost(125); // XXX
6967   format %{ "incl    $dst\t# int" %}
6968   opcode(0xFF); /* Opcode FF /0 */
6969   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
6970   ins_pipe(ialu_mem_imm);
6971 %}
6972 
6973 // XXX why does that use AddI
6974 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
6975 %{
6976   predicate(UseIncDec);
6977   match(Set dst (AddI dst src));
6978   effect(KILL cr);
6979 
6980   format %{ "decl    $dst\t# int" %}
6981   opcode(0xFF, 0x01); // FF /1
6982   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6983   ins_pipe(ialu_reg);
6984 %}
6985 
6986 // XXX why does that use AddI
6987 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
6988 %{
6989   predicate(UseIncDec);
6990   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6991   effect(KILL cr);
6992 
6993   ins_cost(125); // XXX
6994   format %{ "decl    $dst\t# int" %}
6995   opcode(0xFF); /* Opcode FF /1 */
6996   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
6997   ins_pipe(ialu_mem_imm);
6998 %}
6999 
7000 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
7001 %{
7002   match(Set dst (AddI src0 src1));
7003 
7004   ins_cost(110);
7005   format %{ "addr32 leal $dst, [$src0 + $src1]\t# int" %}
7006   opcode(0x8D); /* 0x8D /r */
7007   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7008   ins_pipe(ialu_reg_reg);
7009 %}
7010 
7011 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7012 %{
7013   match(Set dst (AddL dst src));
7014   effect(KILL cr);
7015 
7016   format %{ "addq    $dst, $src\t# long" %}
7017   opcode(0x03);
7018   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7019   ins_pipe(ialu_reg_reg);
7020 %}
7021 
7022 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
7023 %{
7024   match(Set dst (AddL dst src));
7025   effect(KILL cr);
7026 
7027   format %{ "addq    $dst, $src\t# long" %}
7028   opcode(0x81, 0x00); /* /0 id */
7029   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7030   ins_pipe( ialu_reg );
7031 %}
7032 
7033 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7034 %{
7035   match(Set dst (AddL dst (LoadL src)));
7036   effect(KILL cr);
7037 
7038   ins_cost(125); // XXX
7039   format %{ "addq    $dst, $src\t# long" %}
7040   opcode(0x03);
7041   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7042   ins_pipe(ialu_reg_mem);
7043 %}
7044 
7045 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7046 %{
7047   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7048   effect(KILL cr);
7049 
7050   ins_cost(150); // XXX
7051   format %{ "addq    $dst, $src\t# long" %}
7052   opcode(0x01); /* Opcode 01 /r */
7053   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7054   ins_pipe(ialu_mem_reg);
7055 %}
7056 
7057 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7058 %{
7059   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7060   effect(KILL cr);
7061 
7062   ins_cost(125); // XXX
7063   format %{ "addq    $dst, $src\t# long" %}
7064   opcode(0x81); /* Opcode 81 /0 id */
7065   ins_encode(REX_mem_wide(dst),
7066              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
7067   ins_pipe(ialu_mem_imm);
7068 %}
7069 
7070 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
7071 %{
7072   predicate(UseIncDec);
7073   match(Set dst (AddL dst src));
7074   effect(KILL cr);
7075 
7076   format %{ "incq    $dst\t# long" %}
7077   opcode(0xFF, 0x00); // FF /0
7078   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7079   ins_pipe(ialu_reg);
7080 %}
7081 
7082 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
7083 %{
7084   predicate(UseIncDec);
7085   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7086   effect(KILL cr);
7087 
7088   ins_cost(125); // XXX
7089   format %{ "incq    $dst\t# long" %}
7090   opcode(0xFF); /* Opcode FF /0 */
7091   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
7092   ins_pipe(ialu_mem_imm);
7093 %}
7094 
7095 // XXX why does that use AddL
7096 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
7097 %{
7098   predicate(UseIncDec);
7099   match(Set dst (AddL dst src));
7100   effect(KILL cr);
7101 
7102   format %{ "decq    $dst\t# long" %}
7103   opcode(0xFF, 0x01); // FF /1
7104   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7105   ins_pipe(ialu_reg);
7106 %}
7107 
7108 // XXX why does that use AddL
7109 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
7110 %{
7111   predicate(UseIncDec);
7112   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7113   effect(KILL cr);
7114 
7115   ins_cost(125); // XXX
7116   format %{ "decq    $dst\t# long" %}
7117   opcode(0xFF); /* Opcode FF /1 */
7118   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
7119   ins_pipe(ialu_mem_imm);
7120 %}
7121 
7122 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
7123 %{
7124   match(Set dst (AddL src0 src1));
7125 
7126   ins_cost(110);
7127   format %{ "leaq    $dst, [$src0 + $src1]\t# long" %}
7128   opcode(0x8D); /* 0x8D /r */
7129   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7130   ins_pipe(ialu_reg_reg);
7131 %}
7132 
7133 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
7134 %{
7135   match(Set dst (AddP dst src));
7136   effect(KILL cr);
7137 
7138   format %{ "addq    $dst, $src\t# ptr" %}
7139   opcode(0x03);
7140   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7141   ins_pipe(ialu_reg_reg);
7142 %}
7143 
7144 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
7145 %{
7146   match(Set dst (AddP dst src));
7147   effect(KILL cr);
7148 
7149   format %{ "addq    $dst, $src\t# ptr" %}
7150   opcode(0x81, 0x00); /* /0 id */
7151   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7152   ins_pipe( ialu_reg );
7153 %}
7154 
7155 // XXX addP mem ops ????
7156 
7157 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
7158 %{
7159   match(Set dst (AddP src0 src1));
7160 
7161   ins_cost(110);
7162   format %{ "leaq    $dst, [$src0 + $src1]\t# ptr" %}
7163   opcode(0x8D); /* 0x8D /r */
7164   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
7165   ins_pipe(ialu_reg_reg);
7166 %}
7167 
7168 instruct checkCastPP(rRegP dst)
7169 %{
7170   match(Set dst (CheckCastPP dst));
7171 
7172   size(0);
7173   format %{ "# checkcastPP of $dst" %}
7174   ins_encode(/* empty encoding */);
7175   ins_pipe(empty);
7176 %}
7177 
7178 instruct castPP(rRegP dst)
7179 %{
7180   match(Set dst (CastPP dst));
7181 
7182   size(0);
7183   format %{ "# castPP of $dst" %}
7184   ins_encode(/* empty encoding */);
7185   ins_pipe(empty);
7186 %}
7187 
7188 instruct castII(rRegI dst)
7189 %{
7190   match(Set dst (CastII dst));
7191 
7192   size(0);
7193   format %{ "# castII of $dst" %}
7194   ins_encode(/* empty encoding */);
7195   ins_cost(0);
7196   ins_pipe(empty);
7197 %}
7198 
7199 // LoadP-locked same as a regular LoadP when used with compare-swap
7200 instruct loadPLocked(rRegP dst, memory mem)
7201 %{
7202   match(Set dst (LoadPLocked mem));
7203 
7204   ins_cost(125); // XXX
7205   format %{ "movq    $dst, $mem\t# ptr locked" %}
7206   opcode(0x8B);
7207   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
7208   ins_pipe(ialu_reg_mem); // XXX
7209 %}
7210 
7211 // Conditional-store of the updated heap-top.
7212 // Used during allocation of the shared heap.
7213 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
7214 
7215 instruct storePConditional(memory heap_top_ptr,
7216                            rax_RegP oldval, rRegP newval,
7217                            rFlagsReg cr)
7218 %{
7219   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
7220 
7221   format %{ "cmpxchgq $heap_top_ptr, $newval\t# (ptr) "
7222             "If rax == $heap_top_ptr then store $newval into $heap_top_ptr" %}
7223   opcode(0x0F, 0xB1);
7224   ins_encode(lock_prefix,
7225              REX_reg_mem_wide(newval, heap_top_ptr),
7226              OpcP, OpcS,
7227              reg_mem(newval, heap_top_ptr));
7228   ins_pipe(pipe_cmpxchg);
7229 %}
7230 
7231 // Conditional-store of an int value.
7232 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7233 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
7234 %{
7235   match(Set cr (StoreIConditional mem (Binary oldval newval)));
7236   effect(KILL oldval);
7237 
7238   format %{ "cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7239   opcode(0x0F, 0xB1);
7240   ins_encode(lock_prefix,
7241              REX_reg_mem(newval, mem),
7242              OpcP, OpcS,
7243              reg_mem(newval, mem));
7244   ins_pipe(pipe_cmpxchg);
7245 %}
7246 
7247 // Conditional-store of a long value.
7248 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7249 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
7250 %{
7251   match(Set cr (StoreLConditional mem (Binary oldval newval)));
7252   effect(KILL oldval);
7253 
7254   format %{ "cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7255   opcode(0x0F, 0xB1);
7256   ins_encode(lock_prefix,
7257              REX_reg_mem_wide(newval, mem),
7258              OpcP, OpcS,
7259              reg_mem(newval, mem));
7260   ins_pipe(pipe_cmpxchg);
7261 %}
7262 
7263 
7264 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
7265 instruct compareAndSwapP(rRegI res,
7266                          memory mem_ptr,
7267                          rax_RegP oldval, rRegP newval,
7268                          rFlagsReg cr)
7269 %{
7270   predicate(VM_Version::supports_cx8());
7271   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
7272   effect(KILL cr, KILL oldval);
7273 
7274   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7275             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7276             "sete    $res\n\t"
7277             "movzbl  $res, $res" %}
7278   opcode(0x0F, 0xB1);
7279   ins_encode(lock_prefix,
7280              REX_reg_mem_wide(newval, mem_ptr),
7281              OpcP, OpcS,
7282              reg_mem(newval, mem_ptr),
7283              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7284              REX_reg_breg(res, res), // movzbl
7285              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7286   ins_pipe( pipe_cmpxchg );
7287 %}
7288 
7289 instruct compareAndSwapL(rRegI res,
7290                          memory mem_ptr,
7291                          rax_RegL oldval, rRegL newval,
7292                          rFlagsReg cr)
7293 %{
7294   predicate(VM_Version::supports_cx8());
7295   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
7296   effect(KILL cr, KILL oldval);
7297 
7298   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7299             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7300             "sete    $res\n\t"
7301             "movzbl  $res, $res" %}
7302   opcode(0x0F, 0xB1);
7303   ins_encode(lock_prefix,
7304              REX_reg_mem_wide(newval, mem_ptr),
7305              OpcP, OpcS,
7306              reg_mem(newval, mem_ptr),
7307              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7308              REX_reg_breg(res, res), // movzbl
7309              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7310   ins_pipe( pipe_cmpxchg );
7311 %}
7312 
7313 instruct compareAndSwapI(rRegI res,
7314                          memory mem_ptr,
7315                          rax_RegI oldval, rRegI newval,
7316                          rFlagsReg cr)
7317 %{
7318   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
7319   effect(KILL cr, KILL oldval);
7320 
7321   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7322             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7323             "sete    $res\n\t"
7324             "movzbl  $res, $res" %}
7325   opcode(0x0F, 0xB1);
7326   ins_encode(lock_prefix,
7327              REX_reg_mem(newval, mem_ptr),
7328              OpcP, OpcS,
7329              reg_mem(newval, mem_ptr),
7330              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7331              REX_reg_breg(res, res), // movzbl
7332              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7333   ins_pipe( pipe_cmpxchg );
7334 %}
7335 
7336 
7337 instruct compareAndSwapN(rRegI res,
7338                           memory mem_ptr,
7339                           rax_RegN oldval, rRegN newval,
7340                           rFlagsReg cr) %{
7341   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
7342   effect(KILL cr, KILL oldval);
7343 
7344   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7345             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7346             "sete    $res\n\t"
7347             "movzbl  $res, $res" %}
7348   opcode(0x0F, 0xB1);
7349   ins_encode(lock_prefix,
7350              REX_reg_mem(newval, mem_ptr),
7351              OpcP, OpcS,
7352              reg_mem(newval, mem_ptr),
7353              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7354              REX_reg_breg(res, res), // movzbl
7355              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7356   ins_pipe( pipe_cmpxchg );
7357 %}
7358 
7359 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
7360   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7361   match(Set dummy (GetAndAddI mem add));
7362   effect(KILL cr);
7363   format %{ "ADDL  [$mem],$add" %}
7364   ins_encode %{
7365     if (os::is_MP()) { __ lock(); }
7366     __ addl($mem$$Address, $add$$constant);
7367   %}
7368   ins_pipe( pipe_cmpxchg );
7369 %}
7370 
7371 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
7372   match(Set newval (GetAndAddI mem newval));
7373   effect(KILL cr);
7374   format %{ "XADDL  [$mem],$newval" %}
7375   ins_encode %{
7376     if (os::is_MP()) { __ lock(); }
7377     __ xaddl($mem$$Address, $newval$$Register);
7378   %}
7379   ins_pipe( pipe_cmpxchg );
7380 %}
7381 
7382 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
7383   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7384   match(Set dummy (GetAndAddL mem add));
7385   effect(KILL cr);
7386   format %{ "ADDQ  [$mem],$add" %}
7387   ins_encode %{
7388     if (os::is_MP()) { __ lock(); }
7389     __ addq($mem$$Address, $add$$constant);
7390   %}
7391   ins_pipe( pipe_cmpxchg );
7392 %}
7393 
7394 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
7395   match(Set newval (GetAndAddL mem newval));
7396   effect(KILL cr);
7397   format %{ "XADDQ  [$mem],$newval" %}
7398   ins_encode %{
7399     if (os::is_MP()) { __ lock(); }
7400     __ xaddq($mem$$Address, $newval$$Register);
7401   %}
7402   ins_pipe( pipe_cmpxchg );
7403 %}
7404 
7405 instruct xchgI( memory mem, rRegI newval) %{
7406   match(Set newval (GetAndSetI mem newval));
7407   format %{ "XCHGL  $newval,[$mem]" %}
7408   ins_encode %{
7409     __ xchgl($newval$$Register, $mem$$Address);
7410   %}
7411   ins_pipe( pipe_cmpxchg );
7412 %}
7413 
7414 instruct xchgL( memory mem, rRegL newval) %{
7415   match(Set newval (GetAndSetL mem newval));
7416   format %{ "XCHGL  $newval,[$mem]" %}
7417   ins_encode %{
7418     __ xchgq($newval$$Register, $mem$$Address);
7419   %}
7420   ins_pipe( pipe_cmpxchg );
7421 %}
7422 
7423 instruct xchgP( memory mem, rRegP newval) %{
7424   match(Set newval (GetAndSetP mem newval));
7425   format %{ "XCHGQ  $newval,[$mem]" %}
7426   ins_encode %{
7427     __ xchgq($newval$$Register, $mem$$Address);
7428   %}
7429   ins_pipe( pipe_cmpxchg );
7430 %}
7431 
7432 instruct xchgN( memory mem, rRegN newval) %{
7433   match(Set newval (GetAndSetN mem newval));
7434   format %{ "XCHGL  $newval,$mem]" %}
7435   ins_encode %{
7436     __ xchgl($newval$$Register, $mem$$Address);
7437   %}
7438   ins_pipe( pipe_cmpxchg );
7439 %}
7440 
7441 //----------Subtraction Instructions-------------------------------------------
7442 
7443 // Integer Subtraction Instructions
7444 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7445 %{
7446   match(Set dst (SubI dst src));
7447   effect(KILL cr);
7448 
7449   format %{ "subl    $dst, $src\t# int" %}
7450   opcode(0x2B);
7451   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
7452   ins_pipe(ialu_reg_reg);
7453 %}
7454 
7455 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
7456 %{
7457   match(Set dst (SubI dst src));
7458   effect(KILL cr);
7459 
7460   format %{ "subl    $dst, $src\t# int" %}
7461   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7462   ins_encode(OpcSErm(dst, src), Con8or32(src));
7463   ins_pipe(ialu_reg);
7464 %}
7465 
7466 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
7467 %{
7468   match(Set dst (SubI dst (LoadI src)));
7469   effect(KILL cr);
7470 
7471   ins_cost(125);
7472   format %{ "subl    $dst, $src\t# int" %}
7473   opcode(0x2B);
7474   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
7475   ins_pipe(ialu_reg_mem);
7476 %}
7477 
7478 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
7479 %{
7480   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7481   effect(KILL cr);
7482 
7483   ins_cost(150);
7484   format %{ "subl    $dst, $src\t# int" %}
7485   opcode(0x29); /* Opcode 29 /r */
7486   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
7487   ins_pipe(ialu_mem_reg);
7488 %}
7489 
7490 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
7491 %{
7492   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7493   effect(KILL cr);
7494 
7495   ins_cost(125); // XXX
7496   format %{ "subl    $dst, $src\t# int" %}
7497   opcode(0x81); /* Opcode 81 /5 id */
7498   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7499   ins_pipe(ialu_mem_imm);
7500 %}
7501 
7502 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7503 %{
7504   match(Set dst (SubL dst src));
7505   effect(KILL cr);
7506 
7507   format %{ "subq    $dst, $src\t# long" %}
7508   opcode(0x2B);
7509   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7510   ins_pipe(ialu_reg_reg);
7511 %}
7512 
7513 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
7514 %{
7515   match(Set dst (SubL dst src));
7516   effect(KILL cr);
7517 
7518   format %{ "subq    $dst, $src\t# long" %}
7519   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7520   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7521   ins_pipe(ialu_reg);
7522 %}
7523 
7524 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7525 %{
7526   match(Set dst (SubL dst (LoadL src)));
7527   effect(KILL cr);
7528 
7529   ins_cost(125);
7530   format %{ "subq    $dst, $src\t# long" %}
7531   opcode(0x2B);
7532   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7533   ins_pipe(ialu_reg_mem);
7534 %}
7535 
7536 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7537 %{
7538   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7539   effect(KILL cr);
7540 
7541   ins_cost(150);
7542   format %{ "subq    $dst, $src\t# long" %}
7543   opcode(0x29); /* Opcode 29 /r */
7544   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7545   ins_pipe(ialu_mem_reg);
7546 %}
7547 
7548 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7549 %{
7550   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7551   effect(KILL cr);
7552 
7553   ins_cost(125); // XXX
7554   format %{ "subq    $dst, $src\t# long" %}
7555   opcode(0x81); /* Opcode 81 /5 id */
7556   ins_encode(REX_mem_wide(dst),
7557              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7558   ins_pipe(ialu_mem_imm);
7559 %}
7560 
7561 // Subtract from a pointer
7562 // XXX hmpf???
7563 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
7564 %{
7565   match(Set dst (AddP dst (SubI zero src)));
7566   effect(KILL cr);
7567 
7568   format %{ "subq    $dst, $src\t# ptr - int" %}
7569   opcode(0x2B);
7570   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7571   ins_pipe(ialu_reg_reg);
7572 %}
7573 
7574 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
7575 %{
7576   match(Set dst (SubI zero dst));
7577   effect(KILL cr);
7578 
7579   format %{ "negl    $dst\t# int" %}
7580   opcode(0xF7, 0x03);  // Opcode F7 /3
7581   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7582   ins_pipe(ialu_reg);
7583 %}
7584 
7585 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
7586 %{
7587   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
7588   effect(KILL cr);
7589 
7590   format %{ "negl    $dst\t# int" %}
7591   opcode(0xF7, 0x03);  // Opcode F7 /3
7592   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7593   ins_pipe(ialu_reg);
7594 %}
7595 
7596 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
7597 %{
7598   match(Set dst (SubL zero dst));
7599   effect(KILL cr);
7600 
7601   format %{ "negq    $dst\t# long" %}
7602   opcode(0xF7, 0x03);  // Opcode F7 /3
7603   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7604   ins_pipe(ialu_reg);
7605 %}
7606 
7607 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
7608 %{
7609   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
7610   effect(KILL cr);
7611 
7612   format %{ "negq    $dst\t# long" %}
7613   opcode(0xF7, 0x03);  // Opcode F7 /3
7614   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
7615   ins_pipe(ialu_reg);
7616 %}
7617 
7618 //----------Multiplication/Division Instructions-------------------------------
7619 // Integer Multiplication Instructions
7620 // Multiply Register
7621 
7622 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7623 %{
7624   match(Set dst (MulI dst src));
7625   effect(KILL cr);
7626 
7627   ins_cost(300);
7628   format %{ "imull   $dst, $src\t# int" %}
7629   opcode(0x0F, 0xAF);
7630   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
7631   ins_pipe(ialu_reg_reg_alu0);
7632 %}
7633 
7634 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
7635 %{
7636   match(Set dst (MulI src imm));
7637   effect(KILL cr);
7638 
7639   ins_cost(300);
7640   format %{ "imull   $dst, $src, $imm\t# int" %}
7641   opcode(0x69); /* 69 /r id */
7642   ins_encode(REX_reg_reg(dst, src),
7643              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7644   ins_pipe(ialu_reg_reg_alu0);
7645 %}
7646 
7647 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
7648 %{
7649   match(Set dst (MulI dst (LoadI src)));
7650   effect(KILL cr);
7651 
7652   ins_cost(350);
7653   format %{ "imull   $dst, $src\t# int" %}
7654   opcode(0x0F, 0xAF);
7655   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
7656   ins_pipe(ialu_reg_mem_alu0);
7657 %}
7658 
7659 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
7660 %{
7661   match(Set dst (MulI (LoadI src) imm));
7662   effect(KILL cr);
7663 
7664   ins_cost(300);
7665   format %{ "imull   $dst, $src, $imm\t# int" %}
7666   opcode(0x69); /* 69 /r id */
7667   ins_encode(REX_reg_mem(dst, src),
7668              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7669   ins_pipe(ialu_reg_mem_alu0);
7670 %}
7671 
7672 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7673 %{
7674   match(Set dst (MulL dst src));
7675   effect(KILL cr);
7676 
7677   ins_cost(300);
7678   format %{ "imulq   $dst, $src\t# long" %}
7679   opcode(0x0F, 0xAF);
7680   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
7681   ins_pipe(ialu_reg_reg_alu0);
7682 %}
7683 
7684 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
7685 %{
7686   match(Set dst (MulL src imm));
7687   effect(KILL cr);
7688 
7689   ins_cost(300);
7690   format %{ "imulq   $dst, $src, $imm\t# long" %}
7691   opcode(0x69); /* 69 /r id */
7692   ins_encode(REX_reg_reg_wide(dst, src),
7693              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7694   ins_pipe(ialu_reg_reg_alu0);
7695 %}
7696 
7697 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
7698 %{
7699   match(Set dst (MulL dst (LoadL src)));
7700   effect(KILL cr);
7701 
7702   ins_cost(350);
7703   format %{ "imulq   $dst, $src\t# long" %}
7704   opcode(0x0F, 0xAF);
7705   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
7706   ins_pipe(ialu_reg_mem_alu0);
7707 %}
7708 
7709 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
7710 %{
7711   match(Set dst (MulL (LoadL src) imm));
7712   effect(KILL cr);
7713 
7714   ins_cost(300);
7715   format %{ "imulq   $dst, $src, $imm\t# long" %}
7716   opcode(0x69); /* 69 /r id */
7717   ins_encode(REX_reg_mem_wide(dst, src),
7718              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7719   ins_pipe(ialu_reg_mem_alu0);
7720 %}
7721 
7722 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7723 %{
7724   match(Set dst (MulHiL src rax));
7725   effect(USE_KILL rax, KILL cr);
7726 
7727   ins_cost(300);
7728   format %{ "imulq   RDX:RAX, RAX, $src\t# mulhi" %}
7729   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7730   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7731   ins_pipe(ialu_reg_reg_alu0);
7732 %}
7733 
7734 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7735                    rFlagsReg cr)
7736 %{
7737   match(Set rax (DivI rax div));
7738   effect(KILL rdx, KILL cr);
7739 
7740   ins_cost(30*100+10*100); // XXX
7741   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7742             "jne,s   normal\n\t"
7743             "xorl    rdx, rdx\n\t"
7744             "cmpl    $div, -1\n\t"
7745             "je,s    done\n"
7746     "normal: cdql\n\t"
7747             "idivl   $div\n"
7748     "done:"        %}
7749   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7750   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7751   ins_pipe(ialu_reg_reg_alu0);
7752 %}
7753 
7754 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7755                    rFlagsReg cr)
7756 %{
7757   match(Set rax (DivL rax div));
7758   effect(KILL rdx, KILL cr);
7759 
7760   ins_cost(30*100+10*100); // XXX
7761   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7762             "cmpq    rax, rdx\n\t"
7763             "jne,s   normal\n\t"
7764             "xorl    rdx, rdx\n\t"
7765             "cmpq    $div, -1\n\t"
7766             "je,s    done\n"
7767     "normal: cdqq\n\t"
7768             "idivq   $div\n"
7769     "done:"        %}
7770   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7771   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7772   ins_pipe(ialu_reg_reg_alu0);
7773 %}
7774 
7775 // Integer DIVMOD with Register, both quotient and mod results
7776 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7777                              rFlagsReg cr)
7778 %{
7779   match(DivModI rax div);
7780   effect(KILL cr);
7781 
7782   ins_cost(30*100+10*100); // XXX
7783   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7784             "jne,s   normal\n\t"
7785             "xorl    rdx, rdx\n\t"
7786             "cmpl    $div, -1\n\t"
7787             "je,s    done\n"
7788     "normal: cdql\n\t"
7789             "idivl   $div\n"
7790     "done:"        %}
7791   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7792   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7793   ins_pipe(pipe_slow);
7794 %}
7795 
7796 // Long DIVMOD with Register, both quotient and mod results
7797 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7798                              rFlagsReg cr)
7799 %{
7800   match(DivModL rax div);
7801   effect(KILL cr);
7802 
7803   ins_cost(30*100+10*100); // XXX
7804   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7805             "cmpq    rax, rdx\n\t"
7806             "jne,s   normal\n\t"
7807             "xorl    rdx, rdx\n\t"
7808             "cmpq    $div, -1\n\t"
7809             "je,s    done\n"
7810     "normal: cdqq\n\t"
7811             "idivq   $div\n"
7812     "done:"        %}
7813   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7814   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7815   ins_pipe(pipe_slow);
7816 %}
7817 
7818 //----------- DivL-By-Constant-Expansions--------------------------------------
7819 // DivI cases are handled by the compiler
7820 
7821 // Magic constant, reciprocal of 10
7822 instruct loadConL_0x6666666666666667(rRegL dst)
7823 %{
7824   effect(DEF dst);
7825 
7826   format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
7827   ins_encode(load_immL(dst, 0x6666666666666667));
7828   ins_pipe(ialu_reg);
7829 %}
7830 
7831 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7832 %{
7833   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
7834 
7835   format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
7836   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7837   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7838   ins_pipe(ialu_reg_reg_alu0);
7839 %}
7840 
7841 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
7842 %{
7843   effect(USE_DEF dst, KILL cr);
7844 
7845   format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
7846   opcode(0xC1, 0x7); /* C1 /7 ib */
7847   ins_encode(reg_opc_imm_wide(dst, 0x3F));
7848   ins_pipe(ialu_reg);
7849 %}
7850 
7851 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
7852 %{
7853   effect(USE_DEF dst, KILL cr);
7854 
7855   format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
7856   opcode(0xC1, 0x7); /* C1 /7 ib */
7857   ins_encode(reg_opc_imm_wide(dst, 0x2));
7858   ins_pipe(ialu_reg);
7859 %}
7860 
7861 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
7862 %{
7863   match(Set dst (DivL src div));
7864 
7865   ins_cost((5+8)*100);
7866   expand %{
7867     rax_RegL rax;                     // Killed temp
7868     rFlagsReg cr;                     // Killed
7869     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
7870     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
7871     sarL_rReg_63(src, cr);            // sarq  src, 63
7872     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
7873     subL_rReg(dst, src, cr);          // subl  rdx, src
7874   %}
7875 %}
7876 
7877 //-----------------------------------------------------------------------------
7878 
7879 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
7880                    rFlagsReg cr)
7881 %{
7882   match(Set rdx (ModI rax div));
7883   effect(KILL rax, KILL cr);
7884 
7885   ins_cost(300); // XXX
7886   format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
7887             "jne,s   normal\n\t"
7888             "xorl    rdx, rdx\n\t"
7889             "cmpl    $div, -1\n\t"
7890             "je,s    done\n"
7891     "normal: cdql\n\t"
7892             "idivl   $div\n"
7893     "done:"        %}
7894   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7895   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7896   ins_pipe(ialu_reg_reg_alu0);
7897 %}
7898 
7899 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
7900                    rFlagsReg cr)
7901 %{
7902   match(Set rdx (ModL rax div));
7903   effect(KILL rax, KILL cr);
7904 
7905   ins_cost(300); // XXX
7906   format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
7907             "cmpq    rax, rdx\n\t"
7908             "jne,s   normal\n\t"
7909             "xorl    rdx, rdx\n\t"
7910             "cmpq    $div, -1\n\t"
7911             "je,s    done\n"
7912     "normal: cdqq\n\t"
7913             "idivq   $div\n"
7914     "done:"        %}
7915   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7916   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7917   ins_pipe(ialu_reg_reg_alu0);
7918 %}
7919 
7920 // Integer Shift Instructions
7921 // Shift Left by one
7922 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7923 %{
7924   match(Set dst (LShiftI dst shift));
7925   effect(KILL cr);
7926 
7927   format %{ "sall    $dst, $shift" %}
7928   opcode(0xD1, 0x4); /* D1 /4 */
7929   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7930   ins_pipe(ialu_reg);
7931 %}
7932 
7933 // Shift Left by one
7934 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7935 %{
7936   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7937   effect(KILL cr);
7938 
7939   format %{ "sall    $dst, $shift\t" %}
7940   opcode(0xD1, 0x4); /* D1 /4 */
7941   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7942   ins_pipe(ialu_mem_imm);
7943 %}
7944 
7945 // Shift Left by 8-bit immediate
7946 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7947 %{
7948   match(Set dst (LShiftI dst shift));
7949   effect(KILL cr);
7950 
7951   format %{ "sall    $dst, $shift" %}
7952   opcode(0xC1, 0x4); /* C1 /4 ib */
7953   ins_encode(reg_opc_imm(dst, shift));
7954   ins_pipe(ialu_reg);
7955 %}
7956 
7957 // Shift Left by 8-bit immediate
7958 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7959 %{
7960   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7961   effect(KILL cr);
7962 
7963   format %{ "sall    $dst, $shift" %}
7964   opcode(0xC1, 0x4); /* C1 /4 ib */
7965   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
7966   ins_pipe(ialu_mem_imm);
7967 %}
7968 
7969 // Shift Left by variable
7970 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
7971 %{
7972   match(Set dst (LShiftI dst shift));
7973   effect(KILL cr);
7974 
7975   format %{ "sall    $dst, $shift" %}
7976   opcode(0xD3, 0x4); /* D3 /4 */
7977   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7978   ins_pipe(ialu_reg_reg);
7979 %}
7980 
7981 // Shift Left by variable
7982 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
7983 %{
7984   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7985   effect(KILL cr);
7986 
7987   format %{ "sall    $dst, $shift" %}
7988   opcode(0xD3, 0x4); /* D3 /4 */
7989   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7990   ins_pipe(ialu_mem_reg);
7991 %}
7992 
7993 // Arithmetic shift right by one
7994 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7995 %{
7996   match(Set dst (RShiftI dst shift));
7997   effect(KILL cr);
7998 
7999   format %{ "sarl    $dst, $shift" %}
8000   opcode(0xD1, 0x7); /* D1 /7 */
8001   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8002   ins_pipe(ialu_reg);
8003 %}
8004 
8005 // Arithmetic shift right by one
8006 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8007 %{
8008   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8009   effect(KILL cr);
8010 
8011   format %{ "sarl    $dst, $shift" %}
8012   opcode(0xD1, 0x7); /* D1 /7 */
8013   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8014   ins_pipe(ialu_mem_imm);
8015 %}
8016 
8017 // Arithmetic Shift Right by 8-bit immediate
8018 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8019 %{
8020   match(Set dst (RShiftI dst shift));
8021   effect(KILL cr);
8022 
8023   format %{ "sarl    $dst, $shift" %}
8024   opcode(0xC1, 0x7); /* C1 /7 ib */
8025   ins_encode(reg_opc_imm(dst, shift));
8026   ins_pipe(ialu_mem_imm);
8027 %}
8028 
8029 // Arithmetic Shift Right by 8-bit immediate
8030 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8031 %{
8032   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8033   effect(KILL cr);
8034 
8035   format %{ "sarl    $dst, $shift" %}
8036   opcode(0xC1, 0x7); /* C1 /7 ib */
8037   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8038   ins_pipe(ialu_mem_imm);
8039 %}
8040 
8041 // Arithmetic Shift Right by variable
8042 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8043 %{
8044   match(Set dst (RShiftI dst shift));
8045   effect(KILL cr);
8046 
8047   format %{ "sarl    $dst, $shift" %}
8048   opcode(0xD3, 0x7); /* D3 /7 */
8049   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8050   ins_pipe(ialu_reg_reg);
8051 %}
8052 
8053 // Arithmetic Shift Right by variable
8054 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8055 %{
8056   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8057   effect(KILL cr);
8058 
8059   format %{ "sarl    $dst, $shift" %}
8060   opcode(0xD3, 0x7); /* D3 /7 */
8061   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8062   ins_pipe(ialu_mem_reg);
8063 %}
8064 
8065 // Logical shift right by one
8066 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
8067 %{
8068   match(Set dst (URShiftI dst shift));
8069   effect(KILL cr);
8070 
8071   format %{ "shrl    $dst, $shift" %}
8072   opcode(0xD1, 0x5); /* D1 /5 */
8073   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8074   ins_pipe(ialu_reg);
8075 %}
8076 
8077 // Logical shift right by one
8078 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8079 %{
8080   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8081   effect(KILL cr);
8082 
8083   format %{ "shrl    $dst, $shift" %}
8084   opcode(0xD1, 0x5); /* D1 /5 */
8085   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8086   ins_pipe(ialu_mem_imm);
8087 %}
8088 
8089 // Logical Shift Right by 8-bit immediate
8090 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8091 %{
8092   match(Set dst (URShiftI dst shift));
8093   effect(KILL cr);
8094 
8095   format %{ "shrl    $dst, $shift" %}
8096   opcode(0xC1, 0x5); /* C1 /5 ib */
8097   ins_encode(reg_opc_imm(dst, shift));
8098   ins_pipe(ialu_reg);
8099 %}
8100 
8101 // Logical Shift Right by 8-bit immediate
8102 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8103 %{
8104   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8105   effect(KILL cr);
8106 
8107   format %{ "shrl    $dst, $shift" %}
8108   opcode(0xC1, 0x5); /* C1 /5 ib */
8109   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8110   ins_pipe(ialu_mem_imm);
8111 %}
8112 
8113 // Logical Shift Right by variable
8114 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8115 %{
8116   match(Set dst (URShiftI dst shift));
8117   effect(KILL cr);
8118 
8119   format %{ "shrl    $dst, $shift" %}
8120   opcode(0xD3, 0x5); /* D3 /5 */
8121   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8122   ins_pipe(ialu_reg_reg);
8123 %}
8124 
8125 // Logical Shift Right by variable
8126 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8127 %{
8128   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8129   effect(KILL cr);
8130 
8131   format %{ "shrl    $dst, $shift" %}
8132   opcode(0xD3, 0x5); /* D3 /5 */
8133   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8134   ins_pipe(ialu_mem_reg);
8135 %}
8136 
8137 // Long Shift Instructions
8138 // Shift Left by one
8139 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8140 %{
8141   match(Set dst (LShiftL dst shift));
8142   effect(KILL cr);
8143 
8144   format %{ "salq    $dst, $shift" %}
8145   opcode(0xD1, 0x4); /* D1 /4 */
8146   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8147   ins_pipe(ialu_reg);
8148 %}
8149 
8150 // Shift Left by one
8151 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8152 %{
8153   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8154   effect(KILL cr);
8155 
8156   format %{ "salq    $dst, $shift" %}
8157   opcode(0xD1, 0x4); /* D1 /4 */
8158   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8159   ins_pipe(ialu_mem_imm);
8160 %}
8161 
8162 // Shift Left by 8-bit immediate
8163 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8164 %{
8165   match(Set dst (LShiftL dst shift));
8166   effect(KILL cr);
8167 
8168   format %{ "salq    $dst, $shift" %}
8169   opcode(0xC1, 0x4); /* C1 /4 ib */
8170   ins_encode(reg_opc_imm_wide(dst, shift));
8171   ins_pipe(ialu_reg);
8172 %}
8173 
8174 // Shift Left by 8-bit immediate
8175 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8176 %{
8177   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8178   effect(KILL cr);
8179 
8180   format %{ "salq    $dst, $shift" %}
8181   opcode(0xC1, 0x4); /* C1 /4 ib */
8182   ins_encode(REX_mem_wide(dst), OpcP,
8183              RM_opc_mem(secondary, dst), Con8or32(shift));
8184   ins_pipe(ialu_mem_imm);
8185 %}
8186 
8187 // Shift Left by variable
8188 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8189 %{
8190   match(Set dst (LShiftL dst shift));
8191   effect(KILL cr);
8192 
8193   format %{ "salq    $dst, $shift" %}
8194   opcode(0xD3, 0x4); /* D3 /4 */
8195   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8196   ins_pipe(ialu_reg_reg);
8197 %}
8198 
8199 // Shift Left by variable
8200 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8201 %{
8202   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8203   effect(KILL cr);
8204 
8205   format %{ "salq    $dst, $shift" %}
8206   opcode(0xD3, 0x4); /* D3 /4 */
8207   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8208   ins_pipe(ialu_mem_reg);
8209 %}
8210 
8211 // Arithmetic shift right by one
8212 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8213 %{
8214   match(Set dst (RShiftL dst shift));
8215   effect(KILL cr);
8216 
8217   format %{ "sarq    $dst, $shift" %}
8218   opcode(0xD1, 0x7); /* D1 /7 */
8219   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8220   ins_pipe(ialu_reg);
8221 %}
8222 
8223 // Arithmetic shift right by one
8224 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8225 %{
8226   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8227   effect(KILL cr);
8228 
8229   format %{ "sarq    $dst, $shift" %}
8230   opcode(0xD1, 0x7); /* D1 /7 */
8231   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8232   ins_pipe(ialu_mem_imm);
8233 %}
8234 
8235 // Arithmetic Shift Right by 8-bit immediate
8236 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8237 %{
8238   match(Set dst (RShiftL dst shift));
8239   effect(KILL cr);
8240 
8241   format %{ "sarq    $dst, $shift" %}
8242   opcode(0xC1, 0x7); /* C1 /7 ib */
8243   ins_encode(reg_opc_imm_wide(dst, shift));
8244   ins_pipe(ialu_mem_imm);
8245 %}
8246 
8247 // Arithmetic Shift Right by 8-bit immediate
8248 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8249 %{
8250   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8251   effect(KILL cr);
8252 
8253   format %{ "sarq    $dst, $shift" %}
8254   opcode(0xC1, 0x7); /* C1 /7 ib */
8255   ins_encode(REX_mem_wide(dst), OpcP,
8256              RM_opc_mem(secondary, dst), Con8or32(shift));
8257   ins_pipe(ialu_mem_imm);
8258 %}
8259 
8260 // Arithmetic Shift Right by variable
8261 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8262 %{
8263   match(Set dst (RShiftL dst shift));
8264   effect(KILL cr);
8265 
8266   format %{ "sarq    $dst, $shift" %}
8267   opcode(0xD3, 0x7); /* D3 /7 */
8268   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8269   ins_pipe(ialu_reg_reg);
8270 %}
8271 
8272 // Arithmetic Shift Right by variable
8273 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8274 %{
8275   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8276   effect(KILL cr);
8277 
8278   format %{ "sarq    $dst, $shift" %}
8279   opcode(0xD3, 0x7); /* D3 /7 */
8280   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8281   ins_pipe(ialu_mem_reg);
8282 %}
8283 
8284 // Logical shift right by one
8285 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8286 %{
8287   match(Set dst (URShiftL dst shift));
8288   effect(KILL cr);
8289 
8290   format %{ "shrq    $dst, $shift" %}
8291   opcode(0xD1, 0x5); /* D1 /5 */
8292   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
8293   ins_pipe(ialu_reg);
8294 %}
8295 
8296 // Logical shift right by one
8297 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8298 %{
8299   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8300   effect(KILL cr);
8301 
8302   format %{ "shrq    $dst, $shift" %}
8303   opcode(0xD1, 0x5); /* D1 /5 */
8304   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8305   ins_pipe(ialu_mem_imm);
8306 %}
8307 
8308 // Logical Shift Right by 8-bit immediate
8309 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8310 %{
8311   match(Set dst (URShiftL dst shift));
8312   effect(KILL cr);
8313 
8314   format %{ "shrq    $dst, $shift" %}
8315   opcode(0xC1, 0x5); /* C1 /5 ib */
8316   ins_encode(reg_opc_imm_wide(dst, shift));
8317   ins_pipe(ialu_reg);
8318 %}
8319 
8320 
8321 // Logical Shift Right by 8-bit immediate
8322 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8323 %{
8324   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8325   effect(KILL cr);
8326 
8327   format %{ "shrq    $dst, $shift" %}
8328   opcode(0xC1, 0x5); /* C1 /5 ib */
8329   ins_encode(REX_mem_wide(dst), OpcP,
8330              RM_opc_mem(secondary, dst), Con8or32(shift));
8331   ins_pipe(ialu_mem_imm);
8332 %}
8333 
8334 // Logical Shift Right by variable
8335 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8336 %{
8337   match(Set dst (URShiftL dst shift));
8338   effect(KILL cr);
8339 
8340   format %{ "shrq    $dst, $shift" %}
8341   opcode(0xD3, 0x5); /* D3 /5 */
8342   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8343   ins_pipe(ialu_reg_reg);
8344 %}
8345 
8346 // Logical Shift Right by variable
8347 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8348 %{
8349   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8350   effect(KILL cr);
8351 
8352   format %{ "shrq    $dst, $shift" %}
8353   opcode(0xD3, 0x5); /* D3 /5 */
8354   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8355   ins_pipe(ialu_mem_reg);
8356 %}
8357 
8358 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
8359 // This idiom is used by the compiler for the i2b bytecode.
8360 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
8361 %{
8362   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
8363 
8364   format %{ "movsbl  $dst, $src\t# i2b" %}
8365   opcode(0x0F, 0xBE);
8366   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8367   ins_pipe(ialu_reg_reg);
8368 %}
8369 
8370 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
8371 // This idiom is used by the compiler the i2s bytecode.
8372 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
8373 %{
8374   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
8375 
8376   format %{ "movswl  $dst, $src\t# i2s" %}
8377   opcode(0x0F, 0xBF);
8378   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8379   ins_pipe(ialu_reg_reg);
8380 %}
8381 
8382 // ROL/ROR instructions
8383 
8384 // ROL expand
8385 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
8386   effect(KILL cr, USE_DEF dst);
8387 
8388   format %{ "roll    $dst" %}
8389   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8390   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8391   ins_pipe(ialu_reg);
8392 %}
8393 
8394 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
8395   effect(USE_DEF dst, USE shift, KILL cr);
8396 
8397   format %{ "roll    $dst, $shift" %}
8398   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8399   ins_encode( reg_opc_imm(dst, shift) );
8400   ins_pipe(ialu_reg);
8401 %}
8402 
8403 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8404 %{
8405   effect(USE_DEF dst, USE shift, KILL cr);
8406 
8407   format %{ "roll    $dst, $shift" %}
8408   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8409   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8410   ins_pipe(ialu_reg_reg);
8411 %}
8412 // end of ROL expand
8413 
8414 // Rotate Left by one
8415 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8416 %{
8417   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8418 
8419   expand %{
8420     rolI_rReg_imm1(dst, cr);
8421   %}
8422 %}
8423 
8424 // Rotate Left by 8-bit immediate
8425 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8426 %{
8427   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8428   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8429 
8430   expand %{
8431     rolI_rReg_imm8(dst, lshift, cr);
8432   %}
8433 %}
8434 
8435 // Rotate Left by variable
8436 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8437 %{
8438   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
8439 
8440   expand %{
8441     rolI_rReg_CL(dst, shift, cr);
8442   %}
8443 %}
8444 
8445 // Rotate Left by variable
8446 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8447 %{
8448   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
8449 
8450   expand %{
8451     rolI_rReg_CL(dst, shift, cr);
8452   %}
8453 %}
8454 
8455 // ROR expand
8456 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
8457 %{
8458   effect(USE_DEF dst, KILL cr);
8459 
8460   format %{ "rorl    $dst" %}
8461   opcode(0xD1, 0x1); /* D1 /1 */
8462   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8463   ins_pipe(ialu_reg);
8464 %}
8465 
8466 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
8467 %{
8468   effect(USE_DEF dst, USE shift, KILL cr);
8469 
8470   format %{ "rorl    $dst, $shift" %}
8471   opcode(0xC1, 0x1); /* C1 /1 ib */
8472   ins_encode(reg_opc_imm(dst, shift));
8473   ins_pipe(ialu_reg);
8474 %}
8475 
8476 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8477 %{
8478   effect(USE_DEF dst, USE shift, KILL cr);
8479 
8480   format %{ "rorl    $dst, $shift" %}
8481   opcode(0xD3, 0x1); /* D3 /1 */
8482   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8483   ins_pipe(ialu_reg_reg);
8484 %}
8485 // end of ROR expand
8486 
8487 // Rotate Right by one
8488 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8489 %{
8490   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8491 
8492   expand %{
8493     rorI_rReg_imm1(dst, cr);
8494   %}
8495 %}
8496 
8497 // Rotate Right by 8-bit immediate
8498 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8499 %{
8500   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8501   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8502 
8503   expand %{
8504     rorI_rReg_imm8(dst, rshift, cr);
8505   %}
8506 %}
8507 
8508 // Rotate Right by variable
8509 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8510 %{
8511   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
8512 
8513   expand %{
8514     rorI_rReg_CL(dst, shift, cr);
8515   %}
8516 %}
8517 
8518 // Rotate Right by variable
8519 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8520 %{
8521   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
8522 
8523   expand %{
8524     rorI_rReg_CL(dst, shift, cr);
8525   %}
8526 %}
8527 
8528 // for long rotate
8529 // ROL expand
8530 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
8531   effect(USE_DEF dst, KILL cr);
8532 
8533   format %{ "rolq    $dst" %}
8534   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8535   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8536   ins_pipe(ialu_reg);
8537 %}
8538 
8539 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
8540   effect(USE_DEF dst, USE shift, KILL cr);
8541 
8542   format %{ "rolq    $dst, $shift" %}
8543   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8544   ins_encode( reg_opc_imm_wide(dst, shift) );
8545   ins_pipe(ialu_reg);
8546 %}
8547 
8548 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8549 %{
8550   effect(USE_DEF dst, USE shift, KILL cr);
8551 
8552   format %{ "rolq    $dst, $shift" %}
8553   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8554   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8555   ins_pipe(ialu_reg_reg);
8556 %}
8557 // end of ROL expand
8558 
8559 // Rotate Left by one
8560 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8561 %{
8562   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8563 
8564   expand %{
8565     rolL_rReg_imm1(dst, cr);
8566   %}
8567 %}
8568 
8569 // Rotate Left by 8-bit immediate
8570 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8571 %{
8572   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8573   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8574 
8575   expand %{
8576     rolL_rReg_imm8(dst, lshift, cr);
8577   %}
8578 %}
8579 
8580 // Rotate Left by variable
8581 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8582 %{
8583   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
8584 
8585   expand %{
8586     rolL_rReg_CL(dst, shift, cr);
8587   %}
8588 %}
8589 
8590 // Rotate Left by variable
8591 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8592 %{
8593   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
8594 
8595   expand %{
8596     rolL_rReg_CL(dst, shift, cr);
8597   %}
8598 %}
8599 
8600 // ROR expand
8601 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
8602 %{
8603   effect(USE_DEF dst, KILL cr);
8604 
8605   format %{ "rorq    $dst" %}
8606   opcode(0xD1, 0x1); /* D1 /1 */
8607   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8608   ins_pipe(ialu_reg);
8609 %}
8610 
8611 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
8612 %{
8613   effect(USE_DEF dst, USE shift, KILL cr);
8614 
8615   format %{ "rorq    $dst, $shift" %}
8616   opcode(0xC1, 0x1); /* C1 /1 ib */
8617   ins_encode(reg_opc_imm_wide(dst, shift));
8618   ins_pipe(ialu_reg);
8619 %}
8620 
8621 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8622 %{
8623   effect(USE_DEF dst, USE shift, KILL cr);
8624 
8625   format %{ "rorq    $dst, $shift" %}
8626   opcode(0xD3, 0x1); /* D3 /1 */
8627   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8628   ins_pipe(ialu_reg_reg);
8629 %}
8630 // end of ROR expand
8631 
8632 // Rotate Right by one
8633 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8634 %{
8635   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8636 
8637   expand %{
8638     rorL_rReg_imm1(dst, cr);
8639   %}
8640 %}
8641 
8642 // Rotate Right by 8-bit immediate
8643 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8644 %{
8645   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8646   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8647 
8648   expand %{
8649     rorL_rReg_imm8(dst, rshift, cr);
8650   %}
8651 %}
8652 
8653 // Rotate Right by variable
8654 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8655 %{
8656   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
8657 
8658   expand %{
8659     rorL_rReg_CL(dst, shift, cr);
8660   %}
8661 %}
8662 
8663 // Rotate Right by variable
8664 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8665 %{
8666   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
8667 
8668   expand %{
8669     rorL_rReg_CL(dst, shift, cr);
8670   %}
8671 %}
8672 
8673 // Logical Instructions
8674 
8675 // Integer Logical Instructions
8676 
8677 // And Instructions
8678 // And Register with Register
8679 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8680 %{
8681   match(Set dst (AndI dst src));
8682   effect(KILL cr);
8683 
8684   format %{ "andl    $dst, $src\t# int" %}
8685   opcode(0x23);
8686   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8687   ins_pipe(ialu_reg_reg);
8688 %}
8689 
8690 // And Register with Immediate 255
8691 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
8692 %{
8693   match(Set dst (AndI dst src));
8694 
8695   format %{ "movzbl  $dst, $dst\t# int &amp; 0xFF" %}
8696   opcode(0x0F, 0xB6);
8697   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8698   ins_pipe(ialu_reg);
8699 %}
8700 
8701 // And Register with Immediate 255 and promote to long
8702 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
8703 %{
8704   match(Set dst (ConvI2L (AndI src mask)));
8705 
8706   format %{ "movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long" %}
8707   opcode(0x0F, 0xB6);
8708   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8709   ins_pipe(ialu_reg);
8710 %}
8711 
8712 // And Register with Immediate 65535
8713 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
8714 %{
8715   match(Set dst (AndI dst src));
8716 
8717   format %{ "movzwl  $dst, $dst\t# int &amp; 0xFFFF" %}
8718   opcode(0x0F, 0xB7);
8719   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8720   ins_pipe(ialu_reg);
8721 %}
8722 
8723 // And Register with Immediate 65535 and promote to long
8724 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
8725 %{
8726   match(Set dst (ConvI2L (AndI src mask)));
8727 
8728   format %{ "movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long" %}
8729   opcode(0x0F, 0xB7);
8730   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8731   ins_pipe(ialu_reg);
8732 %}
8733 
8734 // And Register with Immediate
8735 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8736 %{
8737   match(Set dst (AndI dst src));
8738   effect(KILL cr);
8739 
8740   format %{ "andl    $dst, $src\t# int" %}
8741   opcode(0x81, 0x04); /* Opcode 81 /4 */
8742   ins_encode(OpcSErm(dst, src), Con8or32(src));
8743   ins_pipe(ialu_reg);
8744 %}
8745 
8746 // And Register with Memory
8747 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8748 %{
8749   match(Set dst (AndI dst (LoadI src)));
8750   effect(KILL cr);
8751 
8752   ins_cost(125);
8753   format %{ "andl    $dst, $src\t# int" %}
8754   opcode(0x23);
8755   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8756   ins_pipe(ialu_reg_mem);
8757 %}
8758 
8759 // And Memory with Register
8760 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8761 %{
8762   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8763   effect(KILL cr);
8764 
8765   ins_cost(150);
8766   format %{ "andl    $dst, $src\t# int" %}
8767   opcode(0x21); /* Opcode 21 /r */
8768   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8769   ins_pipe(ialu_mem_reg);
8770 %}
8771 
8772 // And Memory with Immediate
8773 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
8774 %{
8775   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8776   effect(KILL cr);
8777 
8778   ins_cost(125);
8779   format %{ "andl    $dst, $src\t# int" %}
8780   opcode(0x81, 0x4); /* Opcode 81 /4 id */
8781   ins_encode(REX_mem(dst), OpcSE(src),
8782              RM_opc_mem(secondary, dst), Con8or32(src));
8783   ins_pipe(ialu_mem_imm);
8784 %}
8785 
8786 // BMI1 instructions
8787 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
8788   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
8789   predicate(UseBMI1Instructions);
8790   effect(KILL cr);
8791 
8792   ins_cost(125);
8793   format %{ "andnl  $dst, $src1, $src2" %}
8794 
8795   ins_encode %{
8796     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
8797   %}
8798   ins_pipe(ialu_reg_mem);
8799 %}
8800 
8801 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
8802   match(Set dst (AndI (XorI src1 minus_1) src2));
8803   predicate(UseBMI1Instructions);
8804   effect(KILL cr);
8805 
8806   format %{ "andnl  $dst, $src1, $src2" %}
8807 
8808   ins_encode %{
8809     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
8810   %}
8811   ins_pipe(ialu_reg);
8812 %}
8813 
8814 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
8815   match(Set dst (AndI (SubI imm_zero src) src));
8816   predicate(UseBMI1Instructions);
8817   effect(KILL cr);
8818 
8819   format %{ "blsil  $dst, $src" %}
8820 
8821   ins_encode %{
8822     __ blsil($dst$$Register, $src$$Register);
8823   %}
8824   ins_pipe(ialu_reg);
8825 %}
8826 
8827 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
8828   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
8829   predicate(UseBMI1Instructions);
8830   effect(KILL cr);
8831 
8832   ins_cost(125);
8833   format %{ "blsil  $dst, $src" %}
8834 
8835   ins_encode %{
8836     __ blsil($dst$$Register, $src$$Address);
8837   %}
8838   ins_pipe(ialu_reg_mem);
8839 %}
8840 
8841 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8842 %{
8843   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
8844   predicate(UseBMI1Instructions);
8845   effect(KILL cr);
8846 
8847   ins_cost(125);
8848   format %{ "blsmskl $dst, $src" %}
8849 
8850   ins_encode %{
8851     __ blsmskl($dst$$Register, $src$$Address);
8852   %}
8853   ins_pipe(ialu_reg_mem);
8854 %}
8855 
8856 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8857 %{
8858   match(Set dst (XorI (AddI src minus_1) src));
8859   predicate(UseBMI1Instructions);
8860   effect(KILL cr);
8861 
8862   format %{ "blsmskl $dst, $src" %}
8863 
8864   ins_encode %{
8865     __ blsmskl($dst$$Register, $src$$Register);
8866   %}
8867 
8868   ins_pipe(ialu_reg);
8869 %}
8870 
8871 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8872 %{
8873   match(Set dst (AndI (AddI src minus_1) src) );
8874   predicate(UseBMI1Instructions);
8875   effect(KILL cr);
8876 
8877   format %{ "blsrl  $dst, $src" %}
8878 
8879   ins_encode %{
8880     __ blsrl($dst$$Register, $src$$Register);
8881   %}
8882 
8883   ins_pipe(ialu_reg_mem);
8884 %}
8885 
8886 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8887 %{
8888   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
8889   predicate(UseBMI1Instructions);
8890   effect(KILL cr);
8891 
8892   ins_cost(125);
8893   format %{ "blsrl  $dst, $src" %}
8894 
8895   ins_encode %{
8896     __ blsrl($dst$$Register, $src$$Address);
8897   %}
8898 
8899   ins_pipe(ialu_reg);
8900 %}
8901 
8902 // Or Instructions
8903 // Or Register with Register
8904 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8905 %{
8906   match(Set dst (OrI dst src));
8907   effect(KILL cr);
8908 
8909   format %{ "orl     $dst, $src\t# int" %}
8910   opcode(0x0B);
8911   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8912   ins_pipe(ialu_reg_reg);
8913 %}
8914 
8915 // Or Register with Immediate
8916 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8917 %{
8918   match(Set dst (OrI dst src));
8919   effect(KILL cr);
8920 
8921   format %{ "orl     $dst, $src\t# int" %}
8922   opcode(0x81, 0x01); /* Opcode 81 /1 id */
8923   ins_encode(OpcSErm(dst, src), Con8or32(src));
8924   ins_pipe(ialu_reg);
8925 %}
8926 
8927 // Or Register with Memory
8928 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8929 %{
8930   match(Set dst (OrI dst (LoadI src)));
8931   effect(KILL cr);
8932 
8933   ins_cost(125);
8934   format %{ "orl     $dst, $src\t# int" %}
8935   opcode(0x0B);
8936   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8937   ins_pipe(ialu_reg_mem);
8938 %}
8939 
8940 // Or Memory with Register
8941 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8942 %{
8943   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8944   effect(KILL cr);
8945 
8946   ins_cost(150);
8947   format %{ "orl     $dst, $src\t# int" %}
8948   opcode(0x09); /* Opcode 09 /r */
8949   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8950   ins_pipe(ialu_mem_reg);
8951 %}
8952 
8953 // Or Memory with Immediate
8954 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
8955 %{
8956   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8957   effect(KILL cr);
8958 
8959   ins_cost(125);
8960   format %{ "orl     $dst, $src\t# int" %}
8961   opcode(0x81, 0x1); /* Opcode 81 /1 id */
8962   ins_encode(REX_mem(dst), OpcSE(src),
8963              RM_opc_mem(secondary, dst), Con8or32(src));
8964   ins_pipe(ialu_mem_imm);
8965 %}
8966 
8967 // Xor Instructions
8968 // Xor Register with Register
8969 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8970 %{
8971   match(Set dst (XorI dst src));
8972   effect(KILL cr);
8973 
8974   format %{ "xorl    $dst, $src\t# int" %}
8975   opcode(0x33);
8976   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8977   ins_pipe(ialu_reg_reg);
8978 %}
8979 
8980 // Xor Register with Immediate -1
8981 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
8982   match(Set dst (XorI dst imm));
8983 
8984   format %{ "not    $dst" %}
8985   ins_encode %{
8986      __ notl($dst$$Register);
8987   %}
8988   ins_pipe(ialu_reg);
8989 %}
8990 
8991 // Xor Register with Immediate
8992 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8993 %{
8994   match(Set dst (XorI dst src));
8995   effect(KILL cr);
8996 
8997   format %{ "xorl    $dst, $src\t# int" %}
8998   opcode(0x81, 0x06); /* Opcode 81 /6 id */
8999   ins_encode(OpcSErm(dst, src), Con8or32(src));
9000   ins_pipe(ialu_reg);
9001 %}
9002 
9003 // Xor Register with Memory
9004 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
9005 %{
9006   match(Set dst (XorI dst (LoadI src)));
9007   effect(KILL cr);
9008 
9009   ins_cost(125);
9010   format %{ "xorl    $dst, $src\t# int" %}
9011   opcode(0x33);
9012   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
9013   ins_pipe(ialu_reg_mem);
9014 %}
9015 
9016 // Xor Memory with Register
9017 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
9018 %{
9019   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9020   effect(KILL cr);
9021 
9022   ins_cost(150);
9023   format %{ "xorl    $dst, $src\t# int" %}
9024   opcode(0x31); /* Opcode 31 /r */
9025   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
9026   ins_pipe(ialu_mem_reg);
9027 %}
9028 
9029 // Xor Memory with Immediate
9030 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
9031 %{
9032   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9033   effect(KILL cr);
9034 
9035   ins_cost(125);
9036   format %{ "xorl    $dst, $src\t# int" %}
9037   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9038   ins_encode(REX_mem(dst), OpcSE(src),
9039              RM_opc_mem(secondary, dst), Con8or32(src));
9040   ins_pipe(ialu_mem_imm);
9041 %}
9042 
9043 
9044 // Long Logical Instructions
9045 
9046 // And Instructions
9047 // And Register with Register
9048 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9049 %{
9050   match(Set dst (AndL dst src));
9051   effect(KILL cr);
9052 
9053   format %{ "andq    $dst, $src\t# long" %}
9054   opcode(0x23);
9055   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9056   ins_pipe(ialu_reg_reg);
9057 %}
9058 
9059 // And Register with Immediate 255
9060 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
9061 %{
9062   match(Set dst (AndL dst src));
9063 
9064   format %{ "movzbq  $dst, $dst\t# long &amp; 0xFF" %}
9065   opcode(0x0F, 0xB6);
9066   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9067   ins_pipe(ialu_reg);
9068 %}
9069 
9070 // And Register with Immediate 65535
9071 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
9072 %{
9073   match(Set dst (AndL dst src));
9074 
9075   format %{ "movzwq  $dst, $dst\t# long &amp; 0xFFFF" %}
9076   opcode(0x0F, 0xB7);
9077   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9078   ins_pipe(ialu_reg);
9079 %}
9080 
9081 // And Register with Immediate
9082 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9083 %{
9084   match(Set dst (AndL dst src));
9085   effect(KILL cr);
9086 
9087   format %{ "andq    $dst, $src\t# long" %}
9088   opcode(0x81, 0x04); /* Opcode 81 /4 */
9089   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9090   ins_pipe(ialu_reg);
9091 %}
9092 
9093 // And Register with Memory
9094 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9095 %{
9096   match(Set dst (AndL dst (LoadL src)));
9097   effect(KILL cr);
9098 
9099   ins_cost(125);
9100   format %{ "andq    $dst, $src\t# long" %}
9101   opcode(0x23);
9102   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9103   ins_pipe(ialu_reg_mem);
9104 %}
9105 
9106 // And Memory with Register
9107 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9108 %{
9109   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9110   effect(KILL cr);
9111 
9112   ins_cost(150);
9113   format %{ "andq    $dst, $src\t# long" %}
9114   opcode(0x21); /* Opcode 21 /r */
9115   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9116   ins_pipe(ialu_mem_reg);
9117 %}
9118 
9119 // And Memory with Immediate
9120 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9121 %{
9122   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9123   effect(KILL cr);
9124 
9125   ins_cost(125);
9126   format %{ "andq    $dst, $src\t# long" %}
9127   opcode(0x81, 0x4); /* Opcode 81 /4 id */
9128   ins_encode(REX_mem_wide(dst), OpcSE(src),
9129              RM_opc_mem(secondary, dst), Con8or32(src));
9130   ins_pipe(ialu_mem_imm);
9131 %}
9132 
9133 // BMI1 instructions
9134 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
9135   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
9136   predicate(UseBMI1Instructions);
9137   effect(KILL cr);
9138 
9139   ins_cost(125);
9140   format %{ "andnq  $dst, $src1, $src2" %}
9141 
9142   ins_encode %{
9143     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
9144   %}
9145   ins_pipe(ialu_reg_mem);
9146 %}
9147 
9148 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
9149   match(Set dst (AndL (XorL src1 minus_1) src2));
9150   predicate(UseBMI1Instructions);
9151   effect(KILL cr);
9152 
9153   format %{ "andnq  $dst, $src1, $src2" %}
9154 
9155   ins_encode %{
9156   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
9157   %}
9158   ins_pipe(ialu_reg_mem);
9159 %}
9160 
9161 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
9162   match(Set dst (AndL (SubL imm_zero src) src));
9163   predicate(UseBMI1Instructions);
9164   effect(KILL cr);
9165 
9166   format %{ "blsiq  $dst, $src" %}
9167 
9168   ins_encode %{
9169     __ blsiq($dst$$Register, $src$$Register);
9170   %}
9171   ins_pipe(ialu_reg);
9172 %}
9173 
9174 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
9175   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
9176   predicate(UseBMI1Instructions);
9177   effect(KILL cr);
9178 
9179   ins_cost(125);
9180   format %{ "blsiq  $dst, $src" %}
9181 
9182   ins_encode %{
9183     __ blsiq($dst$$Register, $src$$Address);
9184   %}
9185   ins_pipe(ialu_reg_mem);
9186 %}
9187 
9188 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9189 %{
9190   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
9191   predicate(UseBMI1Instructions);
9192   effect(KILL cr);
9193 
9194   ins_cost(125);
9195   format %{ "blsmskq $dst, $src" %}
9196 
9197   ins_encode %{
9198     __ blsmskq($dst$$Register, $src$$Address);
9199   %}
9200   ins_pipe(ialu_reg_mem);
9201 %}
9202 
9203 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9204 %{
9205   match(Set dst (XorL (AddL src minus_1) src));
9206   predicate(UseBMI1Instructions);
9207   effect(KILL cr);
9208 
9209   format %{ "blsmskq $dst, $src" %}
9210 
9211   ins_encode %{
9212     __ blsmskq($dst$$Register, $src$$Register);
9213   %}
9214 
9215   ins_pipe(ialu_reg);
9216 %}
9217 
9218 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9219 %{
9220   match(Set dst (AndL (AddL src minus_1) src) );
9221   predicate(UseBMI1Instructions);
9222   effect(KILL cr);
9223 
9224   format %{ "blsrq  $dst, $src" %}
9225 
9226   ins_encode %{
9227     __ blsrq($dst$$Register, $src$$Register);
9228   %}
9229 
9230   ins_pipe(ialu_reg);
9231 %}
9232 
9233 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9234 %{
9235   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
9236   predicate(UseBMI1Instructions);
9237   effect(KILL cr);
9238 
9239   ins_cost(125);
9240   format %{ "blsrq  $dst, $src" %}
9241 
9242   ins_encode %{
9243     __ blsrq($dst$$Register, $src$$Address);
9244   %}
9245 
9246   ins_pipe(ialu_reg);
9247 %}
9248 
9249 // Or Instructions
9250 // Or Register with Register
9251 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9252 %{
9253   match(Set dst (OrL dst src));
9254   effect(KILL cr);
9255 
9256   format %{ "orq     $dst, $src\t# long" %}
9257   opcode(0x0B);
9258   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9259   ins_pipe(ialu_reg_reg);
9260 %}
9261 
9262 // Use any_RegP to match R15 (TLS register) without spilling.
9263 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
9264   match(Set dst (OrL dst (CastP2X src)));
9265   effect(KILL cr);
9266 
9267   format %{ "orq     $dst, $src\t# long" %}
9268   opcode(0x0B);
9269   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9270   ins_pipe(ialu_reg_reg);
9271 %}
9272 
9273 
9274 // Or Register with Immediate
9275 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9276 %{
9277   match(Set dst (OrL dst src));
9278   effect(KILL cr);
9279 
9280   format %{ "orq     $dst, $src\t# long" %}
9281   opcode(0x81, 0x01); /* Opcode 81 /1 id */
9282   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9283   ins_pipe(ialu_reg);
9284 %}
9285 
9286 // Or Register with Memory
9287 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9288 %{
9289   match(Set dst (OrL dst (LoadL src)));
9290   effect(KILL cr);
9291 
9292   ins_cost(125);
9293   format %{ "orq     $dst, $src\t# long" %}
9294   opcode(0x0B);
9295   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9296   ins_pipe(ialu_reg_mem);
9297 %}
9298 
9299 // Or Memory with Register
9300 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9301 %{
9302   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9303   effect(KILL cr);
9304 
9305   ins_cost(150);
9306   format %{ "orq     $dst, $src\t# long" %}
9307   opcode(0x09); /* Opcode 09 /r */
9308   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9309   ins_pipe(ialu_mem_reg);
9310 %}
9311 
9312 // Or Memory with Immediate
9313 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9314 %{
9315   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9316   effect(KILL cr);
9317 
9318   ins_cost(125);
9319   format %{ "orq     $dst, $src\t# long" %}
9320   opcode(0x81, 0x1); /* Opcode 81 /1 id */
9321   ins_encode(REX_mem_wide(dst), OpcSE(src),
9322              RM_opc_mem(secondary, dst), Con8or32(src));
9323   ins_pipe(ialu_mem_imm);
9324 %}
9325 
9326 // Xor Instructions
9327 // Xor Register with Register
9328 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9329 %{
9330   match(Set dst (XorL dst src));
9331   effect(KILL cr);
9332 
9333   format %{ "xorq    $dst, $src\t# long" %}
9334   opcode(0x33);
9335   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9336   ins_pipe(ialu_reg_reg);
9337 %}
9338 
9339 // Xor Register with Immediate -1
9340 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
9341   match(Set dst (XorL dst imm));
9342 
9343   format %{ "notq   $dst" %}
9344   ins_encode %{
9345      __ notq($dst$$Register);
9346   %}
9347   ins_pipe(ialu_reg);
9348 %}
9349 
9350 // Xor Register with Immediate
9351 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9352 %{
9353   match(Set dst (XorL dst src));
9354   effect(KILL cr);
9355 
9356   format %{ "xorq    $dst, $src\t# long" %}
9357   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9358   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9359   ins_pipe(ialu_reg);
9360 %}
9361 
9362 // Xor Register with Memory
9363 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9364 %{
9365   match(Set dst (XorL dst (LoadL src)));
9366   effect(KILL cr);
9367 
9368   ins_cost(125);
9369   format %{ "xorq    $dst, $src\t# long" %}
9370   opcode(0x33);
9371   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9372   ins_pipe(ialu_reg_mem);
9373 %}
9374 
9375 // Xor Memory with Register
9376 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9377 %{
9378   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9379   effect(KILL cr);
9380 
9381   ins_cost(150);
9382   format %{ "xorq    $dst, $src\t# long" %}
9383   opcode(0x31); /* Opcode 31 /r */
9384   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9385   ins_pipe(ialu_mem_reg);
9386 %}
9387 
9388 // Xor Memory with Immediate
9389 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9390 %{
9391   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9392   effect(KILL cr);
9393 
9394   ins_cost(125);
9395   format %{ "xorq    $dst, $src\t# long" %}
9396   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9397   ins_encode(REX_mem_wide(dst), OpcSE(src),
9398              RM_opc_mem(secondary, dst), Con8or32(src));
9399   ins_pipe(ialu_mem_imm);
9400 %}
9401 
9402 // Convert Int to Boolean
9403 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
9404 %{
9405   match(Set dst (Conv2B src));
9406   effect(KILL cr);
9407 
9408   format %{ "testl   $src, $src\t# ci2b\n\t"
9409             "setnz   $dst\n\t"
9410             "movzbl  $dst, $dst" %}
9411   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
9412              setNZ_reg(dst),
9413              REX_reg_breg(dst, dst), // movzbl
9414              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9415   ins_pipe(pipe_slow); // XXX
9416 %}
9417 
9418 // Convert Pointer to Boolean
9419 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
9420 %{
9421   match(Set dst (Conv2B src));
9422   effect(KILL cr);
9423 
9424   format %{ "testq   $src, $src\t# cp2b\n\t"
9425             "setnz   $dst\n\t"
9426             "movzbl  $dst, $dst" %}
9427   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
9428              setNZ_reg(dst),
9429              REX_reg_breg(dst, dst), // movzbl
9430              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9431   ins_pipe(pipe_slow); // XXX
9432 %}
9433 
9434 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
9435 %{
9436   match(Set dst (CmpLTMask p q));
9437   effect(KILL cr);
9438 
9439   ins_cost(400);
9440   format %{ "cmpl    $p, $q\t# cmpLTMask\n\t"
9441             "setlt   $dst\n\t"
9442             "movzbl  $dst, $dst\n\t"
9443             "negl    $dst" %}
9444   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
9445              setLT_reg(dst),
9446              REX_reg_breg(dst, dst), // movzbl
9447              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
9448              neg_reg(dst));
9449   ins_pipe(pipe_slow);
9450 %}
9451 
9452 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
9453 %{
9454   match(Set dst (CmpLTMask dst zero));
9455   effect(KILL cr);
9456 
9457   ins_cost(100);
9458   format %{ "sarl    $dst, #31\t# cmpLTMask0" %}
9459   ins_encode %{
9460   __ sarl($dst$$Register, 31);
9461   %}
9462   ins_pipe(ialu_reg);
9463 %}
9464 
9465 /* Better to save a register than avoid a branch */
9466 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9467 %{
9468   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
9469   effect(KILL cr);
9470   ins_cost(300);
9471   format %{ "subl   $p,$q\t# cadd_cmpLTMask\n\t"
9472             "jge    done\n\t"
9473             "addl   $p,$y\n"
9474             "done:  " %}
9475   ins_encode %{
9476     Register Rp = $p$$Register;
9477     Register Rq = $q$$Register;
9478     Register Ry = $y$$Register;
9479     Label done;
9480     __ subl(Rp, Rq);
9481     __ jccb(Assembler::greaterEqual, done);
9482     __ addl(Rp, Ry);
9483     __ bind(done);
9484   %}
9485   ins_pipe(pipe_cmplt);
9486 %}
9487 
9488 /* Better to save a register than avoid a branch */
9489 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9490 %{
9491   match(Set y (AndI (CmpLTMask p q) y));
9492   effect(KILL cr);
9493 
9494   ins_cost(300);
9495 
9496   format %{ "cmpl     $p, $q\t# and_cmpLTMask\n\t"
9497             "jlt      done\n\t"
9498             "xorl     $y, $y\n"
9499             "done:  " %}
9500   ins_encode %{
9501     Register Rp = $p$$Register;
9502     Register Rq = $q$$Register;
9503     Register Ry = $y$$Register;
9504     Label done;
9505     __ cmpl(Rp, Rq);
9506     __ jccb(Assembler::less, done);
9507     __ xorl(Ry, Ry);
9508     __ bind(done);
9509   %}
9510   ins_pipe(pipe_cmplt);
9511 %}
9512 
9513 
9514 //---------- FP Instructions------------------------------------------------
9515 
9516 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
9517 %{
9518   match(Set cr (CmpF src1 src2));
9519 
9520   ins_cost(145);
9521   format %{ "ucomiss $src1, $src2\n\t"
9522             "jnp,s   exit\n\t"
9523             "pushfq\t# saw NaN, set CF\n\t"
9524             "andq    [rsp], #0xffffff2b\n\t"
9525             "popfq\n"
9526     "exit:" %}
9527   ins_encode %{
9528     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9529     emit_cmpfp_fixup(_masm);
9530   %}
9531   ins_pipe(pipe_slow);
9532 %}
9533 
9534 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
9535   match(Set cr (CmpF src1 src2));
9536 
9537   ins_cost(100);
9538   format %{ "ucomiss $src1, $src2" %}
9539   ins_encode %{
9540     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9541   %}
9542   ins_pipe(pipe_slow);
9543 %}
9544 
9545 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
9546 %{
9547   match(Set cr (CmpF src1 (LoadF src2)));
9548 
9549   ins_cost(145);
9550   format %{ "ucomiss $src1, $src2\n\t"
9551             "jnp,s   exit\n\t"
9552             "pushfq\t# saw NaN, set CF\n\t"
9553             "andq    [rsp], #0xffffff2b\n\t"
9554             "popfq\n"
9555     "exit:" %}
9556   ins_encode %{
9557     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9558     emit_cmpfp_fixup(_masm);
9559   %}
9560   ins_pipe(pipe_slow);
9561 %}
9562 
9563 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
9564   match(Set cr (CmpF src1 (LoadF src2)));
9565 
9566   ins_cost(100);
9567   format %{ "ucomiss $src1, $src2" %}
9568   ins_encode %{
9569     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9570   %}
9571   ins_pipe(pipe_slow);
9572 %}
9573 
9574 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
9575   match(Set cr (CmpF src con));
9576 
9577   ins_cost(145);
9578   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9579             "jnp,s   exit\n\t"
9580             "pushfq\t# saw NaN, set CF\n\t"
9581             "andq    [rsp], #0xffffff2b\n\t"
9582             "popfq\n"
9583     "exit:" %}
9584   ins_encode %{
9585     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9586     emit_cmpfp_fixup(_masm);
9587   %}
9588   ins_pipe(pipe_slow);
9589 %}
9590 
9591 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
9592   match(Set cr (CmpF src con));
9593   ins_cost(100);
9594   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con" %}
9595   ins_encode %{
9596     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9597   %}
9598   ins_pipe(pipe_slow);
9599 %}
9600 
9601 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
9602 %{
9603   match(Set cr (CmpD src1 src2));
9604 
9605   ins_cost(145);
9606   format %{ "ucomisd $src1, $src2\n\t"
9607             "jnp,s   exit\n\t"
9608             "pushfq\t# saw NaN, set CF\n\t"
9609             "andq    [rsp], #0xffffff2b\n\t"
9610             "popfq\n"
9611     "exit:" %}
9612   ins_encode %{
9613     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9614     emit_cmpfp_fixup(_masm);
9615   %}
9616   ins_pipe(pipe_slow);
9617 %}
9618 
9619 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
9620   match(Set cr (CmpD src1 src2));
9621 
9622   ins_cost(100);
9623   format %{ "ucomisd $src1, $src2 test" %}
9624   ins_encode %{
9625     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9626   %}
9627   ins_pipe(pipe_slow);
9628 %}
9629 
9630 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
9631 %{
9632   match(Set cr (CmpD src1 (LoadD src2)));
9633 
9634   ins_cost(145);
9635   format %{ "ucomisd $src1, $src2\n\t"
9636             "jnp,s   exit\n\t"
9637             "pushfq\t# saw NaN, set CF\n\t"
9638             "andq    [rsp], #0xffffff2b\n\t"
9639             "popfq\n"
9640     "exit:" %}
9641   ins_encode %{
9642     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9643     emit_cmpfp_fixup(_masm);
9644   %}
9645   ins_pipe(pipe_slow);
9646 %}
9647 
9648 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
9649   match(Set cr (CmpD src1 (LoadD src2)));
9650 
9651   ins_cost(100);
9652   format %{ "ucomisd $src1, $src2" %}
9653   ins_encode %{
9654     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9655   %}
9656   ins_pipe(pipe_slow);
9657 %}
9658 
9659 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
9660   match(Set cr (CmpD src con));
9661 
9662   ins_cost(145);
9663   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9664             "jnp,s   exit\n\t"
9665             "pushfq\t# saw NaN, set CF\n\t"
9666             "andq    [rsp], #0xffffff2b\n\t"
9667             "popfq\n"
9668     "exit:" %}
9669   ins_encode %{
9670     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9671     emit_cmpfp_fixup(_masm);
9672   %}
9673   ins_pipe(pipe_slow);
9674 %}
9675 
9676 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
9677   match(Set cr (CmpD src con));
9678   ins_cost(100);
9679   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con" %}
9680   ins_encode %{
9681     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9682   %}
9683   ins_pipe(pipe_slow);
9684 %}
9685 
9686 // Compare into -1,0,1
9687 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
9688 %{
9689   match(Set dst (CmpF3 src1 src2));
9690   effect(KILL cr);
9691 
9692   ins_cost(275);
9693   format %{ "ucomiss $src1, $src2\n\t"
9694             "movl    $dst, #-1\n\t"
9695             "jp,s    done\n\t"
9696             "jb,s    done\n\t"
9697             "setne   $dst\n\t"
9698             "movzbl  $dst, $dst\n"
9699     "done:" %}
9700   ins_encode %{
9701     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9702     emit_cmpfp3(_masm, $dst$$Register);
9703   %}
9704   ins_pipe(pipe_slow);
9705 %}
9706 
9707 // Compare into -1,0,1
9708 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
9709 %{
9710   match(Set dst (CmpF3 src1 (LoadF src2)));
9711   effect(KILL cr);
9712 
9713   ins_cost(275);
9714   format %{ "ucomiss $src1, $src2\n\t"
9715             "movl    $dst, #-1\n\t"
9716             "jp,s    done\n\t"
9717             "jb,s    done\n\t"
9718             "setne   $dst\n\t"
9719             "movzbl  $dst, $dst\n"
9720     "done:" %}
9721   ins_encode %{
9722     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9723     emit_cmpfp3(_masm, $dst$$Register);
9724   %}
9725   ins_pipe(pipe_slow);
9726 %}
9727 
9728 // Compare into -1,0,1
9729 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
9730   match(Set dst (CmpF3 src con));
9731   effect(KILL cr);
9732 
9733   ins_cost(275);
9734   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9735             "movl    $dst, #-1\n\t"
9736             "jp,s    done\n\t"
9737             "jb,s    done\n\t"
9738             "setne   $dst\n\t"
9739             "movzbl  $dst, $dst\n"
9740     "done:" %}
9741   ins_encode %{
9742     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9743     emit_cmpfp3(_masm, $dst$$Register);
9744   %}
9745   ins_pipe(pipe_slow);
9746 %}
9747 
9748 // Compare into -1,0,1
9749 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
9750 %{
9751   match(Set dst (CmpD3 src1 src2));
9752   effect(KILL cr);
9753 
9754   ins_cost(275);
9755   format %{ "ucomisd $src1, $src2\n\t"
9756             "movl    $dst, #-1\n\t"
9757             "jp,s    done\n\t"
9758             "jb,s    done\n\t"
9759             "setne   $dst\n\t"
9760             "movzbl  $dst, $dst\n"
9761     "done:" %}
9762   ins_encode %{
9763     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9764     emit_cmpfp3(_masm, $dst$$Register);
9765   %}
9766   ins_pipe(pipe_slow);
9767 %}
9768 
9769 // Compare into -1,0,1
9770 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
9771 %{
9772   match(Set dst (CmpD3 src1 (LoadD src2)));
9773   effect(KILL cr);
9774 
9775   ins_cost(275);
9776   format %{ "ucomisd $src1, $src2\n\t"
9777             "movl    $dst, #-1\n\t"
9778             "jp,s    done\n\t"
9779             "jb,s    done\n\t"
9780             "setne   $dst\n\t"
9781             "movzbl  $dst, $dst\n"
9782     "done:" %}
9783   ins_encode %{
9784     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9785     emit_cmpfp3(_masm, $dst$$Register);
9786   %}
9787   ins_pipe(pipe_slow);
9788 %}
9789 
9790 // Compare into -1,0,1
9791 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
9792   match(Set dst (CmpD3 src con));
9793   effect(KILL cr);
9794 
9795   ins_cost(275);
9796   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9797             "movl    $dst, #-1\n\t"
9798             "jp,s    done\n\t"
9799             "jb,s    done\n\t"
9800             "setne   $dst\n\t"
9801             "movzbl  $dst, $dst\n"
9802     "done:" %}
9803   ins_encode %{
9804     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9805     emit_cmpfp3(_masm, $dst$$Register);
9806   %}
9807   ins_pipe(pipe_slow);
9808 %}
9809 
9810 // -----------Trig and Trancendental Instructions------------------------------
9811 instruct cosD_reg(regD dst) %{
9812   match(Set dst (CosD dst));
9813 
9814   format %{ "dcos   $dst\n\t" %}
9815   opcode(0xD9, 0xFF);
9816   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9817   ins_pipe( pipe_slow );
9818 %}
9819 
9820 instruct sinD_reg(regD dst) %{
9821   match(Set dst (SinD dst));
9822 
9823   format %{ "dsin   $dst\n\t" %}
9824   opcode(0xD9, 0xFE);
9825   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9826   ins_pipe( pipe_slow );
9827 %}
9828 
9829 instruct tanD_reg(regD dst) %{
9830   match(Set dst (TanD dst));
9831 
9832   format %{ "dtan   $dst\n\t" %}
9833   ins_encode( Push_SrcXD(dst),
9834               Opcode(0xD9), Opcode(0xF2),   //fptan
9835               Opcode(0xDD), Opcode(0xD8),   //fstp st
9836               Push_ResultXD(dst) );
9837   ins_pipe( pipe_slow );
9838 %}
9839 
9840 instruct log10D_reg(regD dst) %{
9841   // The source and result Double operands in XMM registers
9842   match(Set dst (Log10D dst));
9843   // fldlg2       ; push log_10(2) on the FPU stack; full 80-bit number
9844   // fyl2x        ; compute log_10(2) * log_2(x)
9845   format %{ "fldlg2\t\t\t#Log10\n\t"
9846             "fyl2x\t\t\t# Q=Log10*Log_2(x)\n\t"
9847          %}
9848    ins_encode(Opcode(0xD9), Opcode(0xEC),   // fldlg2
9849               Push_SrcXD(dst),
9850               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9851               Push_ResultXD(dst));
9852 
9853   ins_pipe( pipe_slow );
9854 %}
9855 
9856 instruct logD_reg(regD dst) %{
9857   // The source and result Double operands in XMM registers
9858   match(Set dst (LogD dst));
9859   // fldln2       ; push log_e(2) on the FPU stack; full 80-bit number
9860   // fyl2x        ; compute log_e(2) * log_2(x)
9861   format %{ "fldln2\t\t\t#Log_e\n\t"
9862             "fyl2x\t\t\t# Q=Log_e*Log_2(x)\n\t"
9863          %}
9864   ins_encode( Opcode(0xD9), Opcode(0xED),   // fldln2
9865               Push_SrcXD(dst),
9866               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9867               Push_ResultXD(dst));
9868   ins_pipe( pipe_slow );
9869 %}
9870 
9871 instruct powD_reg(regD dst, regD src0, regD src1, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9872   match(Set dst (PowD src0 src1));  // Raise src0 to the src1'th power
9873   effect(KILL rax, KILL rdx, KILL rcx, KILL cr);
9874   format %{ "fast_pow $src0 $src1 -&gt; $dst  // KILL $rax, $rcx, $rdx" %}
9875   ins_encode %{
9876     __ subptr(rsp, 8);
9877     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
9878     __ fld_d(Address(rsp, 0));
9879     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
9880     __ fld_d(Address(rsp, 0));
9881     __ fast_pow();
9882     __ fstp_d(Address(rsp, 0));
9883     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9884     __ addptr(rsp, 8);
9885   %}
9886   ins_pipe( pipe_slow );
9887 %}
9888 
9889 instruct expD_reg(regD dst, regD src, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9890   match(Set dst (ExpD src));
9891   effect(KILL rax, KILL rcx, KILL rdx, KILL cr);
9892   format %{ "fast_exp $dst -&gt; $src  // KILL $rax, $rcx, $rdx" %}
9893   ins_encode %{
9894     __ subptr(rsp, 8);
9895     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
9896     __ fld_d(Address(rsp, 0));
9897     __ fast_exp();
9898     __ fstp_d(Address(rsp, 0));
9899     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9900     __ addptr(rsp, 8);
9901   %}
9902   ins_pipe( pipe_slow );
9903 %}
9904 
9905 //----------Arithmetic Conversion Instructions---------------------------------
9906 
9907 instruct roundFloat_nop(regF dst)
9908 %{
9909   match(Set dst (RoundFloat dst));
9910 
9911   ins_cost(0);
9912   ins_encode();
9913   ins_pipe(empty);
9914 %}
9915 
9916 instruct roundDouble_nop(regD dst)
9917 %{
9918   match(Set dst (RoundDouble dst));
9919 
9920   ins_cost(0);
9921   ins_encode();
9922   ins_pipe(empty);
9923 %}
9924 
9925 instruct convF2D_reg_reg(regD dst, regF src)
9926 %{
9927   match(Set dst (ConvF2D src));
9928 
9929   format %{ "cvtss2sd $dst, $src" %}
9930   ins_encode %{
9931     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
9932   %}
9933   ins_pipe(pipe_slow); // XXX
9934 %}
9935 
9936 instruct convF2D_reg_mem(regD dst, memory src)
9937 %{
9938   match(Set dst (ConvF2D (LoadF src)));
9939 
9940   format %{ "cvtss2sd $dst, $src" %}
9941   ins_encode %{
9942     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
9943   %}
9944   ins_pipe(pipe_slow); // XXX
9945 %}
9946 
9947 instruct convD2F_reg_reg(regF dst, regD src)
9948 %{
9949   match(Set dst (ConvD2F src));
9950 
9951   format %{ "cvtsd2ss $dst, $src" %}
9952   ins_encode %{
9953     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
9954   %}
9955   ins_pipe(pipe_slow); // XXX
9956 %}
9957 
9958 instruct convD2F_reg_mem(regF dst, memory src)
9959 %{
9960   match(Set dst (ConvD2F (LoadD src)));
9961 
9962   format %{ "cvtsd2ss $dst, $src" %}
9963   ins_encode %{
9964     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
9965   %}
9966   ins_pipe(pipe_slow); // XXX
9967 %}
9968 
9969 // XXX do mem variants
9970 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
9971 %{
9972   match(Set dst (ConvF2I src));
9973   effect(KILL cr);
9974 
9975   format %{ "cvttss2sil $dst, $src\t# f2i\n\t"
9976             "cmpl    $dst, #0x80000000\n\t"
9977             "jne,s   done\n\t"
9978             "subq    rsp, #8\n\t"
9979             "movss   [rsp], $src\n\t"
9980             "call    f2i_fixup\n\t"
9981             "popq    $dst\n"
9982     "done:   "%}
9983   ins_encode %{
9984     Label done;
9985     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
9986     __ cmpl($dst$$Register, 0x80000000);
9987     __ jccb(Assembler::notEqual, done);
9988     __ subptr(rsp, 8);
9989     __ movflt(Address(rsp, 0), $src$$XMMRegister);
9990     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
9991     __ pop($dst$$Register);
9992     __ bind(done);
9993   %}
9994   ins_pipe(pipe_slow);
9995 %}
9996 
9997 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
9998 %{
9999   match(Set dst (ConvF2L src));
10000   effect(KILL cr);
10001 
10002   format %{ "cvttss2siq $dst, $src\t# f2l\n\t"
10003             "cmpq    $dst, [0x8000000000000000]\n\t"
10004             "jne,s   done\n\t"
10005             "subq    rsp, #8\n\t"
10006             "movss   [rsp], $src\n\t"
10007             "call    f2l_fixup\n\t"
10008             "popq    $dst\n"
10009     "done:   "%}
10010   ins_encode %{
10011     Label done;
10012     __ cvttss2siq($dst$$Register, $src$$XMMRegister);
10013     __ cmp64($dst$$Register,
10014              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10015     __ jccb(Assembler::notEqual, done);
10016     __ subptr(rsp, 8);
10017     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10018     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
10019     __ pop($dst$$Register);
10020     __ bind(done);
10021   %}
10022   ins_pipe(pipe_slow);
10023 %}
10024 
10025 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10026 %{
10027   match(Set dst (ConvD2I src));
10028   effect(KILL cr);
10029 
10030   format %{ "cvttsd2sil $dst, $src\t# d2i\n\t"
10031             "cmpl    $dst, #0x80000000\n\t"
10032             "jne,s   done\n\t"
10033             "subq    rsp, #8\n\t"
10034             "movsd   [rsp], $src\n\t"
10035             "call    d2i_fixup\n\t"
10036             "popq    $dst\n"
10037     "done:   "%}
10038   ins_encode %{
10039     Label done;
10040     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10041     __ cmpl($dst$$Register, 0x80000000);
10042     __ jccb(Assembler::notEqual, done);
10043     __ subptr(rsp, 8);
10044     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10045     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
10046     __ pop($dst$$Register);
10047     __ bind(done);
10048   %}
10049   ins_pipe(pipe_slow);
10050 %}
10051 
10052 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10053 %{
10054   match(Set dst (ConvD2L src));
10055   effect(KILL cr);
10056 
10057   format %{ "cvttsd2siq $dst, $src\t# d2l\n\t"
10058             "cmpq    $dst, [0x8000000000000000]\n\t"
10059             "jne,s   done\n\t"
10060             "subq    rsp, #8\n\t"
10061             "movsd   [rsp], $src\n\t"
10062             "call    d2l_fixup\n\t"
10063             "popq    $dst\n"
10064     "done:   "%}
10065   ins_encode %{
10066     Label done;
10067     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);
10068     __ cmp64($dst$$Register,
10069              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10070     __ jccb(Assembler::notEqual, done);
10071     __ subptr(rsp, 8);
10072     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10073     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
10074     __ pop($dst$$Register);
10075     __ bind(done);
10076   %}
10077   ins_pipe(pipe_slow);
10078 %}
10079 
10080 instruct convI2F_reg_reg(regF dst, rRegI src)
10081 %{
10082   predicate(!UseXmmI2F);
10083   match(Set dst (ConvI2F src));
10084 
10085   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10086   ins_encode %{
10087     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10088   %}
10089   ins_pipe(pipe_slow); // XXX
10090 %}
10091 
10092 instruct convI2F_reg_mem(regF dst, memory src)
10093 %{
10094   match(Set dst (ConvI2F (LoadI src)));
10095 
10096   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10097   ins_encode %{
10098     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10099   %}
10100   ins_pipe(pipe_slow); // XXX
10101 %}
10102 
10103 instruct convI2D_reg_reg(regD dst, rRegI src)
10104 %{
10105   predicate(!UseXmmI2D);
10106   match(Set dst (ConvI2D src));
10107 
10108   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10109   ins_encode %{
10110     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10111   %}
10112   ins_pipe(pipe_slow); // XXX
10113 %}
10114 
10115 instruct convI2D_reg_mem(regD dst, memory src)
10116 %{
10117   match(Set dst (ConvI2D (LoadI src)));
10118 
10119   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10120   ins_encode %{
10121     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10122   %}
10123   ins_pipe(pipe_slow); // XXX
10124 %}
10125 
10126 instruct convXI2F_reg(regF dst, rRegI src)
10127 %{
10128   predicate(UseXmmI2F);
10129   match(Set dst (ConvI2F src));
10130 
10131   format %{ "movdl $dst, $src\n\t"
10132             "cvtdq2psl $dst, $dst\t# i2f" %}
10133   ins_encode %{
10134     __ movdl($dst$$XMMRegister, $src$$Register);
10135     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10136   %}
10137   ins_pipe(pipe_slow); // XXX
10138 %}
10139 
10140 instruct convXI2D_reg(regD dst, rRegI src)
10141 %{
10142   predicate(UseXmmI2D);
10143   match(Set dst (ConvI2D src));
10144 
10145   format %{ "movdl $dst, $src\n\t"
10146             "cvtdq2pdl $dst, $dst\t# i2d" %}
10147   ins_encode %{
10148     __ movdl($dst$$XMMRegister, $src$$Register);
10149     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10150   %}
10151   ins_pipe(pipe_slow); // XXX
10152 %}
10153 
10154 instruct convL2F_reg_reg(regF dst, rRegL src)
10155 %{
10156   match(Set dst (ConvL2F src));
10157 
10158   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10159   ins_encode %{
10160     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10161   %}
10162   ins_pipe(pipe_slow); // XXX
10163 %}
10164 
10165 instruct convL2F_reg_mem(regF dst, memory src)
10166 %{
10167   match(Set dst (ConvL2F (LoadL src)));
10168 
10169   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10170   ins_encode %{
10171     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10172   %}
10173   ins_pipe(pipe_slow); // XXX
10174 %}
10175 
10176 instruct convL2D_reg_reg(regD dst, rRegL src)
10177 %{
10178   match(Set dst (ConvL2D src));
10179 
10180   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10181   ins_encode %{
10182     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10183   %}
10184   ins_pipe(pipe_slow); // XXX
10185 %}
10186 
10187 instruct convL2D_reg_mem(regD dst, memory src)
10188 %{
10189   match(Set dst (ConvL2D (LoadL src)));
10190 
10191   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10192   ins_encode %{
10193     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10194   %}
10195   ins_pipe(pipe_slow); // XXX
10196 %}
10197 
10198 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10199 %{
10200   match(Set dst (ConvI2L src));
10201 
10202   ins_cost(125);
10203   format %{ "movslq  $dst, $src\t# i2l" %}
10204   ins_encode %{
10205     __ movslq($dst$$Register, $src$$Register);
10206   %}
10207   ins_pipe(ialu_reg_reg);
10208 %}
10209 
10210 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10211 // %{
10212 //   match(Set dst (ConvI2L src));
10213 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10214 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10215 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10216 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10217 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10218 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10219 
10220 //   format %{ "movl    $dst, $src\t# unsigned i2l" %}
10221 //   ins_encode(enc_copy(dst, src));
10222 // //   opcode(0x63); // needs REX.W
10223 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10224 //   ins_pipe(ialu_reg_reg);
10225 // %}
10226 
10227 // Zero-extend convert int to long
10228 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10229 %{
10230   match(Set dst (AndL (ConvI2L src) mask));
10231 
10232   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10233   ins_encode %{
10234     if ($dst$$reg != $src$$reg) {
10235       __ movl($dst$$Register, $src$$Register);
10236     }
10237   %}
10238   ins_pipe(ialu_reg_reg);
10239 %}
10240 
10241 // Zero-extend convert int to long
10242 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10243 %{
10244   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10245 
10246   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10247   ins_encode %{
10248     __ movl($dst$$Register, $src$$Address);
10249   %}
10250   ins_pipe(ialu_reg_mem);
10251 %}
10252 
10253 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10254 %{
10255   match(Set dst (AndL src mask));
10256 
10257   format %{ "movl    $dst, $src\t# zero-extend long" %}
10258   ins_encode %{
10259     __ movl($dst$$Register, $src$$Register);
10260   %}
10261   ins_pipe(ialu_reg_reg);
10262 %}
10263 
10264 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10265 %{
10266   match(Set dst (ConvL2I src));
10267 
10268   format %{ "movl    $dst, $src\t# l2i" %}
10269   ins_encode %{
10270     __ movl($dst$$Register, $src$$Register);
10271   %}
10272   ins_pipe(ialu_reg_reg);
10273 %}
10274 
10275 
10276 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10277   match(Set dst (MoveF2I src));
10278   effect(DEF dst, USE src);
10279 
10280   ins_cost(125);
10281   format %{ "movl    $dst, $src\t# MoveF2I_stack_reg" %}
10282   ins_encode %{
10283     __ movl($dst$$Register, Address(rsp, $src$$disp));
10284   %}
10285   ins_pipe(ialu_reg_mem);
10286 %}
10287 
10288 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10289   match(Set dst (MoveI2F src));
10290   effect(DEF dst, USE src);
10291 
10292   ins_cost(125);
10293   format %{ "movss   $dst, $src\t# MoveI2F_stack_reg" %}
10294   ins_encode %{
10295     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10296   %}
10297   ins_pipe(pipe_slow);
10298 %}
10299 
10300 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10301   match(Set dst (MoveD2L src));
10302   effect(DEF dst, USE src);
10303 
10304   ins_cost(125);
10305   format %{ "movq    $dst, $src\t# MoveD2L_stack_reg" %}
10306   ins_encode %{
10307     __ movq($dst$$Register, Address(rsp, $src$$disp));
10308   %}
10309   ins_pipe(ialu_reg_mem);
10310 %}
10311 
10312 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10313   predicate(!UseXmmLoadAndClearUpper);
10314   match(Set dst (MoveL2D src));
10315   effect(DEF dst, USE src);
10316 
10317   ins_cost(125);
10318   format %{ "movlpd  $dst, $src\t# MoveL2D_stack_reg" %}
10319   ins_encode %{
10320     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10321   %}
10322   ins_pipe(pipe_slow);
10323 %}
10324 
10325 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10326   predicate(UseXmmLoadAndClearUpper);
10327   match(Set dst (MoveL2D src));
10328   effect(DEF dst, USE src);
10329 
10330   ins_cost(125);
10331   format %{ "movsd   $dst, $src\t# MoveL2D_stack_reg" %}
10332   ins_encode %{
10333     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10334   %}
10335   ins_pipe(pipe_slow);
10336 %}
10337 
10338 
10339 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10340   match(Set dst (MoveF2I src));
10341   effect(DEF dst, USE src);
10342 
10343   ins_cost(95); // XXX
10344   format %{ "movss   $dst, $src\t# MoveF2I_reg_stack" %}
10345   ins_encode %{
10346     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10347   %}
10348   ins_pipe(pipe_slow);
10349 %}
10350 
10351 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10352   match(Set dst (MoveI2F src));
10353   effect(DEF dst, USE src);
10354 
10355   ins_cost(100);
10356   format %{ "movl    $dst, $src\t# MoveI2F_reg_stack" %}
10357   ins_encode %{
10358     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10359   %}
10360   ins_pipe( ialu_mem_reg );
10361 %}
10362 
10363 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10364   match(Set dst (MoveD2L src));
10365   effect(DEF dst, USE src);
10366 
10367   ins_cost(95); // XXX
10368   format %{ "movsd   $dst, $src\t# MoveL2D_reg_stack" %}
10369   ins_encode %{
10370     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10371   %}
10372   ins_pipe(pipe_slow);
10373 %}
10374 
10375 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10376   match(Set dst (MoveL2D src));
10377   effect(DEF dst, USE src);
10378 
10379   ins_cost(100);
10380   format %{ "movq    $dst, $src\t# MoveL2D_reg_stack" %}
10381   ins_encode %{
10382     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10383   %}
10384   ins_pipe(ialu_mem_reg);
10385 %}
10386 
10387 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10388   match(Set dst (MoveF2I src));
10389   effect(DEF dst, USE src);
10390   ins_cost(85);
10391   format %{ "movd    $dst,$src\t# MoveF2I" %}
10392   ins_encode %{
10393     __ movdl($dst$$Register, $src$$XMMRegister);
10394   %}
10395   ins_pipe( pipe_slow );
10396 %}
10397 
10398 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10399   match(Set dst (MoveD2L src));
10400   effect(DEF dst, USE src);
10401   ins_cost(85);
10402   format %{ "movd    $dst,$src\t# MoveD2L" %}
10403   ins_encode %{
10404     __ movdq($dst$$Register, $src$$XMMRegister);
10405   %}
10406   ins_pipe( pipe_slow );
10407 %}
10408 
10409 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10410   match(Set dst (MoveI2F src));
10411   effect(DEF dst, USE src);
10412   ins_cost(100);
10413   format %{ "movd    $dst,$src\t# MoveI2F" %}
10414   ins_encode %{
10415     __ movdl($dst$$XMMRegister, $src$$Register);
10416   %}
10417   ins_pipe( pipe_slow );
10418 %}
10419 
10420 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10421   match(Set dst (MoveL2D src));
10422   effect(DEF dst, USE src);
10423   ins_cost(100);
10424   format %{ "movd    $dst,$src\t# MoveL2D" %}
10425   ins_encode %{
10426      __ movdq($dst$$XMMRegister, $src$$Register);
10427   %}
10428   ins_pipe( pipe_slow );
10429 %}
10430 
10431 
10432 // =======================================================================
10433 // fast clearing of an array
10434 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10435                   rFlagsReg cr)
10436 %{
10437   predicate(!UseFastStosb);
10438   match(Set dummy (ClearArray cnt base));
10439   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10440 
10441   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10442             "rep     stosq\t# Store rax to *rdi++ while rcx--" %}
10443   ins_encode %{
10444     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10445   %}
10446   ins_pipe(pipe_slow);
10447 %}
10448 
10449 instruct rep_fast_stosb(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10450                         rFlagsReg cr)
10451 %{
10452   predicate(UseFastStosb);
10453   match(Set dummy (ClearArray cnt base));
10454   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10455   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10456             "shlq    rcx,3\t# Convert doublewords to bytes\n\t"
10457             "rep     stosb\t# Store rax to *rdi++ while rcx--" %}
10458   ins_encode %{
10459     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10460   %}
10461   ins_pipe( pipe_slow );
10462 %}
10463 
10464 instruct string_compare(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10465                         rax_RegI result, regD tmp1, rFlagsReg cr)
10466 %{
10467   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10468   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10469 
10470   format %{ "String Compare $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10471   ins_encode %{
10472     __ string_compare($str1$$Register, $str2$$Register,
10473                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10474                       $tmp1$$XMMRegister);
10475   %}
10476   ins_pipe( pipe_slow );
10477 %}
10478 
10479 // fast search of substring with known size.
10480 instruct string_indexof_con(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10481                             rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10482 %{
10483   predicate(UseSSE42Intrinsics);
10484   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10485   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10486 
10487   format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10488   ins_encode %{
10489     int icnt2 = (int)$int_cnt2$$constant;
10490     if (icnt2 &gt;= 8) {
10491       // IndexOf for constant substrings with size &gt;= 8 elements
10492       // which don't need to be loaded through stack.
10493       __ string_indexofC8($str1$$Register, $str2$$Register,
10494                           $cnt1$$Register, $cnt2$$Register,
10495                           icnt2, $result$$Register,
10496                           $vec$$XMMRegister, $tmp$$Register);
10497     } else {
10498       // Small strings are loaded through stack if they cross page boundary.
10499       __ string_indexof($str1$$Register, $str2$$Register,
10500                         $cnt1$$Register, $cnt2$$Register,
10501                         icnt2, $result$$Register,
10502                         $vec$$XMMRegister, $tmp$$Register);
10503     }
10504   %}
10505   ins_pipe( pipe_slow );
10506 %}
10507 
10508 instruct string_indexof(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10509                         rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10510 %{
10511   predicate(UseSSE42Intrinsics);
10512   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10513   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10514 
10515   format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10516   ins_encode %{
10517     __ string_indexof($str1$$Register, $str2$$Register,
10518                       $cnt1$$Register, $cnt2$$Register,
10519                       (-1), $result$$Register,
10520                       $vec$$XMMRegister, $tmp$$Register);
10521   %}
10522   ins_pipe( pipe_slow );
10523 %}
10524 
10525 // fast string equals
10526 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
10527                        regD tmp1, regD tmp2, rbx_RegI tmp3, rFlagsReg cr)
10528 %{
10529   match(Set result (StrEquals (Binary str1 str2) cnt));
10530   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
10531 
10532   format %{ "String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3" %}
10533   ins_encode %{
10534     __ char_arrays_equals(false, $str1$$Register, $str2$$Register,
10535                           $cnt$$Register, $result$$Register, $tmp3$$Register,
10536                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10537   %}
10538   ins_pipe( pipe_slow );
10539 %}
10540 
10541 // fast array equals
10542 instruct array_equals(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
10543                       regD tmp1, regD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
10544 %{
10545   match(Set result (AryEq ary1 ary2));
10546   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
10547   //ins_cost(300);
10548 
10549   format %{ "Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4" %}
10550   ins_encode %{
10551     __ char_arrays_equals(true, $ary1$$Register, $ary2$$Register,
10552                           $tmp3$$Register, $result$$Register, $tmp4$$Register,
10553                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10554   %}
10555   ins_pipe( pipe_slow );
10556 %}
10557 
10558 // encode char[] to byte[] in ISO_8859_1
10559 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
10560                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
10561                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
10562   match(Set result (EncodeISOArray src (Binary dst len)));
10563   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
10564 
10565   format %{ "Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI " %}
10566   ins_encode %{
10567     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
10568                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
10569                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
10570   %}
10571   ins_pipe( pipe_slow );
10572 %}
10573 
10574 //----------Overflow Math Instructions-----------------------------------------
10575 
10576 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10577 %{
10578   match(Set cr (OverflowAddI op1 op2));
10579   effect(DEF cr, USE_KILL op1, USE op2);
10580 
10581   format %{ "addl    $op1, $op2\t# overflow check int" %}
10582 
10583   ins_encode %{
10584     __ addl($op1$$Register, $op2$$Register);
10585   %}
10586   ins_pipe(ialu_reg_reg);
10587 %}
10588 
10589 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
10590 %{
10591   match(Set cr (OverflowAddI op1 op2));
10592   effect(DEF cr, USE_KILL op1, USE op2);
10593 
10594   format %{ "addl    $op1, $op2\t# overflow check int" %}
10595 
10596   ins_encode %{
10597     __ addl($op1$$Register, $op2$$constant);
10598   %}
10599   ins_pipe(ialu_reg_reg);
10600 %}
10601 
10602 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10603 %{
10604   match(Set cr (OverflowAddL op1 op2));
10605   effect(DEF cr, USE_KILL op1, USE op2);
10606 
10607   format %{ "addq    $op1, $op2\t# overflow check long" %}
10608   ins_encode %{
10609     __ addq($op1$$Register, $op2$$Register);
10610   %}
10611   ins_pipe(ialu_reg_reg);
10612 %}
10613 
10614 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
10615 %{
10616   match(Set cr (OverflowAddL op1 op2));
10617   effect(DEF cr, USE_KILL op1, USE op2);
10618 
10619   format %{ "addq    $op1, $op2\t# overflow check long" %}
10620   ins_encode %{
10621     __ addq($op1$$Register, $op2$$constant);
10622   %}
10623   ins_pipe(ialu_reg_reg);
10624 %}
10625 
10626 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10627 %{
10628   match(Set cr (OverflowSubI op1 op2));
10629 
10630   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10631   ins_encode %{
10632     __ cmpl($op1$$Register, $op2$$Register);
10633   %}
10634   ins_pipe(ialu_reg_reg);
10635 %}
10636 
10637 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10638 %{
10639   match(Set cr (OverflowSubI op1 op2));
10640 
10641   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10642   ins_encode %{
10643     __ cmpl($op1$$Register, $op2$$constant);
10644   %}
10645   ins_pipe(ialu_reg_reg);
10646 %}
10647 
10648 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
10649 %{
10650   match(Set cr (OverflowSubL op1 op2));
10651 
10652   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10653   ins_encode %{
10654     __ cmpq($op1$$Register, $op2$$Register);
10655   %}
10656   ins_pipe(ialu_reg_reg);
10657 %}
10658 
10659 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
10660 %{
10661   match(Set cr (OverflowSubL op1 op2));
10662 
10663   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10664   ins_encode %{
10665     __ cmpq($op1$$Register, $op2$$constant);
10666   %}
10667   ins_pipe(ialu_reg_reg);
10668 %}
10669 
10670 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
10671 %{
10672   match(Set cr (OverflowSubI zero op2));
10673   effect(DEF cr, USE_KILL op2);
10674 
10675   format %{ "negl    $op2\t# overflow check int" %}
10676   ins_encode %{
10677     __ negl($op2$$Register);
10678   %}
10679   ins_pipe(ialu_reg_reg);
10680 %}
10681 
10682 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
10683 %{
10684   match(Set cr (OverflowSubL zero op2));
10685   effect(DEF cr, USE_KILL op2);
10686 
10687   format %{ "negq    $op2\t# overflow check long" %}
10688   ins_encode %{
10689     __ negq($op2$$Register);
10690   %}
10691   ins_pipe(ialu_reg_reg);
10692 %}
10693 
10694 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10695 %{
10696   match(Set cr (OverflowMulI op1 op2));
10697   effect(DEF cr, USE_KILL op1, USE op2);
10698 
10699   format %{ "imull    $op1, $op2\t# overflow check int" %}
10700   ins_encode %{
10701     __ imull($op1$$Register, $op2$$Register);
10702   %}
10703   ins_pipe(ialu_reg_reg_alu0);
10704 %}
10705 
10706 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
10707 %{
10708   match(Set cr (OverflowMulI op1 op2));
10709   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10710 
10711   format %{ "imull    $tmp, $op1, $op2\t# overflow check int" %}
10712   ins_encode %{
10713     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
10714   %}
10715   ins_pipe(ialu_reg_reg_alu0);
10716 %}
10717 
10718 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10719 %{
10720   match(Set cr (OverflowMulL op1 op2));
10721   effect(DEF cr, USE_KILL op1, USE op2);
10722 
10723   format %{ "imulq    $op1, $op2\t# overflow check long" %}
10724   ins_encode %{
10725     __ imulq($op1$$Register, $op2$$Register);
10726   %}
10727   ins_pipe(ialu_reg_reg_alu0);
10728 %}
10729 
10730 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
10731 %{
10732   match(Set cr (OverflowMulL op1 op2));
10733   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10734 
10735   format %{ "imulq    $tmp, $op1, $op2\t# overflow check long" %}
10736   ins_encode %{
10737     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
10738   %}
10739   ins_pipe(ialu_reg_reg_alu0);
10740 %}
10741 
10742 
10743 //----------Control Flow Instructions------------------------------------------
10744 // Signed compare Instructions
10745 
10746 // XXX more variants!!
10747 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10748 %{
10749   match(Set cr (CmpI op1 op2));
10750   effect(DEF cr, USE op1, USE op2);
10751 
10752   format %{ "cmpl    $op1, $op2" %}
10753   opcode(0x3B);  /* Opcode 3B /r */
10754   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10755   ins_pipe(ialu_cr_reg_reg);
10756 %}
10757 
10758 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10759 %{
10760   match(Set cr (CmpI op1 op2));
10761 
10762   format %{ "cmpl    $op1, $op2" %}
10763   opcode(0x81, 0x07); /* Opcode 81 /7 */
10764   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10765   ins_pipe(ialu_cr_reg_imm);
10766 %}
10767 
10768 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
10769 %{
10770   match(Set cr (CmpI op1 (LoadI op2)));
10771 
10772   ins_cost(500); // XXX
10773   format %{ "cmpl    $op1, $op2" %}
10774   opcode(0x3B); /* Opcode 3B /r */
10775   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10776   ins_pipe(ialu_cr_reg_mem);
10777 %}
10778 
10779 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
10780 %{
10781   match(Set cr (CmpI src zero));
10782 
10783   format %{ "testl   $src, $src" %}
10784   opcode(0x85);
10785   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10786   ins_pipe(ialu_cr_reg_imm);
10787 %}
10788 
10789 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
10790 %{
10791   match(Set cr (CmpI (AndI src con) zero));
10792 
10793   format %{ "testl   $src, $con" %}
10794   opcode(0xF7, 0x00);
10795   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
10796   ins_pipe(ialu_cr_reg_imm);
10797 %}
10798 
10799 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
10800 %{
10801   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
10802 
10803   format %{ "testl   $src, $mem" %}
10804   opcode(0x85);
10805   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
10806   ins_pipe(ialu_cr_reg_mem);
10807 %}
10808 
10809 // Unsigned compare Instructions; really, same as signed except they
10810 // produce an rFlagsRegU instead of rFlagsReg.
10811 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
10812 %{
10813   match(Set cr (CmpU op1 op2));
10814 
10815   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10816   opcode(0x3B); /* Opcode 3B /r */
10817   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10818   ins_pipe(ialu_cr_reg_reg);
10819 %}
10820 
10821 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
10822 %{
10823   match(Set cr (CmpU op1 op2));
10824 
10825   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10826   opcode(0x81,0x07); /* Opcode 81 /7 */
10827   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10828   ins_pipe(ialu_cr_reg_imm);
10829 %}
10830 
10831 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
10832 %{
10833   match(Set cr (CmpU op1 (LoadI op2)));
10834 
10835   ins_cost(500); // XXX
10836   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10837   opcode(0x3B); /* Opcode 3B /r */
10838   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10839   ins_pipe(ialu_cr_reg_mem);
10840 %}
10841 
10842 // // // Cisc-spilled version of cmpU_rReg
10843 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
10844 // //%{
10845 // //  match(Set cr (CmpU (LoadI op1) op2));
10846 // //
10847 // //  format %{ "CMPu   $op1,$op2" %}
10848 // //  ins_cost(500);
10849 // //  opcode(0x39);  /* Opcode 39 /r */
10850 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10851 // //%}
10852 
10853 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
10854 %{
10855   match(Set cr (CmpU src zero));
10856 
10857   format %{ "testl  $src, $src\t# unsigned" %}
10858   opcode(0x85);
10859   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10860   ins_pipe(ialu_cr_reg_imm);
10861 %}
10862 
10863 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
10864 %{
10865   match(Set cr (CmpP op1 op2));
10866 
10867   format %{ "cmpq    $op1, $op2\t# ptr" %}
10868   opcode(0x3B); /* Opcode 3B /r */
10869   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
10870   ins_pipe(ialu_cr_reg_reg);
10871 %}
10872 
10873 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
10874 %{
10875   match(Set cr (CmpP op1 (LoadP op2)));
10876 
10877   ins_cost(500); // XXX
10878   format %{ "cmpq    $op1, $op2\t# ptr" %}
10879   opcode(0x3B); /* Opcode 3B /r */
10880   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10881   ins_pipe(ialu_cr_reg_mem);
10882 %}
10883 
10884 // // // Cisc-spilled version of cmpP_rReg
10885 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
10886 // //%{
10887 // //  match(Set cr (CmpP (LoadP op1) op2));
10888 // //
10889 // //  format %{ "CMPu   $op1,$op2" %}
10890 // //  ins_cost(500);
10891 // //  opcode(0x39);  /* Opcode 39 /r */
10892 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10893 // //%}
10894 
10895 // XXX this is generalized by compP_rReg_mem???
10896 // Compare raw pointer (used in out-of-heap check).
10897 // Only works because non-oop pointers must be raw pointers
10898 // and raw pointers have no anti-dependencies.
10899 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
10900 %{
10901   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);
10902   match(Set cr (CmpP op1 (LoadP op2)));
10903 
10904   format %{ "cmpq    $op1, $op2\t# raw ptr" %}
10905   opcode(0x3B); /* Opcode 3B /r */
10906   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10907   ins_pipe(ialu_cr_reg_mem);
10908 %}
10909 
10910 // This will generate a signed flags result. This should be OK since
10911 // any compare to a zero should be eq/neq.
10912 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
10913 %{
10914   match(Set cr (CmpP src zero));
10915 
10916   format %{ "testq   $src, $src\t# ptr" %}
10917   opcode(0x85);
10918   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
10919   ins_pipe(ialu_cr_reg_imm);
10920 %}
10921 
10922 // This will generate a signed flags result. This should be OK since
10923 // any compare to a zero should be eq/neq.
10924 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
10925 %{
10926   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
10927   match(Set cr (CmpP (LoadP op) zero));
10928 
10929   ins_cost(500); // XXX
10930   format %{ "testq   $op, 0xffffffffffffffff\t# ptr" %}
10931   opcode(0xF7); /* Opcode F7 /0 */
10932   ins_encode(REX_mem_wide(op),
10933              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
10934   ins_pipe(ialu_cr_reg_imm);
10935 %}
10936 
10937 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
10938 %{
10939   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
10940   match(Set cr (CmpP (LoadP mem) zero));
10941 
10942   format %{ "cmpq    R12, $mem\t# ptr (R12_heapbase==0)" %}
10943   ins_encode %{
10944     __ cmpq(r12, $mem$$Address);
10945   %}
10946   ins_pipe(ialu_cr_reg_mem);
10947 %}
10948 
10949 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
10950 %{
10951   match(Set cr (CmpN op1 op2));
10952 
10953   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10954   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
10955   ins_pipe(ialu_cr_reg_reg);
10956 %}
10957 
10958 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
10959 %{
10960   match(Set cr (CmpN src (LoadN mem)));
10961 
10962   format %{ "cmpl    $src, $mem\t# compressed ptr" %}
10963   ins_encode %{
10964     __ cmpl($src$$Register, $mem$$Address);
10965   %}
10966   ins_pipe(ialu_cr_reg_mem);
10967 %}
10968 
10969 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
10970   match(Set cr (CmpN op1 op2));
10971 
10972   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10973   ins_encode %{
10974     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
10975   %}
10976   ins_pipe(ialu_cr_reg_imm);
10977 %}
10978 
10979 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
10980 %{
10981   match(Set cr (CmpN src (LoadN mem)));
10982 
10983   format %{ "cmpl    $mem, $src\t# compressed ptr" %}
10984   ins_encode %{
10985     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
10986   %}
10987   ins_pipe(ialu_cr_reg_mem);
10988 %}
10989 
10990 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
10991   match(Set cr (CmpN op1 op2));
10992 
10993   format %{ "cmpl    $op1, $op2\t# compressed klass ptr" %}
10994   ins_encode %{
10995     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
10996   %}
10997   ins_pipe(ialu_cr_reg_imm);
10998 %}
10999 
11000 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11001 %{
11002   match(Set cr (CmpN src (LoadNKlass mem)));
11003 
11004   format %{ "cmpl    $mem, $src\t# compressed klass ptr" %}
11005   ins_encode %{
11006     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11007   %}
11008   ins_pipe(ialu_cr_reg_mem);
11009 %}
11010 
11011 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11012   match(Set cr (CmpN src zero));
11013 
11014   format %{ "testl   $src, $src\t# compressed ptr" %}
11015   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11016   ins_pipe(ialu_cr_reg_imm);
11017 %}
11018 
11019 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11020 %{
11021   predicate(Universe::narrow_oop_base() != NULL);
11022   match(Set cr (CmpN (LoadN mem) zero));
11023 
11024   ins_cost(500); // XXX
11025   format %{ "testl   $mem, 0xffffffff\t# compressed ptr" %}
11026   ins_encode %{
11027     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11028   %}
11029   ins_pipe(ialu_cr_reg_mem);
11030 %}
11031 
11032 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11033 %{
11034   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));
11035   match(Set cr (CmpN (LoadN mem) zero));
11036 
11037   format %{ "cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)" %}
11038   ins_encode %{
11039     __ cmpl(r12, $mem$$Address);
11040   %}
11041   ins_pipe(ialu_cr_reg_mem);
11042 %}
11043 
11044 // Yanked all unsigned pointer compare operations.
11045 // Pointer compares are done with CmpP which is already unsigned.
11046 
11047 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11048 %{
11049   match(Set cr (CmpL op1 op2));
11050 
11051   format %{ "cmpq    $op1, $op2" %}
11052   opcode(0x3B);  /* Opcode 3B /r */
11053   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11054   ins_pipe(ialu_cr_reg_reg);
11055 %}
11056 
11057 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11058 %{
11059   match(Set cr (CmpL op1 op2));
11060 
11061   format %{ "cmpq    $op1, $op2" %}
11062   opcode(0x81, 0x07); /* Opcode 81 /7 */
11063   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11064   ins_pipe(ialu_cr_reg_imm);
11065 %}
11066 
11067 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11068 %{
11069   match(Set cr (CmpL op1 (LoadL op2)));
11070 
11071   format %{ "cmpq    $op1, $op2" %}
11072   opcode(0x3B); /* Opcode 3B /r */
11073   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11074   ins_pipe(ialu_cr_reg_mem);
11075 %}
11076 
11077 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11078 %{
11079   match(Set cr (CmpL src zero));
11080 
11081   format %{ "testq   $src, $src" %}
11082   opcode(0x85);
11083   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11084   ins_pipe(ialu_cr_reg_imm);
11085 %}
11086 
11087 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11088 %{
11089   match(Set cr (CmpL (AndL src con) zero));
11090 
11091   format %{ "testq   $src, $con\t# long" %}
11092   opcode(0xF7, 0x00);
11093   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11094   ins_pipe(ialu_cr_reg_imm);
11095 %}
11096 
11097 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11098 %{
11099   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11100 
11101   format %{ "testq   $src, $mem" %}
11102   opcode(0x85);
11103   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11104   ins_pipe(ialu_cr_reg_mem);
11105 %}
11106 
11107 // Manifest a CmpL result in an integer register.  Very painful.
11108 // This is the test to avoid.
11109 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11110 %{
11111   match(Set dst (CmpL3 src1 src2));
11112   effect(KILL flags);
11113 
11114   ins_cost(275); // XXX
11115   format %{ "cmpq    $src1, $src2\t# CmpL3\n\t"
11116             "movl    $dst, -1\n\t"
11117             "jl,s    done\n\t"
11118             "setne   $dst\n\t"
11119             "movzbl  $dst, $dst\n\t"
11120     "done:" %}
11121   ins_encode(cmpl3_flag(src1, src2, dst));
11122   ins_pipe(pipe_slow);
11123 %}
11124 
11125 //----------Max and Min--------------------------------------------------------
11126 // Min Instructions
11127 
11128 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11129 %{
11130   effect(USE_DEF dst, USE src, USE cr);
11131 
11132   format %{ "cmovlgt $dst, $src\t# min" %}
11133   opcode(0x0F, 0x4F);
11134   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11135   ins_pipe(pipe_cmov_reg);
11136 %}
11137 
11138 
11139 instruct minI_rReg(rRegI dst, rRegI src)
11140 %{
11141   match(Set dst (MinI dst src));
11142 
11143   ins_cost(200);
11144   expand %{
11145     rFlagsReg cr;
11146     compI_rReg(cr, dst, src);
11147     cmovI_reg_g(dst, src, cr);
11148   %}
11149 %}
11150 
11151 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
11152 %{
11153   effect(USE_DEF dst, USE src, USE cr);
11154 
11155   format %{ "cmovllt $dst, $src\t# max" %}
11156   opcode(0x0F, 0x4C);
11157   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11158   ins_pipe(pipe_cmov_reg);
11159 %}
11160 
11161 
11162 instruct maxI_rReg(rRegI dst, rRegI src)
11163 %{
11164   match(Set dst (MaxI dst src));
11165 
11166   ins_cost(200);
11167   expand %{
11168     rFlagsReg cr;
11169     compI_rReg(cr, dst, src);
11170     cmovI_reg_l(dst, src, cr);
11171   %}
11172 %}
11173 
11174 // ============================================================================
11175 // Branch Instructions
11176 
11177 // Jump Direct - Label defines a relative address from JMP+1
11178 instruct jmpDir(label labl)
11179 %{
11180   match(Goto);
11181   effect(USE labl);
11182 
11183   ins_cost(300);
11184   format %{ "jmp     $labl" %}
11185   size(5);
11186   ins_encode %{
11187     Label* L = $labl$$label;
11188     __ jmp(*L, false); // Always long jump
11189   %}
11190   ins_pipe(pipe_jmp);
11191 %}
11192 
11193 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11194 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
11195 %{
11196   match(If cop cr);
11197   effect(USE labl);
11198 
11199   ins_cost(300);
11200   format %{ "j$cop     $labl" %}
11201   size(6);
11202   ins_encode %{
11203     Label* L = $labl$$label;
11204     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11205   %}
11206   ins_pipe(pipe_jcc);
11207 %}
11208 
11209 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11210 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
11211 %{
11212   match(CountedLoopEnd cop cr);
11213   effect(USE labl);
11214 
11215   ins_cost(300);
11216   format %{ "j$cop     $labl\t# loop end" %}
11217   size(6);
11218   ins_encode %{
11219     Label* L = $labl$$label;
11220     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11221   %}
11222   ins_pipe(pipe_jcc);
11223 %}
11224 
11225 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11226 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11227   match(CountedLoopEnd cop cmp);
11228   effect(USE labl);
11229 
11230   ins_cost(300);
11231   format %{ "j$cop,u   $labl\t# loop end" %}
11232   size(6);
11233   ins_encode %{
11234     Label* L = $labl$$label;
11235     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11236   %}
11237   ins_pipe(pipe_jcc);
11238 %}
11239 
11240 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11241   match(CountedLoopEnd cop cmp);
11242   effect(USE labl);
11243 
11244   ins_cost(200);
11245   format %{ "j$cop,u   $labl\t# loop end" %}
11246   size(6);
11247   ins_encode %{
11248     Label* L = $labl$$label;
11249     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11250   %}
11251   ins_pipe(pipe_jcc);
11252 %}
11253 
11254 // Jump Direct Conditional - using unsigned comparison
11255 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11256   match(If cop cmp);
11257   effect(USE labl);
11258 
11259   ins_cost(300);
11260   format %{ "j$cop,u  $labl" %}
11261   size(6);
11262   ins_encode %{
11263     Label* L = $labl$$label;
11264     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11265   %}
11266   ins_pipe(pipe_jcc);
11267 %}
11268 
11269 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11270   match(If cop cmp);
11271   effect(USE labl);
11272 
11273   ins_cost(200);
11274   format %{ "j$cop,u  $labl" %}
11275   size(6);
11276   ins_encode %{
11277     Label* L = $labl$$label;
11278     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11279   %}
11280   ins_pipe(pipe_jcc);
11281 %}
11282 
11283 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11284   match(If cop cmp);
11285   effect(USE labl);
11286 
11287   ins_cost(200);
11288   format %{ $$template
11289     if ($cop$$cmpcode == Assembler::notEqual) {
11290       $$emit$$"jp,u   $labl\n\t"
11291       $$emit$$"j$cop,u   $labl"
11292     } else {
11293       $$emit$$"jp,u   done\n\t"
11294       $$emit$$"j$cop,u   $labl\n\t"
11295       $$emit$$"done:"
11296     }
11297   %}
11298   ins_encode %{
11299     Label* l = $labl$$label;
11300     if ($cop$$cmpcode == Assembler::notEqual) {
11301       __ jcc(Assembler::parity, *l, false);
11302       __ jcc(Assembler::notEqual, *l, false);
11303     } else if ($cop$$cmpcode == Assembler::equal) {
11304       Label done;
11305       __ jccb(Assembler::parity, done);
11306       __ jcc(Assembler::equal, *l, false);
11307       __ bind(done);
11308     } else {
11309        ShouldNotReachHere();
11310     }
11311   %}
11312   ins_pipe(pipe_jcc);
11313 %}
11314 
11315 // ============================================================================
11316 // The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
11317 // superklass array for an instance of the superklass.  Set a hidden
11318 // internal cache on a hit (cache is checked with exposed code in
11319 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
11320 // encoding ALSO sets flags.
11321 
11322 instruct partialSubtypeCheck(rdi_RegP result,
11323                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11324                              rFlagsReg cr)
11325 %{
11326   match(Set result (PartialSubtypeCheck sub super));
11327   effect(KILL rcx, KILL cr);
11328 
11329   ins_cost(1100);  // slightly larger than the next version
11330   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11331             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11332             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11333             "repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t"
11334             "jne,s   miss\t\t# Missed: rdi not-zero\n\t"
11335             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11336             "xorq    $result, $result\t\t Hit: rdi zero\n\t"
11337     "miss:\t" %}
11338 
11339   opcode(0x1); // Force a XOR of RDI
11340   ins_encode(enc_PartialSubtypeCheck());
11341   ins_pipe(pipe_slow);
11342 %}
11343 
11344 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
11345                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11346                                      immP0 zero,
11347                                      rdi_RegP result)
11348 %{
11349   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
11350   effect(KILL rcx, KILL result);
11351 
11352   ins_cost(1000);
11353   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11354             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11355             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11356             "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
11357             "jne,s   miss\t\t# Missed: flags nz\n\t"
11358             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11359     "miss:\t" %}
11360 
11361   opcode(0x0); // No need to XOR RDI
11362   ins_encode(enc_PartialSubtypeCheck());
11363   ins_pipe(pipe_slow);
11364 %}
11365 
11366 // ============================================================================
11367 // Branch Instructions -- short offset versions
11368 //
11369 // These instructions are used to replace jumps of a long offset (the default
11370 // match) with jumps of a shorter offset.  These instructions are all tagged
11371 // with the ins_short_branch attribute, which causes the ADLC to suppress the
11372 // match rules in general matching.  Instead, the ADLC generates a conversion
11373 // method in the MachNode which can be used to do in-place replacement of the
11374 // long variant with the shorter variant.  The compiler will determine if a
11375 // branch can be taken by the is_short_branch_offset() predicate in the machine
11376 // specific code section of the file.
11377 
11378 // Jump Direct - Label defines a relative address from JMP+1
11379 instruct jmpDir_short(label labl) %{
11380   match(Goto);
11381   effect(USE labl);
11382 
11383   ins_cost(300);
11384   format %{ "jmp,s   $labl" %}
11385   size(2);
11386   ins_encode %{
11387     Label* L = $labl$$label;
11388     __ jmpb(*L);
11389   %}
11390   ins_pipe(pipe_jmp);
11391   ins_short_branch(1);
11392 %}
11393 
11394 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11395 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
11396   match(If cop cr);
11397   effect(USE labl);
11398 
11399   ins_cost(300);
11400   format %{ "j$cop,s   $labl" %}
11401   size(2);
11402   ins_encode %{
11403     Label* L = $labl$$label;
11404     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11405   %}
11406   ins_pipe(pipe_jcc);
11407   ins_short_branch(1);
11408 %}
11409 
11410 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11411 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
11412   match(CountedLoopEnd cop cr);
11413   effect(USE labl);
11414 
11415   ins_cost(300);
11416   format %{ "j$cop,s   $labl\t# loop end" %}
11417   size(2);
11418   ins_encode %{
11419     Label* L = $labl$$label;
11420     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11421   %}
11422   ins_pipe(pipe_jcc);
11423   ins_short_branch(1);
11424 %}
11425 
11426 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11427 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11428   match(CountedLoopEnd cop cmp);
11429   effect(USE labl);
11430 
11431   ins_cost(300);
11432   format %{ "j$cop,us  $labl\t# loop end" %}
11433   size(2);
11434   ins_encode %{
11435     Label* L = $labl$$label;
11436     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11437   %}
11438   ins_pipe(pipe_jcc);
11439   ins_short_branch(1);
11440 %}
11441 
11442 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11443   match(CountedLoopEnd cop cmp);
11444   effect(USE labl);
11445 
11446   ins_cost(300);
11447   format %{ "j$cop,us  $labl\t# loop end" %}
11448   size(2);
11449   ins_encode %{
11450     Label* L = $labl$$label;
11451     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11452   %}
11453   ins_pipe(pipe_jcc);
11454   ins_short_branch(1);
11455 %}
11456 
11457 // Jump Direct Conditional - using unsigned comparison
11458 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11459   match(If cop cmp);
11460   effect(USE labl);
11461 
11462   ins_cost(300);
11463   format %{ "j$cop,us  $labl" %}
11464   size(2);
11465   ins_encode %{
11466     Label* L = $labl$$label;
11467     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11468   %}
11469   ins_pipe(pipe_jcc);
11470   ins_short_branch(1);
11471 %}
11472 
11473 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11474   match(If cop cmp);
11475   effect(USE labl);
11476 
11477   ins_cost(300);
11478   format %{ "j$cop,us  $labl" %}
11479   size(2);
11480   ins_encode %{
11481     Label* L = $labl$$label;
11482     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11483   %}
11484   ins_pipe(pipe_jcc);
11485   ins_short_branch(1);
11486 %}
11487 
11488 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11489   match(If cop cmp);
11490   effect(USE labl);
11491 
11492   ins_cost(300);
11493   format %{ $$template
11494     if ($cop$$cmpcode == Assembler::notEqual) {
11495       $$emit$$"jp,u,s   $labl\n\t"
11496       $$emit$$"j$cop,u,s   $labl"
11497     } else {
11498       $$emit$$"jp,u,s   done\n\t"
11499       $$emit$$"j$cop,u,s  $labl\n\t"
11500       $$emit$$"done:"
11501     }
11502   %}
11503   size(4);
11504   ins_encode %{
11505     Label* l = $labl$$label;
11506     if ($cop$$cmpcode == Assembler::notEqual) {
11507       __ jccb(Assembler::parity, *l);
11508       __ jccb(Assembler::notEqual, *l);
11509     } else if ($cop$$cmpcode == Assembler::equal) {
11510       Label done;
11511       __ jccb(Assembler::parity, done);
11512       __ jccb(Assembler::equal, *l);
11513       __ bind(done);
11514     } else {
11515        ShouldNotReachHere();
11516     }
11517   %}
11518   ins_pipe(pipe_jcc);
11519   ins_short_branch(1);
11520 %}
11521 
11522 // ============================================================================
11523 // inlined locking and unlocking
11524 
11525 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
11526   predicate(Compile::current()-&gt;use_rtm());
11527   match(Set cr (FastLock object box));
11528   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
11529   ins_cost(300);
11530   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2" %}
11531   ins_encode %{
11532     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11533                  $scr$$Register, $cx1$$Register, $cx2$$Register,
11534                  _counters, _rtm_counters, _stack_rtm_counters,
11535                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11536                  true, ra_-&gt;C-&gt;profile_rtm());
11537   %}
11538   ins_pipe(pipe_slow);
11539 %}
11540 
11541 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
11542   predicate(!Compile::current()-&gt;use_rtm());
11543   match(Set cr (FastLock object box));
11544   effect(TEMP tmp, TEMP scr, USE_KILL box);
11545   ins_cost(300);
11546   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr" %}
11547   ins_encode %{
11548     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11549                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
11550   %}
11551   ins_pipe(pipe_slow);
11552 %}
11553 
11554 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
11555   match(Set cr (FastUnlock object box));
11556   effect(TEMP tmp, USE_KILL box);
11557   ins_cost(300);
11558   format %{ "fastunlock $object,$box\t! kills $box,$tmp" %}
11559   ins_encode %{
11560     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
11561   %}
11562   ins_pipe(pipe_slow);
11563 %}
11564 
11565 
11566 // ============================================================================
11567 // Safepoint Instructions
11568 instruct safePoint_poll(rFlagsReg cr)
11569 %{
11570   predicate(!Assembler::is_polling_page_far());
11571   match(SafePoint);
11572   effect(KILL cr);
11573 
11574   format %{ "testl  rax, [rip + #offset_to_poll_page]\t"
11575             "# Safepoint: poll for GC" %}
11576   ins_cost(125);
11577   ins_encode %{
11578     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
11579     __ testl(rax, addr);
11580   %}
11581   ins_pipe(ialu_reg_mem);
11582 %}
11583 
11584 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
11585 %{
11586   predicate(Assembler::is_polling_page_far());
11587   match(SafePoint poll);
11588   effect(KILL cr, USE poll);
11589 
11590   format %{ "testl  rax, [$poll]\t"
11591             "# Safepoint: poll for GC" %}
11592   ins_cost(125);
11593   ins_encode %{
11594     __ relocate(relocInfo::poll_type);
11595     __ testl(rax, Address($poll$$Register, 0));
11596   %}
11597   ins_pipe(ialu_reg_mem);
11598 %}
11599 
11600 // ============================================================================
11601 // Procedure Call/Return Instructions
11602 // Call Java Static Instruction
11603 // Note: If this code changes, the corresponding ret_addr_offset() and
11604 //       compute_padding() functions will have to be adjusted.
11605 instruct CallStaticJavaDirect(method meth) %{
11606   match(CallStaticJava);
11607   effect(USE meth);
11608 
11609   ins_cost(300);
11610   format %{ "call,static " %}
11611   opcode(0xE8); /* E8 cd */
11612   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
11613   ins_pipe(pipe_slow);
11614   ins_alignment(4);
11615 %}
11616 
11617 // Call Java Dynamic Instruction
11618 // Note: If this code changes, the corresponding ret_addr_offset() and
11619 //       compute_padding() functions will have to be adjusted.
11620 instruct CallDynamicJavaDirect(method meth)
11621 %{
11622   match(CallDynamicJava);
11623   effect(USE meth);
11624 
11625   ins_cost(300);
11626   format %{ "movq    rax, #Universe::non_oop_word()\n\t"
11627             "call,dynamic " %}
11628   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
11629   ins_pipe(pipe_slow);
11630   ins_alignment(4);
11631 %}
11632 
11633 // Call Runtime Instruction
11634 instruct CallRuntimeDirect(method meth)
11635 %{
11636   match(CallRuntime);
11637   effect(USE meth);
11638 
11639   ins_cost(300);
11640   format %{ "call,runtime " %}
11641   ins_encode(clear_avx, Java_To_Runtime(meth));
11642   ins_pipe(pipe_slow);
11643 %}
11644 
11645 // Call runtime without safepoint
11646 instruct CallLeafDirect(method meth)
11647 %{
11648   match(CallLeaf);
11649   effect(USE meth);
11650 
11651   ins_cost(300);
11652   format %{ "call_leaf,runtime " %}
11653   ins_encode(clear_avx, Java_To_Runtime(meth));
11654   ins_pipe(pipe_slow);
11655 %}
11656 
11657 // Call runtime without safepoint
11658 instruct CallLeafNoFPDirect(method meth)
11659 %{
11660   match(CallLeafNoFP);
11661   effect(USE meth);
11662 
11663   ins_cost(300);
11664   format %{ "call_leaf_nofp,runtime " %}
11665   ins_encode(Java_To_Runtime(meth));
11666   ins_pipe(pipe_slow);
11667 %}
11668 
11669 // Return Instruction
11670 // Remove the return address &amp; jump to it.
11671 // Notice: We always emit a nop after a ret to make sure there is room
11672 // for safepoint patching
11673 instruct Ret()
11674 %{
11675   match(Return);
11676 
11677   format %{ "ret" %}
11678   opcode(0xC3);
11679   ins_encode(OpcP);
11680   ins_pipe(pipe_jmp);
11681 %}
11682 
11683 // Tail Call; Jump from runtime stub to Java code.
11684 // Also known as an 'interprocedural jump'.
11685 // Target of jump will eventually return to caller.
11686 // TailJump below removes the return address.
11687 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
11688 %{
11689   match(TailCall jump_target method_oop);
11690 
11691   ins_cost(300);
11692   format %{ "jmp     $jump_target\t# rbx holds method oop" %}
11693   opcode(0xFF, 0x4); /* Opcode FF /4 */
11694   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
11695   ins_pipe(pipe_jmp);
11696 %}
11697 
11698 // Tail Jump; remove the return address; jump to target.
11699 // TailCall above leaves the return address around.
11700 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
11701 %{
11702   match(TailJump jump_target ex_oop);
11703 
11704   ins_cost(300);
11705   format %{ "popq    rdx\t# pop return address\n\t"
11706             "jmp     $jump_target" %}
11707   opcode(0xFF, 0x4); /* Opcode FF /4 */
11708   ins_encode(Opcode(0x5a), // popq rdx
11709              REX_reg(jump_target), OpcP, reg_opc(jump_target));
11710   ins_pipe(pipe_jmp);
11711 %}
11712 
11713 // Create exception oop: created by stack-crawling runtime code.
11714 // Created exception is now available to this handler, and is setup
11715 // just prior to jumping to this handler.  No code emitted.
11716 instruct CreateException(rax_RegP ex_oop)
11717 %{
11718   match(Set ex_oop (CreateEx));
11719 
11720   size(0);
11721   // use the following format syntax
11722   format %{ "# exception oop is in rax; no code emitted" %}
11723   ins_encode();
11724   ins_pipe(empty);
11725 %}
11726 
11727 // Rethrow exception:
11728 // The exception oop will come in the first argument position.
11729 // Then JUMP (not call) to the rethrow stub code.
11730 instruct RethrowException()
11731 %{
11732   match(Rethrow);
11733 
11734   // use the following format syntax
11735   format %{ "jmp     rethrow_stub" %}
11736   ins_encode(enc_rethrow);
11737   ins_pipe(pipe_jmp);
11738 %}
11739 
11740 
11741 // ============================================================================
11742 // This name is KNOWN by the ADLC and cannot be changed.
11743 // The ADLC forces a 'TypeRawPtr::BOTTOM' output type
11744 // for this guy.
11745 instruct tlsLoadP(r15_RegP dst) %{
11746   match(Set dst (ThreadLocal));
11747   effect(DEF dst);
11748 
11749   size(0);
11750   format %{ "# TLS is in R15" %}
11751   ins_encode( /*empty encoding*/ );
11752   ins_pipe(ialu_reg_reg);
11753 %}
11754 
11755 
11756 //----------PEEPHOLE RULES-----------------------------------------------------
11757 // These must follow all instruction definitions as they use the names
11758 // defined in the instructions definitions.
11759 //
11760 // peepmatch ( root_instr_name [preceding_instruction]* );
11761 //
11762 // peepconstraint %{
11763 // (instruction_number.operand_name relational_op instruction_number.operand_name
11764 //  [, ...] );
11765 // // instruction numbers are zero-based using left to right order in peepmatch
11766 //
11767 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
11768 // // provide an instruction_number.operand_name for each operand that appears
11769 // // in the replacement instruction's match rule
11770 //
11771 // ---------VM FLAGS---------------------------------------------------------
11772 //
11773 // All peephole optimizations can be turned off using -XX:-OptoPeephole
11774 //
11775 // Each peephole rule is given an identifying number starting with zero and
11776 // increasing by one in the order seen by the parser.  An individual peephole
11777 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
11778 // on the command-line.
11779 //
11780 // ---------CURRENT LIMITATIONS----------------------------------------------
11781 //
11782 // Only match adjacent instructions in same basic block
11783 // Only equality constraints
11784 // Only constraints between operands, not (0.dest_reg == RAX_enc)
11785 // Only one replacement instruction
11786 //
11787 // ---------EXAMPLE----------------------------------------------------------
11788 //
11789 // // pertinent parts of existing instructions in architecture description
11790 // instruct movI(rRegI dst, rRegI src)
11791 // %{
11792 //   match(Set dst (CopyI src));
11793 // %}
11794 //
11795 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
11796 // %{
11797 //   match(Set dst (AddI dst src));
11798 //   effect(KILL cr);
11799 // %}
11800 //
11801 // // Change (inc mov) to lea
11802 // peephole %{
11803 //   // increment preceeded by register-register move
11804 //   peepmatch ( incI_rReg movI );
11805 //   // require that the destination register of the increment
11806 //   // match the destination register of the move
11807 //   peepconstraint ( 0.dst == 1.dst );
11808 //   // construct a replacement instruction that sets
11809 //   // the destination to ( move's source register + one )
11810 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
11811 // %}
11812 //
11813 
11814 // Implementation no longer uses movX instructions since
11815 // machine-independent system no longer uses CopyX nodes.
11816 //
11817 // peephole
11818 // %{
11819 //   peepmatch (incI_rReg movI);
11820 //   peepconstraint (0.dst == 1.dst);
11821 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11822 // %}
11823 
11824 // peephole
11825 // %{
11826 //   peepmatch (decI_rReg movI);
11827 //   peepconstraint (0.dst == 1.dst);
11828 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11829 // %}
11830 
11831 // peephole
11832 // %{
11833 //   peepmatch (addI_rReg_imm movI);
11834 //   peepconstraint (0.dst == 1.dst);
11835 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11836 // %}
11837 
11838 // peephole
11839 // %{
11840 //   peepmatch (incL_rReg movL);
11841 //   peepconstraint (0.dst == 1.dst);
11842 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11843 // %}
11844 
11845 // peephole
11846 // %{
11847 //   peepmatch (decL_rReg movL);
11848 //   peepconstraint (0.dst == 1.dst);
11849 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11850 // %}
11851 
11852 // peephole
11853 // %{
11854 //   peepmatch (addL_rReg_imm movL);
11855 //   peepconstraint (0.dst == 1.dst);
11856 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11857 // %}
11858 
11859 // peephole
11860 // %{
11861 //   peepmatch (addP_rReg_imm movP);
11862 //   peepconstraint (0.dst == 1.dst);
11863 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
11864 // %}
11865 
11866 // // Change load of spilled value to only a spill
11867 // instruct storeI(memory mem, rRegI src)
11868 // %{
11869 //   match(Set mem (StoreI mem src));
11870 // %}
11871 //
11872 // instruct loadI(rRegI dst, memory mem)
11873 // %{
11874 //   match(Set dst (LoadI mem));
11875 // %}
11876 //
11877 
11878 peephole
11879 %{
11880   peepmatch (loadI storeI);
11881   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11882   peepreplace (storeI(1.mem 1.mem 1.src));
11883 %}
11884 
11885 peephole
11886 %{
11887   peepmatch (loadL storeL);
11888   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11889   peepreplace (storeL(1.mem 1.mem 1.src));
11890 %}
11891 
11892 //----------SMARTSPILL RULES---------------------------------------------------
11893 // These must follow all instruction definitions as they use the names
11894 // defined in the instructions definitions.
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
