<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New src/cpu/x86/vm/x86_64.ad</title>
<body id="SUNWwebrev">
<pre>
   1 //
   2 // Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.
   3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4 //
   5 // This code is free software; you can redistribute it and/or modify it
   6 // under the terms of the GNU General Public License version 2 only, as
   7 // published by the Free Software Foundation.
   8 //
   9 // This code is distributed in the hope that it will be useful, but WITHOUT
  10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12 // version 2 for more details (a copy is included in the LICENSE file that
  13 // accompanied this code).
  14 //
  15 // You should have received a copy of the GNU General Public License version
  16 // 2 along with this work; if not, write to the Free Software Foundation,
  17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18 //
  19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20 // or visit www.oracle.com if you need additional information or have any
  21 // questions.
  22 //
  23 //
  24 
  25 // AMD64 Architecture Description File
  26 
  27 //----------REGISTER DEFINITION BLOCK------------------------------------------
  28 // This information is used by the matcher and the register allocator to
  29 // describe individual registers and classes of registers within the target
  30 // archtecture.
  31 
  32 register %{
  33 //----------Architecture Description Register Definitions----------------------
  34 // General Registers
  35 // "reg_def"  name ( register save type, C convention save type,
  36 //                   ideal register type, encoding );
  37 // Register Save Types:
  38 //
  39 // NS  = No-Save:       The register allocator assumes that these registers
  40 //                      can be used without saving upon entry to the method, &amp;
  41 //                      that they do not need to be saved at call sites.
  42 //
  43 // SOC = Save-On-Call:  The register allocator assumes that these registers
  44 //                      can be used without saving upon entry to the method,
  45 //                      but that they must be saved at call sites.
  46 //
  47 // SOE = Save-On-Entry: The register allocator assumes that these registers
  48 //                      must be saved before using them upon entry to the
  49 //                      method, but they do not need to be saved at call
  50 //                      sites.
  51 //
  52 // AS  = Always-Save:   The register allocator assumes that these registers
  53 //                      must be saved before using them upon entry to the
  54 //                      method, &amp; that they must be saved at call sites.
  55 //
  56 // Ideal Register Type is used to determine how to save &amp; restore a
  57 // register.  Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
  58 // spilled with LoadP/StoreP.  If the register supports both, use Op_RegI.
  59 //
  60 // The encoding number is the actual bit-pattern placed into the opcodes.
  61 
  62 // General Registers
  63 // R8-R15 must be encoded with REX.  (RSP, RBP, RSI, RDI need REX when
  64 // used as byte registers)
  65 
  66 // Previously set RBX, RSI, and RDI as save-on-entry for java code
  67 // Turn off SOE in java-code due to frequent use of uncommon-traps.
  68 // Now that allocator is better, turn on RSI and RDI as SOE registers.
  69 
  70 reg_def RAX  (SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg());
  71 reg_def RAX_H(SOC, SOC, Op_RegI,  0, rax-&gt;as_VMReg()-&gt;next());
  72 
  73 reg_def RCX  (SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg());
  74 reg_def RCX_H(SOC, SOC, Op_RegI,  1, rcx-&gt;as_VMReg()-&gt;next());
  75 
  76 reg_def RDX  (SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg());
  77 reg_def RDX_H(SOC, SOC, Op_RegI,  2, rdx-&gt;as_VMReg()-&gt;next());
  78 
  79 reg_def RBX  (SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg());
  80 reg_def RBX_H(SOC, SOE, Op_RegI,  3, rbx-&gt;as_VMReg()-&gt;next());
  81 
  82 reg_def RSP  (NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg());
  83 reg_def RSP_H(NS,  NS,  Op_RegI,  4, rsp-&gt;as_VMReg()-&gt;next());
  84 
  85 // now that adapter frames are gone RBP is always saved and restored by the prolog/epilog code
  86 reg_def RBP  (NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg());
  87 reg_def RBP_H(NS, SOE, Op_RegI,  5, rbp-&gt;as_VMReg()-&gt;next());
  88 
  89 #ifdef _WIN64
  90 
  91 reg_def RSI  (SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg());
  92 reg_def RSI_H(SOC, SOE, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
  93 
  94 reg_def RDI  (SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg());
  95 reg_def RDI_H(SOC, SOE, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
  96 
  97 #else
  98 
  99 reg_def RSI  (SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg());
 100 reg_def RSI_H(SOC, SOC, Op_RegI,  6, rsi-&gt;as_VMReg()-&gt;next());
 101 
 102 reg_def RDI  (SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg());
 103 reg_def RDI_H(SOC, SOC, Op_RegI,  7, rdi-&gt;as_VMReg()-&gt;next());
 104 
 105 #endif
 106 
 107 reg_def R8   (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg());
 108 reg_def R8_H (SOC, SOC, Op_RegI,  8, r8-&gt;as_VMReg()-&gt;next());
 109 
 110 reg_def R9   (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg());
 111 reg_def R9_H (SOC, SOC, Op_RegI,  9, r9-&gt;as_VMReg()-&gt;next());
 112 
 113 reg_def R10  (SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg());
 114 reg_def R10_H(SOC, SOC, Op_RegI, 10, r10-&gt;as_VMReg()-&gt;next());
 115 
 116 reg_def R11  (SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg());
 117 reg_def R11_H(SOC, SOC, Op_RegI, 11, r11-&gt;as_VMReg()-&gt;next());
 118 
 119 reg_def R12  (SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg());
 120 reg_def R12_H(SOC, SOE, Op_RegI, 12, r12-&gt;as_VMReg()-&gt;next());
 121 
 122 reg_def R13  (SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg());
 123 reg_def R13_H(SOC, SOE, Op_RegI, 13, r13-&gt;as_VMReg()-&gt;next());
 124 
 125 reg_def R14  (SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg());
 126 reg_def R14_H(SOC, SOE, Op_RegI, 14, r14-&gt;as_VMReg()-&gt;next());
 127 
 128 reg_def R15  (SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg());
 129 reg_def R15_H(SOC, SOE, Op_RegI, 15, r15-&gt;as_VMReg()-&gt;next());
 130 
 131 
 132 // Floating Point Registers
 133 
 134 // Specify priority of register selection within phases of register
 135 // allocation.  Highest priority is first.  A useful heuristic is to
 136 // give registers a low priority when they are required by machine
 137 // instructions, like EAX and EDX on I486, and choose no-save registers
 138 // before save-on-call, &amp; save-on-call before save-on-entry.  Registers
 139 // which participate in fixed calling sequences should come last.
 140 // Registers which are used as pairs must fall on an even boundary.
 141 
 142 alloc_class chunk0(R10,         R10_H,
 143                    R11,         R11_H,
 144                    R8,          R8_H,
 145                    R9,          R9_H,
 146                    R12,         R12_H,
 147                    RCX,         RCX_H,
 148                    RBX,         RBX_H,
 149                    RDI,         RDI_H,
 150                    RDX,         RDX_H,
 151                    RSI,         RSI_H,
 152                    RAX,         RAX_H,
 153                    RBP,         RBP_H,
 154                    R13,         R13_H,
 155                    R14,         R14_H,
 156                    R15,         R15_H,
 157                    RSP,         RSP_H);
 158 
 159 
 160 //----------Architecture Description Register Classes--------------------------
 161 // Several register classes are automatically defined based upon information in
 162 // this architecture description.
 163 // 1) reg_class inline_cache_reg           ( /* as def'd in frame section */ )
 164 // 2) reg_class compiler_method_oop_reg    ( /* as def'd in frame section */ )
 165 // 2) reg_class interpreter_method_oop_reg ( /* as def'd in frame section */ )
 166 // 3) reg_class stack_slots( /* one chunk of stack-based "registers" */ )
 167 //
 168 
 169 // Empty register class.
 170 reg_class no_reg();
 171 
 172 // Class for all pointer registers (including RSP and RBP)
 173 reg_class any_reg_with_rbp(RAX, RAX_H,
 174                            RDX, RDX_H,
 175                            RBP, RBP_H,
 176                            RDI, RDI_H,
 177                            RSI, RSI_H,
 178                            RCX, RCX_H,
 179                            RBX, RBX_H,
 180                            RSP, RSP_H,
 181                            R8,  R8_H,
 182                            R9,  R9_H,
 183                            R10, R10_H,
 184                            R11, R11_H,
 185                            R12, R12_H,
 186                            R13, R13_H,
 187                            R14, R14_H,
 188                            R15, R15_H);
 189 
 190 // Class for all pointer registers (including RSP, but excluding RBP)
 191 reg_class any_reg_no_rbp(RAX, RAX_H,
 192                          RDX, RDX_H,
 193                          RDI, RDI_H,
 194                          RSI, RSI_H,
 195                          RCX, RCX_H,
 196                          RBX, RBX_H,
 197                          RSP, RSP_H,
 198                          R8,  R8_H,
 199                          R9,  R9_H,
 200                          R10, R10_H,
 201                          R11, R11_H,
 202                          R12, R12_H,
 203                          R13, R13_H,
 204                          R14, R14_H,
 205                          R15, R15_H);
 206 
 207 // Dynamic register class that selects at runtime between register classes
 208 // any_reg_no_rbp and any_reg_with_rbp (depending on the value of the flag PreserveFramePointer).
 209 // Equivalent to: return PreserveFramePointer ? any_reg_no_rbp : any_reg_with_rbp;
 210 reg_class_dynamic any_reg(any_reg_no_rbp, any_reg_with_rbp, %{ PreserveFramePointer %});
 211 
 212 // Class for all pointer registers (excluding RSP)
 213 reg_class ptr_reg_with_rbp(RAX, RAX_H,
 214                            RDX, RDX_H,
 215                            RBP, RBP_H,
 216                            RDI, RDI_H,
 217                            RSI, RSI_H,
 218                            RCX, RCX_H,
 219                            RBX, RBX_H,
 220                            R8,  R8_H,
 221                            R9,  R9_H,
 222                            R10, R10_H,
 223                            R11, R11_H,
 224                            R13, R13_H,
 225                            R14, R14_H);
 226 
 227 // Class for all pointer registers (excluding RSP and RBP)
 228 reg_class ptr_reg_no_rbp(RAX, RAX_H,
 229                          RDX, RDX_H,
 230                          RDI, RDI_H,
 231                          RSI, RSI_H,
 232                          RCX, RCX_H,
 233                          RBX, RBX_H,
 234                          R8,  R8_H,
 235                          R9,  R9_H,
 236                          R10, R10_H,
 237                          R11, R11_H,
 238                          R13, R13_H,
 239                          R14, R14_H);
 240 
 241 // Dynamic register class that selects between ptr_reg_no_rbp and ptr_reg_with_rbp.
 242 reg_class_dynamic ptr_reg(ptr_reg_no_rbp, ptr_reg_with_rbp, %{ PreserveFramePointer %});
 243 
 244 // Class for all pointer registers (excluding RAX and RSP)
 245 reg_class ptr_no_rax_reg_with_rbp(RDX, RDX_H,
 246                                   RBP, RBP_H,
 247                                   RDI, RDI_H,
 248                                   RSI, RSI_H,
 249                                   RCX, RCX_H,
 250                                   RBX, RBX_H,
 251                                   R8,  R8_H,
 252                                   R9,  R9_H,
 253                                   R10, R10_H,
 254                                   R11, R11_H,
 255                                   R13, R13_H,
 256                                   R14, R14_H);
 257 
 258 // Class for all pointer registers (excluding RAX, RSP, and RBP)
 259 reg_class ptr_no_rax_reg_no_rbp(RDX, RDX_H,
 260                                 RDI, RDI_H,
 261                                 RSI, RSI_H,
 262                                 RCX, RCX_H,
 263                                 RBX, RBX_H,
 264                                 R8,  R8_H,
 265                                 R9,  R9_H,
 266                                 R10, R10_H,
 267                                 R11, R11_H,
 268                                 R13, R13_H,
 269                                 R14, R14_H);
 270 
 271 // Dynamic register class that selects between ptr_no_rax_reg_no_rbp and ptr_no_rax_reg_with_rbp.
 272 reg_class_dynamic ptr_no_rax_reg(ptr_no_rax_reg_no_rbp, ptr_no_rax_reg_with_rbp, %{ PreserveFramePointer %});
 273 
 274 // Class for all pointer registers (excluding RAX, RBX, and RSP)
 275 reg_class ptr_no_rax_rbx_reg_with_rbp(RDX, RDX_H,
 276                                       RBP, RBP_H,
 277                                       RDI, RDI_H,
 278                                       RSI, RSI_H,
 279                                       RCX, RCX_H,
 280                                       R8,  R8_H,
 281                                       R9,  R9_H,
 282                                       R10, R10_H,
 283                                       R11, R11_H,
 284                                       R13, R13_H,
 285                                       R14, R14_H);
 286 
 287 // Class for all pointer registers (excluding RAX, RBX, RSP, and RBP)
 288 reg_class ptr_no_rax_rbx_reg_no_rbp(RDX, RDX_H,
 289                                     RDI, RDI_H,
 290                                     RSI, RSI_H,
 291                                     RCX, RCX_H,
 292                                     R8,  R8_H,
 293                                     R9,  R9_H,
 294                                     R10, R10_H,
 295                                     R11, R11_H,
 296                                     R13, R13_H,
 297                                     R14, R14_H);
 298 
 299 // Dynamic register class that selects between ptr_no_rax_rbx_reg_no_rbp and ptr_no_rax_rbx_reg_with_rbp.
 300 reg_class_dynamic ptr_no_rax_rbx_reg(ptr_no_rax_rbx_reg_no_rbp, ptr_no_rax_rbx_reg_with_rbp, %{ PreserveFramePointer %});
 301 
 302 // Singleton class for RAX pointer register
 303 reg_class ptr_rax_reg(RAX, RAX_H);
 304 
 305 // Singleton class for RBX pointer register
 306 reg_class ptr_rbx_reg(RBX, RBX_H);
 307 
 308 // Singleton class for RSI pointer register
 309 reg_class ptr_rsi_reg(RSI, RSI_H);
 310 
 311 // Singleton class for RDI pointer register
 312 reg_class ptr_rdi_reg(RDI, RDI_H);
 313 
 314 // Singleton class for stack pointer
 315 reg_class ptr_rsp_reg(RSP, RSP_H);
 316 
 317 // Singleton class for TLS pointer
 318 reg_class ptr_r15_reg(R15, R15_H);
 319 
 320 // Class for all long registers (excluding RSP)
 321 reg_class long_reg_with_rbp(RAX, RAX_H,
 322                             RDX, RDX_H,
 323                             RBP, RBP_H,
 324                             RDI, RDI_H,
 325                             RSI, RSI_H,
 326                             RCX, RCX_H,
 327                             RBX, RBX_H,
 328                             R8,  R8_H,
 329                             R9,  R9_H,
 330                             R10, R10_H,
 331                             R11, R11_H,
 332                             R13, R13_H,
 333                             R14, R14_H);
 334 
 335 // Class for all long registers (excluding RSP and RBP)
 336 reg_class long_reg_no_rbp(RAX, RAX_H,
 337                           RDX, RDX_H,
 338                           RDI, RDI_H,
 339                           RSI, RSI_H,
 340                           RCX, RCX_H,
 341                           RBX, RBX_H,
 342                           R8,  R8_H,
 343                           R9,  R9_H,
 344                           R10, R10_H,
 345                           R11, R11_H,
 346                           R13, R13_H,
 347                           R14, R14_H);
 348 
 349 // Dynamic register class that selects between long_reg_no_rbp and long_reg_with_rbp.
 350 reg_class_dynamic long_reg(long_reg_no_rbp, long_reg_with_rbp, %{ PreserveFramePointer %});
 351 
 352 // Class for all long registers (excluding RAX, RDX and RSP)
 353 reg_class long_no_rax_rdx_reg_with_rbp(RBP, RBP_H,
 354                                        RDI, RDI_H,
 355                                        RSI, RSI_H,
 356                                        RCX, RCX_H,
 357                                        RBX, RBX_H,
 358                                        R8,  R8_H,
 359                                        R9,  R9_H,
 360                                        R10, R10_H,
 361                                        R11, R11_H,
 362                                        R13, R13_H,
 363                                        R14, R14_H);
 364 
 365 // Class for all long registers (excluding RAX, RDX, RSP, and RBP)
 366 reg_class long_no_rax_rdx_reg_no_rbp(RDI, RDI_H,
 367                                      RSI, RSI_H,
 368                                      RCX, RCX_H,
 369                                      RBX, RBX_H,
 370                                      R8,  R8_H,
 371                                      R9,  R9_H,
 372                                      R10, R10_H,
 373                                      R11, R11_H,
 374                                      R13, R13_H,
 375                                      R14, R14_H);
 376 
 377 // Dynamic register class that selects between long_no_rax_rdx_reg_no_rbp and long_no_rax_rdx_reg_with_rbp.
 378 reg_class_dynamic long_no_rax_rdx_reg(long_no_rax_rdx_reg_no_rbp, long_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 379 
 380 // Class for all long registers (excluding RCX and RSP)
 381 reg_class long_no_rcx_reg_with_rbp(RBP, RBP_H,
 382                                    RDI, RDI_H,
 383                                    RSI, RSI_H,
 384                                    RAX, RAX_H,
 385                                    RDX, RDX_H,
 386                                    RBX, RBX_H,
 387                                    R8,  R8_H,
 388                                    R9,  R9_H,
 389                                    R10, R10_H,
 390                                    R11, R11_H,
 391                                    R13, R13_H,
 392                                    R14, R14_H);
 393 
 394 // Class for all long registers (excluding RCX, RSP, and RBP)
 395 reg_class long_no_rcx_reg_no_rbp(RDI, RDI_H,
 396                                  RSI, RSI_H,
 397                                  RAX, RAX_H,
 398                                  RDX, RDX_H,
 399                                  RBX, RBX_H,
 400                                  R8,  R8_H,
 401                                  R9,  R9_H,
 402                                  R10, R10_H,
 403                                  R11, R11_H,
 404                                  R13, R13_H,
 405                                  R14, R14_H);
 406 
 407 // Dynamic register class that selects between long_no_rcx_reg_no_rbp and long_no_rcx_reg_with_rbp.
 408 reg_class_dynamic long_no_rcx_reg(long_no_rcx_reg_no_rbp, long_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 409 
 410 // Singleton class for RAX long register
 411 reg_class long_rax_reg(RAX, RAX_H);
 412 
 413 // Singleton class for RCX long register
 414 reg_class long_rcx_reg(RCX, RCX_H);
 415 
 416 // Singleton class for RDX long register
 417 reg_class long_rdx_reg(RDX, RDX_H);
 418 
 419 // Class for all int registers (excluding RSP)
 420 reg_class int_reg_with_rbp(RAX,
 421                            RDX,
 422                            RBP,
 423                            RDI,
 424                            RSI,
 425                            RCX,
 426                            RBX,
 427                            R8,
 428                            R9,
 429                            R10,
 430                            R11,
 431                            R13,
 432                            R14);
 433 
 434 // Class for all int registers (excluding RSP and RBP)
 435 reg_class int_reg_no_rbp(RAX,
 436                          RDX,
 437                          RDI,
 438                          RSI,
 439                          RCX,
 440                          RBX,
 441                          R8,
 442                          R9,
 443                          R10,
 444                          R11,
 445                          R13,
 446                          R14);
 447 
 448 // Dynamic register class that selects between int_reg_no_rbp and int_reg_with_rbp.
 449 reg_class_dynamic int_reg(int_reg_no_rbp, int_reg_with_rbp, %{ PreserveFramePointer %});
 450 
 451 // Class for all int registers (excluding RCX and RSP)
 452 reg_class int_no_rcx_reg_with_rbp(RAX,
 453                                   RDX,
 454                                   RBP,
 455                                   RDI,
 456                                   RSI,
 457                                   RBX,
 458                                   R8,
 459                                   R9,
 460                                   R10,
 461                                   R11,
 462                                   R13,
 463                                   R14);
 464 
 465 // Class for all int registers (excluding RCX, RSP, and RBP)
 466 reg_class int_no_rcx_reg_no_rbp(RAX,
 467                                 RDX,
 468                                 RDI,
 469                                 RSI,
 470                                 RBX,
 471                                 R8,
 472                                 R9,
 473                                 R10,
 474                                 R11,
 475                                 R13,
 476                                 R14);
 477 
 478 // Dynamic register class that selects between int_no_rcx_reg_no_rbp and int_no_rcx_reg_with_rbp.
 479 reg_class_dynamic int_no_rcx_reg(int_no_rcx_reg_no_rbp, int_no_rcx_reg_with_rbp, %{ PreserveFramePointer %});
 480 
 481 // Class for all int registers (excluding RAX, RDX, and RSP)
 482 reg_class int_no_rax_rdx_reg_with_rbp(RBP,
 483                                       RDI,
 484                                       RSI,
 485                                       RCX,
 486                                       RBX,
 487                                       R8,
 488                                       R9,
 489                                       R10,
 490                                       R11,
 491                                       R13,
 492                                       R14);
 493 
 494 // Class for all int registers (excluding RAX, RDX, RSP, and RBP)
 495 reg_class int_no_rax_rdx_reg_no_rbp(RDI,
 496                                     RSI,
 497                                     RCX,
 498                                     RBX,
 499                                     R8,
 500                                     R9,
 501                                     R10,
 502                                     R11,
 503                                     R13,
 504                                     R14);
 505 
 506 // Dynamic register class that selects between int_no_rax_rdx_reg_no_rbp and int_no_rax_rdx_reg_with_rbp.
 507 reg_class_dynamic int_no_rax_rdx_reg(int_no_rax_rdx_reg_no_rbp, int_no_rax_rdx_reg_with_rbp, %{ PreserveFramePointer %});
 508 
 509 // Singleton class for RAX int register
 510 reg_class int_rax_reg(RAX);
 511 
 512 // Singleton class for RBX int register
 513 reg_class int_rbx_reg(RBX);
 514 
 515 // Singleton class for RCX int register
 516 reg_class int_rcx_reg(RCX);
 517 
 518 // Singleton class for RCX int register
 519 reg_class int_rdx_reg(RDX);
 520 
 521 // Singleton class for RCX int register
 522 reg_class int_rdi_reg(RDI);
 523 
 524 // Singleton class for instruction pointer
 525 // reg_class ip_reg(RIP);
 526 
 527 %}
 528 
 529 //----------SOURCE BLOCK-------------------------------------------------------
 530 // This is a block of C++ code which provides values, functions, and
 531 // definitions necessary in the rest of the architecture description
 532 source %{
 533 #define   RELOC_IMM64    Assembler::imm_operand
 534 #define   RELOC_DISP32   Assembler::disp32_operand
 535 
 536 #define __ _masm.
 537 
 538 static int clear_avx_size() {
 539   if(UseAVX &gt; 2) {
 540     return 0; // vzeroupper is ignored
 541   } else {
 542     return (Compile::current()-&gt;max_vector_size() &gt; 16) ? 3 : 0;  // vzeroupper
 543   }
 544 }
 545 
 546 // !!!!! Special hack to get all types of calls to specify the byte offset
 547 //       from the start of the call to the point where the return address
 548 //       will point.
 549 int MachCallStaticJavaNode::ret_addr_offset()
 550 {
 551   int offset = 5; // 5 bytes from start of call to where return address points
 552   offset += clear_avx_size();
 553   return offset;
 554 }
 555 
 556 int MachCallDynamicJavaNode::ret_addr_offset()
 557 {
 558   int offset = 15; // 15 bytes from start of call to where return address points
 559   offset += clear_avx_size();
 560   return offset;
 561 }
 562 
 563 int MachCallRuntimeNode::ret_addr_offset() {
 564   int offset = 13; // movq r10,#addr; callq (r10)
 565   offset += clear_avx_size();
 566   return offset;
 567 }
 568 
 569 // Indicate if the safepoint node needs the polling page as an input,
 570 // it does if the polling page is more than disp32 away.
 571 bool SafePointNode::needs_polling_address_input()
 572 {
 573   return Assembler::is_polling_page_far();
 574 }
 575 
 576 //
 577 // Compute padding required for nodes which need alignment
 578 //
 579 
 580 // The address of the call instruction needs to be 4-byte aligned to
 581 // ensure that it does not span a cache line so that it can be patched.
 582 int CallStaticJavaDirectNode::compute_padding(int current_offset) const
 583 {
 584   current_offset += clear_avx_size(); // skip vzeroupper
 585   current_offset += 1; // skip call opcode byte
 586   return round_to(current_offset, alignment_required()) - current_offset;
 587 }
 588 
 589 // The address of the call instruction needs to be 4-byte aligned to
 590 // ensure that it does not span a cache line so that it can be patched.
 591 int CallDynamicJavaDirectNode::compute_padding(int current_offset) const
 592 {
 593   current_offset += clear_avx_size(); // skip vzeroupper
 594   current_offset += 11; // skip movq instruction + call opcode byte
 595   return round_to(current_offset, alignment_required()) - current_offset;
 596 }
 597 
 598 // EMIT_RM()
 599 void emit_rm(CodeBuffer &amp;cbuf, int f1, int f2, int f3) {
 600   unsigned char c = (unsigned char) ((f1 &lt;&lt; 6) | (f2 &lt;&lt; 3) | f3);
 601   cbuf.insts()-&gt;emit_int8(c);
 602 }
 603 
 604 // EMIT_CC()
 605 void emit_cc(CodeBuffer &amp;cbuf, int f1, int f2) {
 606   unsigned char c = (unsigned char) (f1 | f2);
 607   cbuf.insts()-&gt;emit_int8(c);
 608 }
 609 
 610 // EMIT_OPCODE()
 611 void emit_opcode(CodeBuffer &amp;cbuf, int code) {
 612   cbuf.insts()-&gt;emit_int8((unsigned char) code);
 613 }
 614 
 615 // EMIT_OPCODE() w/ relocation information
 616 void emit_opcode(CodeBuffer &amp;cbuf,
 617                  int code, relocInfo::relocType reloc, int offset, int format)
 618 {
 619   cbuf.relocate(cbuf.insts_mark() + offset, reloc, format);
 620   emit_opcode(cbuf, code);
 621 }
 622 
 623 // EMIT_D8()
 624 void emit_d8(CodeBuffer &amp;cbuf, int d8) {
 625   cbuf.insts()-&gt;emit_int8((unsigned char) d8);
 626 }
 627 
 628 // EMIT_D16()
 629 void emit_d16(CodeBuffer &amp;cbuf, int d16) {
 630   cbuf.insts()-&gt;emit_int16(d16);
 631 }
 632 
 633 // EMIT_D32()
 634 void emit_d32(CodeBuffer &amp;cbuf, int d32) {
 635   cbuf.insts()-&gt;emit_int32(d32);
 636 }
 637 
 638 // EMIT_D64()
 639 void emit_d64(CodeBuffer &amp;cbuf, int64_t d64) {
 640   cbuf.insts()-&gt;emit_int64(d64);
 641 }
 642 
 643 // emit 32 bit value and construct relocation entry from relocInfo::relocType
 644 void emit_d32_reloc(CodeBuffer&amp; cbuf,
 645                     int d32,
 646                     relocInfo::relocType reloc,
 647                     int format)
 648 {
 649   assert(reloc != relocInfo::external_word_type, "use 2-arg emit_d32_reloc");
 650   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 651   cbuf.insts()-&gt;emit_int32(d32);
 652 }
 653 
 654 // emit 32 bit value and construct relocation entry from RelocationHolder
 655 void emit_d32_reloc(CodeBuffer&amp; cbuf, int d32, RelocationHolder const&amp; rspec, int format) {
 656 #ifdef ASSERT
 657   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 658       d32 != 0 &amp;&amp; d32 != (intptr_t) Universe::non_oop_word()) {
 659     assert(Universe::heap()-&gt;is_in_reserved((address)(intptr_t)d32), "should be real oop");
 660     assert(cast_to_oop((intptr_t)d32)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop((intptr_t)d32)-&gt;is_scavengable()), "cannot embed scavengable oops in code");
 661   }
 662 #endif
 663   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 664   cbuf.insts()-&gt;emit_int32(d32);
 665 }
 666 
 667 void emit_d32_reloc(CodeBuffer&amp; cbuf, address addr) {
 668   address next_ip = cbuf.insts_end() + 4;
 669   emit_d32_reloc(cbuf, (int) (addr - next_ip),
 670                  external_word_Relocation::spec(addr),
 671                  RELOC_DISP32);
 672 }
 673 
 674 
 675 // emit 64 bit value and construct relocation entry from relocInfo::relocType
 676 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, relocInfo::relocType reloc, int format) {
 677   cbuf.relocate(cbuf.insts_mark(), reloc, format);
 678   cbuf.insts()-&gt;emit_int64(d64);
 679 }
 680 
 681 // emit 64 bit value and construct relocation entry from RelocationHolder
 682 void emit_d64_reloc(CodeBuffer&amp; cbuf, int64_t d64, RelocationHolder const&amp; rspec, int format) {
 683 #ifdef ASSERT
 684   if (rspec.reloc()-&gt;type() == relocInfo::oop_type &amp;&amp;
 685       d64 != 0 &amp;&amp; d64 != (int64_t) Universe::non_oop_word()) {
 686     assert(Universe::heap()-&gt;is_in_reserved((address)d64), "should be real oop");
 687     assert(cast_to_oop(d64)-&gt;is_oop() &amp;&amp; (ScavengeRootsInCode || !cast_to_oop(d64)-&gt;is_scavengable()),
 688            "cannot embed scavengable oops in code");
 689   }
 690 #endif
 691   cbuf.relocate(cbuf.insts_mark(), rspec, format);
 692   cbuf.insts()-&gt;emit_int64(d64);
 693 }
 694 
 695 // Access stack slot for load or store
 696 void store_to_stackslot(CodeBuffer &amp;cbuf, int opcode, int rm_field, int disp)
 697 {
 698   emit_opcode(cbuf, opcode);                  // (e.g., FILD   [RSP+src])
 699   if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80) {
 700     emit_rm(cbuf, 0x01, rm_field, RSP_enc);   // R/M byte
 701     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 702     emit_d8(cbuf, disp);     // Displacement  // R/M byte
 703   } else {
 704     emit_rm(cbuf, 0x02, rm_field, RSP_enc);   // R/M byte
 705     emit_rm(cbuf, 0x00, RSP_enc, RSP_enc);    // SIB byte
 706     emit_d32(cbuf, disp);     // Displacement // R/M byte
 707   }
 708 }
 709 
 710    // rRegI ereg, memory mem) %{    // emit_reg_mem
 711 void encode_RegMem(CodeBuffer &amp;cbuf,
 712                    int reg,
 713                    int base, int index, int scale, int disp, relocInfo::relocType disp_reloc)
 714 {
 715   assert(disp_reloc == relocInfo::none, "cannot have disp");
 716   int regenc = reg &amp; 7;
 717   int baseenc = base &amp; 7;
 718   int indexenc = index &amp; 7;
 719 
 720   // There is no index &amp; no scale, use form without SIB byte
 721   if (index == 0x4 &amp;&amp; scale == 0 &amp;&amp; base != RSP_enc &amp;&amp; base != R12_enc) {
 722     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 723     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 724       emit_rm(cbuf, 0x0, regenc, baseenc); // *
 725     } else if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 726       // If 8-bit displacement, mode 0x1
 727       emit_rm(cbuf, 0x1, regenc, baseenc); // *
 728       emit_d8(cbuf, disp);
 729     } else {
 730       // If 32-bit displacement
 731       if (base == -1) { // Special flag for absolute address
 732         emit_rm(cbuf, 0x0, regenc, 0x5); // *
 733         if (disp_reloc != relocInfo::none) {
 734           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 735         } else {
 736           emit_d32(cbuf, disp);
 737         }
 738       } else {
 739         // Normal base + offset
 740         emit_rm(cbuf, 0x2, regenc, baseenc); // *
 741         if (disp_reloc != relocInfo::none) {
 742           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 743         } else {
 744           emit_d32(cbuf, disp);
 745         }
 746       }
 747     }
 748   } else {
 749     // Else, encode with the SIB byte
 750     // If no displacement, mode is 0x0; unless base is [RBP] or [R13]
 751     if (disp == 0 &amp;&amp; base != RBP_enc &amp;&amp; base != R13_enc) {
 752       // If no displacement
 753       emit_rm(cbuf, 0x0, regenc, 0x4); // *
 754       emit_rm(cbuf, scale, indexenc, baseenc);
 755     } else {
 756       if (-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80 &amp;&amp; disp_reloc == relocInfo::none) {
 757         // If 8-bit displacement, mode 0x1
 758         emit_rm(cbuf, 0x1, regenc, 0x4); // *
 759         emit_rm(cbuf, scale, indexenc, baseenc);
 760         emit_d8(cbuf, disp);
 761       } else {
 762         // If 32-bit displacement
 763         if (base == 0x04 ) {
 764           emit_rm(cbuf, 0x2, regenc, 0x4);
 765           emit_rm(cbuf, scale, indexenc, 0x04); // XXX is this valid???
 766         } else {
 767           emit_rm(cbuf, 0x2, regenc, 0x4);
 768           emit_rm(cbuf, scale, indexenc, baseenc); // *
 769         }
 770         if (disp_reloc != relocInfo::none) {
 771           emit_d32_reloc(cbuf, disp, relocInfo::oop_type, RELOC_DISP32);
 772         } else {
 773           emit_d32(cbuf, disp);
 774         }
 775       }
 776     }
 777   }
 778 }
 779 
 780 // This could be in MacroAssembler but it's fairly C2 specific
 781 void emit_cmpfp_fixup(MacroAssembler&amp; _masm) {
 782   Label exit;
 783   __ jccb(Assembler::noParity, exit);
 784   __ pushf();
 785   //
 786   // comiss/ucomiss instructions set ZF,PF,CF flags and
 787   // zero OF,AF,SF for NaN values.
 788   // Fixup flags by zeroing ZF,PF so that compare of NaN
 789   // values returns 'less than' result (CF is set).
 790   // Leave the rest of flags unchanged.
 791   //
 792   //    7 6 5 4 3 2 1 0
 793   //   |S|Z|r|A|r|P|r|C|  (r - reserved bit)
 794   //    0 0 1 0 1 0 1 1   (0x2B)
 795   //
 796   __ andq(Address(rsp, 0), 0xffffff2b);
 797   __ popf();
 798   __ bind(exit);
 799 }
 800 
 801 void emit_cmpfp3(MacroAssembler&amp; _masm, Register dst) {
 802   Label done;
 803   __ movl(dst, -1);
 804   __ jcc(Assembler::parity, done);
 805   __ jcc(Assembler::below, done);
 806   __ setb(Assembler::notEqual, dst);
 807   __ movzbl(dst, dst);
 808   __ bind(done);
 809 }
 810 
 811 
 812 //=============================================================================
 813 const RegMask&amp; MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 814 
 815 int Compile::ConstantTable::calculate_table_base_offset() const {
 816   return 0;  // absolute addressing, no offset
 817 }
 818 
 819 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 820 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 821   ShouldNotReachHere();
 822 }
 823 
 824 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 825   // Empty encoding
 826 }
 827 
 828 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 829   return 0;
 830 }
 831 
 832 #ifndef PRODUCT
 833 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 834   st-&gt;print("# MachConstantBaseNode (empty encoding)");
 835 }
 836 #endif
 837 
 838 
 839 //=============================================================================
 840 #ifndef PRODUCT
 841 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 842   Compile* C = ra_-&gt;C;
 843 
 844   int framesize = C-&gt;frame_size_in_bytes();
 845   int bangsize = C-&gt;bang_size_in_bytes();
 846   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 847   // Remove wordSize for return addr which is already pushed.
 848   framesize -= wordSize;
 849 
 850   if (C-&gt;need_stack_bang(bangsize)) {
 851     framesize -= wordSize;
 852     st-&gt;print("# stack bang (%d bytes)", bangsize);
 853     st-&gt;print("\n\t");
 854     st-&gt;print("pushq   rbp\t# Save rbp");
 855     if (PreserveFramePointer) {
 856         st-&gt;print("\n\t");
 857         st-&gt;print("movq    rbp, rsp\t# Save the caller's SP into rbp");
 858     }
 859     if (framesize) {
 860       st-&gt;print("\n\t");
 861       st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 862     }
 863   } else {
 864     st-&gt;print("subq    rsp, #%d\t# Create frame",framesize);
 865     st-&gt;print("\n\t");
 866     framesize -= wordSize;
 867     st-&gt;print("movq    [rsp + #%d], rbp\t# Save rbp",framesize);
 868     if (PreserveFramePointer) {
 869       st-&gt;print("\n\t");
 870       st-&gt;print("movq    rbp, [rsp + #%d]\t# Save the caller's SP into rbp", (framesize + wordSize));
 871     }
 872   }
 873 
 874   if (VerifyStackAtCalls) {
 875     st-&gt;print("\n\t");
 876     framesize -= wordSize;
 877     st-&gt;print("movq    [rsp + #%d], 0xbadb100d\t# Majik cookie for stack depth check",framesize);
 878 #ifdef ASSERT
 879     st-&gt;print("\n\t");
 880     st-&gt;print("# stack alignment check");
 881 #endif
 882   }
 883   st-&gt;cr();
 884 }
 885 #endif
 886 
 887 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 888   Compile* C = ra_-&gt;C;
 889   MacroAssembler _masm(&amp;cbuf);
 890 
 891   int framesize = C-&gt;frame_size_in_bytes();
 892   int bangsize = C-&gt;bang_size_in_bytes();
 893 
 894   __ verified_entry(framesize, C-&gt;need_stack_bang(bangsize)?bangsize:0, false);
 895 
 896   C-&gt;set_frame_complete(cbuf.insts_size());
 897 
 898   if (C-&gt;has_mach_constant_base_node()) {
 899     // NOTE: We set the table base offset here because users might be
 900     // emitted before MachConstantBaseNode.
 901     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();
 902     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 903   }
 904 }
 905 
 906 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
 907 {
 908   return MachNode::size(ra_); // too many variables; just compute it
 909                               // the hard way
 910 }
 911 
 912 int MachPrologNode::reloc() const
 913 {
 914   return 0; // a large enough number
 915 }
 916 
 917 //=============================================================================
 918 #ifndef PRODUCT
 919 void MachEpilogNode::format(PhaseRegAlloc* ra_, outputStream* st) const
 920 {
 921   Compile* C = ra_-&gt;C;
 922   if (C-&gt;max_vector_size() &gt; 16) {
 923     st-&gt;print("vzeroupper");
 924     st-&gt;cr(); st-&gt;print("\t");
 925   }
 926 
 927   int framesize = C-&gt;frame_size_in_bytes();
 928   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 929   // Remove word for return adr already pushed
 930   // and RBP
 931   framesize -= 2*wordSize;
 932 
 933   if (framesize) {
 934     st-&gt;print_cr("addq    rsp, %d\t# Destroy frame", framesize);
 935     st-&gt;print("\t");
 936   }
 937 
 938   st-&gt;print_cr("popq   rbp");
 939   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 940     st-&gt;print("\t");
 941     if (Assembler::is_polling_page_far()) {
 942       st-&gt;print_cr("movq   rscratch1, #polling_page_address\n\t"
 943                    "testl  rax, [rscratch1]\t"
 944                    "# Safepoint: poll for GC");
 945     } else {
 946       st-&gt;print_cr("testl  rax, [rip + #offset_to_poll_page]\t"
 947                    "# Safepoint: poll for GC");
 948     }
 949   }
 950 }
 951 #endif
 952 
 953 void MachEpilogNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
 954 {
 955   Compile* C = ra_-&gt;C;
 956   if (C-&gt;max_vector_size() &gt; 16) {
 957     // Clear upper bits of YMM registers when current compiled code uses
 958     // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
 959     MacroAssembler _masm(&amp;cbuf);
 960     __ vzeroupper();
 961   }
 962 
 963   int framesize = C-&gt;frame_size_in_bytes();
 964   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
 965   // Remove word for return adr already pushed
 966   // and RBP
 967   framesize -= 2*wordSize;
 968 
 969   // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here
 970 
 971   if (framesize) {
 972     emit_opcode(cbuf, Assembler::REX_W);
 973     if (framesize &lt; 0x80) {
 974       emit_opcode(cbuf, 0x83); // addq rsp, #framesize
 975       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 976       emit_d8(cbuf, framesize);
 977     } else {
 978       emit_opcode(cbuf, 0x81); // addq rsp, #framesize
 979       emit_rm(cbuf, 0x3, 0x00, RSP_enc);
 980       emit_d32(cbuf, framesize);
 981     }
 982   }
 983 
 984   // popq rbp
 985   emit_opcode(cbuf, 0x58 | RBP_enc);
 986 
 987   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 988     MacroAssembler _masm(&amp;cbuf);
 989     AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
 990     if (Assembler::is_polling_page_far()) {
 991       __ lea(rscratch1, polling_page);
 992       __ relocate(relocInfo::poll_return_type);
 993       __ testl(rax, Address(rscratch1, 0));
 994     } else {
 995       __ testl(rax, polling_page);
 996     }
 997   }
 998 }
 999 
1000 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
1001 {
1002   return MachNode::size(ra_); // too many variables; just compute it
1003                               // the hard way
1004 }
1005 
1006 int MachEpilogNode::reloc() const
1007 {
1008   return 2; // a large enough number
1009 }
1010 
1011 const Pipeline* MachEpilogNode::pipeline() const
1012 {
1013   return MachNode::pipeline_class();
1014 }
1015 
1016 int MachEpilogNode::safepoint_offset() const
1017 {
1018   return 0;
1019 }
1020 
1021 //=============================================================================
1022 
1023 enum RC {
1024   rc_bad,
1025   rc_int,
1026   rc_float,
1027   rc_stack
1028 };
1029 
1030 static enum RC rc_class(OptoReg::Name reg)
1031 {
1032   if( !OptoReg::is_valid(reg)  ) return rc_bad;
1033 
1034   if (OptoReg::is_stack(reg)) return rc_stack;
1035 
1036   VMReg r = OptoReg::as_VMReg(reg);
1037 
1038   if (r-&gt;is_Register()) return rc_int;
1039 
1040   assert(r-&gt;is_XMMRegister(), "must be");
1041   return rc_float;
1042 }
1043 
1044 // Next two methods are shared by 32- and 64-bit VM. They are defined in x86.ad.
1045 static int vec_mov_helper(CodeBuffer *cbuf, bool do_size, int src_lo, int dst_lo,
1046                           int src_hi, int dst_hi, uint ireg, outputStream* st);
1047 
1048 static int vec_spill_helper(CodeBuffer *cbuf, bool do_size, bool is_load,
1049                             int stack_offset, int reg, uint ireg, outputStream* st);
1050 
1051 static void vec_stack_to_stack_helper(CodeBuffer *cbuf, int src_offset,
1052                                       int dst_offset, uint ireg, outputStream* st) {
1053   if (cbuf) {
1054     MacroAssembler _masm(cbuf);
1055     switch (ireg) {
1056     case Op_VecS:
1057       __ movq(Address(rsp, -8), rax);
1058       __ movl(rax, Address(rsp, src_offset));
1059       __ movl(Address(rsp, dst_offset), rax);
1060       __ movq(rax, Address(rsp, -8));
1061       break;
1062     case Op_VecD:
1063       __ pushq(Address(rsp, src_offset));
1064       __ popq (Address(rsp, dst_offset));
1065       break;
1066     case Op_VecX:
1067       __ pushq(Address(rsp, src_offset));
1068       __ popq (Address(rsp, dst_offset));
1069       __ pushq(Address(rsp, src_offset+8));
1070       __ popq (Address(rsp, dst_offset+8));
1071       break;
1072     case Op_VecY:
1073       __ vmovdqu(Address(rsp, -32), xmm0);
1074       __ vmovdqu(xmm0, Address(rsp, src_offset));
1075       __ vmovdqu(Address(rsp, dst_offset), xmm0);
1076       __ vmovdqu(xmm0, Address(rsp, -32));
1077     case Op_VecZ:
1078       __ evmovdqul(Address(rsp, -64), xmm0, 2);
1079       __ evmovdqul(xmm0, Address(rsp, src_offset), 2);
1080       __ evmovdqul(Address(rsp, dst_offset), xmm0, 2);
1081       __ evmovdqul(xmm0, Address(rsp, -64), 2);
1082       break;
1083     default:
1084       ShouldNotReachHere();
1085     }
1086 #ifndef PRODUCT
1087   } else {
1088     switch (ireg) {
1089     case Op_VecS:
1090       st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1091                 "movl    rax, [rsp + #%d]\n\t"
1092                 "movl    [rsp + #%d], rax\n\t"
1093                 "movq    rax, [rsp - #8]",
1094                 src_offset, dst_offset);
1095       break;
1096     case Op_VecD:
1097       st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1098                 "popq    [rsp + #%d]",
1099                 src_offset, dst_offset);
1100       break;
1101      case Op_VecX:
1102       st-&gt;print("pushq   [rsp + #%d]\t# 128-bit mem-mem spill\n\t"
1103                 "popq    [rsp + #%d]\n\t"
1104                 "pushq   [rsp + #%d]\n\t"
1105                 "popq    [rsp + #%d]",
1106                 src_offset, dst_offset, src_offset+8, dst_offset+8);
1107       break;
1108     case Op_VecY:
1109       st-&gt;print("vmovdqu [rsp - #32], xmm0\t# 256-bit mem-mem spill\n\t"
1110                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1111                 "vmovdqu [rsp + #%d], xmm0\n\t"
1112                 "vmovdqu xmm0, [rsp - #32]",
1113                 src_offset, dst_offset);
1114       break;
1115     case Op_VecZ:
1116       st-&gt;print("vmovdqu [rsp - #64], xmm0\t# 512-bit mem-mem spill\n\t"
1117                 "vmovdqu xmm0, [rsp + #%d]\n\t"
1118                 "vmovdqu [rsp + #%d], xmm0\n\t"
1119                 "vmovdqu xmm0, [rsp - #64]",
1120                 src_offset, dst_offset);
1121       break;
1122     default:
1123       ShouldNotReachHere();
1124     }
1125 #endif
1126   }
1127 }
1128 
1129 uint MachSpillCopyNode::implementation(CodeBuffer* cbuf,
1130                                        PhaseRegAlloc* ra_,
1131                                        bool do_size,
1132                                        outputStream* st) const {
1133   assert(cbuf != NULL || st  != NULL, "sanity");
1134   // Get registers to move
1135   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
1136   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
1137   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this);
1138   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this);
1139 
1140   enum RC src_second_rc = rc_class(src_second);
1141   enum RC src_first_rc = rc_class(src_first);
1142   enum RC dst_second_rc = rc_class(dst_second);
1143   enum RC dst_first_rc = rc_class(dst_first);
1144 
1145   assert(OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first),
1146          "must move at least 1 register" );
1147 
1148   if (src_first == dst_first &amp;&amp; src_second == dst_second) {
1149     // Self copy, no move
1150     return 0;
1151   }
1152   if (bottom_type()-&gt;isa_vect() != NULL) {
1153     uint ireg = ideal_reg();
1154     assert((src_first_rc != rc_int &amp;&amp; dst_first_rc != rc_int), "sanity");
1155     assert((ireg == Op_VecS || ireg == Op_VecD || ireg == Op_VecX || ireg == Op_VecY || ireg == Op_VecZ ), "sanity");
1156     if( src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack ) {
1157       // mem -&gt; mem
1158       int src_offset = ra_-&gt;reg2offset(src_first);
1159       int dst_offset = ra_-&gt;reg2offset(dst_first);
1160       vec_stack_to_stack_helper(cbuf, src_offset, dst_offset, ireg, st);
1161     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float ) {
1162       vec_mov_helper(cbuf, false, src_first, dst_first, src_second, dst_second, ireg, st);
1163     } else if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack ) {
1164       int stack_offset = ra_-&gt;reg2offset(dst_first);
1165       vec_spill_helper(cbuf, false, false, stack_offset, src_first, ireg, st);
1166     } else if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_float ) {
1167       int stack_offset = ra_-&gt;reg2offset(src_first);
1168       vec_spill_helper(cbuf, false, true,  stack_offset, dst_first, ireg, st);
1169     } else {
1170       ShouldNotReachHere();
1171     }
1172     return 0;
1173   }
1174   if (src_first_rc == rc_stack) {
1175     // mem -&gt;
1176     if (dst_first_rc == rc_stack) {
1177       // mem -&gt; mem
1178       assert(src_second != dst_first, "overlap");
1179       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1180           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1181         // 64-bit
1182         int src_offset = ra_-&gt;reg2offset(src_first);
1183         int dst_offset = ra_-&gt;reg2offset(dst_first);
1184         if (cbuf) {
1185           MacroAssembler _masm(cbuf);
1186           __ pushq(Address(rsp, src_offset));
1187           __ popq (Address(rsp, dst_offset));
1188 #ifndef PRODUCT
1189         } else {
1190           st-&gt;print("pushq   [rsp + #%d]\t# 64-bit mem-mem spill\n\t"
1191                     "popq    [rsp + #%d]",
1192                      src_offset, dst_offset);
1193 #endif
1194         }
1195       } else {
1196         // 32-bit
1197         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1198         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1199         // No pushl/popl, so:
1200         int src_offset = ra_-&gt;reg2offset(src_first);
1201         int dst_offset = ra_-&gt;reg2offset(dst_first);
1202         if (cbuf) {
1203           MacroAssembler _masm(cbuf);
1204           __ movq(Address(rsp, -8), rax);
1205           __ movl(rax, Address(rsp, src_offset));
1206           __ movl(Address(rsp, dst_offset), rax);
1207           __ movq(rax, Address(rsp, -8));
1208 #ifndef PRODUCT
1209         } else {
1210           st-&gt;print("movq    [rsp - #8], rax\t# 32-bit mem-mem spill\n\t"
1211                     "movl    rax, [rsp + #%d]\n\t"
1212                     "movl    [rsp + #%d], rax\n\t"
1213                     "movq    rax, [rsp - #8]",
1214                      src_offset, dst_offset);
1215 #endif
1216         }
1217       }
1218       return 0;
1219     } else if (dst_first_rc == rc_int) {
1220       // mem -&gt; gpr
1221       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1222           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1223         // 64-bit
1224         int offset = ra_-&gt;reg2offset(src_first);
1225         if (cbuf) {
1226           MacroAssembler _masm(cbuf);
1227           __ movq(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1228 #ifndef PRODUCT
1229         } else {
1230           st-&gt;print("movq    %s, [rsp + #%d]\t# spill",
1231                      Matcher::regName[dst_first],
1232                      offset);
1233 #endif
1234         }
1235       } else {
1236         // 32-bit
1237         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1238         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1239         int offset = ra_-&gt;reg2offset(src_first);
1240         if (cbuf) {
1241           MacroAssembler _masm(cbuf);
1242           __ movl(as_Register(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1243 #ifndef PRODUCT
1244         } else {
1245           st-&gt;print("movl    %s, [rsp + #%d]\t# spill",
1246                      Matcher::regName[dst_first],
1247                      offset);
1248 #endif
1249         }
1250       }
1251       return 0;
1252     } else if (dst_first_rc == rc_float) {
1253       // mem-&gt; xmm
1254       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1255           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1256         // 64-bit
1257         int offset = ra_-&gt;reg2offset(src_first);
1258         if (cbuf) {
1259           MacroAssembler _masm(cbuf);
1260           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1261 #ifndef PRODUCT
1262         } else {
1263           st-&gt;print("%s  %s, [rsp + #%d]\t# spill",
1264                      UseXmmLoadAndClearUpper ? "movsd " : "movlpd",
1265                      Matcher::regName[dst_first],
1266                      offset);
1267 #endif
1268         }
1269       } else {
1270         // 32-bit
1271         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1272         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1273         int offset = ra_-&gt;reg2offset(src_first);
1274         if (cbuf) {
1275           MacroAssembler _masm(cbuf);
1276           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), Address(rsp, offset));
1277 #ifndef PRODUCT
1278         } else {
1279           st-&gt;print("movss   %s, [rsp + #%d]\t# spill",
1280                      Matcher::regName[dst_first],
1281                      offset);
1282 #endif
1283         }
1284       }
1285       return 0;
1286     }
1287   } else if (src_first_rc == rc_int) {
1288     // gpr -&gt;
1289     if (dst_first_rc == rc_stack) {
1290       // gpr -&gt; mem
1291       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1292           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1293         // 64-bit
1294         int offset = ra_-&gt;reg2offset(dst_first);
1295         if (cbuf) {
1296           MacroAssembler _masm(cbuf);
1297           __ movq(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1298 #ifndef PRODUCT
1299         } else {
1300           st-&gt;print("movq    [rsp + #%d], %s\t# spill",
1301                      offset,
1302                      Matcher::regName[src_first]);
1303 #endif
1304         }
1305       } else {
1306         // 32-bit
1307         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1308         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1309         int offset = ra_-&gt;reg2offset(dst_first);
1310         if (cbuf) {
1311           MacroAssembler _masm(cbuf);
1312           __ movl(Address(rsp, offset), as_Register(Matcher::_regEncode[src_first]));
1313 #ifndef PRODUCT
1314         } else {
1315           st-&gt;print("movl    [rsp + #%d], %s\t# spill",
1316                      offset,
1317                      Matcher::regName[src_first]);
1318 #endif
1319         }
1320       }
1321       return 0;
1322     } else if (dst_first_rc == rc_int) {
1323       // gpr -&gt; gpr
1324       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1325           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1326         // 64-bit
1327         if (cbuf) {
1328           MacroAssembler _masm(cbuf);
1329           __ movq(as_Register(Matcher::_regEncode[dst_first]),
1330                   as_Register(Matcher::_regEncode[src_first]));
1331 #ifndef PRODUCT
1332         } else {
1333           st-&gt;print("movq    %s, %s\t# spill",
1334                      Matcher::regName[dst_first],
1335                      Matcher::regName[src_first]);
1336 #endif
1337         }
1338         return 0;
1339       } else {
1340         // 32-bit
1341         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1342         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1343         if (cbuf) {
1344           MacroAssembler _masm(cbuf);
1345           __ movl(as_Register(Matcher::_regEncode[dst_first]),
1346                   as_Register(Matcher::_regEncode[src_first]));
1347 #ifndef PRODUCT
1348         } else {
1349           st-&gt;print("movl    %s, %s\t# spill",
1350                      Matcher::regName[dst_first],
1351                      Matcher::regName[src_first]);
1352 #endif
1353         }
1354         return 0;
1355       }
1356     } else if (dst_first_rc == rc_float) {
1357       // gpr -&gt; xmm
1358       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1359           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1360         // 64-bit
1361         if (cbuf) {
1362           MacroAssembler _masm(cbuf);
1363           __ movdq( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1364 #ifndef PRODUCT
1365         } else {
1366           st-&gt;print("movdq   %s, %s\t# spill",
1367                      Matcher::regName[dst_first],
1368                      Matcher::regName[src_first]);
1369 #endif
1370         }
1371       } else {
1372         // 32-bit
1373         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1374         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1375         if (cbuf) {
1376           MacroAssembler _masm(cbuf);
1377           __ movdl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_Register(Matcher::_regEncode[src_first]));
1378 #ifndef PRODUCT
1379         } else {
1380           st-&gt;print("movdl   %s, %s\t# spill",
1381                      Matcher::regName[dst_first],
1382                      Matcher::regName[src_first]);
1383 #endif
1384         }
1385       }
1386       return 0;
1387     }
1388   } else if (src_first_rc == rc_float) {
1389     // xmm -&gt;
1390     if (dst_first_rc == rc_stack) {
1391       // xmm -&gt; mem
1392       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1393           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1394         // 64-bit
1395         int offset = ra_-&gt;reg2offset(dst_first);
1396         if (cbuf) {
1397           MacroAssembler _masm(cbuf);
1398           __ movdbl( Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1399 #ifndef PRODUCT
1400         } else {
1401           st-&gt;print("movsd   [rsp + #%d], %s\t# spill",
1402                      offset,
1403                      Matcher::regName[src_first]);
1404 #endif
1405         }
1406       } else {
1407         // 32-bit
1408         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1409         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1410         int offset = ra_-&gt;reg2offset(dst_first);
1411         if (cbuf) {
1412           MacroAssembler _masm(cbuf);
1413           __ movflt(Address(rsp, offset), as_XMMRegister(Matcher::_regEncode[src_first]));
1414 #ifndef PRODUCT
1415         } else {
1416           st-&gt;print("movss   [rsp + #%d], %s\t# spill",
1417                      offset,
1418                      Matcher::regName[src_first]);
1419 #endif
1420         }
1421       }
1422       return 0;
1423     } else if (dst_first_rc == rc_int) {
1424       // xmm -&gt; gpr
1425       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1426           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1427         // 64-bit
1428         if (cbuf) {
1429           MacroAssembler _masm(cbuf);
1430           __ movdq( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1431 #ifndef PRODUCT
1432         } else {
1433           st-&gt;print("movdq   %s, %s\t# spill",
1434                      Matcher::regName[dst_first],
1435                      Matcher::regName[src_first]);
1436 #endif
1437         }
1438       } else {
1439         // 32-bit
1440         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1441         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1442         if (cbuf) {
1443           MacroAssembler _masm(cbuf);
1444           __ movdl( as_Register(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1445 #ifndef PRODUCT
1446         } else {
1447           st-&gt;print("movdl   %s, %s\t# spill",
1448                      Matcher::regName[dst_first],
1449                      Matcher::regName[src_first]);
1450 #endif
1451         }
1452       }
1453       return 0;
1454     } else if (dst_first_rc == rc_float) {
1455       // xmm -&gt; xmm
1456       if ((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second &amp;&amp;
1457           (dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second) {
1458         // 64-bit
1459         if (cbuf) {
1460           MacroAssembler _masm(cbuf);
1461           __ movdbl( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1462 #ifndef PRODUCT
1463         } else {
1464           st-&gt;print("%s  %s, %s\t# spill",
1465                      UseXmmRegToRegMoveAll ? "movapd" : "movsd ",
1466                      Matcher::regName[dst_first],
1467                      Matcher::regName[src_first]);
1468 #endif
1469         }
1470       } else {
1471         // 32-bit
1472         assert(!((src_first &amp; 1) == 0 &amp;&amp; src_first + 1 == src_second), "no transform");
1473         assert(!((dst_first &amp; 1) == 0 &amp;&amp; dst_first + 1 == dst_second), "no transform");
1474         if (cbuf) {
1475           MacroAssembler _masm(cbuf);
1476           __ movflt( as_XMMRegister(Matcher::_regEncode[dst_first]), as_XMMRegister(Matcher::_regEncode[src_first]));
1477 #ifndef PRODUCT
1478         } else {
1479           st-&gt;print("%s  %s, %s\t# spill",
1480                      UseXmmRegToRegMoveAll ? "movaps" : "movss ",
1481                      Matcher::regName[dst_first],
1482                      Matcher::regName[src_first]);
1483 #endif
1484         }
1485       }
1486       return 0;
1487     }
1488   }
1489 
1490   assert(0," foo ");
1491   Unimplemented();
1492   return 0;
1493 }
1494 
1495 #ifndef PRODUCT
1496 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream* st) const {
1497   implementation(NULL, ra_, false, st);
1498 }
1499 #endif
1500 
1501 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
1502   implementation(&amp;cbuf, ra_, false, NULL);
1503 }
1504 
1505 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
1506   return MachNode::size(ra_);
1507 }
1508 
1509 //=============================================================================
1510 #ifndef PRODUCT
1511 void BoxLockNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1512 {
1513   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1514   int reg = ra_-&gt;get_reg_first(this);
1515   st-&gt;print("leaq    %s, [rsp + #%d]\t# box lock",
1516             Matcher::regName[reg], offset);
1517 }
1518 #endif
1519 
1520 void BoxLockNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1521 {
1522   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1523   int reg = ra_-&gt;get_encode(this);
1524   if (offset &gt;= 0x80) {
1525     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1526     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1527     emit_rm(cbuf, 0x2, reg &amp; 7, 0x04);
1528     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1529     emit_d32(cbuf, offset);
1530   } else {
1531     emit_opcode(cbuf, reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WR);
1532     emit_opcode(cbuf, 0x8D); // LEA  reg,[SP+offset]
1533     emit_rm(cbuf, 0x1, reg &amp; 7, 0x04);
1534     emit_rm(cbuf, 0x0, 0x04, RSP_enc);
1535     emit_d8(cbuf, offset);
1536   }
1537 }
1538 
1539 uint BoxLockNode::size(PhaseRegAlloc *ra_) const
1540 {
1541   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
1542   return (offset &lt; 0x80) ? 5 : 8; // REX
1543 }
1544 
1545 //=============================================================================
1546 #ifndef PRODUCT
1547 void MachUEPNode::format(PhaseRegAlloc* ra_, outputStream* st) const
1548 {
1549   if (UseCompressedClassPointers) {
1550     st-&gt;print_cr("movl    rscratch1, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t# compressed klass");
1551     st-&gt;print_cr("\tdecode_klass_not_null rscratch1, rscratch1");
1552     st-&gt;print_cr("\tcmpq    rax, rscratch1\t # Inline cache check");
1553   } else {
1554     st-&gt;print_cr("\tcmpq    rax, [j_rarg0 + oopDesc::klass_offset_in_bytes()]\t"
1555                  "# Inline cache check");
1556   }
1557   st-&gt;print_cr("\tjne     SharedRuntime::_ic_miss_stub");
1558   st-&gt;print_cr("\tnop\t# nops to align entry point");
1559 }
1560 #endif
1561 
1562 void MachUEPNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const
1563 {
1564   MacroAssembler masm(&amp;cbuf);
1565   uint insts_size = cbuf.insts_size();
1566   if (UseCompressedClassPointers) {
1567     masm.load_klass(rscratch1, j_rarg0);
1568     masm.cmpptr(rax, rscratch1);
1569   } else {
1570     masm.cmpptr(rax, Address(j_rarg0, oopDesc::klass_offset_in_bytes()));
1571   }
1572 
1573   masm.jump_cc(Assembler::notEqual, RuntimeAddress(SharedRuntime::get_ic_miss_stub()));
1574 
1575   /* WARNING these NOPs are critical so that verified entry point is properly
1576      4 bytes aligned for patching by NativeJump::patch_verified_entry() */
1577   int nops_cnt = 4 - ((cbuf.insts_size() - insts_size) &amp; 0x3);
1578   if (OptoBreakpoint) {
1579     // Leave space for int3
1580     nops_cnt -= 1;
1581   }
1582   nops_cnt &amp;= 0x3; // Do not add nops if code is aligned.
1583   if (nops_cnt &gt; 0)
1584     masm.nop(nops_cnt);
1585 }
1586 
1587 uint MachUEPNode::size(PhaseRegAlloc* ra_) const
1588 {
1589   return MachNode::size(ra_); // too many variables; just compute it
1590                               // the hard way
1591 }
1592 
1593 
1594 //=============================================================================
1595 
1596 int Matcher::regnum_to_fpu_offset(int regnum)
1597 {
1598   return regnum - 32; // The FP registers are in the second chunk
1599 }
1600 
1601 // This is UltraSparc specific, true just means we have fast l2f conversion
1602 const bool Matcher::convL2FSupported(void) {
1603   return true;
1604 }
1605 
1606 // Is this branch offset short enough that a short branch can be used?
1607 //
1608 // NOTE: If the platform does not provide any short branch variants, then
1609 //       this method should return false for offset 0.
1610 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
1611   // The passed offset is relative to address of the branch.
1612   // On 86 a branch displacement is calculated relative to address
1613   // of a next instruction.
1614   offset -= br_size;
1615 
1616   // the short version of jmpConUCF2 contains multiple branches,
1617   // making the reach slightly less
1618   if (rule == jmpConUCF2_rule)
1619     return (-126 &lt;= offset &amp;&amp; offset &lt;= 125);
1620   return (-128 &lt;= offset &amp;&amp; offset &lt;= 127);
1621 }
1622 
1623 const bool Matcher::isSimpleConstant64(jlong value) {
1624   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
1625   //return value == (int) value;  // Cf. storeImmL and immL32.
1626 
1627   // Probably always true, even if a temp register is required.
1628   return true;
1629 }
1630 
1631 // The ecx parameter to rep stosq for the ClearArray node is in words.
1632 const bool Matcher::init_array_count_is_in_bytes = false;
1633 
1634 // Threshold size for cleararray.
1635 const int Matcher::init_array_short_size = 8 * BytesPerLong;
1636 
1637 // No additional cost for CMOVL.
1638 const int Matcher::long_cmove_cost() { return 0; }
1639 
1640 // No CMOVF/CMOVD with SSE2
1641 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
1642 
1643 // Does the CPU require late expand (see block.cpp for description of late expand)?
1644 const bool Matcher::require_postalloc_expand = false;
1645 
1646 // Should the Matcher clone shifts on addressing modes, expecting them
1647 // to be subsumed into complex addressing expressions or compute them
1648 // into registers?  True for Intel but false for most RISCs
1649 const bool Matcher::clone_shift_expressions = true;
1650 
1651 // Do we need to mask the count passed to shift instructions or does
1652 // the cpu only look at the lower 5/6 bits anyway?
1653 const bool Matcher::need_masked_shift_count = false;
1654 
1655 bool Matcher::narrow_oop_use_complex_address() {
1656   assert(UseCompressedOops, "only for compressed oops code");
1657   return (LogMinObjAlignmentInBytes &lt;= 3);
1658 }
1659 
1660 bool Matcher::narrow_klass_use_complex_address() {
1661   assert(UseCompressedClassPointers, "only for compressed klass code");
1662   return (LogKlassAlignmentInBytes &lt;= 3);
1663 }
1664 
1665 // Is it better to copy float constants, or load them directly from
1666 // memory?  Intel can load a float constant from a direct address,
1667 // requiring no extra registers.  Most RISCs will have to materialize
1668 // an address into a register first, so they would do better to copy
1669 // the constant from stack.
1670 const bool Matcher::rematerialize_float_constants = true; // XXX
1671 
1672 // If CPU can load and store mis-aligned doubles directly then no
1673 // fixup is needed.  Else we split the double into 2 integer pieces
1674 // and move it piece-by-piece.  Only happens when passing doubles into
1675 // C code as the Java calling convention forces doubles to be aligned.
1676 const bool Matcher::misaligned_doubles_ok = true;
1677 
1678 // No-op on amd64
1679 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {}
1680 
1681 // Advertise here if the CPU requires explicit rounding operations to
1682 // implement the UseStrictFP mode.
1683 const bool Matcher::strict_fp_requires_explicit_rounding = true;
1684 
1685 // Are floats conerted to double when stored to stack during deoptimization?
1686 // On x64 it is stored without convertion so we can use normal access.
1687 bool Matcher::float_in_double() { return false; }
1688 
1689 // Do ints take an entire long register or just half?
1690 const bool Matcher::int_in_long = true;
1691 
1692 // Return whether or not this register is ever used as an argument.
1693 // This function is used on startup to build the trampoline stubs in
1694 // generateOptoStub.  Registers not mentioned will be killed by the VM
1695 // call in the trampoline, and arguments in those registers not be
1696 // available to the callee.
1697 bool Matcher::can_be_java_arg(int reg)
1698 {
1699   return
1700     reg ==  RDI_num || reg == RDI_H_num ||
1701     reg ==  RSI_num || reg == RSI_H_num ||
1702     reg ==  RDX_num || reg == RDX_H_num ||
1703     reg ==  RCX_num || reg == RCX_H_num ||
1704     reg ==   R8_num || reg ==  R8_H_num ||
1705     reg ==   R9_num || reg ==  R9_H_num ||
1706     reg ==  R12_num || reg == R12_H_num ||
1707     reg == XMM0_num || reg == XMM0b_num ||
1708     reg == XMM1_num || reg == XMM1b_num ||
1709     reg == XMM2_num || reg == XMM2b_num ||
1710     reg == XMM3_num || reg == XMM3b_num ||
1711     reg == XMM4_num || reg == XMM4b_num ||
1712     reg == XMM5_num || reg == XMM5b_num ||
1713     reg == XMM6_num || reg == XMM6b_num ||
1714     reg == XMM7_num || reg == XMM7b_num;
1715 }
1716 
1717 bool Matcher::is_spillable_arg(int reg)
1718 {
1719   return can_be_java_arg(reg);
1720 }
1721 
1722 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
1723   // In 64 bit mode a code which use multiply when
1724   // devisor is constant is faster than hardware
1725   // DIV instruction (it uses MulHiL).
1726   return false;
1727 }
1728 
1729 // Register for DIVI projection of divmodI
1730 RegMask Matcher::divI_proj_mask() {
1731   return INT_RAX_REG_mask();
1732 }
1733 
1734 // Register for MODI projection of divmodI
1735 RegMask Matcher::modI_proj_mask() {
1736   return INT_RDX_REG_mask();
1737 }
1738 
1739 // Register for DIVL projection of divmodL
1740 RegMask Matcher::divL_proj_mask() {
1741   return LONG_RAX_REG_mask();
1742 }
1743 
1744 // Register for MODL projection of divmodL
1745 RegMask Matcher::modL_proj_mask() {
1746   return LONG_RDX_REG_mask();
1747 }
1748 
1749 // Register for saving SP into on method handle invokes. Not used on x86_64.
1750 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
1751     return NO_REG_mask();
1752 }
1753 
1754 %}
1755 
1756 //----------ENCODING BLOCK-----------------------------------------------------
1757 // This block specifies the encoding classes used by the compiler to
1758 // output byte streams.  Encoding classes are parameterized macros
1759 // used by Machine Instruction Nodes in order to generate the bit
1760 // encoding of the instruction.  Operands specify their base encoding
1761 // interface with the interface keyword.  There are currently
1762 // supported four interfaces, REG_INTER, CONST_INTER, MEMORY_INTER, &amp;
1763 // COND_INTER.  REG_INTER causes an operand to generate a function
1764 // which returns its register number when queried.  CONST_INTER causes
1765 // an operand to generate a function which returns the value of the
1766 // constant when queried.  MEMORY_INTER causes an operand to generate
1767 // four functions which return the Base Register, the Index Register,
1768 // the Scale Value, and the Offset Value of the operand when queried.
1769 // COND_INTER causes an operand to generate six functions which return
1770 // the encoding code (ie - encoding bits for the instruction)
1771 // associated with each basic boolean condition for a conditional
1772 // instruction.
1773 //
1774 // Instructions specify two basic values for encoding.  Again, a
1775 // function is available to check if the constant displacement is an
1776 // oop. They use the ins_encode keyword to specify their encoding
1777 // classes (which must be a sequence of enc_class names, and their
1778 // parameters, specified in the encoding block), and they use the
1779 // opcode keyword to specify, in order, their primary, secondary, and
1780 // tertiary opcode.  Only the opcode sections which a particular
1781 // instruction needs for encoding need to be specified.
1782 encode %{
1783   // Build emit functions for each basic byte or larger field in the
1784   // intel encoding scheme (opcode, rm, sib, immediate), and call them
1785   // from C++ code in the enc_class source block.  Emit functions will
1786   // live in the main source block for now.  In future, we can
1787   // generalize this by adding a syntax that specifies the sizes of
1788   // fields in an order, so that the adlc can build the emit functions
1789   // automagically
1790 
1791   // Emit primary opcode
1792   enc_class OpcP
1793   %{
1794     emit_opcode(cbuf, $primary);
1795   %}
1796 
1797   // Emit secondary opcode
1798   enc_class OpcS
1799   %{
1800     emit_opcode(cbuf, $secondary);
1801   %}
1802 
1803   // Emit tertiary opcode
1804   enc_class OpcT
1805   %{
1806     emit_opcode(cbuf, $tertiary);
1807   %}
1808 
1809   // Emit opcode directly
1810   enc_class Opcode(immI d8)
1811   %{
1812     emit_opcode(cbuf, $d8$$constant);
1813   %}
1814 
1815   // Emit size prefix
1816   enc_class SizePrefix
1817   %{
1818     emit_opcode(cbuf, 0x66);
1819   %}
1820 
1821   enc_class reg(rRegI reg)
1822   %{
1823     emit_rm(cbuf, 0x3, 0, $reg$$reg &amp; 7);
1824   %}
1825 
1826   enc_class reg_reg(rRegI dst, rRegI src)
1827   %{
1828     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1829   %}
1830 
1831   enc_class opc_reg_reg(immI opcode, rRegI dst, rRegI src)
1832   %{
1833     emit_opcode(cbuf, $opcode$$constant);
1834     emit_rm(cbuf, 0x3, $dst$$reg &amp; 7, $src$$reg &amp; 7);
1835   %}
1836 
1837   enc_class cdql_enc(no_rax_rdx_RegI div)
1838   %{
1839     // Full implementation of Java idiv and irem; checks for
1840     // special case as described in JVM spec., p.243 &amp; p.271.
1841     //
1842     //         normal case                           special case
1843     //
1844     // input : rax: dividend                         min_int
1845     //         reg: divisor                          -1
1846     //
1847     // output: rax: quotient  (= rax idiv reg)       min_int
1848     //         rdx: remainder (= rax irem reg)       0
1849     //
1850     //  Code sequnce:
1851     //
1852     //    0:   3d 00 00 00 80          cmp    $0x80000000,%eax
1853     //    5:   75 07/08                jne    e &lt;normal&gt;
1854     //    7:   33 d2                   xor    %edx,%edx
1855     //  [div &gt;= 8 -&gt; offset + 1]
1856     //  [REX_B]
1857     //    9:   83 f9 ff                cmp    $0xffffffffffffffff,$div
1858     //    c:   74 03/04                je     11 &lt;done&gt;
1859     // 000000000000000e &lt;normal&gt;:
1860     //    e:   99                      cltd
1861     //  [div &gt;= 8 -&gt; offset + 1]
1862     //  [REX_B]
1863     //    f:   f7 f9                   idiv   $div
1864     // 0000000000000011 &lt;done&gt;:
1865 
1866     // cmp    $0x80000000,%eax
1867     emit_opcode(cbuf, 0x3d);
1868     emit_d8(cbuf, 0x00);
1869     emit_d8(cbuf, 0x00);
1870     emit_d8(cbuf, 0x00);
1871     emit_d8(cbuf, 0x80);
1872 
1873     // jne    e &lt;normal&gt;
1874     emit_opcode(cbuf, 0x75);
1875     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x07 : 0x08);
1876 
1877     // xor    %edx,%edx
1878     emit_opcode(cbuf, 0x33);
1879     emit_d8(cbuf, 0xD2);
1880 
1881     // cmp    $0xffffffffffffffff,%ecx
1882     if ($div$$reg &gt;= 8) {
1883       emit_opcode(cbuf, Assembler::REX_B);
1884     }
1885     emit_opcode(cbuf, 0x83);
1886     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1887     emit_d8(cbuf, 0xFF);
1888 
1889     // je     11 &lt;done&gt;
1890     emit_opcode(cbuf, 0x74);
1891     emit_d8(cbuf, $div$$reg &lt; 8 ? 0x03 : 0x04);
1892 
1893     // &lt;normal&gt;
1894     // cltd
1895     emit_opcode(cbuf, 0x99);
1896 
1897     // idivl (note: must be emitted by the user of this rule)
1898     // &lt;done&gt;
1899   %}
1900 
1901   enc_class cdqq_enc(no_rax_rdx_RegL div)
1902   %{
1903     // Full implementation of Java ldiv and lrem; checks for
1904     // special case as described in JVM spec., p.243 &amp; p.271.
1905     //
1906     //         normal case                           special case
1907     //
1908     // input : rax: dividend                         min_long
1909     //         reg: divisor                          -1
1910     //
1911     // output: rax: quotient  (= rax idiv reg)       min_long
1912     //         rdx: remainder (= rax irem reg)       0
1913     //
1914     //  Code sequnce:
1915     //
1916     //    0:   48 ba 00 00 00 00 00    mov    $0x8000000000000000,%rdx
1917     //    7:   00 00 80
1918     //    a:   48 39 d0                cmp    %rdx,%rax
1919     //    d:   75 08                   jne    17 &lt;normal&gt;
1920     //    f:   33 d2                   xor    %edx,%edx
1921     //   11:   48 83 f9 ff             cmp    $0xffffffffffffffff,$div
1922     //   15:   74 05                   je     1c &lt;done&gt;
1923     // 0000000000000017 &lt;normal&gt;:
1924     //   17:   48 99                   cqto
1925     //   19:   48 f7 f9                idiv   $div
1926     // 000000000000001c &lt;done&gt;:
1927 
1928     // mov    $0x8000000000000000,%rdx
1929     emit_opcode(cbuf, Assembler::REX_W);
1930     emit_opcode(cbuf, 0xBA);
1931     emit_d8(cbuf, 0x00);
1932     emit_d8(cbuf, 0x00);
1933     emit_d8(cbuf, 0x00);
1934     emit_d8(cbuf, 0x00);
1935     emit_d8(cbuf, 0x00);
1936     emit_d8(cbuf, 0x00);
1937     emit_d8(cbuf, 0x00);
1938     emit_d8(cbuf, 0x80);
1939 
1940     // cmp    %rdx,%rax
1941     emit_opcode(cbuf, Assembler::REX_W);
1942     emit_opcode(cbuf, 0x39);
1943     emit_d8(cbuf, 0xD0);
1944 
1945     // jne    17 &lt;normal&gt;
1946     emit_opcode(cbuf, 0x75);
1947     emit_d8(cbuf, 0x08);
1948 
1949     // xor    %edx,%edx
1950     emit_opcode(cbuf, 0x33);
1951     emit_d8(cbuf, 0xD2);
1952 
1953     // cmp    $0xffffffffffffffff,$div
1954     emit_opcode(cbuf, $div$$reg &lt; 8 ? Assembler::REX_W : Assembler::REX_WB);
1955     emit_opcode(cbuf, 0x83);
1956     emit_rm(cbuf, 0x3, 0x7, $div$$reg &amp; 7);
1957     emit_d8(cbuf, 0xFF);
1958 
1959     // je     1e &lt;done&gt;
1960     emit_opcode(cbuf, 0x74);
1961     emit_d8(cbuf, 0x05);
1962 
1963     // &lt;normal&gt;
1964     // cqto
1965     emit_opcode(cbuf, Assembler::REX_W);
1966     emit_opcode(cbuf, 0x99);
1967 
1968     // idivq (note: must be emitted by the user of this rule)
1969     // &lt;done&gt;
1970   %}
1971 
1972   // Opcde enc_class for 8/32 bit immediate instructions with sign-extension
1973   enc_class OpcSE(immI imm)
1974   %{
1975     // Emit primary opcode and set sign-extend bit
1976     // Check for 8-bit immediate, and set sign extend bit in opcode
1977     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1978       emit_opcode(cbuf, $primary | 0x02);
1979     } else {
1980       // 32-bit immediate
1981       emit_opcode(cbuf, $primary);
1982     }
1983   %}
1984 
1985   enc_class OpcSErm(rRegI dst, immI imm)
1986   %{
1987     // OpcSEr/m
1988     int dstenc = $dst$$reg;
1989     if (dstenc &gt;= 8) {
1990       emit_opcode(cbuf, Assembler::REX_B);
1991       dstenc -= 8;
1992     }
1993     // Emit primary opcode and set sign-extend bit
1994     // Check for 8-bit immediate, and set sign extend bit in opcode
1995     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
1996       emit_opcode(cbuf, $primary | 0x02);
1997     } else {
1998       // 32-bit immediate
1999       emit_opcode(cbuf, $primary);
2000     }
2001     // Emit r/m byte with secondary opcode, after primary opcode.
2002     emit_rm(cbuf, 0x3, $secondary, dstenc);
2003   %}
2004 
2005   enc_class OpcSErm_wide(rRegL dst, immI imm)
2006   %{
2007     // OpcSEr/m
2008     int dstenc = $dst$$reg;
2009     if (dstenc &lt; 8) {
2010       emit_opcode(cbuf, Assembler::REX_W);
2011     } else {
2012       emit_opcode(cbuf, Assembler::REX_WB);
2013       dstenc -= 8;
2014     }
2015     // Emit primary opcode and set sign-extend bit
2016     // Check for 8-bit immediate, and set sign extend bit in opcode
2017     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2018       emit_opcode(cbuf, $primary | 0x02);
2019     } else {
2020       // 32-bit immediate
2021       emit_opcode(cbuf, $primary);
2022     }
2023     // Emit r/m byte with secondary opcode, after primary opcode.
2024     emit_rm(cbuf, 0x3, $secondary, dstenc);
2025   %}
2026 
2027   enc_class Con8or32(immI imm)
2028   %{
2029     // Check for 8-bit immediate, and set sign extend bit in opcode
2030     if (-0x80 &lt;= $imm$$constant &amp;&amp; $imm$$constant &lt; 0x80) {
2031       $$$emit8$imm$$constant;
2032     } else {
2033       // 32-bit immediate
2034       $$$emit32$imm$$constant;
2035     }
2036   %}
2037 
2038   enc_class opc2_reg(rRegI dst)
2039   %{
2040     // BSWAP
2041     emit_cc(cbuf, $secondary, $dst$$reg);
2042   %}
2043 
2044   enc_class opc3_reg(rRegI dst)
2045   %{
2046     // BSWAP
2047     emit_cc(cbuf, $tertiary, $dst$$reg);
2048   %}
2049 
2050   enc_class reg_opc(rRegI div)
2051   %{
2052     // INC, DEC, IDIV, IMOD, JMP indirect, ...
2053     emit_rm(cbuf, 0x3, $secondary, $div$$reg &amp; 7);
2054   %}
2055 
2056   enc_class enc_cmov(cmpOp cop)
2057   %{
2058     // CMOV
2059     $$$emit8$primary;
2060     emit_cc(cbuf, $secondary, $cop$$cmpcode);
2061   %}
2062 
2063   enc_class enc_PartialSubtypeCheck()
2064   %{
2065     Register Rrdi = as_Register(RDI_enc); // result register
2066     Register Rrax = as_Register(RAX_enc); // super class
2067     Register Rrcx = as_Register(RCX_enc); // killed
2068     Register Rrsi = as_Register(RSI_enc); // sub class
2069     Label miss;
2070     const bool set_cond_codes = true;
2071 
2072     MacroAssembler _masm(&amp;cbuf);
2073     __ check_klass_subtype_slow_path(Rrsi, Rrax, Rrcx, Rrdi,
2074                                      NULL, &amp;miss,
2075                                      /*set_cond_codes:*/ true);
2076     if ($primary) {
2077       __ xorptr(Rrdi, Rrdi);
2078     }
2079     __ bind(miss);
2080   %}
2081 
2082   enc_class clear_avx %{
2083     debug_only(int off0 = cbuf.insts_size());
2084     if (ra_-&gt;C-&gt;max_vector_size() &gt; 16) {
2085       // Clear upper bits of YMM registers when current compiled code uses
2086       // wide vectors to avoid AVX &lt;-&gt; SSE transition penalty during call.
2087       MacroAssembler _masm(&amp;cbuf);
2088       __ vzeroupper();
2089     }
2090     debug_only(int off1 = cbuf.insts_size());
2091     assert(off1 - off0 == clear_avx_size(), "correct size prediction");
2092   %}
2093 
2094   enc_class Java_To_Runtime(method meth) %{
2095     // No relocation needed
2096     MacroAssembler _masm(&amp;cbuf);
2097     __ mov64(r10, (int64_t) $meth$$method);
2098     __ call(r10);
2099   %}
2100 
2101   enc_class Java_To_Interpreter(method meth)
2102   %{
2103     // CALL Java_To_Interpreter
2104     // This is the instruction starting address for relocation info.
2105     cbuf.set_insts_mark();
2106     $$$emit8$primary;
2107     // CALL directly to the runtime
2108     emit_d32_reloc(cbuf,
2109                    (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2110                    runtime_call_Relocation::spec(),
2111                    RELOC_DISP32);
2112   %}
2113 
2114   enc_class Java_Static_Call(method meth)
2115   %{
2116     // JAVA STATIC CALL
2117     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to
2118     // determine who we intended to call.
2119     cbuf.set_insts_mark();
2120     $$$emit8$primary;
2121 
2122     if (!_method) {
2123       emit_d32_reloc(cbuf,
2124                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2125                      runtime_call_Relocation::spec(),
2126                      RELOC_DISP32);
2127     } else if (_optimized_virtual) {
2128       emit_d32_reloc(cbuf,
2129                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2130                      opt_virtual_call_Relocation::spec(),
2131                      RELOC_DISP32);
2132     } else {
2133       emit_d32_reloc(cbuf,
2134                      (int) ($meth$$method - ((intptr_t) cbuf.insts_end()) - 4),
2135                      static_call_Relocation::spec(),
2136                      RELOC_DISP32);
2137     }
2138     if (_method) {
2139       // Emit stub for static call.
2140       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
2141       if (stub == NULL) {
2142         ciEnv::current()-&gt;record_failure("CodeCache is full");
2143         return;
2144       } 
2145     }
2146   %}
2147 
2148   enc_class Java_Dynamic_Call(method meth) %{
2149     MacroAssembler _masm(&amp;cbuf);
2150     __ ic_call((address)$meth$$method);
2151   %}
2152 
2153   enc_class Java_Compiled_Call(method meth)
2154   %{
2155     // JAVA COMPILED CALL
2156     int disp = in_bytes(Method:: from_compiled_offset());
2157 
2158     // XXX XXX offset is 128 is 1.5 NON-PRODUCT !!!
2159     // assert(-0x80 &lt;= disp &amp;&amp; disp &lt; 0x80, "compiled_code_offset isn't small");
2160 
2161     // callq *disp(%rax)
2162     cbuf.set_insts_mark();
2163     $$$emit8$primary;
2164     if (disp &lt; 0x80) {
2165       emit_rm(cbuf, 0x01, $secondary, RAX_enc); // R/M byte
2166       emit_d8(cbuf, disp); // Displacement
2167     } else {
2168       emit_rm(cbuf, 0x02, $secondary, RAX_enc); // R/M byte
2169       emit_d32(cbuf, disp); // Displacement
2170     }
2171   %}
2172 
2173   enc_class reg_opc_imm(rRegI dst, immI8 shift)
2174   %{
2175     // SAL, SAR, SHR
2176     int dstenc = $dst$$reg;
2177     if (dstenc &gt;= 8) {
2178       emit_opcode(cbuf, Assembler::REX_B);
2179       dstenc -= 8;
2180     }
2181     $$$emit8$primary;
2182     emit_rm(cbuf, 0x3, $secondary, dstenc);
2183     $$$emit8$shift$$constant;
2184   %}
2185 
2186   enc_class reg_opc_imm_wide(rRegL dst, immI8 shift)
2187   %{
2188     // SAL, SAR, SHR
2189     int dstenc = $dst$$reg;
2190     if (dstenc &lt; 8) {
2191       emit_opcode(cbuf, Assembler::REX_W);
2192     } else {
2193       emit_opcode(cbuf, Assembler::REX_WB);
2194       dstenc -= 8;
2195     }
2196     $$$emit8$primary;
2197     emit_rm(cbuf, 0x3, $secondary, dstenc);
2198     $$$emit8$shift$$constant;
2199   %}
2200 
2201   enc_class load_immI(rRegI dst, immI src)
2202   %{
2203     int dstenc = $dst$$reg;
2204     if (dstenc &gt;= 8) {
2205       emit_opcode(cbuf, Assembler::REX_B);
2206       dstenc -= 8;
2207     }
2208     emit_opcode(cbuf, 0xB8 | dstenc);
2209     $$$emit32$src$$constant;
2210   %}
2211 
2212   enc_class load_immL(rRegL dst, immL src)
2213   %{
2214     int dstenc = $dst$$reg;
2215     if (dstenc &lt; 8) {
2216       emit_opcode(cbuf, Assembler::REX_W);
2217     } else {
2218       emit_opcode(cbuf, Assembler::REX_WB);
2219       dstenc -= 8;
2220     }
2221     emit_opcode(cbuf, 0xB8 | dstenc);
2222     emit_d64(cbuf, $src$$constant);
2223   %}
2224 
2225   enc_class load_immUL32(rRegL dst, immUL32 src)
2226   %{
2227     // same as load_immI, but this time we care about zeroes in the high word
2228     int dstenc = $dst$$reg;
2229     if (dstenc &gt;= 8) {
2230       emit_opcode(cbuf, Assembler::REX_B);
2231       dstenc -= 8;
2232     }
2233     emit_opcode(cbuf, 0xB8 | dstenc);
2234     $$$emit32$src$$constant;
2235   %}
2236 
2237   enc_class load_immL32(rRegL dst, immL32 src)
2238   %{
2239     int dstenc = $dst$$reg;
2240     if (dstenc &lt; 8) {
2241       emit_opcode(cbuf, Assembler::REX_W);
2242     } else {
2243       emit_opcode(cbuf, Assembler::REX_WB);
2244       dstenc -= 8;
2245     }
2246     emit_opcode(cbuf, 0xC7);
2247     emit_rm(cbuf, 0x03, 0x00, dstenc);
2248     $$$emit32$src$$constant;
2249   %}
2250 
2251   enc_class load_immP31(rRegP dst, immP32 src)
2252   %{
2253     // same as load_immI, but this time we care about zeroes in the high word
2254     int dstenc = $dst$$reg;
2255     if (dstenc &gt;= 8) {
2256       emit_opcode(cbuf, Assembler::REX_B);
2257       dstenc -= 8;
2258     }
2259     emit_opcode(cbuf, 0xB8 | dstenc);
2260     $$$emit32$src$$constant;
2261   %}
2262 
2263   enc_class load_immP(rRegP dst, immP src)
2264   %{
2265     int dstenc = $dst$$reg;
2266     if (dstenc &lt; 8) {
2267       emit_opcode(cbuf, Assembler::REX_W);
2268     } else {
2269       emit_opcode(cbuf, Assembler::REX_WB);
2270       dstenc -= 8;
2271     }
2272     emit_opcode(cbuf, 0xB8 | dstenc);
2273     // This next line should be generated from ADLC
2274     if ($src-&gt;constant_reloc() != relocInfo::none) {
2275       emit_d64_reloc(cbuf, $src$$constant, $src-&gt;constant_reloc(), RELOC_IMM64);
2276     } else {
2277       emit_d64(cbuf, $src$$constant);
2278     }
2279   %}
2280 
2281   enc_class Con32(immI src)
2282   %{
2283     // Output immediate
2284     $$$emit32$src$$constant;
2285   %}
2286 
2287   enc_class Con32F_as_bits(immF src)
2288   %{
2289     // Output Float immediate bits
2290     jfloat jf = $src$$constant;
2291     jint jf_as_bits = jint_cast(jf);
2292     emit_d32(cbuf, jf_as_bits);
2293   %}
2294 
2295   enc_class Con16(immI src)
2296   %{
2297     // Output immediate
2298     $$$emit16$src$$constant;
2299   %}
2300 
2301   // How is this different from Con32??? XXX
2302   enc_class Con_d32(immI src)
2303   %{
2304     emit_d32(cbuf,$src$$constant);
2305   %}
2306 
2307   enc_class conmemref (rRegP t1) %{    // Con32(storeImmI)
2308     // Output immediate memory reference
2309     emit_rm(cbuf, 0x00, $t1$$reg, 0x05 );
2310     emit_d32(cbuf, 0x00);
2311   %}
2312 
2313   enc_class lock_prefix()
2314   %{
2315     if (os::is_MP()) {
2316       emit_opcode(cbuf, 0xF0); // lock
2317     }
2318   %}
2319 
2320   enc_class REX_mem(memory mem)
2321   %{
2322     if ($mem$$base &gt;= 8) {
2323       if ($mem$$index &lt; 8) {
2324         emit_opcode(cbuf, Assembler::REX_B);
2325       } else {
2326         emit_opcode(cbuf, Assembler::REX_XB);
2327       }
2328     } else {
2329       if ($mem$$index &gt;= 8) {
2330         emit_opcode(cbuf, Assembler::REX_X);
2331       }
2332     }
2333   %}
2334 
2335   enc_class REX_mem_wide(memory mem)
2336   %{
2337     if ($mem$$base &gt;= 8) {
2338       if ($mem$$index &lt; 8) {
2339         emit_opcode(cbuf, Assembler::REX_WB);
2340       } else {
2341         emit_opcode(cbuf, Assembler::REX_WXB);
2342       }
2343     } else {
2344       if ($mem$$index &lt; 8) {
2345         emit_opcode(cbuf, Assembler::REX_W);
2346       } else {
2347         emit_opcode(cbuf, Assembler::REX_WX);
2348       }
2349     }
2350   %}
2351 
2352   // for byte regs
2353   enc_class REX_breg(rRegI reg)
2354   %{
2355     if ($reg$$reg &gt;= 4) {
2356       emit_opcode(cbuf, $reg$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2357     }
2358   %}
2359 
2360   // for byte regs
2361   enc_class REX_reg_breg(rRegI dst, rRegI src)
2362   %{
2363     if ($dst$$reg &lt; 8) {
2364       if ($src$$reg &gt;= 4) {
2365         emit_opcode(cbuf, $src$$reg &lt; 8 ? Assembler::REX : Assembler::REX_B);
2366       }
2367     } else {
2368       if ($src$$reg &lt; 8) {
2369         emit_opcode(cbuf, Assembler::REX_R);
2370       } else {
2371         emit_opcode(cbuf, Assembler::REX_RB);
2372       }
2373     }
2374   %}
2375 
2376   // for byte regs
2377   enc_class REX_breg_mem(rRegI reg, memory mem)
2378   %{
2379     if ($reg$$reg &lt; 8) {
2380       if ($mem$$base &lt; 8) {
2381         if ($mem$$index &gt;= 8) {
2382           emit_opcode(cbuf, Assembler::REX_X);
2383         } else if ($reg$$reg &gt;= 4) {
2384           emit_opcode(cbuf, Assembler::REX);
2385         }
2386       } else {
2387         if ($mem$$index &lt; 8) {
2388           emit_opcode(cbuf, Assembler::REX_B);
2389         } else {
2390           emit_opcode(cbuf, Assembler::REX_XB);
2391         }
2392       }
2393     } else {
2394       if ($mem$$base &lt; 8) {
2395         if ($mem$$index &lt; 8) {
2396           emit_opcode(cbuf, Assembler::REX_R);
2397         } else {
2398           emit_opcode(cbuf, Assembler::REX_RX);
2399         }
2400       } else {
2401         if ($mem$$index &lt; 8) {
2402           emit_opcode(cbuf, Assembler::REX_RB);
2403         } else {
2404           emit_opcode(cbuf, Assembler::REX_RXB);
2405         }
2406       }
2407     }
2408   %}
2409 
2410   enc_class REX_reg(rRegI reg)
2411   %{
2412     if ($reg$$reg &gt;= 8) {
2413       emit_opcode(cbuf, Assembler::REX_B);
2414     }
2415   %}
2416 
2417   enc_class REX_reg_wide(rRegI reg)
2418   %{
2419     if ($reg$$reg &lt; 8) {
2420       emit_opcode(cbuf, Assembler::REX_W);
2421     } else {
2422       emit_opcode(cbuf, Assembler::REX_WB);
2423     }
2424   %}
2425 
2426   enc_class REX_reg_reg(rRegI dst, rRegI src)
2427   %{
2428     if ($dst$$reg &lt; 8) {
2429       if ($src$$reg &gt;= 8) {
2430         emit_opcode(cbuf, Assembler::REX_B);
2431       }
2432     } else {
2433       if ($src$$reg &lt; 8) {
2434         emit_opcode(cbuf, Assembler::REX_R);
2435       } else {
2436         emit_opcode(cbuf, Assembler::REX_RB);
2437       }
2438     }
2439   %}
2440 
2441   enc_class REX_reg_reg_wide(rRegI dst, rRegI src)
2442   %{
2443     if ($dst$$reg &lt; 8) {
2444       if ($src$$reg &lt; 8) {
2445         emit_opcode(cbuf, Assembler::REX_W);
2446       } else {
2447         emit_opcode(cbuf, Assembler::REX_WB);
2448       }
2449     } else {
2450       if ($src$$reg &lt; 8) {
2451         emit_opcode(cbuf, Assembler::REX_WR);
2452       } else {
2453         emit_opcode(cbuf, Assembler::REX_WRB);
2454       }
2455     }
2456   %}
2457 
2458   enc_class REX_reg_mem(rRegI reg, memory mem)
2459   %{
2460     if ($reg$$reg &lt; 8) {
2461       if ($mem$$base &lt; 8) {
2462         if ($mem$$index &gt;= 8) {
2463           emit_opcode(cbuf, Assembler::REX_X);
2464         }
2465       } else {
2466         if ($mem$$index &lt; 8) {
2467           emit_opcode(cbuf, Assembler::REX_B);
2468         } else {
2469           emit_opcode(cbuf, Assembler::REX_XB);
2470         }
2471       }
2472     } else {
2473       if ($mem$$base &lt; 8) {
2474         if ($mem$$index &lt; 8) {
2475           emit_opcode(cbuf, Assembler::REX_R);
2476         } else {
2477           emit_opcode(cbuf, Assembler::REX_RX);
2478         }
2479       } else {
2480         if ($mem$$index &lt; 8) {
2481           emit_opcode(cbuf, Assembler::REX_RB);
2482         } else {
2483           emit_opcode(cbuf, Assembler::REX_RXB);
2484         }
2485       }
2486     }
2487   %}
2488 
2489   enc_class REX_reg_mem_wide(rRegL reg, memory mem)
2490   %{
2491     if ($reg$$reg &lt; 8) {
2492       if ($mem$$base &lt; 8) {
2493         if ($mem$$index &lt; 8) {
2494           emit_opcode(cbuf, Assembler::REX_W);
2495         } else {
2496           emit_opcode(cbuf, Assembler::REX_WX);
2497         }
2498       } else {
2499         if ($mem$$index &lt; 8) {
2500           emit_opcode(cbuf, Assembler::REX_WB);
2501         } else {
2502           emit_opcode(cbuf, Assembler::REX_WXB);
2503         }
2504       }
2505     } else {
2506       if ($mem$$base &lt; 8) {
2507         if ($mem$$index &lt; 8) {
2508           emit_opcode(cbuf, Assembler::REX_WR);
2509         } else {
2510           emit_opcode(cbuf, Assembler::REX_WRX);
2511         }
2512       } else {
2513         if ($mem$$index &lt; 8) {
2514           emit_opcode(cbuf, Assembler::REX_WRB);
2515         } else {
2516           emit_opcode(cbuf, Assembler::REX_WRXB);
2517         }
2518       }
2519     }
2520   %}
2521 
2522   enc_class reg_mem(rRegI ereg, memory mem)
2523   %{
2524     // High registers handle in encode_RegMem
2525     int reg = $ereg$$reg;
2526     int base = $mem$$base;
2527     int index = $mem$$index;
2528     int scale = $mem$$scale;
2529     int disp = $mem$$disp;
2530     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();
2531 
2532     encode_RegMem(cbuf, reg, base, index, scale, disp, disp_reloc);
2533   %}
2534 
2535   enc_class RM_opc_mem(immI rm_opcode, memory mem)
2536   %{
2537     int rm_byte_opcode = $rm_opcode$$constant;
2538 
2539     // High registers handle in encode_RegMem
2540     int base = $mem$$base;
2541     int index = $mem$$index;
2542     int scale = $mem$$scale;
2543     int displace = $mem$$disp;
2544 
2545     relocInfo::relocType disp_reloc = $mem-&gt;disp_reloc();       // disp-as-oop when
2546                                             // working with static
2547                                             // globals
2548     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace,
2549                   disp_reloc);
2550   %}
2551 
2552   enc_class reg_lea(rRegI dst, rRegI src0, immI src1)
2553   %{
2554     int reg_encoding = $dst$$reg;
2555     int base         = $src0$$reg;      // 0xFFFFFFFF indicates no base
2556     int index        = 0x04;            // 0x04 indicates no index
2557     int scale        = 0x00;            // 0x00 indicates no scale
2558     int displace     = $src1$$constant; // 0x00 indicates no displacement
2559     relocInfo::relocType disp_reloc = relocInfo::none;
2560     encode_RegMem(cbuf, reg_encoding, base, index, scale, displace,
2561                   disp_reloc);
2562   %}
2563 
2564   enc_class neg_reg(rRegI dst)
2565   %{
2566     int dstenc = $dst$$reg;
2567     if (dstenc &gt;= 8) {
2568       emit_opcode(cbuf, Assembler::REX_B);
2569       dstenc -= 8;
2570     }
2571     // NEG $dst
2572     emit_opcode(cbuf, 0xF7);
2573     emit_rm(cbuf, 0x3, 0x03, dstenc);
2574   %}
2575 
2576   enc_class neg_reg_wide(rRegI dst)
2577   %{
2578     int dstenc = $dst$$reg;
2579     if (dstenc &lt; 8) {
2580       emit_opcode(cbuf, Assembler::REX_W);
2581     } else {
2582       emit_opcode(cbuf, Assembler::REX_WB);
2583       dstenc -= 8;
2584     }
2585     // NEG $dst
2586     emit_opcode(cbuf, 0xF7);
2587     emit_rm(cbuf, 0x3, 0x03, dstenc);
2588   %}
2589 
2590   enc_class setLT_reg(rRegI dst)
2591   %{
2592     int dstenc = $dst$$reg;
2593     if (dstenc &gt;= 8) {
2594       emit_opcode(cbuf, Assembler::REX_B);
2595       dstenc -= 8;
2596     } else if (dstenc &gt;= 4) {
2597       emit_opcode(cbuf, Assembler::REX);
2598     }
2599     // SETLT $dst
2600     emit_opcode(cbuf, 0x0F);
2601     emit_opcode(cbuf, 0x9C);
2602     emit_rm(cbuf, 0x3, 0x0, dstenc);
2603   %}
2604 
2605   enc_class setNZ_reg(rRegI dst)
2606   %{
2607     int dstenc = $dst$$reg;
2608     if (dstenc &gt;= 8) {
2609       emit_opcode(cbuf, Assembler::REX_B);
2610       dstenc -= 8;
2611     } else if (dstenc &gt;= 4) {
2612       emit_opcode(cbuf, Assembler::REX);
2613     }
2614     // SETNZ $dst
2615     emit_opcode(cbuf, 0x0F);
2616     emit_opcode(cbuf, 0x95);
2617     emit_rm(cbuf, 0x3, 0x0, dstenc);
2618   %}
2619 
2620 
2621   // Compare the lonogs and set -1, 0, or 1 into dst
2622   enc_class cmpl3_flag(rRegL src1, rRegL src2, rRegI dst)
2623   %{
2624     int src1enc = $src1$$reg;
2625     int src2enc = $src2$$reg;
2626     int dstenc = $dst$$reg;
2627 
2628     // cmpq $src1, $src2
2629     if (src1enc &lt; 8) {
2630       if (src2enc &lt; 8) {
2631         emit_opcode(cbuf, Assembler::REX_W);
2632       } else {
2633         emit_opcode(cbuf, Assembler::REX_WB);
2634       }
2635     } else {
2636       if (src2enc &lt; 8) {
2637         emit_opcode(cbuf, Assembler::REX_WR);
2638       } else {
2639         emit_opcode(cbuf, Assembler::REX_WRB);
2640       }
2641     }
2642     emit_opcode(cbuf, 0x3B);
2643     emit_rm(cbuf, 0x3, src1enc &amp; 7, src2enc &amp; 7);
2644 
2645     // movl $dst, -1
2646     if (dstenc &gt;= 8) {
2647       emit_opcode(cbuf, Assembler::REX_B);
2648     }
2649     emit_opcode(cbuf, 0xB8 | (dstenc &amp; 7));
2650     emit_d32(cbuf, -1);
2651 
2652     // jl,s done
2653     emit_opcode(cbuf, 0x7C);
2654     emit_d8(cbuf, dstenc &lt; 4 ? 0x06 : 0x08);
2655 
2656     // setne $dst
2657     if (dstenc &gt;= 4) {
2658       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_B);
2659     }
2660     emit_opcode(cbuf, 0x0F);
2661     emit_opcode(cbuf, 0x95);
2662     emit_opcode(cbuf, 0xC0 | (dstenc &amp; 7));
2663 
2664     // movzbl $dst, $dst
2665     if (dstenc &gt;= 4) {
2666       emit_opcode(cbuf, dstenc &lt; 8 ? Assembler::REX : Assembler::REX_RB);
2667     }
2668     emit_opcode(cbuf, 0x0F);
2669     emit_opcode(cbuf, 0xB6);
2670     emit_rm(cbuf, 0x3, dstenc &amp; 7, dstenc &amp; 7);
2671   %}
2672 
2673   enc_class Push_ResultXD(regD dst) %{
2674     MacroAssembler _masm(&amp;cbuf);
2675     __ fstp_d(Address(rsp, 0));
2676     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
2677     __ addptr(rsp, 8);
2678   %}
2679 
2680   enc_class Push_SrcXD(regD src) %{
2681     MacroAssembler _masm(&amp;cbuf);
2682     __ subptr(rsp, 8);
2683     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
2684     __ fld_d(Address(rsp, 0));
2685   %}
2686 
2687 
2688   enc_class enc_rethrow()
2689   %{
2690     cbuf.set_insts_mark();
2691     emit_opcode(cbuf, 0xE9); // jmp entry
2692     emit_d32_reloc(cbuf,
2693                    (int) (OptoRuntime::rethrow_stub() - cbuf.insts_end() - 4),
2694                    runtime_call_Relocation::spec(),
2695                    RELOC_DISP32);
2696   %}
2697 
2698 %}
2699 
2700 
2701 
2702 //----------FRAME--------------------------------------------------------------
2703 // Definition of frame structure and management information.
2704 //
2705 //  S T A C K   L A Y O U T    Allocators stack-slot number
2706 //                             |   (to get allocators register number
2707 //  G  Owned by    |        |  v    add OptoReg::stack0())
2708 //  r   CALLER     |        |
2709 //  o     |        +--------+      pad to even-align allocators stack-slot
2710 //  w     V        |  pad0  |        numbers; owned by CALLER
2711 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
2712 //  h     ^        |   in   |  5
2713 //        |        |  args  |  4   Holes in incoming args owned by SELF
2714 //  |     |        |        |  3
2715 //  |     |        +--------+
2716 //  V     |        | old out|      Empty on Intel, window on Sparc
2717 //        |    old |preserve|      Must be even aligned.
2718 //        |     SP-+--------+----&gt; Matcher::_old_SP, even aligned
2719 //        |        |   in   |  3   area for Intel ret address
2720 //     Owned by    |preserve|      Empty on Sparc.
2721 //       SELF      +--------+
2722 //        |        |  pad2  |  2   pad to align old SP
2723 //        |        +--------+  1
2724 //        |        | locks  |  0
2725 //        |        +--------+----&gt; OptoReg::stack0(), even aligned
2726 //        |        |  pad1  | 11   pad to align new SP
2727 //        |        +--------+
2728 //        |        |        | 10
2729 //        |        | spills |  9   spills
2730 //        V        |        |  8   (pad0 slot for callee)
2731 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
2732 //        ^        |  out   |  7
2733 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
2734 //     Owned by    +--------+
2735 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
2736 //        |    new |preserve|      Must be even-aligned.
2737 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
2738 //        |        |        |
2739 //
2740 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
2741 //         known from SELF's arguments and the Java calling convention.
2742 //         Region 6-7 is determined per call site.
2743 // Note 2: If the calling convention leaves holes in the incoming argument
2744 //         area, those holes are owned by SELF.  Holes in the outgoing area
2745 //         are owned by the CALLEE.  Holes should not be nessecary in the
2746 //         incoming area, as the Java calling convention is completely under
2747 //         the control of the AD file.  Doubles can be sorted and packed to
2748 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
2749 //         varargs C calling conventions.
2750 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
2751 //         even aligned with pad0 as needed.
2752 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
2753 //         region 6-11 is even aligned; it may be padded out more so that
2754 //         the region from SP to FP meets the minimum stack alignment.
2755 // Note 4: For I2C adapters, the incoming FP may not meet the minimum stack
2756 //         alignment.  Region 11, pad1, may be dynamically extended so that
2757 //         SP meets the minimum alignment.
2758 
2759 frame
2760 %{
2761   // What direction does stack grow in (assumed to be same for C &amp; Java)
2762   stack_direction(TOWARDS_LOW);
2763 
2764   // These three registers define part of the calling convention
2765   // between compiled code and the interpreter.
2766   inline_cache_reg(RAX);                // Inline Cache Register
2767   interpreter_method_oop_reg(RBX);      // Method Oop Register when
2768                                         // calling interpreter
2769 
2770   // Optional: name the operand used by cisc-spilling to access
2771   // [stack_pointer + offset]
2772   cisc_spilling_operand_name(indOffset32);
2773 
2774   // Number of stack slots consumed by locking an object
2775   sync_stack_slots(2);
2776 
2777   // Compiled code's Frame Pointer
2778   frame_pointer(RSP);
2779 
2780   // Interpreter stores its frame pointer in a register which is
2781   // stored to the stack by I2CAdaptors.
2782   // I2CAdaptors convert from interpreted java to compiled java.
2783   interpreter_frame_pointer(RBP);
2784 
2785   // Stack alignment requirement
2786   stack_alignment(StackAlignmentInBytes); // Alignment size in bytes (128-bit -&gt; 16 bytes)
2787 
2788   // Number of stack slots between incoming argument block and the start of
2789   // a new frame.  The PROLOG must add this many slots to the stack.  The
2790   // EPILOG must remove this many slots.  amd64 needs two slots for
2791   // return address.
2792   in_preserve_stack_slots(4 + 2 * VerifyStackAtCalls);
2793 
2794   // Number of outgoing stack slots killed above the out_preserve_stack_slots
2795   // for calls to C.  Supports the var-args backing area for register parms.
2796   varargs_C_out_slots_killed(frame::arg_reg_save_area_bytes/BytesPerInt);
2797 
2798   // The after-PROLOG location of the return address.  Location of
2799   // return address specifies a type (REG or STACK) and a number
2800   // representing the register number (i.e. - use a register name) or
2801   // stack slot.
2802   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
2803   // Otherwise, it is above the locks and verification slot and alignment word
2804   return_addr(STACK - 2 +
2805               round_to((Compile::current()-&gt;in_preserve_stack_slots() +
2806                         Compile::current()-&gt;fixed_slots()),
2807                        stack_alignment_in_slots()));
2808 
2809   // Body of function which returns an integer array locating
2810   // arguments either in registers or in stack slots.  Passed an array
2811   // of ideal registers called "sig" and a "length" count.  Stack-slot
2812   // offsets are based on outgoing arguments, i.e. a CALLER setting up
2813   // arguments for a CALLEE.  Incoming stack arguments are
2814   // automatically biased by the preserve_stack_slots field above.
2815 
2816   calling_convention
2817   %{
2818     // No difference between ingoing/outgoing just pass false
2819     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
2820   %}
2821 
2822   c_calling_convention
2823   %{
2824     // This is obviously always outgoing
2825     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
2826   %}
2827 
2828   // Location of compiled Java return values.  Same as C for now.
2829   return_value
2830   %{
2831     assert(ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL,
2832            "only return normal values");
2833 
2834     static const int lo[Op_RegL + 1] = {
2835       0,
2836       0,
2837       RAX_num,  // Op_RegN
2838       RAX_num,  // Op_RegI
2839       RAX_num,  // Op_RegP
2840       XMM0_num, // Op_RegF
2841       XMM0_num, // Op_RegD
2842       RAX_num   // Op_RegL
2843     };
2844     static const int hi[Op_RegL + 1] = {
2845       0,
2846       0,
2847       OptoReg::Bad, // Op_RegN
2848       OptoReg::Bad, // Op_RegI
2849       RAX_H_num,    // Op_RegP
2850       OptoReg::Bad, // Op_RegF
2851       XMM0b_num,    // Op_RegD
2852       RAX_H_num     // Op_RegL
2853     };
2854     // Excluded flags and vector registers.
2855     assert(ARRAY_SIZE(hi) == _last_machine_leaf - 6, "missing type");
2856     return OptoRegPair(hi[ideal_reg], lo[ideal_reg]);
2857   %}
2858 %}
2859 
2860 //----------ATTRIBUTES---------------------------------------------------------
2861 //----------Operand Attributes-------------------------------------------------
2862 op_attrib op_cost(0);        // Required cost attribute
2863 
2864 //----------Instruction Attributes---------------------------------------------
2865 ins_attrib ins_cost(100);       // Required cost attribute
2866 ins_attrib ins_size(8);         // Required size attribute (in bits)
2867 ins_attrib ins_short_branch(0); // Required flag: is this instruction
2868                                 // a non-matching short branch variant
2869                                 // of some long branch?
2870 ins_attrib ins_alignment(1);    // Required alignment attribute (must
2871                                 // be a power of 2) specifies the
2872                                 // alignment that some part of the
2873                                 // instruction (not necessarily the
2874                                 // start) requires.  If &gt; 1, a
2875                                 // compute_padding() function must be
2876                                 // provided for the instruction
2877 
2878 //----------OPERANDS-----------------------------------------------------------
2879 // Operand definitions must precede instruction definitions for correct parsing
2880 // in the ADLC because operands constitute user defined types which are used in
2881 // instruction definitions.
2882 
2883 //----------Simple Operands----------------------------------------------------
2884 // Immediate Operands
2885 // Integer Immediate
2886 operand immI()
2887 %{
2888   match(ConI);
2889 
2890   op_cost(10);
2891   format %{ %}
2892   interface(CONST_INTER);
2893 %}
2894 
2895 // Constant for test vs zero
2896 operand immI0()
2897 %{
2898   predicate(n-&gt;get_int() == 0);
2899   match(ConI);
2900 
2901   op_cost(0);
2902   format %{ %}
2903   interface(CONST_INTER);
2904 %}
2905 
2906 // Constant for increment
2907 operand immI1()
2908 %{
2909   predicate(n-&gt;get_int() == 1);
2910   match(ConI);
2911 
2912   op_cost(0);
2913   format %{ %}
2914   interface(CONST_INTER);
2915 %}
2916 
2917 // Constant for decrement
2918 operand immI_M1()
2919 %{
2920   predicate(n-&gt;get_int() == -1);
2921   match(ConI);
2922 
2923   op_cost(0);
2924   format %{ %}
2925   interface(CONST_INTER);
2926 %}
2927 
2928 // Valid scale values for addressing modes
2929 operand immI2()
2930 %{
2931   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 3));
2932   match(ConI);
2933 
2934   format %{ %}
2935   interface(CONST_INTER);
2936 %}
2937 
2938 operand immI8()
2939 %{
2940   predicate((-0x80 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt; 0x80));
2941   match(ConI);
2942 
2943   op_cost(5);
2944   format %{ %}
2945   interface(CONST_INTER);
2946 %}
2947 
2948 operand immI16()
2949 %{
2950   predicate((-32768 &lt;= n-&gt;get_int()) &amp;&amp; (n-&gt;get_int() &lt;= 32767));
2951   match(ConI);
2952 
2953   op_cost(10);
2954   format %{ %}
2955   interface(CONST_INTER);
2956 %}
2957 
2958 // Int Immediate non-negative
2959 operand immU31()
2960 %{
2961   predicate(n-&gt;get_int() &gt;= 0);
2962   match(ConI);
2963 
2964   op_cost(0);
2965   format %{ %}
2966   interface(CONST_INTER);
2967 %}
2968 
2969 // Constant for long shifts
2970 operand immI_32()
2971 %{
2972   predicate( n-&gt;get_int() == 32 );
2973   match(ConI);
2974 
2975   op_cost(0);
2976   format %{ %}
2977   interface(CONST_INTER);
2978 %}
2979 
2980 // Constant for long shifts
2981 operand immI_64()
2982 %{
2983   predicate( n-&gt;get_int() == 64 );
2984   match(ConI);
2985 
2986   op_cost(0);
2987   format %{ %}
2988   interface(CONST_INTER);
2989 %}
2990 
2991 // Pointer Immediate
2992 operand immP()
2993 %{
2994   match(ConP);
2995 
2996   op_cost(10);
2997   format %{ %}
2998   interface(CONST_INTER);
2999 %}
3000 
3001 // NULL Pointer Immediate
3002 operand immP0()
3003 %{
3004   predicate(n-&gt;get_ptr() == 0);
3005   match(ConP);
3006 
3007   op_cost(5);
3008   format %{ %}
3009   interface(CONST_INTER);
3010 %}
3011 
3012 // Pointer Immediate
3013 operand immN() %{
3014   match(ConN);
3015 
3016   op_cost(10);
3017   format %{ %}
3018   interface(CONST_INTER);
3019 %}
3020 
3021 operand immNKlass() %{
3022   match(ConNKlass);
3023 
3024   op_cost(10);
3025   format %{ %}
3026   interface(CONST_INTER);
3027 %}
3028 
3029 // NULL Pointer Immediate
3030 operand immN0() %{
3031   predicate(n-&gt;get_narrowcon() == 0);
3032   match(ConN);
3033 
3034   op_cost(5);
3035   format %{ %}
3036   interface(CONST_INTER);
3037 %}
3038 
3039 operand immP31()
3040 %{
3041   predicate(n-&gt;as_Type()-&gt;type()-&gt;reloc() == relocInfo::none
3042             &amp;&amp; (n-&gt;get_ptr() &gt;&gt; 31) == 0);
3043   match(ConP);
3044 
3045   op_cost(5);
3046   format %{ %}
3047   interface(CONST_INTER);
3048 %}
3049 
3050 
3051 // Long Immediate
3052 operand immL()
3053 %{
3054   match(ConL);
3055 
3056   op_cost(20);
3057   format %{ %}
3058   interface(CONST_INTER);
3059 %}
3060 
3061 // Long Immediate 8-bit
3062 operand immL8()
3063 %{
3064   predicate(-0x80L &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80L);
3065   match(ConL);
3066 
3067   op_cost(5);
3068   format %{ %}
3069   interface(CONST_INTER);
3070 %}
3071 
3072 // Long Immediate 32-bit unsigned
3073 operand immUL32()
3074 %{
3075   predicate(n-&gt;get_long() == (unsigned int) (n-&gt;get_long()));
3076   match(ConL);
3077 
3078   op_cost(10);
3079   format %{ %}
3080   interface(CONST_INTER);
3081 %}
3082 
3083 // Long Immediate 32-bit signed
3084 operand immL32()
3085 %{
3086   predicate(n-&gt;get_long() == (int) (n-&gt;get_long()));
3087   match(ConL);
3088 
3089   op_cost(15);
3090   format %{ %}
3091   interface(CONST_INTER);
3092 %}
3093 
3094 // Long Immediate zero
3095 operand immL0()
3096 %{
3097   predicate(n-&gt;get_long() == 0L);
3098   match(ConL);
3099 
3100   op_cost(10);
3101   format %{ %}
3102   interface(CONST_INTER);
3103 %}
3104 
3105 // Constant for increment
3106 operand immL1()
3107 %{
3108   predicate(n-&gt;get_long() == 1);
3109   match(ConL);
3110 
3111   format %{ %}
3112   interface(CONST_INTER);
3113 %}
3114 
3115 // Constant for decrement
3116 operand immL_M1()
3117 %{
3118   predicate(n-&gt;get_long() == -1);
3119   match(ConL);
3120 
3121   format %{ %}
3122   interface(CONST_INTER);
3123 %}
3124 
3125 // Long Immediate: the value 10
3126 operand immL10()
3127 %{
3128   predicate(n-&gt;get_long() == 10);
3129   match(ConL);
3130 
3131   format %{ %}
3132   interface(CONST_INTER);
3133 %}
3134 
3135 // Long immediate from 0 to 127.
3136 // Used for a shorter form of long mul by 10.
3137 operand immL_127()
3138 %{
3139   predicate(0 &lt;= n-&gt;get_long() &amp;&amp; n-&gt;get_long() &lt; 0x80);
3140   match(ConL);
3141 
3142   op_cost(10);
3143   format %{ %}
3144   interface(CONST_INTER);
3145 %}
3146 
3147 // Long Immediate: low 32-bit mask
3148 operand immL_32bits()
3149 %{
3150   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
3151   match(ConL);
3152   op_cost(20);
3153 
3154   format %{ %}
3155   interface(CONST_INTER);
3156 %}
3157 
3158 // Float Immediate zero
3159 operand immF0()
3160 %{
3161   predicate(jint_cast(n-&gt;getf()) == 0);
3162   match(ConF);
3163 
3164   op_cost(5);
3165   format %{ %}
3166   interface(CONST_INTER);
3167 %}
3168 
3169 // Float Immediate
3170 operand immF()
3171 %{
3172   match(ConF);
3173 
3174   op_cost(15);
3175   format %{ %}
3176   interface(CONST_INTER);
3177 %}
3178 
3179 // Double Immediate zero
3180 operand immD0()
3181 %{
3182   predicate(jlong_cast(n-&gt;getd()) == 0);
3183   match(ConD);
3184 
3185   op_cost(5);
3186   format %{ %}
3187   interface(CONST_INTER);
3188 %}
3189 
3190 // Double Immediate
3191 operand immD()
3192 %{
3193   match(ConD);
3194 
3195   op_cost(15);
3196   format %{ %}
3197   interface(CONST_INTER);
3198 %}
3199 
3200 // Immediates for special shifts (sign extend)
3201 
3202 // Constants for increment
3203 operand immI_16()
3204 %{
3205   predicate(n-&gt;get_int() == 16);
3206   match(ConI);
3207 
3208   format %{ %}
3209   interface(CONST_INTER);
3210 %}
3211 
3212 operand immI_24()
3213 %{
3214   predicate(n-&gt;get_int() == 24);
3215   match(ConI);
3216 
3217   format %{ %}
3218   interface(CONST_INTER);
3219 %}
3220 
3221 // Constant for byte-wide masking
3222 operand immI_255()
3223 %{
3224   predicate(n-&gt;get_int() == 255);
3225   match(ConI);
3226 
3227   format %{ %}
3228   interface(CONST_INTER);
3229 %}
3230 
3231 // Constant for short-wide masking
3232 operand immI_65535()
3233 %{
3234   predicate(n-&gt;get_int() == 65535);
3235   match(ConI);
3236 
3237   format %{ %}
3238   interface(CONST_INTER);
3239 %}
3240 
3241 // Constant for byte-wide masking
3242 operand immL_255()
3243 %{
3244   predicate(n-&gt;get_long() == 255);
3245   match(ConL);
3246 
3247   format %{ %}
3248   interface(CONST_INTER);
3249 %}
3250 
3251 // Constant for short-wide masking
3252 operand immL_65535()
3253 %{
3254   predicate(n-&gt;get_long() == 65535);
3255   match(ConL);
3256 
3257   format %{ %}
3258   interface(CONST_INTER);
3259 %}
3260 
3261 // Register Operands
3262 // Integer Register
3263 operand rRegI()
3264 %{
3265   constraint(ALLOC_IN_RC(int_reg));
3266   match(RegI);
3267 
3268   match(rax_RegI);
3269   match(rbx_RegI);
3270   match(rcx_RegI);
3271   match(rdx_RegI);
3272   match(rdi_RegI);
3273 
3274   format %{ %}
3275   interface(REG_INTER);
3276 %}
3277 
3278 // Special Registers
3279 operand rax_RegI()
3280 %{
3281   constraint(ALLOC_IN_RC(int_rax_reg));
3282   match(RegI);
3283   match(rRegI);
3284 
3285   format %{ "RAX" %}
3286   interface(REG_INTER);
3287 %}
3288 
3289 // Special Registers
3290 operand rbx_RegI()
3291 %{
3292   constraint(ALLOC_IN_RC(int_rbx_reg));
3293   match(RegI);
3294   match(rRegI);
3295 
3296   format %{ "RBX" %}
3297   interface(REG_INTER);
3298 %}
3299 
3300 operand rcx_RegI()
3301 %{
3302   constraint(ALLOC_IN_RC(int_rcx_reg));
3303   match(RegI);
3304   match(rRegI);
3305 
3306   format %{ "RCX" %}
3307   interface(REG_INTER);
3308 %}
3309 
3310 operand rdx_RegI()
3311 %{
3312   constraint(ALLOC_IN_RC(int_rdx_reg));
3313   match(RegI);
3314   match(rRegI);
3315 
3316   format %{ "RDX" %}
3317   interface(REG_INTER);
3318 %}
3319 
3320 operand rdi_RegI()
3321 %{
3322   constraint(ALLOC_IN_RC(int_rdi_reg));
3323   match(RegI);
3324   match(rRegI);
3325 
3326   format %{ "RDI" %}
3327   interface(REG_INTER);
3328 %}
3329 
3330 operand no_rcx_RegI()
3331 %{
3332   constraint(ALLOC_IN_RC(int_no_rcx_reg));
3333   match(RegI);
3334   match(rax_RegI);
3335   match(rbx_RegI);
3336   match(rdx_RegI);
3337   match(rdi_RegI);
3338 
3339   format %{ %}
3340   interface(REG_INTER);
3341 %}
3342 
3343 operand no_rax_rdx_RegI()
3344 %{
3345   constraint(ALLOC_IN_RC(int_no_rax_rdx_reg));
3346   match(RegI);
3347   match(rbx_RegI);
3348   match(rcx_RegI);
3349   match(rdi_RegI);
3350 
3351   format %{ %}
3352   interface(REG_INTER);
3353 %}
3354 
3355 // Pointer Register
3356 operand any_RegP()
3357 %{
3358   constraint(ALLOC_IN_RC(any_reg));
3359   match(RegP);
3360   match(rax_RegP);
3361   match(rbx_RegP);
3362   match(rdi_RegP);
3363   match(rsi_RegP);
3364   match(rbp_RegP);
3365   match(r15_RegP);
3366   match(rRegP);
3367 
3368   format %{ %}
3369   interface(REG_INTER);
3370 %}
3371 
3372 operand rRegP()
3373 %{
3374   constraint(ALLOC_IN_RC(ptr_reg));
3375   match(RegP);
3376   match(rax_RegP);
3377   match(rbx_RegP);
3378   match(rdi_RegP);
3379   match(rsi_RegP);
3380   match(rbp_RegP);  // See Q&amp;A below about
3381   match(r15_RegP);  // r15_RegP and rbp_RegP.
3382 
3383   format %{ %}
3384   interface(REG_INTER);
3385 %}
3386 
3387 operand rRegN() %{
3388   constraint(ALLOC_IN_RC(int_reg));
3389   match(RegN);
3390 
3391   format %{ %}
3392   interface(REG_INTER);
3393 %}
3394 
3395 // Question: Why is r15_RegP (the read-only TLS register) a match for rRegP?
3396 // Answer: Operand match rules govern the DFA as it processes instruction inputs.
3397 // It's fine for an instruction input that expects rRegP to match a r15_RegP.
3398 // The output of an instruction is controlled by the allocator, which respects
3399 // register class masks, not match rules.  Unless an instruction mentions
3400 // r15_RegP or any_RegP explicitly as its output, r15 will not be considered
3401 // by the allocator as an input.
3402 // The same logic applies to rbp_RegP being a match for rRegP: If PreserveFramePointer==true,
3403 // the RBP is used as a proper frame pointer and is not included in ptr_reg. As a
3404 // result, RBP is not included in the output of the instruction either.
3405 
3406 operand no_rax_RegP()
3407 %{
3408   constraint(ALLOC_IN_RC(ptr_no_rax_reg));
3409   match(RegP);
3410   match(rbx_RegP);
3411   match(rsi_RegP);
3412   match(rdi_RegP);
3413 
3414   format %{ %}
3415   interface(REG_INTER);
3416 %}
3417 
3418 // This operand is not allowed to use RBP even if
3419 // RBP is not used to hold the frame pointer.
3420 operand no_rbp_RegP()
3421 %{
3422   constraint(ALLOC_IN_RC(ptr_reg_no_rbp));
3423   match(RegP);
3424   match(rbx_RegP);
3425   match(rsi_RegP);
3426   match(rdi_RegP);
3427 
3428   format %{ %}
3429   interface(REG_INTER);
3430 %}
3431 
3432 operand no_rax_rbx_RegP()
3433 %{
3434   constraint(ALLOC_IN_RC(ptr_no_rax_rbx_reg));
3435   match(RegP);
3436   match(rsi_RegP);
3437   match(rdi_RegP);
3438 
3439   format %{ %}
3440   interface(REG_INTER);
3441 %}
3442 
3443 // Special Registers
3444 // Return a pointer value
3445 operand rax_RegP()
3446 %{
3447   constraint(ALLOC_IN_RC(ptr_rax_reg));
3448   match(RegP);
3449   match(rRegP);
3450 
3451   format %{ %}
3452   interface(REG_INTER);
3453 %}
3454 
3455 // Special Registers
3456 // Return a compressed pointer value
3457 operand rax_RegN()
3458 %{
3459   constraint(ALLOC_IN_RC(int_rax_reg));
3460   match(RegN);
3461   match(rRegN);
3462 
3463   format %{ %}
3464   interface(REG_INTER);
3465 %}
3466 
3467 // Used in AtomicAdd
3468 operand rbx_RegP()
3469 %{
3470   constraint(ALLOC_IN_RC(ptr_rbx_reg));
3471   match(RegP);
3472   match(rRegP);
3473 
3474   format %{ %}
3475   interface(REG_INTER);
3476 %}
3477 
3478 operand rsi_RegP()
3479 %{
3480   constraint(ALLOC_IN_RC(ptr_rsi_reg));
3481   match(RegP);
3482   match(rRegP);
3483 
3484   format %{ %}
3485   interface(REG_INTER);
3486 %}
3487 
3488 // Used in rep stosq
3489 operand rdi_RegP()
3490 %{
3491   constraint(ALLOC_IN_RC(ptr_rdi_reg));
3492   match(RegP);
3493   match(rRegP);
3494 
3495   format %{ %}
3496   interface(REG_INTER);
3497 %}
3498 
3499 operand r15_RegP()
3500 %{
3501   constraint(ALLOC_IN_RC(ptr_r15_reg));
3502   match(RegP);
3503   match(rRegP);
3504 
3505   format %{ %}
3506   interface(REG_INTER);
3507 %}
3508 
3509 operand rRegL()
3510 %{
3511   constraint(ALLOC_IN_RC(long_reg));
3512   match(RegL);
3513   match(rax_RegL);
3514   match(rdx_RegL);
3515 
3516   format %{ %}
3517   interface(REG_INTER);
3518 %}
3519 
3520 // Special Registers
3521 operand no_rax_rdx_RegL()
3522 %{
3523   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3524   match(RegL);
3525   match(rRegL);
3526 
3527   format %{ %}
3528   interface(REG_INTER);
3529 %}
3530 
3531 operand no_rax_RegL()
3532 %{
3533   constraint(ALLOC_IN_RC(long_no_rax_rdx_reg));
3534   match(RegL);
3535   match(rRegL);
3536   match(rdx_RegL);
3537 
3538   format %{ %}
3539   interface(REG_INTER);
3540 %}
3541 
3542 operand no_rcx_RegL()
3543 %{
3544   constraint(ALLOC_IN_RC(long_no_rcx_reg));
3545   match(RegL);
3546   match(rRegL);
3547 
3548   format %{ %}
3549   interface(REG_INTER);
3550 %}
3551 
3552 operand rax_RegL()
3553 %{
3554   constraint(ALLOC_IN_RC(long_rax_reg));
3555   match(RegL);
3556   match(rRegL);
3557 
3558   format %{ "RAX" %}
3559   interface(REG_INTER);
3560 %}
3561 
3562 operand rcx_RegL()
3563 %{
3564   constraint(ALLOC_IN_RC(long_rcx_reg));
3565   match(RegL);
3566   match(rRegL);
3567 
3568   format %{ %}
3569   interface(REG_INTER);
3570 %}
3571 
3572 operand rdx_RegL()
3573 %{
3574   constraint(ALLOC_IN_RC(long_rdx_reg));
3575   match(RegL);
3576   match(rRegL);
3577 
3578   format %{ %}
3579   interface(REG_INTER);
3580 %}
3581 
3582 // Flags register, used as output of compare instructions
3583 operand rFlagsReg()
3584 %{
3585   constraint(ALLOC_IN_RC(int_flags));
3586   match(RegFlags);
3587 
3588   format %{ "RFLAGS" %}
3589   interface(REG_INTER);
3590 %}
3591 
3592 // Flags register, used as output of FLOATING POINT compare instructions
3593 operand rFlagsRegU()
3594 %{
3595   constraint(ALLOC_IN_RC(int_flags));
3596   match(RegFlags);
3597 
3598   format %{ "RFLAGS_U" %}
3599   interface(REG_INTER);
3600 %}
3601 
3602 operand rFlagsRegUCF() %{
3603   constraint(ALLOC_IN_RC(int_flags));
3604   match(RegFlags);
3605   predicate(false);
3606 
3607   format %{ "RFLAGS_U_CF" %}
3608   interface(REG_INTER);
3609 %}
3610 
3611 // Float register operands
3612 operand regF() %{
3613    constraint(ALLOC_IN_RC(float_reg));
3614    match(RegF);
3615 
3616    format %{ %}
3617    interface(REG_INTER);
3618 %}
3619 
3620 // Double register operands
3621 operand regD() %{
3622    constraint(ALLOC_IN_RC(double_reg));
3623    match(RegD);
3624 
3625    format %{ %}
3626    interface(REG_INTER);
3627 %}
3628 
3629 // Vectors
3630 operand vecS() %{
3631   constraint(ALLOC_IN_RC(vectors_reg));
3632   match(VecS);
3633 
3634   format %{ %}
3635   interface(REG_INTER);
3636 %}
3637 
3638 operand vecD() %{
3639   constraint(ALLOC_IN_RC(vectord_reg));
3640   match(VecD);
3641 
3642   format %{ %}
3643   interface(REG_INTER);
3644 %}
3645 
3646 operand vecX() %{
3647   constraint(ALLOC_IN_RC(vectorx_reg));
3648   match(VecX);
3649 
3650   format %{ %}
3651   interface(REG_INTER);
3652 %}
3653 
3654 operand vecY() %{
3655   constraint(ALLOC_IN_RC(vectory_reg));
3656   match(VecY);
3657 
3658   format %{ %}
3659   interface(REG_INTER);
3660 %}
3661 
3662 //----------Memory Operands----------------------------------------------------
3663 // Direct Memory Operand
3664 // operand direct(immP addr)
3665 // %{
3666 //   match(addr);
3667 
3668 //   format %{ "[$addr]" %}
3669 //   interface(MEMORY_INTER) %{
3670 //     base(0xFFFFFFFF);
3671 //     index(0x4);
3672 //     scale(0x0);
3673 //     disp($addr);
3674 //   %}
3675 // %}
3676 
3677 // Indirect Memory Operand
3678 operand indirect(any_RegP reg)
3679 %{
3680   constraint(ALLOC_IN_RC(ptr_reg));
3681   match(reg);
3682 
3683   format %{ "[$reg]" %}
3684   interface(MEMORY_INTER) %{
3685     base($reg);
3686     index(0x4);
3687     scale(0x0);
3688     disp(0x0);
3689   %}
3690 %}
3691 
3692 // Indirect Memory Plus Short Offset Operand
3693 operand indOffset8(any_RegP reg, immL8 off)
3694 %{
3695   constraint(ALLOC_IN_RC(ptr_reg));
3696   match(AddP reg off);
3697 
3698   format %{ "[$reg + $off (8-bit)]" %}
3699   interface(MEMORY_INTER) %{
3700     base($reg);
3701     index(0x4);
3702     scale(0x0);
3703     disp($off);
3704   %}
3705 %}
3706 
3707 // Indirect Memory Plus Long Offset Operand
3708 operand indOffset32(any_RegP reg, immL32 off)
3709 %{
3710   constraint(ALLOC_IN_RC(ptr_reg));
3711   match(AddP reg off);
3712 
3713   format %{ "[$reg + $off (32-bit)]" %}
3714   interface(MEMORY_INTER) %{
3715     base($reg);
3716     index(0x4);
3717     scale(0x0);
3718     disp($off);
3719   %}
3720 %}
3721 
3722 // Indirect Memory Plus Index Register Plus Offset Operand
3723 operand indIndexOffset(any_RegP reg, rRegL lreg, immL32 off)
3724 %{
3725   constraint(ALLOC_IN_RC(ptr_reg));
3726   match(AddP (AddP reg lreg) off);
3727 
3728   op_cost(10);
3729   format %{"[$reg + $off + $lreg]" %}
3730   interface(MEMORY_INTER) %{
3731     base($reg);
3732     index($lreg);
3733     scale(0x0);
3734     disp($off);
3735   %}
3736 %}
3737 
3738 // Indirect Memory Plus Index Register Plus Offset Operand
3739 operand indIndex(any_RegP reg, rRegL lreg)
3740 %{
3741   constraint(ALLOC_IN_RC(ptr_reg));
3742   match(AddP reg lreg);
3743 
3744   op_cost(10);
3745   format %{"[$reg + $lreg]" %}
3746   interface(MEMORY_INTER) %{
3747     base($reg);
3748     index($lreg);
3749     scale(0x0);
3750     disp(0x0);
3751   %}
3752 %}
3753 
3754 // Indirect Memory Times Scale Plus Index Register
3755 operand indIndexScale(any_RegP reg, rRegL lreg, immI2 scale)
3756 %{
3757   constraint(ALLOC_IN_RC(ptr_reg));
3758   match(AddP reg (LShiftL lreg scale));
3759 
3760   op_cost(10);
3761   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3762   interface(MEMORY_INTER) %{
3763     base($reg);
3764     index($lreg);
3765     scale($scale);
3766     disp(0x0);
3767   %}
3768 %}
3769 
3770 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3771 operand indIndexScaleOffset(any_RegP reg, immL32 off, rRegL lreg, immI2 scale)
3772 %{
3773   constraint(ALLOC_IN_RC(ptr_reg));
3774   match(AddP (AddP reg (LShiftL lreg scale)) off);
3775 
3776   op_cost(10);
3777   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3778   interface(MEMORY_INTER) %{
3779     base($reg);
3780     index($lreg);
3781     scale($scale);
3782     disp($off);
3783   %}
3784 %}
3785 
3786 // Indirect Memory Plus Positive Index Register Plus Offset Operand
3787 operand indPosIndexOffset(any_RegP reg, immL32 off, rRegI idx)
3788 %{
3789   constraint(ALLOC_IN_RC(ptr_reg));
3790   predicate(n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3791   match(AddP (AddP reg (ConvI2L idx)) off);
3792 
3793   op_cost(10);
3794   format %{"[$reg + $off + $idx]" %}
3795   interface(MEMORY_INTER) %{
3796     base($reg);
3797     index($idx);
3798     scale(0x0);
3799     disp($off);
3800   %}
3801 %}
3802 
3803 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3804 operand indPosIndexScaleOffset(any_RegP reg, immL32 off, rRegI idx, immI2 scale)
3805 %{
3806   constraint(ALLOC_IN_RC(ptr_reg));
3807   predicate(n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3808   match(AddP (AddP reg (LShiftL (ConvI2L idx) scale)) off);
3809 
3810   op_cost(10);
3811   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3812   interface(MEMORY_INTER) %{
3813     base($reg);
3814     index($idx);
3815     scale($scale);
3816     disp($off);
3817   %}
3818 %}
3819 
3820 // Indirect Narrow Oop Plus Offset Operand
3821 // Note: x86 architecture doesn't support "scale * index + offset" without a base
3822 // we can't free r12 even with Universe::narrow_oop_base() == NULL.
3823 operand indCompressedOopOffset(rRegN reg, immL32 off) %{
3824   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() == Address::times_8));
3825   constraint(ALLOC_IN_RC(ptr_reg));
3826   match(AddP (DecodeN reg) off);
3827 
3828   op_cost(10);
3829   format %{"[R12 + $reg &lt;&lt; 3 + $off] (compressed oop addressing)" %}
3830   interface(MEMORY_INTER) %{
3831     base(0xc); // R12
3832     index($reg);
3833     scale(0x3);
3834     disp($off);
3835   %}
3836 %}
3837 
3838 // Indirect Memory Operand
3839 operand indirectNarrow(rRegN reg)
3840 %{
3841   predicate(Universe::narrow_oop_shift() == 0);
3842   constraint(ALLOC_IN_RC(ptr_reg));
3843   match(DecodeN reg);
3844 
3845   format %{ "[$reg]" %}
3846   interface(MEMORY_INTER) %{
3847     base($reg);
3848     index(0x4);
3849     scale(0x0);
3850     disp(0x0);
3851   %}
3852 %}
3853 
3854 // Indirect Memory Plus Short Offset Operand
3855 operand indOffset8Narrow(rRegN reg, immL8 off)
3856 %{
3857   predicate(Universe::narrow_oop_shift() == 0);
3858   constraint(ALLOC_IN_RC(ptr_reg));
3859   match(AddP (DecodeN reg) off);
3860 
3861   format %{ "[$reg + $off (8-bit)]" %}
3862   interface(MEMORY_INTER) %{
3863     base($reg);
3864     index(0x4);
3865     scale(0x0);
3866     disp($off);
3867   %}
3868 %}
3869 
3870 // Indirect Memory Plus Long Offset Operand
3871 operand indOffset32Narrow(rRegN reg, immL32 off)
3872 %{
3873   predicate(Universe::narrow_oop_shift() == 0);
3874   constraint(ALLOC_IN_RC(ptr_reg));
3875   match(AddP (DecodeN reg) off);
3876 
3877   format %{ "[$reg + $off (32-bit)]" %}
3878   interface(MEMORY_INTER) %{
3879     base($reg);
3880     index(0x4);
3881     scale(0x0);
3882     disp($off);
3883   %}
3884 %}
3885 
3886 // Indirect Memory Plus Index Register Plus Offset Operand
3887 operand indIndexOffsetNarrow(rRegN reg, rRegL lreg, immL32 off)
3888 %{
3889   predicate(Universe::narrow_oop_shift() == 0);
3890   constraint(ALLOC_IN_RC(ptr_reg));
3891   match(AddP (AddP (DecodeN reg) lreg) off);
3892 
3893   op_cost(10);
3894   format %{"[$reg + $off + $lreg]" %}
3895   interface(MEMORY_INTER) %{
3896     base($reg);
3897     index($lreg);
3898     scale(0x0);
3899     disp($off);
3900   %}
3901 %}
3902 
3903 // Indirect Memory Plus Index Register Plus Offset Operand
3904 operand indIndexNarrow(rRegN reg, rRegL lreg)
3905 %{
3906   predicate(Universe::narrow_oop_shift() == 0);
3907   constraint(ALLOC_IN_RC(ptr_reg));
3908   match(AddP (DecodeN reg) lreg);
3909 
3910   op_cost(10);
3911   format %{"[$reg + $lreg]" %}
3912   interface(MEMORY_INTER) %{
3913     base($reg);
3914     index($lreg);
3915     scale(0x0);
3916     disp(0x0);
3917   %}
3918 %}
3919 
3920 // Indirect Memory Times Scale Plus Index Register
3921 operand indIndexScaleNarrow(rRegN reg, rRegL lreg, immI2 scale)
3922 %{
3923   predicate(Universe::narrow_oop_shift() == 0);
3924   constraint(ALLOC_IN_RC(ptr_reg));
3925   match(AddP (DecodeN reg) (LShiftL lreg scale));
3926 
3927   op_cost(10);
3928   format %{"[$reg + $lreg &lt;&lt; $scale]" %}
3929   interface(MEMORY_INTER) %{
3930     base($reg);
3931     index($lreg);
3932     scale($scale);
3933     disp(0x0);
3934   %}
3935 %}
3936 
3937 // Indirect Memory Times Scale Plus Index Register Plus Offset Operand
3938 operand indIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegL lreg, immI2 scale)
3939 %{
3940   predicate(Universe::narrow_oop_shift() == 0);
3941   constraint(ALLOC_IN_RC(ptr_reg));
3942   match(AddP (AddP (DecodeN reg) (LShiftL lreg scale)) off);
3943 
3944   op_cost(10);
3945   format %{"[$reg + $off + $lreg &lt;&lt; $scale]" %}
3946   interface(MEMORY_INTER) %{
3947     base($reg);
3948     index($lreg);
3949     scale($scale);
3950     disp($off);
3951   %}
3952 %}
3953 
3954 // Indirect Memory Times Plus Positive Index Register Plus Offset Operand
3955 operand indPosIndexOffsetNarrow(rRegN reg, immL32 off, rRegI idx)
3956 %{
3957   constraint(ALLOC_IN_RC(ptr_reg));
3958   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3959   match(AddP (AddP (DecodeN reg) (ConvI2L idx)) off);
3960 
3961   op_cost(10);
3962   format %{"[$reg + $off + $idx]" %}
3963   interface(MEMORY_INTER) %{
3964     base($reg);
3965     index($idx);
3966     scale(0x0);
3967     disp($off);
3968   %}
3969 %}
3970 
3971 // Indirect Memory Times Scale Plus Positive Index Register Plus Offset Operand
3972 operand indPosIndexScaleOffsetNarrow(rRegN reg, immL32 off, rRegI idx, immI2 scale)
3973 %{
3974   constraint(ALLOC_IN_RC(ptr_reg));
3975   predicate(Universe::narrow_oop_shift() == 0 &amp;&amp; n-&gt;in(2)-&gt;in(3)-&gt;in(1)-&gt;as_Type()-&gt;type()-&gt;is_long()-&gt;_lo &gt;= 0);
3976   match(AddP (AddP (DecodeN reg) (LShiftL (ConvI2L idx) scale)) off);
3977 
3978   op_cost(10);
3979   format %{"[$reg + $off + $idx &lt;&lt; $scale]" %}
3980   interface(MEMORY_INTER) %{
3981     base($reg);
3982     index($idx);
3983     scale($scale);
3984     disp($off);
3985   %}
3986 %}
3987 
3988 //----------Special Memory Operands--------------------------------------------
3989 // Stack Slot Operand - This operand is used for loading and storing temporary
3990 //                      values on the stack where a match requires a value to
3991 //                      flow through memory.
3992 operand stackSlotP(sRegP reg)
3993 %{
3994   constraint(ALLOC_IN_RC(stack_slots));
3995   // No match rule because this operand is only generated in matching
3996 
3997   format %{ "[$reg]" %}
3998   interface(MEMORY_INTER) %{
3999     base(0x4);   // RSP
4000     index(0x4);  // No Index
4001     scale(0x0);  // No Scale
4002     disp($reg);  // Stack Offset
4003   %}
4004 %}
4005 
4006 operand stackSlotI(sRegI reg)
4007 %{
4008   constraint(ALLOC_IN_RC(stack_slots));
4009   // No match rule because this operand is only generated in matching
4010 
4011   format %{ "[$reg]" %}
4012   interface(MEMORY_INTER) %{
4013     base(0x4);   // RSP
4014     index(0x4);  // No Index
4015     scale(0x0);  // No Scale
4016     disp($reg);  // Stack Offset
4017   %}
4018 %}
4019 
4020 operand stackSlotF(sRegF reg)
4021 %{
4022   constraint(ALLOC_IN_RC(stack_slots));
4023   // No match rule because this operand is only generated in matching
4024 
4025   format %{ "[$reg]" %}
4026   interface(MEMORY_INTER) %{
4027     base(0x4);   // RSP
4028     index(0x4);  // No Index
4029     scale(0x0);  // No Scale
4030     disp($reg);  // Stack Offset
4031   %}
4032 %}
4033 
4034 operand stackSlotD(sRegD reg)
4035 %{
4036   constraint(ALLOC_IN_RC(stack_slots));
4037   // No match rule because this operand is only generated in matching
4038 
4039   format %{ "[$reg]" %}
4040   interface(MEMORY_INTER) %{
4041     base(0x4);   // RSP
4042     index(0x4);  // No Index
4043     scale(0x0);  // No Scale
4044     disp($reg);  // Stack Offset
4045   %}
4046 %}
4047 operand stackSlotL(sRegL reg)
4048 %{
4049   constraint(ALLOC_IN_RC(stack_slots));
4050   // No match rule because this operand is only generated in matching
4051 
4052   format %{ "[$reg]" %}
4053   interface(MEMORY_INTER) %{
4054     base(0x4);   // RSP
4055     index(0x4);  // No Index
4056     scale(0x0);  // No Scale
4057     disp($reg);  // Stack Offset
4058   %}
4059 %}
4060 
4061 //----------Conditional Branch Operands----------------------------------------
4062 // Comparison Op  - This is the operation of the comparison, and is limited to
4063 //                  the following set of codes:
4064 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
4065 //
4066 // Other attributes of the comparison, such as unsignedness, are specified
4067 // by the comparison instruction that sets a condition code flags register.
4068 // That result is represented by a flags operand whose subtype is appropriate
4069 // to the unsignedness (etc.) of the comparison.
4070 //
4071 // Later, the instruction which matches both the Comparison Op (a Bool) and
4072 // the flags (produced by the Cmp) specifies the coding of the comparison op
4073 // by matching a specific subtype of Bool operand below, such as cmpOpU.
4074 
4075 // Comparision Code
4076 operand cmpOp()
4077 %{
4078   match(Bool);
4079 
4080   format %{ "" %}
4081   interface(COND_INTER) %{
4082     equal(0x4, "e");
4083     not_equal(0x5, "ne");
4084     less(0xC, "l");
4085     greater_equal(0xD, "ge");
4086     less_equal(0xE, "le");
4087     greater(0xF, "g");
4088     overflow(0x0, "o");
4089     no_overflow(0x1, "no");
4090   %}
4091 %}
4092 
4093 // Comparison Code, unsigned compare.  Used by FP also, with
4094 // C2 (unordered) turned into GT or LT already.  The other bits
4095 // C0 and C3 are turned into Carry &amp; Zero flags.
4096 operand cmpOpU()
4097 %{
4098   match(Bool);
4099 
4100   format %{ "" %}
4101   interface(COND_INTER) %{
4102     equal(0x4, "e");
4103     not_equal(0x5, "ne");
4104     less(0x2, "b");
4105     greater_equal(0x3, "nb");
4106     less_equal(0x6, "be");
4107     greater(0x7, "nbe");
4108     overflow(0x0, "o");
4109     no_overflow(0x1, "no");
4110   %}
4111 %}
4112 
4113 
4114 // Floating comparisons that don't require any fixup for the unordered case
4115 operand cmpOpUCF() %{
4116   match(Bool);
4117   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
4118             n-&gt;as_Bool()-&gt;_test._test == BoolTest::ge ||
4119             n-&gt;as_Bool()-&gt;_test._test == BoolTest::le ||
4120             n-&gt;as_Bool()-&gt;_test._test == BoolTest::gt);
4121   format %{ "" %}
4122   interface(COND_INTER) %{
4123     equal(0x4, "e");
4124     not_equal(0x5, "ne");
4125     less(0x2, "b");
4126     greater_equal(0x3, "nb");
4127     less_equal(0x6, "be");
4128     greater(0x7, "nbe");
4129     overflow(0x0, "o");
4130     no_overflow(0x1, "no");
4131   %}
4132 %}
4133 
4134 
4135 // Floating comparisons that can be fixed up with extra conditional jumps
4136 operand cmpOpUCF2() %{
4137   match(Bool);
4138   predicate(n-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
4139             n-&gt;as_Bool()-&gt;_test._test == BoolTest::eq);
4140   format %{ "" %}
4141   interface(COND_INTER) %{
4142     equal(0x4, "e");
4143     not_equal(0x5, "ne");
4144     less(0x2, "b");
4145     greater_equal(0x3, "nb");
4146     less_equal(0x6, "be");
4147     greater(0x7, "nbe");
4148     overflow(0x0, "o");
4149     no_overflow(0x1, "no");
4150   %}
4151 %}
4152 
4153 
4154 //----------OPERAND CLASSES----------------------------------------------------
4155 // Operand Classes are groups of operands that are used as to simplify
4156 // instruction definitions by not requiring the AD writer to specify separate
4157 // instructions for every form of operand when the instruction accepts
4158 // multiple operand types with the same basic encoding and format.  The classic
4159 // case of this is memory operands.
4160 
4161 opclass memory(indirect, indOffset8, indOffset32, indIndexOffset, indIndex,
4162                indIndexScale, indIndexScaleOffset, indPosIndexOffset, indPosIndexScaleOffset,
4163                indCompressedOopOffset,
4164                indirectNarrow, indOffset8Narrow, indOffset32Narrow,
4165                indIndexOffsetNarrow, indIndexNarrow, indIndexScaleNarrow,
4166                indIndexScaleOffsetNarrow, indPosIndexOffsetNarrow, indPosIndexScaleOffsetNarrow);
4167 
4168 //----------PIPELINE-----------------------------------------------------------
4169 // Rules which define the behavior of the target architectures pipeline.
4170 pipeline %{
4171 
4172 //----------ATTRIBUTES---------------------------------------------------------
4173 attributes %{
4174   variable_size_instructions;        // Fixed size instructions
4175   max_instructions_per_bundle = 3;   // Up to 3 instructions per bundle
4176   instruction_unit_size = 1;         // An instruction is 1 bytes long
4177   instruction_fetch_unit_size = 16;  // The processor fetches one line
4178   instruction_fetch_units = 1;       // of 16 bytes
4179 
4180   // List of nop instructions
4181   nops( MachNop );
4182 %}
4183 
4184 //----------RESOURCES----------------------------------------------------------
4185 // Resources are the functional units available to the machine
4186 
4187 // Generic P2/P3 pipeline
4188 // 3 decoders, only D0 handles big operands; a "bundle" is the limit of
4189 // 3 instructions decoded per cycle.
4190 // 2 load/store ops per cycle, 1 branch, 1 FPU,
4191 // 3 ALU op, only ALU0 handles mul instructions.
4192 resources( D0, D1, D2, DECODE = D0 | D1 | D2,
4193            MS0, MS1, MS2, MEM = MS0 | MS1 | MS2,
4194            BR, FPU,
4195            ALU0, ALU1, ALU2, ALU = ALU0 | ALU1 | ALU2);
4196 
4197 //----------PIPELINE DESCRIPTION-----------------------------------------------
4198 // Pipeline Description specifies the stages in the machine's pipeline
4199 
4200 // Generic P2/P3 pipeline
4201 pipe_desc(S0, S1, S2, S3, S4, S5);
4202 
4203 //----------PIPELINE CLASSES---------------------------------------------------
4204 // Pipeline Classes describe the stages in which input and output are
4205 // referenced by the hardware pipeline.
4206 
4207 // Naming convention: ialu or fpu
4208 // Then: _reg
4209 // Then: _reg if there is a 2nd register
4210 // Then: _long if it's a pair of instructions implementing a long
4211 // Then: _fat if it requires the big decoder
4212 //   Or: _mem if it requires the big decoder and a memory unit.
4213 
4214 // Integer ALU reg operation
4215 pipe_class ialu_reg(rRegI dst)
4216 %{
4217     single_instruction;
4218     dst    : S4(write);
4219     dst    : S3(read);
4220     DECODE : S0;        // any decoder
4221     ALU    : S3;        // any alu
4222 %}
4223 
4224 // Long ALU reg operation
4225 pipe_class ialu_reg_long(rRegL dst)
4226 %{
4227     instruction_count(2);
4228     dst    : S4(write);
4229     dst    : S3(read);
4230     DECODE : S0(2);     // any 2 decoders
4231     ALU    : S3(2);     // both alus
4232 %}
4233 
4234 // Integer ALU reg operation using big decoder
4235 pipe_class ialu_reg_fat(rRegI dst)
4236 %{
4237     single_instruction;
4238     dst    : S4(write);
4239     dst    : S3(read);
4240     D0     : S0;        // big decoder only
4241     ALU    : S3;        // any alu
4242 %}
4243 
4244 // Long ALU reg operation using big decoder
4245 pipe_class ialu_reg_long_fat(rRegL dst)
4246 %{
4247     instruction_count(2);
4248     dst    : S4(write);
4249     dst    : S3(read);
4250     D0     : S0(2);     // big decoder only; twice
4251     ALU    : S3(2);     // any 2 alus
4252 %}
4253 
4254 // Integer ALU reg-reg operation
4255 pipe_class ialu_reg_reg(rRegI dst, rRegI src)
4256 %{
4257     single_instruction;
4258     dst    : S4(write);
4259     src    : S3(read);
4260     DECODE : S0;        // any decoder
4261     ALU    : S3;        // any alu
4262 %}
4263 
4264 // Long ALU reg-reg operation
4265 pipe_class ialu_reg_reg_long(rRegL dst, rRegL src)
4266 %{
4267     instruction_count(2);
4268     dst    : S4(write);
4269     src    : S3(read);
4270     DECODE : S0(2);     // any 2 decoders
4271     ALU    : S3(2);     // both alus
4272 %}
4273 
4274 // Integer ALU reg-reg operation
4275 pipe_class ialu_reg_reg_fat(rRegI dst, memory src)
4276 %{
4277     single_instruction;
4278     dst    : S4(write);
4279     src    : S3(read);
4280     D0     : S0;        // big decoder only
4281     ALU    : S3;        // any alu
4282 %}
4283 
4284 // Long ALU reg-reg operation
4285 pipe_class ialu_reg_reg_long_fat(rRegL dst, rRegL src)
4286 %{
4287     instruction_count(2);
4288     dst    : S4(write);
4289     src    : S3(read);
4290     D0     : S0(2);     // big decoder only; twice
4291     ALU    : S3(2);     // both alus
4292 %}
4293 
4294 // Integer ALU reg-mem operation
4295 pipe_class ialu_reg_mem(rRegI dst, memory mem)
4296 %{
4297     single_instruction;
4298     dst    : S5(write);
4299     mem    : S3(read);
4300     D0     : S0;        // big decoder only
4301     ALU    : S4;        // any alu
4302     MEM    : S3;        // any mem
4303 %}
4304 
4305 // Integer mem operation (prefetch)
4306 pipe_class ialu_mem(memory mem)
4307 %{
4308     single_instruction;
4309     mem    : S3(read);
4310     D0     : S0;        // big decoder only
4311     MEM    : S3;        // any mem
4312 %}
4313 
4314 // Integer Store to Memory
4315 pipe_class ialu_mem_reg(memory mem, rRegI src)
4316 %{
4317     single_instruction;
4318     mem    : S3(read);
4319     src    : S5(read);
4320     D0     : S0;        // big decoder only
4321     ALU    : S4;        // any alu
4322     MEM    : S3;
4323 %}
4324 
4325 // // Long Store to Memory
4326 // pipe_class ialu_mem_long_reg(memory mem, rRegL src)
4327 // %{
4328 //     instruction_count(2);
4329 //     mem    : S3(read);
4330 //     src    : S5(read);
4331 //     D0     : S0(2);          // big decoder only; twice
4332 //     ALU    : S4(2);     // any 2 alus
4333 //     MEM    : S3(2);  // Both mems
4334 // %}
4335 
4336 // Integer Store to Memory
4337 pipe_class ialu_mem_imm(memory mem)
4338 %{
4339     single_instruction;
4340     mem    : S3(read);
4341     D0     : S0;        // big decoder only
4342     ALU    : S4;        // any alu
4343     MEM    : S3;
4344 %}
4345 
4346 // Integer ALU0 reg-reg operation
4347 pipe_class ialu_reg_reg_alu0(rRegI dst, rRegI src)
4348 %{
4349     single_instruction;
4350     dst    : S4(write);
4351     src    : S3(read);
4352     D0     : S0;        // Big decoder only
4353     ALU0   : S3;        // only alu0
4354 %}
4355 
4356 // Integer ALU0 reg-mem operation
4357 pipe_class ialu_reg_mem_alu0(rRegI dst, memory mem)
4358 %{
4359     single_instruction;
4360     dst    : S5(write);
4361     mem    : S3(read);
4362     D0     : S0;        // big decoder only
4363     ALU0   : S4;        // ALU0 only
4364     MEM    : S3;        // any mem
4365 %}
4366 
4367 // Integer ALU reg-reg operation
4368 pipe_class ialu_cr_reg_reg(rFlagsReg cr, rRegI src1, rRegI src2)
4369 %{
4370     single_instruction;
4371     cr     : S4(write);
4372     src1   : S3(read);
4373     src2   : S3(read);
4374     DECODE : S0;        // any decoder
4375     ALU    : S3;        // any alu
4376 %}
4377 
4378 // Integer ALU reg-imm operation
4379 pipe_class ialu_cr_reg_imm(rFlagsReg cr, rRegI src1)
4380 %{
4381     single_instruction;
4382     cr     : S4(write);
4383     src1   : S3(read);
4384     DECODE : S0;        // any decoder
4385     ALU    : S3;        // any alu
4386 %}
4387 
4388 // Integer ALU reg-mem operation
4389 pipe_class ialu_cr_reg_mem(rFlagsReg cr, rRegI src1, memory src2)
4390 %{
4391     single_instruction;
4392     cr     : S4(write);
4393     src1   : S3(read);
4394     src2   : S3(read);
4395     D0     : S0;        // big decoder only
4396     ALU    : S4;        // any alu
4397     MEM    : S3;
4398 %}
4399 
4400 // Conditional move reg-reg
4401 pipe_class pipe_cmplt( rRegI p, rRegI q, rRegI y)
4402 %{
4403     instruction_count(4);
4404     y      : S4(read);
4405     q      : S3(read);
4406     p      : S3(read);
4407     DECODE : S0(4);     // any decoder
4408 %}
4409 
4410 // Conditional move reg-reg
4411 pipe_class pipe_cmov_reg( rRegI dst, rRegI src, rFlagsReg cr)
4412 %{
4413     single_instruction;
4414     dst    : S4(write);
4415     src    : S3(read);
4416     cr     : S3(read);
4417     DECODE : S0;        // any decoder
4418 %}
4419 
4420 // Conditional move reg-mem
4421 pipe_class pipe_cmov_mem( rFlagsReg cr, rRegI dst, memory src)
4422 %{
4423     single_instruction;
4424     dst    : S4(write);
4425     src    : S3(read);
4426     cr     : S3(read);
4427     DECODE : S0;        // any decoder
4428     MEM    : S3;
4429 %}
4430 
4431 // Conditional move reg-reg long
4432 pipe_class pipe_cmov_reg_long( rFlagsReg cr, rRegL dst, rRegL src)
4433 %{
4434     single_instruction;
4435     dst    : S4(write);
4436     src    : S3(read);
4437     cr     : S3(read);
4438     DECODE : S0(2);     // any 2 decoders
4439 %}
4440 
4441 // XXX
4442 // // Conditional move double reg-reg
4443 // pipe_class pipe_cmovD_reg( rFlagsReg cr, regDPR1 dst, regD src)
4444 // %{
4445 //     single_instruction;
4446 //     dst    : S4(write);
4447 //     src    : S3(read);
4448 //     cr     : S3(read);
4449 //     DECODE : S0;     // any decoder
4450 // %}
4451 
4452 // Float reg-reg operation
4453 pipe_class fpu_reg(regD dst)
4454 %{
4455     instruction_count(2);
4456     dst    : S3(read);
4457     DECODE : S0(2);     // any 2 decoders
4458     FPU    : S3;
4459 %}
4460 
4461 // Float reg-reg operation
4462 pipe_class fpu_reg_reg(regD dst, regD src)
4463 %{
4464     instruction_count(2);
4465     dst    : S4(write);
4466     src    : S3(read);
4467     DECODE : S0(2);     // any 2 decoders
4468     FPU    : S3;
4469 %}
4470 
4471 // Float reg-reg operation
4472 pipe_class fpu_reg_reg_reg(regD dst, regD src1, regD src2)
4473 %{
4474     instruction_count(3);
4475     dst    : S4(write);
4476     src1   : S3(read);
4477     src2   : S3(read);
4478     DECODE : S0(3);     // any 3 decoders
4479     FPU    : S3(2);
4480 %}
4481 
4482 // Float reg-reg operation
4483 pipe_class fpu_reg_reg_reg_reg(regD dst, regD src1, regD src2, regD src3)
4484 %{
4485     instruction_count(4);
4486     dst    : S4(write);
4487     src1   : S3(read);
4488     src2   : S3(read);
4489     src3   : S3(read);
4490     DECODE : S0(4);     // any 3 decoders
4491     FPU    : S3(2);
4492 %}
4493 
4494 // Float reg-reg operation
4495 pipe_class fpu_reg_mem_reg_reg(regD dst, memory src1, regD src2, regD src3)
4496 %{
4497     instruction_count(4);
4498     dst    : S4(write);
4499     src1   : S3(read);
4500     src2   : S3(read);
4501     src3   : S3(read);
4502     DECODE : S1(3);     // any 3 decoders
4503     D0     : S0;        // Big decoder only
4504     FPU    : S3(2);
4505     MEM    : S3;
4506 %}
4507 
4508 // Float reg-mem operation
4509 pipe_class fpu_reg_mem(regD dst, memory mem)
4510 %{
4511     instruction_count(2);
4512     dst    : S5(write);
4513     mem    : S3(read);
4514     D0     : S0;        // big decoder only
4515     DECODE : S1;        // any decoder for FPU POP
4516     FPU    : S4;
4517     MEM    : S3;        // any mem
4518 %}
4519 
4520 // Float reg-mem operation
4521 pipe_class fpu_reg_reg_mem(regD dst, regD src1, memory mem)
4522 %{
4523     instruction_count(3);
4524     dst    : S5(write);
4525     src1   : S3(read);
4526     mem    : S3(read);
4527     D0     : S0;        // big decoder only
4528     DECODE : S1(2);     // any decoder for FPU POP
4529     FPU    : S4;
4530     MEM    : S3;        // any mem
4531 %}
4532 
4533 // Float mem-reg operation
4534 pipe_class fpu_mem_reg(memory mem, regD src)
4535 %{
4536     instruction_count(2);
4537     src    : S5(read);
4538     mem    : S3(read);
4539     DECODE : S0;        // any decoder for FPU PUSH
4540     D0     : S1;        // big decoder only
4541     FPU    : S4;
4542     MEM    : S3;        // any mem
4543 %}
4544 
4545 pipe_class fpu_mem_reg_reg(memory mem, regD src1, regD src2)
4546 %{
4547     instruction_count(3);
4548     src1   : S3(read);
4549     src2   : S3(read);
4550     mem    : S3(read);
4551     DECODE : S0(2);     // any decoder for FPU PUSH
4552     D0     : S1;        // big decoder only
4553     FPU    : S4;
4554     MEM    : S3;        // any mem
4555 %}
4556 
4557 pipe_class fpu_mem_reg_mem(memory mem, regD src1, memory src2)
4558 %{
4559     instruction_count(3);
4560     src1   : S3(read);
4561     src2   : S3(read);
4562     mem    : S4(read);
4563     DECODE : S0;        // any decoder for FPU PUSH
4564     D0     : S0(2);     // big decoder only
4565     FPU    : S4;
4566     MEM    : S3(2);     // any mem
4567 %}
4568 
4569 pipe_class fpu_mem_mem(memory dst, memory src1)
4570 %{
4571     instruction_count(2);
4572     src1   : S3(read);
4573     dst    : S4(read);
4574     D0     : S0(2);     // big decoder only
4575     MEM    : S3(2);     // any mem
4576 %}
4577 
4578 pipe_class fpu_mem_mem_mem(memory dst, memory src1, memory src2)
4579 %{
4580     instruction_count(3);
4581     src1   : S3(read);
4582     src2   : S3(read);
4583     dst    : S4(read);
4584     D0     : S0(3);     // big decoder only
4585     FPU    : S4;
4586     MEM    : S3(3);     // any mem
4587 %}
4588 
4589 pipe_class fpu_mem_reg_con(memory mem, regD src1)
4590 %{
4591     instruction_count(3);
4592     src1   : S4(read);
4593     mem    : S4(read);
4594     DECODE : S0;        // any decoder for FPU PUSH
4595     D0     : S0(2);     // big decoder only
4596     FPU    : S4;
4597     MEM    : S3(2);     // any mem
4598 %}
4599 
4600 // Float load constant
4601 pipe_class fpu_reg_con(regD dst)
4602 %{
4603     instruction_count(2);
4604     dst    : S5(write);
4605     D0     : S0;        // big decoder only for the load
4606     DECODE : S1;        // any decoder for FPU POP
4607     FPU    : S4;
4608     MEM    : S3;        // any mem
4609 %}
4610 
4611 // Float load constant
4612 pipe_class fpu_reg_reg_con(regD dst, regD src)
4613 %{
4614     instruction_count(3);
4615     dst    : S5(write);
4616     src    : S3(read);
4617     D0     : S0;        // big decoder only for the load
4618     DECODE : S1(2);     // any decoder for FPU POP
4619     FPU    : S4;
4620     MEM    : S3;        // any mem
4621 %}
4622 
4623 // UnConditional branch
4624 pipe_class pipe_jmp(label labl)
4625 %{
4626     single_instruction;
4627     BR   : S3;
4628 %}
4629 
4630 // Conditional branch
4631 pipe_class pipe_jcc(cmpOp cmp, rFlagsReg cr, label labl)
4632 %{
4633     single_instruction;
4634     cr    : S1(read);
4635     BR    : S3;
4636 %}
4637 
4638 // Allocation idiom
4639 pipe_class pipe_cmpxchg(rRegP dst, rRegP heap_ptr)
4640 %{
4641     instruction_count(1); force_serialization;
4642     fixed_latency(6);
4643     heap_ptr : S3(read);
4644     DECODE   : S0(3);
4645     D0       : S2;
4646     MEM      : S3;
4647     ALU      : S3(2);
4648     dst      : S5(write);
4649     BR       : S5;
4650 %}
4651 
4652 // Generic big/slow expanded idiom
4653 pipe_class pipe_slow()
4654 %{
4655     instruction_count(10); multiple_bundles; force_serialization;
4656     fixed_latency(100);
4657     D0  : S0(2);
4658     MEM : S3(2);
4659 %}
4660 
4661 // The real do-nothing guy
4662 pipe_class empty()
4663 %{
4664     instruction_count(0);
4665 %}
4666 
4667 // Define the class for the Nop node
4668 define
4669 %{
4670    MachNop = empty;
4671 %}
4672 
4673 %}
4674 
4675 //----------INSTRUCTIONS-------------------------------------------------------
4676 //
4677 // match      -- States which machine-independent subtree may be replaced
4678 //               by this instruction.
4679 // ins_cost   -- The estimated cost of this instruction is used by instruction
4680 //               selection to identify a minimum cost tree of machine
4681 //               instructions that matches a tree of machine-independent
4682 //               instructions.
4683 // format     -- A string providing the disassembly for this instruction.
4684 //               The value of an instruction's operand may be inserted
4685 //               by referring to it with a '$' prefix.
4686 // opcode     -- Three instruction opcodes may be provided.  These are referred
4687 //               to within an encode class as $primary, $secondary, and $tertiary
4688 //               rrspectively.  The primary opcode is commonly used to
4689 //               indicate the type of machine instruction, while secondary
4690 //               and tertiary are often used for prefix options or addressing
4691 //               modes.
4692 // ins_encode -- A list of encode classes with parameters. The encode class
4693 //               name must have been defined in an 'enc_class' specification
4694 //               in the encode section of the architecture description.
4695 
4696 
4697 //----------Load/Store/Move Instructions---------------------------------------
4698 //----------Load Instructions--------------------------------------------------
4699 
4700 // Load Byte (8 bit signed)
4701 instruct loadB(rRegI dst, memory mem)
4702 %{
4703   match(Set dst (LoadB mem));
4704 
4705   ins_cost(125);
4706   format %{ "movsbl  $dst, $mem\t# byte" %}
4707 
4708   ins_encode %{
4709     __ movsbl($dst$$Register, $mem$$Address);
4710   %}
4711 
4712   ins_pipe(ialu_reg_mem);
4713 %}
4714 
4715 // Load Byte (8 bit signed) into Long Register
4716 instruct loadB2L(rRegL dst, memory mem)
4717 %{
4718   match(Set dst (ConvI2L (LoadB mem)));
4719 
4720   ins_cost(125);
4721   format %{ "movsbq  $dst, $mem\t# byte -&gt; long" %}
4722 
4723   ins_encode %{
4724     __ movsbq($dst$$Register, $mem$$Address);
4725   %}
4726 
4727   ins_pipe(ialu_reg_mem);
4728 %}
4729 
4730 // Load Unsigned Byte (8 bit UNsigned)
4731 instruct loadUB(rRegI dst, memory mem)
4732 %{
4733   match(Set dst (LoadUB mem));
4734 
4735   ins_cost(125);
4736   format %{ "movzbl  $dst, $mem\t# ubyte" %}
4737 
4738   ins_encode %{
4739     __ movzbl($dst$$Register, $mem$$Address);
4740   %}
4741 
4742   ins_pipe(ialu_reg_mem);
4743 %}
4744 
4745 // Load Unsigned Byte (8 bit UNsigned) into Long Register
4746 instruct loadUB2L(rRegL dst, memory mem)
4747 %{
4748   match(Set dst (ConvI2L (LoadUB mem)));
4749 
4750   ins_cost(125);
4751   format %{ "movzbq  $dst, $mem\t# ubyte -&gt; long" %}
4752 
4753   ins_encode %{
4754     __ movzbq($dst$$Register, $mem$$Address);
4755   %}
4756 
4757   ins_pipe(ialu_reg_mem);
4758 %}
4759 
4760 // Load Unsigned Byte (8 bit UNsigned) with 32-bit mask into Long Register
4761 instruct loadUB2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4762   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
4763   effect(KILL cr);
4764 
4765   format %{ "movzbq  $dst, $mem\t# ubyte &amp; 32-bit mask -&gt; long\n\t"
4766             "andl    $dst, right_n_bits($mask, 8)" %}
4767   ins_encode %{
4768     Register Rdst = $dst$$Register;
4769     __ movzbq(Rdst, $mem$$Address);
4770     __ andl(Rdst, $mask$$constant &amp; right_n_bits(8));
4771   %}
4772   ins_pipe(ialu_reg_mem);
4773 %}
4774 
4775 // Load Short (16 bit signed)
4776 instruct loadS(rRegI dst, memory mem)
4777 %{
4778   match(Set dst (LoadS mem));
4779 
4780   ins_cost(125);
4781   format %{ "movswl $dst, $mem\t# short" %}
4782 
4783   ins_encode %{
4784     __ movswl($dst$$Register, $mem$$Address);
4785   %}
4786 
4787   ins_pipe(ialu_reg_mem);
4788 %}
4789 
4790 // Load Short (16 bit signed) to Byte (8 bit signed)
4791 instruct loadS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4792   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
4793 
4794   ins_cost(125);
4795   format %{ "movsbl $dst, $mem\t# short -&gt; byte" %}
4796   ins_encode %{
4797     __ movsbl($dst$$Register, $mem$$Address);
4798   %}
4799   ins_pipe(ialu_reg_mem);
4800 %}
4801 
4802 // Load Short (16 bit signed) into Long Register
4803 instruct loadS2L(rRegL dst, memory mem)
4804 %{
4805   match(Set dst (ConvI2L (LoadS mem)));
4806 
4807   ins_cost(125);
4808   format %{ "movswq $dst, $mem\t# short -&gt; long" %}
4809 
4810   ins_encode %{
4811     __ movswq($dst$$Register, $mem$$Address);
4812   %}
4813 
4814   ins_pipe(ialu_reg_mem);
4815 %}
4816 
4817 // Load Unsigned Short/Char (16 bit UNsigned)
4818 instruct loadUS(rRegI dst, memory mem)
4819 %{
4820   match(Set dst (LoadUS mem));
4821 
4822   ins_cost(125);
4823   format %{ "movzwl  $dst, $mem\t# ushort/char" %}
4824 
4825   ins_encode %{
4826     __ movzwl($dst$$Register, $mem$$Address);
4827   %}
4828 
4829   ins_pipe(ialu_reg_mem);
4830 %}
4831 
4832 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
4833 instruct loadUS2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4834   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
4835 
4836   ins_cost(125);
4837   format %{ "movsbl $dst, $mem\t# ushort -&gt; byte" %}
4838   ins_encode %{
4839     __ movsbl($dst$$Register, $mem$$Address);
4840   %}
4841   ins_pipe(ialu_reg_mem);
4842 %}
4843 
4844 // Load Unsigned Short/Char (16 bit UNsigned) into Long Register
4845 instruct loadUS2L(rRegL dst, memory mem)
4846 %{
4847   match(Set dst (ConvI2L (LoadUS mem)));
4848 
4849   ins_cost(125);
4850   format %{ "movzwq  $dst, $mem\t# ushort/char -&gt; long" %}
4851 
4852   ins_encode %{
4853     __ movzwq($dst$$Register, $mem$$Address);
4854   %}
4855 
4856   ins_pipe(ialu_reg_mem);
4857 %}
4858 
4859 // Load Unsigned Short/Char (16 bit UNsigned) with mask 0xFF into Long Register
4860 instruct loadUS2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4861   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4862 
4863   format %{ "movzbq  $dst, $mem\t# ushort/char &amp; 0xFF -&gt; long" %}
4864   ins_encode %{
4865     __ movzbq($dst$$Register, $mem$$Address);
4866   %}
4867   ins_pipe(ialu_reg_mem);
4868 %}
4869 
4870 // Load Unsigned Short/Char (16 bit UNsigned) with 32-bit mask into Long Register
4871 instruct loadUS2L_immI(rRegL dst, memory mem, immI mask, rFlagsReg cr) %{
4872   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
4873   effect(KILL cr);
4874 
4875   format %{ "movzwq  $dst, $mem\t# ushort/char &amp; 32-bit mask -&gt; long\n\t"
4876             "andl    $dst, right_n_bits($mask, 16)" %}
4877   ins_encode %{
4878     Register Rdst = $dst$$Register;
4879     __ movzwq(Rdst, $mem$$Address);
4880     __ andl(Rdst, $mask$$constant &amp; right_n_bits(16));
4881   %}
4882   ins_pipe(ialu_reg_mem);
4883 %}
4884 
4885 // Load Integer
4886 instruct loadI(rRegI dst, memory mem)
4887 %{
4888   match(Set dst (LoadI mem));
4889 
4890   ins_cost(125);
4891   format %{ "movl    $dst, $mem\t# int" %}
4892 
4893   ins_encode %{
4894     __ movl($dst$$Register, $mem$$Address);
4895   %}
4896 
4897   ins_pipe(ialu_reg_mem);
4898 %}
4899 
4900 // Load Integer (32 bit signed) to Byte (8 bit signed)
4901 instruct loadI2B(rRegI dst, memory mem, immI_24 twentyfour) %{
4902   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
4903 
4904   ins_cost(125);
4905   format %{ "movsbl  $dst, $mem\t# int -&gt; byte" %}
4906   ins_encode %{
4907     __ movsbl($dst$$Register, $mem$$Address);
4908   %}
4909   ins_pipe(ialu_reg_mem);
4910 %}
4911 
4912 // Load Integer (32 bit signed) to Unsigned Byte (8 bit UNsigned)
4913 instruct loadI2UB(rRegI dst, memory mem, immI_255 mask) %{
4914   match(Set dst (AndI (LoadI mem) mask));
4915 
4916   ins_cost(125);
4917   format %{ "movzbl  $dst, $mem\t# int -&gt; ubyte" %}
4918   ins_encode %{
4919     __ movzbl($dst$$Register, $mem$$Address);
4920   %}
4921   ins_pipe(ialu_reg_mem);
4922 %}
4923 
4924 // Load Integer (32 bit signed) to Short (16 bit signed)
4925 instruct loadI2S(rRegI dst, memory mem, immI_16 sixteen) %{
4926   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
4927 
4928   ins_cost(125);
4929   format %{ "movswl  $dst, $mem\t# int -&gt; short" %}
4930   ins_encode %{
4931     __ movswl($dst$$Register, $mem$$Address);
4932   %}
4933   ins_pipe(ialu_reg_mem);
4934 %}
4935 
4936 // Load Integer (32 bit signed) to Unsigned Short/Char (16 bit UNsigned)
4937 instruct loadI2US(rRegI dst, memory mem, immI_65535 mask) %{
4938   match(Set dst (AndI (LoadI mem) mask));
4939 
4940   ins_cost(125);
4941   format %{ "movzwl  $dst, $mem\t# int -&gt; ushort/char" %}
4942   ins_encode %{
4943     __ movzwl($dst$$Register, $mem$$Address);
4944   %}
4945   ins_pipe(ialu_reg_mem);
4946 %}
4947 
4948 // Load Integer into Long Register
4949 instruct loadI2L(rRegL dst, memory mem)
4950 %{
4951   match(Set dst (ConvI2L (LoadI mem)));
4952 
4953   ins_cost(125);
4954   format %{ "movslq  $dst, $mem\t# int -&gt; long" %}
4955 
4956   ins_encode %{
4957     __ movslq($dst$$Register, $mem$$Address);
4958   %}
4959 
4960   ins_pipe(ialu_reg_mem);
4961 %}
4962 
4963 // Load Integer with mask 0xFF into Long Register
4964 instruct loadI2L_immI_255(rRegL dst, memory mem, immI_255 mask) %{
4965   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4966 
4967   format %{ "movzbq  $dst, $mem\t# int &amp; 0xFF -&gt; long" %}
4968   ins_encode %{
4969     __ movzbq($dst$$Register, $mem$$Address);
4970   %}
4971   ins_pipe(ialu_reg_mem);
4972 %}
4973 
4974 // Load Integer with mask 0xFFFF into Long Register
4975 instruct loadI2L_immI_65535(rRegL dst, memory mem, immI_65535 mask) %{
4976   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4977 
4978   format %{ "movzwq  $dst, $mem\t# int &amp; 0xFFFF -&gt; long" %}
4979   ins_encode %{
4980     __ movzwq($dst$$Register, $mem$$Address);
4981   %}
4982   ins_pipe(ialu_reg_mem);
4983 %}
4984 
4985 // Load Integer with a 31-bit mask into Long Register
4986 instruct loadI2L_immU31(rRegL dst, memory mem, immU31 mask, rFlagsReg cr) %{
4987   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
4988   effect(KILL cr);
4989 
4990   format %{ "movl    $dst, $mem\t# int &amp; 31-bit mask -&gt; long\n\t"
4991             "andl    $dst, $mask" %}
4992   ins_encode %{
4993     Register Rdst = $dst$$Register;
4994     __ movl(Rdst, $mem$$Address);
4995     __ andl(Rdst, $mask$$constant);
4996   %}
4997   ins_pipe(ialu_reg_mem);
4998 %}
4999 
5000 // Load Unsigned Integer into Long Register
5001 instruct loadUI2L(rRegL dst, memory mem, immL_32bits mask)
5002 %{
5003   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
5004 
5005   ins_cost(125);
5006   format %{ "movl    $dst, $mem\t# uint -&gt; long" %}
5007 
5008   ins_encode %{
5009     __ movl($dst$$Register, $mem$$Address);
5010   %}
5011 
5012   ins_pipe(ialu_reg_mem);
5013 %}
5014 
5015 // Load Long
5016 instruct loadL(rRegL dst, memory mem)
5017 %{
5018   match(Set dst (LoadL mem));
5019 
5020   ins_cost(125);
5021   format %{ "movq    $dst, $mem\t# long" %}
5022 
5023   ins_encode %{
5024     __ movq($dst$$Register, $mem$$Address);
5025   %}
5026 
5027   ins_pipe(ialu_reg_mem); // XXX
5028 %}
5029 
5030 // Load Range
5031 instruct loadRange(rRegI dst, memory mem)
5032 %{
5033   match(Set dst (LoadRange mem));
5034 
5035   ins_cost(125); // XXX
5036   format %{ "movl    $dst, $mem\t# range" %}
5037   opcode(0x8B);
5038   ins_encode(REX_reg_mem(dst, mem), OpcP, reg_mem(dst, mem));
5039   ins_pipe(ialu_reg_mem);
5040 %}
5041 
5042 // Load Pointer
5043 instruct loadP(rRegP dst, memory mem)
5044 %{
5045   match(Set dst (LoadP mem));
5046 
5047   ins_cost(125); // XXX
5048   format %{ "movq    $dst, $mem\t# ptr" %}
5049   opcode(0x8B);
5050   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5051   ins_pipe(ialu_reg_mem); // XXX
5052 %}
5053 
5054 // Load Compressed Pointer
5055 instruct loadN(rRegN dst, memory mem)
5056 %{
5057    match(Set dst (LoadN mem));
5058 
5059    ins_cost(125); // XXX
5060    format %{ "movl    $dst, $mem\t# compressed ptr" %}
5061    ins_encode %{
5062      __ movl($dst$$Register, $mem$$Address);
5063    %}
5064    ins_pipe(ialu_reg_mem); // XXX
5065 %}
5066 
5067 
5068 // Load Klass Pointer
5069 instruct loadKlass(rRegP dst, memory mem)
5070 %{
5071   match(Set dst (LoadKlass mem));
5072 
5073   ins_cost(125); // XXX
5074   format %{ "movq    $dst, $mem\t# class" %}
5075   opcode(0x8B);
5076   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5077   ins_pipe(ialu_reg_mem); // XXX
5078 %}
5079 
5080 // Load narrow Klass Pointer
5081 instruct loadNKlass(rRegN dst, memory mem)
5082 %{
5083   match(Set dst (LoadNKlass mem));
5084 
5085   ins_cost(125); // XXX
5086   format %{ "movl    $dst, $mem\t# compressed klass ptr" %}
5087   ins_encode %{
5088     __ movl($dst$$Register, $mem$$Address);
5089   %}
5090   ins_pipe(ialu_reg_mem); // XXX
5091 %}
5092 
5093 // Load Float
5094 instruct loadF(regF dst, memory mem)
5095 %{
5096   match(Set dst (LoadF mem));
5097 
5098   ins_cost(145); // XXX
5099   format %{ "movss   $dst, $mem\t# float" %}
5100   ins_encode %{
5101     __ movflt($dst$$XMMRegister, $mem$$Address);
5102   %}
5103   ins_pipe(pipe_slow); // XXX
5104 %}
5105 
5106 // Load Double
5107 instruct loadD_partial(regD dst, memory mem)
5108 %{
5109   predicate(!UseXmmLoadAndClearUpper);
5110   match(Set dst (LoadD mem));
5111 
5112   ins_cost(145); // XXX
5113   format %{ "movlpd  $dst, $mem\t# double" %}
5114   ins_encode %{
5115     __ movdbl($dst$$XMMRegister, $mem$$Address);
5116   %}
5117   ins_pipe(pipe_slow); // XXX
5118 %}
5119 
5120 instruct loadD(regD dst, memory mem)
5121 %{
5122   predicate(UseXmmLoadAndClearUpper);
5123   match(Set dst (LoadD mem));
5124 
5125   ins_cost(145); // XXX
5126   format %{ "movsd   $dst, $mem\t# double" %}
5127   ins_encode %{
5128     __ movdbl($dst$$XMMRegister, $mem$$Address);
5129   %}
5130   ins_pipe(pipe_slow); // XXX
5131 %}
5132 
5133 // Load Effective Address
5134 instruct leaP8(rRegP dst, indOffset8 mem)
5135 %{
5136   match(Set dst mem);
5137 
5138   ins_cost(110); // XXX
5139   format %{ "leaq    $dst, $mem\t# ptr 8" %}
5140   opcode(0x8D);
5141   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5142   ins_pipe(ialu_reg_reg_fat);
5143 %}
5144 
5145 instruct leaP32(rRegP dst, indOffset32 mem)
5146 %{
5147   match(Set dst mem);
5148 
5149   ins_cost(110);
5150   format %{ "leaq    $dst, $mem\t# ptr 32" %}
5151   opcode(0x8D);
5152   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5153   ins_pipe(ialu_reg_reg_fat);
5154 %}
5155 
5156 // instruct leaPIdx(rRegP dst, indIndex mem)
5157 // %{
5158 //   match(Set dst mem);
5159 
5160 //   ins_cost(110);
5161 //   format %{ "leaq    $dst, $mem\t# ptr idx" %}
5162 //   opcode(0x8D);
5163 //   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5164 //   ins_pipe(ialu_reg_reg_fat);
5165 // %}
5166 
5167 instruct leaPIdxOff(rRegP dst, indIndexOffset mem)
5168 %{
5169   match(Set dst mem);
5170 
5171   ins_cost(110);
5172   format %{ "leaq    $dst, $mem\t# ptr idxoff" %}
5173   opcode(0x8D);
5174   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5175   ins_pipe(ialu_reg_reg_fat);
5176 %}
5177 
5178 instruct leaPIdxScale(rRegP dst, indIndexScale mem)
5179 %{
5180   match(Set dst mem);
5181 
5182   ins_cost(110);
5183   format %{ "leaq    $dst, $mem\t# ptr idxscale" %}
5184   opcode(0x8D);
5185   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5186   ins_pipe(ialu_reg_reg_fat);
5187 %}
5188 
5189 instruct leaPIdxScaleOff(rRegP dst, indIndexScaleOffset mem)
5190 %{
5191   match(Set dst mem);
5192 
5193   ins_cost(110);
5194   format %{ "leaq    $dst, $mem\t# ptr idxscaleoff" %}
5195   opcode(0x8D);
5196   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5197   ins_pipe(ialu_reg_reg_fat);
5198 %}
5199 
5200 instruct leaPPosIdxOff(rRegP dst, indPosIndexOffset mem)
5201 %{
5202   match(Set dst mem);
5203 
5204   ins_cost(110);
5205   format %{ "leaq    $dst, $mem\t# ptr posidxoff" %}
5206   opcode(0x8D);
5207   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5208   ins_pipe(ialu_reg_reg_fat);
5209 %}
5210 
5211 instruct leaPPosIdxScaleOff(rRegP dst, indPosIndexScaleOffset mem)
5212 %{
5213   match(Set dst mem);
5214 
5215   ins_cost(110);
5216   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoff" %}
5217   opcode(0x8D);
5218   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5219   ins_pipe(ialu_reg_reg_fat);
5220 %}
5221 
5222 // Load Effective Address which uses Narrow (32-bits) oop
5223 instruct leaPCompressedOopOffset(rRegP dst, indCompressedOopOffset mem)
5224 %{
5225   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_shift() != 0));
5226   match(Set dst mem);
5227 
5228   ins_cost(110);
5229   format %{ "leaq    $dst, $mem\t# ptr compressedoopoff32" %}
5230   opcode(0x8D);
5231   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5232   ins_pipe(ialu_reg_reg_fat);
5233 %}
5234 
5235 instruct leaP8Narrow(rRegP dst, indOffset8Narrow mem)
5236 %{
5237   predicate(Universe::narrow_oop_shift() == 0);
5238   match(Set dst mem);
5239 
5240   ins_cost(110); // XXX
5241   format %{ "leaq    $dst, $mem\t# ptr off8narrow" %}
5242   opcode(0x8D);
5243   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5244   ins_pipe(ialu_reg_reg_fat);
5245 %}
5246 
5247 instruct leaP32Narrow(rRegP dst, indOffset32Narrow mem)
5248 %{
5249   predicate(Universe::narrow_oop_shift() == 0);
5250   match(Set dst mem);
5251 
5252   ins_cost(110);
5253   format %{ "leaq    $dst, $mem\t# ptr off32narrow" %}
5254   opcode(0x8D);
5255   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5256   ins_pipe(ialu_reg_reg_fat);
5257 %}
5258 
5259 instruct leaPIdxOffNarrow(rRegP dst, indIndexOffsetNarrow mem)
5260 %{
5261   predicate(Universe::narrow_oop_shift() == 0);
5262   match(Set dst mem);
5263 
5264   ins_cost(110);
5265   format %{ "leaq    $dst, $mem\t# ptr idxoffnarrow" %}
5266   opcode(0x8D);
5267   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5268   ins_pipe(ialu_reg_reg_fat);
5269 %}
5270 
5271 instruct leaPIdxScaleNarrow(rRegP dst, indIndexScaleNarrow mem)
5272 %{
5273   predicate(Universe::narrow_oop_shift() == 0);
5274   match(Set dst mem);
5275 
5276   ins_cost(110);
5277   format %{ "leaq    $dst, $mem\t# ptr idxscalenarrow" %}
5278   opcode(0x8D);
5279   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5280   ins_pipe(ialu_reg_reg_fat);
5281 %}
5282 
5283 instruct leaPIdxScaleOffNarrow(rRegP dst, indIndexScaleOffsetNarrow mem)
5284 %{
5285   predicate(Universe::narrow_oop_shift() == 0);
5286   match(Set dst mem);
5287 
5288   ins_cost(110);
5289   format %{ "leaq    $dst, $mem\t# ptr idxscaleoffnarrow" %}
5290   opcode(0x8D);
5291   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5292   ins_pipe(ialu_reg_reg_fat);
5293 %}
5294 
5295 instruct leaPPosIdxOffNarrow(rRegP dst, indPosIndexOffsetNarrow mem)
5296 %{
5297   predicate(Universe::narrow_oop_shift() == 0);
5298   match(Set dst mem);
5299 
5300   ins_cost(110);
5301   format %{ "leaq    $dst, $mem\t# ptr posidxoffnarrow" %}
5302   opcode(0x8D);
5303   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5304   ins_pipe(ialu_reg_reg_fat);
5305 %}
5306 
5307 instruct leaPPosIdxScaleOffNarrow(rRegP dst, indPosIndexScaleOffsetNarrow mem)
5308 %{
5309   predicate(Universe::narrow_oop_shift() == 0);
5310   match(Set dst mem);
5311 
5312   ins_cost(110);
5313   format %{ "leaq    $dst, $mem\t# ptr posidxscaleoffnarrow" %}
5314   opcode(0x8D);
5315   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
5316   ins_pipe(ialu_reg_reg_fat);
5317 %}
5318 
5319 instruct loadConI(rRegI dst, immI src)
5320 %{
5321   match(Set dst src);
5322 
5323   format %{ "movl    $dst, $src\t# int" %}
5324   ins_encode(load_immI(dst, src));
5325   ins_pipe(ialu_reg_fat); // XXX
5326 %}
5327 
5328 instruct loadConI0(rRegI dst, immI0 src, rFlagsReg cr)
5329 %{
5330   match(Set dst src);
5331   effect(KILL cr);
5332 
5333   ins_cost(50);
5334   format %{ "xorl    $dst, $dst\t# int" %}
5335   opcode(0x33); /* + rd */
5336   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5337   ins_pipe(ialu_reg);
5338 %}
5339 
5340 instruct loadConL(rRegL dst, immL src)
5341 %{
5342   match(Set dst src);
5343 
5344   ins_cost(150);
5345   format %{ "movq    $dst, $src\t# long" %}
5346   ins_encode(load_immL(dst, src));
5347   ins_pipe(ialu_reg);
5348 %}
5349 
5350 instruct loadConL0(rRegL dst, immL0 src, rFlagsReg cr)
5351 %{
5352   match(Set dst src);
5353   effect(KILL cr);
5354 
5355   ins_cost(50);
5356   format %{ "xorl    $dst, $dst\t# long" %}
5357   opcode(0x33); /* + rd */
5358   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5359   ins_pipe(ialu_reg); // XXX
5360 %}
5361 
5362 instruct loadConUL32(rRegL dst, immUL32 src)
5363 %{
5364   match(Set dst src);
5365 
5366   ins_cost(60);
5367   format %{ "movl    $dst, $src\t# long (unsigned 32-bit)" %}
5368   ins_encode(load_immUL32(dst, src));
5369   ins_pipe(ialu_reg);
5370 %}
5371 
5372 instruct loadConL32(rRegL dst, immL32 src)
5373 %{
5374   match(Set dst src);
5375 
5376   ins_cost(70);
5377   format %{ "movq    $dst, $src\t# long (32-bit)" %}
5378   ins_encode(load_immL32(dst, src));
5379   ins_pipe(ialu_reg);
5380 %}
5381 
5382 instruct loadConP(rRegP dst, immP con) %{
5383   match(Set dst con);
5384 
5385   format %{ "movq    $dst, $con\t# ptr" %}
5386   ins_encode(load_immP(dst, con));
5387   ins_pipe(ialu_reg_fat); // XXX
5388 %}
5389 
5390 instruct loadConP0(rRegP dst, immP0 src, rFlagsReg cr)
5391 %{
5392   match(Set dst src);
5393   effect(KILL cr);
5394 
5395   ins_cost(50);
5396   format %{ "xorl    $dst, $dst\t# ptr" %}
5397   opcode(0x33); /* + rd */
5398   ins_encode(REX_reg_reg(dst, dst), OpcP, reg_reg(dst, dst));
5399   ins_pipe(ialu_reg);
5400 %}
5401 
5402 instruct loadConP31(rRegP dst, immP31 src, rFlagsReg cr)
5403 %{
5404   match(Set dst src);
5405   effect(KILL cr);
5406 
5407   ins_cost(60);
5408   format %{ "movl    $dst, $src\t# ptr (positive 32-bit)" %}
5409   ins_encode(load_immP31(dst, src));
5410   ins_pipe(ialu_reg);
5411 %}
5412 
5413 instruct loadConF(regF dst, immF con) %{
5414   match(Set dst con);
5415   ins_cost(125);
5416   format %{ "movss   $dst, [$constantaddress]\t# load from constant table: float=$con" %}
5417   ins_encode %{
5418     __ movflt($dst$$XMMRegister, $constantaddress($con));
5419   %}
5420   ins_pipe(pipe_slow);
5421 %}
5422 
5423 instruct loadConN0(rRegN dst, immN0 src, rFlagsReg cr) %{
5424   match(Set dst src);
5425   effect(KILL cr);
5426   format %{ "xorq    $dst, $src\t# compressed NULL ptr" %}
5427   ins_encode %{
5428     __ xorq($dst$$Register, $dst$$Register);
5429   %}
5430   ins_pipe(ialu_reg);
5431 %}
5432 
5433 instruct loadConN(rRegN dst, immN src) %{
5434   match(Set dst src);
5435 
5436   ins_cost(125);
5437   format %{ "movl    $dst, $src\t# compressed ptr" %}
5438   ins_encode %{
5439     address con = (address)$src$$constant;
5440     if (con == NULL) {
5441       ShouldNotReachHere();
5442     } else {
5443       __ set_narrow_oop($dst$$Register, (jobject)$src$$constant);
5444     }
5445   %}
5446   ins_pipe(ialu_reg_fat); // XXX
5447 %}
5448 
5449 instruct loadConNKlass(rRegN dst, immNKlass src) %{
5450   match(Set dst src);
5451 
5452   ins_cost(125);
5453   format %{ "movl    $dst, $src\t# compressed klass ptr" %}
5454   ins_encode %{
5455     address con = (address)$src$$constant;
5456     if (con == NULL) {
5457       ShouldNotReachHere();
5458     } else {
5459       __ set_narrow_klass($dst$$Register, (Klass*)$src$$constant);
5460     }
5461   %}
5462   ins_pipe(ialu_reg_fat); // XXX
5463 %}
5464 
5465 instruct loadConF0(regF dst, immF0 src)
5466 %{
5467   match(Set dst src);
5468   ins_cost(100);
5469 
5470   format %{ "xorps   $dst, $dst\t# float 0.0" %}
5471   ins_encode %{
5472     __ xorps($dst$$XMMRegister, $dst$$XMMRegister);
5473   %}
5474   ins_pipe(pipe_slow);
5475 %}
5476 
5477 // Use the same format since predicate() can not be used here.
5478 instruct loadConD(regD dst, immD con) %{
5479   match(Set dst con);
5480   ins_cost(125);
5481   format %{ "movsd   $dst, [$constantaddress]\t# load from constant table: double=$con" %}
5482   ins_encode %{
5483     __ movdbl($dst$$XMMRegister, $constantaddress($con));
5484   %}
5485   ins_pipe(pipe_slow);
5486 %}
5487 
5488 instruct loadConD0(regD dst, immD0 src)
5489 %{
5490   match(Set dst src);
5491   ins_cost(100);
5492 
5493   format %{ "xorpd   $dst, $dst\t# double 0.0" %}
5494   ins_encode %{
5495     __ xorpd ($dst$$XMMRegister, $dst$$XMMRegister);
5496   %}
5497   ins_pipe(pipe_slow);
5498 %}
5499 
5500 instruct loadSSI(rRegI dst, stackSlotI src)
5501 %{
5502   match(Set dst src);
5503 
5504   ins_cost(125);
5505   format %{ "movl    $dst, $src\t# int stk" %}
5506   opcode(0x8B);
5507   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
5508   ins_pipe(ialu_reg_mem);
5509 %}
5510 
5511 instruct loadSSL(rRegL dst, stackSlotL src)
5512 %{
5513   match(Set dst src);
5514 
5515   ins_cost(125);
5516   format %{ "movq    $dst, $src\t# long stk" %}
5517   opcode(0x8B);
5518   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5519   ins_pipe(ialu_reg_mem);
5520 %}
5521 
5522 instruct loadSSP(rRegP dst, stackSlotP src)
5523 %{
5524   match(Set dst src);
5525 
5526   ins_cost(125);
5527   format %{ "movq    $dst, $src\t# ptr stk" %}
5528   opcode(0x8B);
5529   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
5530   ins_pipe(ialu_reg_mem);
5531 %}
5532 
5533 instruct loadSSF(regF dst, stackSlotF src)
5534 %{
5535   match(Set dst src);
5536 
5537   ins_cost(125);
5538   format %{ "movss   $dst, $src\t# float stk" %}
5539   ins_encode %{
5540     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
5541   %}
5542   ins_pipe(pipe_slow); // XXX
5543 %}
5544 
5545 // Use the same format since predicate() can not be used here.
5546 instruct loadSSD(regD dst, stackSlotD src)
5547 %{
5548   match(Set dst src);
5549 
5550   ins_cost(125);
5551   format %{ "movsd   $dst, $src\t# double stk" %}
5552   ins_encode  %{
5553     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
5554   %}
5555   ins_pipe(pipe_slow); // XXX
5556 %}
5557 
5558 // Prefetch instructions for allocation.
5559 // Must be safe to execute with invalid address (cannot fault).
5560 
5561 instruct prefetchAlloc( memory mem ) %{
5562   predicate(AllocatePrefetchInstr==3);
5563   match(PrefetchAllocation mem);
5564   ins_cost(125);
5565 
5566   format %{ "PREFETCHW $mem\t# Prefetch allocation into level 1 cache and mark modified" %}
5567   ins_encode %{
5568     __ prefetchw($mem$$Address);
5569   %}
5570   ins_pipe(ialu_mem);
5571 %}
5572 
5573 instruct prefetchAllocNTA( memory mem ) %{
5574   predicate(AllocatePrefetchInstr==0);
5575   match(PrefetchAllocation mem);
5576   ins_cost(125);
5577 
5578   format %{ "PREFETCHNTA $mem\t# Prefetch allocation to non-temporal cache for write" %}
5579   ins_encode %{
5580     __ prefetchnta($mem$$Address);
5581   %}
5582   ins_pipe(ialu_mem);
5583 %}
5584 
5585 instruct prefetchAllocT0( memory mem ) %{
5586   predicate(AllocatePrefetchInstr==1);
5587   match(PrefetchAllocation mem);
5588   ins_cost(125);
5589 
5590   format %{ "PREFETCHT0 $mem\t# Prefetch allocation to level 1 and 2 caches for write" %}
5591   ins_encode %{
5592     __ prefetcht0($mem$$Address);
5593   %}
5594   ins_pipe(ialu_mem);
5595 %}
5596 
5597 instruct prefetchAllocT2( memory mem ) %{
5598   predicate(AllocatePrefetchInstr==2);
5599   match(PrefetchAllocation mem);
5600   ins_cost(125);
5601 
5602   format %{ "PREFETCHT2 $mem\t# Prefetch allocation to level 2 cache for write" %}
5603   ins_encode %{
5604     __ prefetcht2($mem$$Address);
5605   %}
5606   ins_pipe(ialu_mem);
5607 %}
5608 
5609 //----------Store Instructions-------------------------------------------------
5610 
5611 // Store Byte
5612 instruct storeB(memory mem, rRegI src)
5613 %{
5614   match(Set mem (StoreB mem src));
5615 
5616   ins_cost(125); // XXX
5617   format %{ "movb    $mem, $src\t# byte" %}
5618   opcode(0x88);
5619   ins_encode(REX_breg_mem(src, mem), OpcP, reg_mem(src, mem));
5620   ins_pipe(ialu_mem_reg);
5621 %}
5622 
5623 // Store Char/Short
5624 instruct storeC(memory mem, rRegI src)
5625 %{
5626   match(Set mem (StoreC mem src));
5627 
5628   ins_cost(125); // XXX
5629   format %{ "movw    $mem, $src\t# char/short" %}
5630   opcode(0x89);
5631   ins_encode(SizePrefix, REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5632   ins_pipe(ialu_mem_reg);
5633 %}
5634 
5635 // Store Integer
5636 instruct storeI(memory mem, rRegI src)
5637 %{
5638   match(Set mem (StoreI mem src));
5639 
5640   ins_cost(125); // XXX
5641   format %{ "movl    $mem, $src\t# int" %}
5642   opcode(0x89);
5643   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
5644   ins_pipe(ialu_mem_reg);
5645 %}
5646 
5647 // Store Long
5648 instruct storeL(memory mem, rRegL src)
5649 %{
5650   match(Set mem (StoreL mem src));
5651 
5652   ins_cost(125); // XXX
5653   format %{ "movq    $mem, $src\t# long" %}
5654   opcode(0x89);
5655   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5656   ins_pipe(ialu_mem_reg); // XXX
5657 %}
5658 
5659 // Store Pointer
5660 instruct storeP(memory mem, any_RegP src)
5661 %{
5662   match(Set mem (StoreP mem src));
5663 
5664   ins_cost(125); // XXX
5665   format %{ "movq    $mem, $src\t# ptr" %}
5666   opcode(0x89);
5667   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
5668   ins_pipe(ialu_mem_reg);
5669 %}
5670 
5671 instruct storeImmP0(memory mem, immP0 zero)
5672 %{
5673   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5674   match(Set mem (StoreP mem zero));
5675 
5676   ins_cost(125); // XXX
5677   format %{ "movq    $mem, R12\t# ptr (R12_heapbase==0)" %}
5678   ins_encode %{
5679     __ movq($mem$$Address, r12);
5680   %}
5681   ins_pipe(ialu_mem_reg);
5682 %}
5683 
5684 // Store NULL Pointer, mark word, or other simple pointer constant.
5685 instruct storeImmP(memory mem, immP31 src)
5686 %{
5687   match(Set mem (StoreP mem src));
5688 
5689   ins_cost(150); // XXX
5690   format %{ "movq    $mem, $src\t# ptr" %}
5691   opcode(0xC7); /* C7 /0 */
5692   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5693   ins_pipe(ialu_mem_imm);
5694 %}
5695 
5696 // Store Compressed Pointer
5697 instruct storeN(memory mem, rRegN src)
5698 %{
5699   match(Set mem (StoreN mem src));
5700 
5701   ins_cost(125); // XXX
5702   format %{ "movl    $mem, $src\t# compressed ptr" %}
5703   ins_encode %{
5704     __ movl($mem$$Address, $src$$Register);
5705   %}
5706   ins_pipe(ialu_mem_reg);
5707 %}
5708 
5709 instruct storeNKlass(memory mem, rRegN src)
5710 %{
5711   match(Set mem (StoreNKlass mem src));
5712 
5713   ins_cost(125); // XXX
5714   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5715   ins_encode %{
5716     __ movl($mem$$Address, $src$$Register);
5717   %}
5718   ins_pipe(ialu_mem_reg);
5719 %}
5720 
5721 instruct storeImmN0(memory mem, immN0 zero)
5722 %{
5723   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; Universe::narrow_klass_base() == NULL);
5724   match(Set mem (StoreN mem zero));
5725 
5726   ins_cost(125); // XXX
5727   format %{ "movl    $mem, R12\t# compressed ptr (R12_heapbase==0)" %}
5728   ins_encode %{
5729     __ movl($mem$$Address, r12);
5730   %}
5731   ins_pipe(ialu_mem_reg);
5732 %}
5733 
5734 instruct storeImmN(memory mem, immN src)
5735 %{
5736   match(Set mem (StoreN mem src));
5737 
5738   ins_cost(150); // XXX
5739   format %{ "movl    $mem, $src\t# compressed ptr" %}
5740   ins_encode %{
5741     address con = (address)$src$$constant;
5742     if (con == NULL) {
5743       __ movl($mem$$Address, (int32_t)0);
5744     } else {
5745       __ set_narrow_oop($mem$$Address, (jobject)$src$$constant);
5746     }
5747   %}
5748   ins_pipe(ialu_mem_imm);
5749 %}
5750 
5751 instruct storeImmNKlass(memory mem, immNKlass src)
5752 %{
5753   match(Set mem (StoreNKlass mem src));
5754 
5755   ins_cost(150); // XXX
5756   format %{ "movl    $mem, $src\t# compressed klass ptr" %}
5757   ins_encode %{
5758     __ set_narrow_klass($mem$$Address, (Klass*)$src$$constant);
5759   %}
5760   ins_pipe(ialu_mem_imm);
5761 %}
5762 
5763 // Store Integer Immediate
5764 instruct storeImmI0(memory mem, immI0 zero)
5765 %{
5766   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5767   match(Set mem (StoreI mem zero));
5768 
5769   ins_cost(125); // XXX
5770   format %{ "movl    $mem, R12\t# int (R12_heapbase==0)" %}
5771   ins_encode %{
5772     __ movl($mem$$Address, r12);
5773   %}
5774   ins_pipe(ialu_mem_reg);
5775 %}
5776 
5777 instruct storeImmI(memory mem, immI src)
5778 %{
5779   match(Set mem (StoreI mem src));
5780 
5781   ins_cost(150);
5782   format %{ "movl    $mem, $src\t# int" %}
5783   opcode(0xC7); /* C7 /0 */
5784   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5785   ins_pipe(ialu_mem_imm);
5786 %}
5787 
5788 // Store Long Immediate
5789 instruct storeImmL0(memory mem, immL0 zero)
5790 %{
5791   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5792   match(Set mem (StoreL mem zero));
5793 
5794   ins_cost(125); // XXX
5795   format %{ "movq    $mem, R12\t# long (R12_heapbase==0)" %}
5796   ins_encode %{
5797     __ movq($mem$$Address, r12);
5798   %}
5799   ins_pipe(ialu_mem_reg);
5800 %}
5801 
5802 instruct storeImmL(memory mem, immL32 src)
5803 %{
5804   match(Set mem (StoreL mem src));
5805 
5806   ins_cost(150);
5807   format %{ "movq    $mem, $src\t# long" %}
5808   opcode(0xC7); /* C7 /0 */
5809   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32(src));
5810   ins_pipe(ialu_mem_imm);
5811 %}
5812 
5813 // Store Short/Char Immediate
5814 instruct storeImmC0(memory mem, immI0 zero)
5815 %{
5816   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5817   match(Set mem (StoreC mem zero));
5818 
5819   ins_cost(125); // XXX
5820   format %{ "movw    $mem, R12\t# short/char (R12_heapbase==0)" %}
5821   ins_encode %{
5822     __ movw($mem$$Address, r12);
5823   %}
5824   ins_pipe(ialu_mem_reg);
5825 %}
5826 
5827 instruct storeImmI16(memory mem, immI16 src)
5828 %{
5829   predicate(UseStoreImmI16);
5830   match(Set mem (StoreC mem src));
5831 
5832   ins_cost(150);
5833   format %{ "movw    $mem, $src\t# short/char" %}
5834   opcode(0xC7); /* C7 /0 Same as 32 store immediate with prefix */
5835   ins_encode(SizePrefix, REX_mem(mem), OpcP, RM_opc_mem(0x00, mem),Con16(src));
5836   ins_pipe(ialu_mem_imm);
5837 %}
5838 
5839 // Store Byte Immediate
5840 instruct storeImmB0(memory mem, immI0 zero)
5841 %{
5842   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5843   match(Set mem (StoreB mem zero));
5844 
5845   ins_cost(125); // XXX
5846   format %{ "movb    $mem, R12\t# short/char (R12_heapbase==0)" %}
5847   ins_encode %{
5848     __ movb($mem$$Address, r12);
5849   %}
5850   ins_pipe(ialu_mem_reg);
5851 %}
5852 
5853 instruct storeImmB(memory mem, immI8 src)
5854 %{
5855   match(Set mem (StoreB mem src));
5856 
5857   ins_cost(150); // XXX
5858   format %{ "movb    $mem, $src\t# byte" %}
5859   opcode(0xC6); /* C6 /0 */
5860   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5861   ins_pipe(ialu_mem_imm);
5862 %}
5863 
5864 // Store CMS card-mark Immediate
5865 instruct storeImmCM0_reg(memory mem, immI0 zero)
5866 %{
5867   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5868   match(Set mem (StoreCM mem zero));
5869 
5870   ins_cost(125); // XXX
5871   format %{ "movb    $mem, R12\t# CMS card-mark byte 0 (R12_heapbase==0)" %}
5872   ins_encode %{
5873     __ movb($mem$$Address, r12);
5874   %}
5875   ins_pipe(ialu_mem_reg);
5876 %}
5877 
5878 instruct storeImmCM0(memory mem, immI0 src)
5879 %{
5880   match(Set mem (StoreCM mem src));
5881 
5882   ins_cost(150); // XXX
5883   format %{ "movb    $mem, $src\t# CMS card-mark byte 0" %}
5884   opcode(0xC6); /* C6 /0 */
5885   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con8or32(src));
5886   ins_pipe(ialu_mem_imm);
5887 %}
5888 
5889 // Store Float
5890 instruct storeF(memory mem, regF src)
5891 %{
5892   match(Set mem (StoreF mem src));
5893 
5894   ins_cost(95); // XXX
5895   format %{ "movss   $mem, $src\t# float" %}
5896   ins_encode %{
5897     __ movflt($mem$$Address, $src$$XMMRegister);
5898   %}
5899   ins_pipe(pipe_slow); // XXX
5900 %}
5901 
5902 // Store immediate Float value (it is faster than store from XMM register)
5903 instruct storeF0(memory mem, immF0 zero)
5904 %{
5905   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5906   match(Set mem (StoreF mem zero));
5907 
5908   ins_cost(25); // XXX
5909   format %{ "movl    $mem, R12\t# float 0. (R12_heapbase==0)" %}
5910   ins_encode %{
5911     __ movl($mem$$Address, r12);
5912   %}
5913   ins_pipe(ialu_mem_reg);
5914 %}
5915 
5916 instruct storeF_imm(memory mem, immF src)
5917 %{
5918   match(Set mem (StoreF mem src));
5919 
5920   ins_cost(50);
5921   format %{ "movl    $mem, $src\t# float" %}
5922   opcode(0xC7); /* C7 /0 */
5923   ins_encode(REX_mem(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5924   ins_pipe(ialu_mem_imm);
5925 %}
5926 
5927 // Store Double
5928 instruct storeD(memory mem, regD src)
5929 %{
5930   match(Set mem (StoreD mem src));
5931 
5932   ins_cost(95); // XXX
5933   format %{ "movsd   $mem, $src\t# double" %}
5934   ins_encode %{
5935     __ movdbl($mem$$Address, $src$$XMMRegister);
5936   %}
5937   ins_pipe(pipe_slow); // XXX
5938 %}
5939 
5940 // Store immediate double 0.0 (it is faster than store from XMM register)
5941 instruct storeD0_imm(memory mem, immD0 src)
5942 %{
5943   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
5944   match(Set mem (StoreD mem src));
5945 
5946   ins_cost(50);
5947   format %{ "movq    $mem, $src\t# double 0." %}
5948   opcode(0xC7); /* C7 /0 */
5949   ins_encode(REX_mem_wide(mem), OpcP, RM_opc_mem(0x00, mem), Con32F_as_bits(src));
5950   ins_pipe(ialu_mem_imm);
5951 %}
5952 
5953 instruct storeD0(memory mem, immD0 zero)
5954 %{
5955   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
5956   match(Set mem (StoreD mem zero));
5957 
5958   ins_cost(25); // XXX
5959   format %{ "movq    $mem, R12\t# double 0. (R12_heapbase==0)" %}
5960   ins_encode %{
5961     __ movq($mem$$Address, r12);
5962   %}
5963   ins_pipe(ialu_mem_reg);
5964 %}
5965 
5966 instruct storeSSI(stackSlotI dst, rRegI src)
5967 %{
5968   match(Set dst src);
5969 
5970   ins_cost(100);
5971   format %{ "movl    $dst, $src\t# int stk" %}
5972   opcode(0x89);
5973   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
5974   ins_pipe( ialu_mem_reg );
5975 %}
5976 
5977 instruct storeSSL(stackSlotL dst, rRegL src)
5978 %{
5979   match(Set dst src);
5980 
5981   ins_cost(100);
5982   format %{ "movq    $dst, $src\t# long stk" %}
5983   opcode(0x89);
5984   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5985   ins_pipe(ialu_mem_reg);
5986 %}
5987 
5988 instruct storeSSP(stackSlotP dst, rRegP src)
5989 %{
5990   match(Set dst src);
5991 
5992   ins_cost(100);
5993   format %{ "movq    $dst, $src\t# ptr stk" %}
5994   opcode(0x89);
5995   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
5996   ins_pipe(ialu_mem_reg);
5997 %}
5998 
5999 instruct storeSSF(stackSlotF dst, regF src)
6000 %{
6001   match(Set dst src);
6002 
6003   ins_cost(95); // XXX
6004   format %{ "movss   $dst, $src\t# float stk" %}
6005   ins_encode %{
6006     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
6007   %}
6008   ins_pipe(pipe_slow); // XXX
6009 %}
6010 
6011 instruct storeSSD(stackSlotD dst, regD src)
6012 %{
6013   match(Set dst src);
6014 
6015   ins_cost(95); // XXX
6016   format %{ "movsd   $dst, $src\t# double stk" %}
6017   ins_encode %{
6018     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
6019   %}
6020   ins_pipe(pipe_slow); // XXX
6021 %}
6022 
6023 //----------BSWAP Instructions-------------------------------------------------
6024 instruct bytes_reverse_int(rRegI dst) %{
6025   match(Set dst (ReverseBytesI dst));
6026 
6027   format %{ "bswapl  $dst" %}
6028   opcode(0x0F, 0xC8);  /*Opcode 0F /C8 */
6029   ins_encode( REX_reg(dst), OpcP, opc2_reg(dst) );
6030   ins_pipe( ialu_reg );
6031 %}
6032 
6033 instruct bytes_reverse_long(rRegL dst) %{
6034   match(Set dst (ReverseBytesL dst));
6035 
6036   format %{ "bswapq  $dst" %}
6037   opcode(0x0F, 0xC8); /* Opcode 0F /C8 */
6038   ins_encode( REX_reg_wide(dst), OpcP, opc2_reg(dst) );
6039   ins_pipe( ialu_reg);
6040 %}
6041 
6042 instruct bytes_reverse_unsigned_short(rRegI dst, rFlagsReg cr) %{
6043   match(Set dst (ReverseBytesUS dst));
6044   effect(KILL cr);
6045 
6046   format %{ "bswapl  $dst\n\t"
6047             "shrl    $dst,16\n\t" %}
6048   ins_encode %{
6049     __ bswapl($dst$$Register);
6050     __ shrl($dst$$Register, 16);
6051   %}
6052   ins_pipe( ialu_reg );
6053 %}
6054 
6055 instruct bytes_reverse_short(rRegI dst, rFlagsReg cr) %{
6056   match(Set dst (ReverseBytesS dst));
6057   effect(KILL cr);
6058 
6059   format %{ "bswapl  $dst\n\t"
6060             "sar     $dst,16\n\t" %}
6061   ins_encode %{
6062     __ bswapl($dst$$Register);
6063     __ sarl($dst$$Register, 16);
6064   %}
6065   ins_pipe( ialu_reg );
6066 %}
6067 
6068 //---------- Zeros Count Instructions ------------------------------------------
6069 
6070 instruct countLeadingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6071   predicate(UseCountLeadingZerosInstruction);
6072   match(Set dst (CountLeadingZerosI src));
6073   effect(KILL cr);
6074 
6075   format %{ "lzcntl  $dst, $src\t# count leading zeros (int)" %}
6076   ins_encode %{
6077     __ lzcntl($dst$$Register, $src$$Register);
6078   %}
6079   ins_pipe(ialu_reg);
6080 %}
6081 
6082 instruct countLeadingZerosI_bsr(rRegI dst, rRegI src, rFlagsReg cr) %{
6083   predicate(!UseCountLeadingZerosInstruction);
6084   match(Set dst (CountLeadingZerosI src));
6085   effect(KILL cr);
6086 
6087   format %{ "bsrl    $dst, $src\t# count leading zeros (int)\n\t"
6088             "jnz     skip\n\t"
6089             "movl    $dst, -1\n"
6090       "skip:\n\t"
6091             "negl    $dst\n\t"
6092             "addl    $dst, 31" %}
6093   ins_encode %{
6094     Register Rdst = $dst$$Register;
6095     Register Rsrc = $src$$Register;
6096     Label skip;
6097     __ bsrl(Rdst, Rsrc);
6098     __ jccb(Assembler::notZero, skip);
6099     __ movl(Rdst, -1);
6100     __ bind(skip);
6101     __ negl(Rdst);
6102     __ addl(Rdst, BitsPerInt - 1);
6103   %}
6104   ins_pipe(ialu_reg);
6105 %}
6106 
6107 instruct countLeadingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6108   predicate(UseCountLeadingZerosInstruction);
6109   match(Set dst (CountLeadingZerosL src));
6110   effect(KILL cr);
6111 
6112   format %{ "lzcntq  $dst, $src\t# count leading zeros (long)" %}
6113   ins_encode %{
6114     __ lzcntq($dst$$Register, $src$$Register);
6115   %}
6116   ins_pipe(ialu_reg);
6117 %}
6118 
6119 instruct countLeadingZerosL_bsr(rRegI dst, rRegL src, rFlagsReg cr) %{
6120   predicate(!UseCountLeadingZerosInstruction);
6121   match(Set dst (CountLeadingZerosL src));
6122   effect(KILL cr);
6123 
6124   format %{ "bsrq    $dst, $src\t# count leading zeros (long)\n\t"
6125             "jnz     skip\n\t"
6126             "movl    $dst, -1\n"
6127       "skip:\n\t"
6128             "negl    $dst\n\t"
6129             "addl    $dst, 63" %}
6130   ins_encode %{
6131     Register Rdst = $dst$$Register;
6132     Register Rsrc = $src$$Register;
6133     Label skip;
6134     __ bsrq(Rdst, Rsrc);
6135     __ jccb(Assembler::notZero, skip);
6136     __ movl(Rdst, -1);
6137     __ bind(skip);
6138     __ negl(Rdst);
6139     __ addl(Rdst, BitsPerLong - 1);
6140   %}
6141   ins_pipe(ialu_reg);
6142 %}
6143 
6144 instruct countTrailingZerosI(rRegI dst, rRegI src, rFlagsReg cr) %{
6145   predicate(UseCountTrailingZerosInstruction);
6146   match(Set dst (CountTrailingZerosI src));
6147   effect(KILL cr);
6148 
6149   format %{ "tzcntl    $dst, $src\t# count trailing zeros (int)" %}
6150   ins_encode %{
6151     __ tzcntl($dst$$Register, $src$$Register);
6152   %}
6153   ins_pipe(ialu_reg);
6154 %}
6155 
6156 instruct countTrailingZerosI_bsf(rRegI dst, rRegI src, rFlagsReg cr) %{
6157   predicate(!UseCountTrailingZerosInstruction);
6158   match(Set dst (CountTrailingZerosI src));
6159   effect(KILL cr);
6160 
6161   format %{ "bsfl    $dst, $src\t# count trailing zeros (int)\n\t"
6162             "jnz     done\n\t"
6163             "movl    $dst, 32\n"
6164       "done:" %}
6165   ins_encode %{
6166     Register Rdst = $dst$$Register;
6167     Label done;
6168     __ bsfl(Rdst, $src$$Register);
6169     __ jccb(Assembler::notZero, done);
6170     __ movl(Rdst, BitsPerInt);
6171     __ bind(done);
6172   %}
6173   ins_pipe(ialu_reg);
6174 %}
6175 
6176 instruct countTrailingZerosL(rRegI dst, rRegL src, rFlagsReg cr) %{
6177   predicate(UseCountTrailingZerosInstruction);
6178   match(Set dst (CountTrailingZerosL src));
6179   effect(KILL cr);
6180 
6181   format %{ "tzcntq    $dst, $src\t# count trailing zeros (long)" %}
6182   ins_encode %{
6183     __ tzcntq($dst$$Register, $src$$Register);
6184   %}
6185   ins_pipe(ialu_reg);
6186 %}
6187 
6188 instruct countTrailingZerosL_bsf(rRegI dst, rRegL src, rFlagsReg cr) %{
6189   predicate(!UseCountTrailingZerosInstruction);
6190   match(Set dst (CountTrailingZerosL src));
6191   effect(KILL cr);
6192 
6193   format %{ "bsfq    $dst, $src\t# count trailing zeros (long)\n\t"
6194             "jnz     done\n\t"
6195             "movl    $dst, 64\n"
6196       "done:" %}
6197   ins_encode %{
6198     Register Rdst = $dst$$Register;
6199     Label done;
6200     __ bsfq(Rdst, $src$$Register);
6201     __ jccb(Assembler::notZero, done);
6202     __ movl(Rdst, BitsPerLong);
6203     __ bind(done);
6204   %}
6205   ins_pipe(ialu_reg);
6206 %}
6207 
6208 
6209 //---------- Population Count Instructions -------------------------------------
6210 
6211 instruct popCountI(rRegI dst, rRegI src, rFlagsReg cr) %{
6212   predicate(UsePopCountInstruction);
6213   match(Set dst (PopCountI src));
6214   effect(KILL cr);
6215 
6216   format %{ "popcnt  $dst, $src" %}
6217   ins_encode %{
6218     __ popcntl($dst$$Register, $src$$Register);
6219   %}
6220   ins_pipe(ialu_reg);
6221 %}
6222 
6223 instruct popCountI_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6224   predicate(UsePopCountInstruction);
6225   match(Set dst (PopCountI (LoadI mem)));
6226   effect(KILL cr);
6227 
6228   format %{ "popcnt  $dst, $mem" %}
6229   ins_encode %{
6230     __ popcntl($dst$$Register, $mem$$Address);
6231   %}
6232   ins_pipe(ialu_reg);
6233 %}
6234 
6235 // Note: Long.bitCount(long) returns an int.
6236 instruct popCountL(rRegI dst, rRegL src, rFlagsReg cr) %{
6237   predicate(UsePopCountInstruction);
6238   match(Set dst (PopCountL src));
6239   effect(KILL cr);
6240 
6241   format %{ "popcnt  $dst, $src" %}
6242   ins_encode %{
6243     __ popcntq($dst$$Register, $src$$Register);
6244   %}
6245   ins_pipe(ialu_reg);
6246 %}
6247 
6248 // Note: Long.bitCount(long) returns an int.
6249 instruct popCountL_mem(rRegI dst, memory mem, rFlagsReg cr) %{
6250   predicate(UsePopCountInstruction);
6251   match(Set dst (PopCountL (LoadL mem)));
6252   effect(KILL cr);
6253 
6254   format %{ "popcnt  $dst, $mem" %}
6255   ins_encode %{
6256     __ popcntq($dst$$Register, $mem$$Address);
6257   %}
6258   ins_pipe(ialu_reg);
6259 %}
6260 
6261 
6262 //----------MemBar Instructions-----------------------------------------------
6263 // Memory barrier flavors
6264 
6265 instruct membar_acquire()
6266 %{
6267   match(MemBarAcquire);
6268   match(LoadFence);
6269   ins_cost(0);
6270 
6271   size(0);
6272   format %{ "MEMBAR-acquire ! (empty encoding)" %}
6273   ins_encode();
6274   ins_pipe(empty);
6275 %}
6276 
6277 instruct membar_acquire_lock()
6278 %{
6279   match(MemBarAcquireLock);
6280   ins_cost(0);
6281 
6282   size(0);
6283   format %{ "MEMBAR-acquire (prior CMPXCHG in FastLock so empty encoding)" %}
6284   ins_encode();
6285   ins_pipe(empty);
6286 %}
6287 
6288 instruct membar_release()
6289 %{
6290   match(MemBarRelease);
6291   match(StoreFence);
6292   ins_cost(0);
6293 
6294   size(0);
6295   format %{ "MEMBAR-release ! (empty encoding)" %}
6296   ins_encode();
6297   ins_pipe(empty);
6298 %}
6299 
6300 instruct membar_release_lock()
6301 %{
6302   match(MemBarReleaseLock);
6303   ins_cost(0);
6304 
6305   size(0);
6306   format %{ "MEMBAR-release (a FastUnlock follows so empty encoding)" %}
6307   ins_encode();
6308   ins_pipe(empty);
6309 %}
6310 
6311 instruct spinloophint()
6312 %{
6313   match(SpinLoopHint);
6314   ins_cost(200);
6315 
6316   format %{
6317     $$template
6318     if (os::is_MP()) {
6319       $$emit$$"pause\t! membar_spinloophint"
6320     } else {
6321       $$emit$$"MEMBAR-spinloophint ! (empty encoding)"
6322     }
6323   %}
6324   ins_encode %{
6325     __ pause();
6326   %}
6327   ins_pipe(pipe_slow);
6328 %}
6329 
6330 instruct membar_volatile(rFlagsReg cr) %{
6331   match(MemBarVolatile);
6332   effect(KILL cr);
6333   ins_cost(400);
6334 
6335   format %{
6336     $$template
6337     if (os::is_MP()) {
6338       $$emit$$"lock addl [rsp + #0], 0\t! membar_volatile"
6339     } else {
6340       $$emit$$"MEMBAR-volatile ! (empty encoding)"
6341     }
6342   %}
6343   ins_encode %{
6344     __ membar(Assembler::StoreLoad);
6345   %}
6346   ins_pipe(pipe_slow);
6347 %}
6348 
6349 instruct unnecessary_membar_volatile()
6350 %{
6351   match(MemBarVolatile);
6352   predicate(Matcher::post_store_load_barrier(n));
6353   ins_cost(0);
6354 
6355   size(0);
6356   format %{ "MEMBAR-volatile (unnecessary so empty encoding)" %}
6357   ins_encode();
6358   ins_pipe(empty);
6359 %}
6360 
6361 instruct membar_storestore() %{
6362   match(MemBarStoreStore);
6363   ins_cost(0);
6364 
6365   size(0);
6366   format %{ "MEMBAR-storestore (empty encoding)" %}
6367   ins_encode( );
6368   ins_pipe(empty);
6369 %}
6370 
6371 //----------Move Instructions--------------------------------------------------
6372 
6373 instruct castX2P(rRegP dst, rRegL src)
6374 %{
6375   match(Set dst (CastX2P src));
6376 
6377   format %{ "movq    $dst, $src\t# long-&gt;ptr" %}
6378   ins_encode %{
6379     if ($dst$$reg != $src$$reg) {
6380       __ movptr($dst$$Register, $src$$Register);
6381     }
6382   %}
6383   ins_pipe(ialu_reg_reg); // XXX
6384 %}
6385 
6386 instruct castP2X(rRegL dst, rRegP src)
6387 %{
6388   match(Set dst (CastP2X src));
6389 
6390   format %{ "movq    $dst, $src\t# ptr -&gt; long" %}
6391   ins_encode %{
6392     if ($dst$$reg != $src$$reg) {
6393       __ movptr($dst$$Register, $src$$Register);
6394     }
6395   %}
6396   ins_pipe(ialu_reg_reg); // XXX
6397 %}
6398 
6399 // Convert oop into int for vectors alignment masking
6400 instruct convP2I(rRegI dst, rRegP src)
6401 %{
6402   match(Set dst (ConvL2I (CastP2X src)));
6403 
6404   format %{ "movl    $dst, $src\t# ptr -&gt; int" %}
6405   ins_encode %{
6406     __ movl($dst$$Register, $src$$Register);
6407   %}
6408   ins_pipe(ialu_reg_reg); // XXX
6409 %}
6410 
6411 // Convert compressed oop into int for vectors alignment masking
6412 // in case of 32bit oops (heap &lt; 4Gb).
6413 instruct convN2I(rRegI dst, rRegN src)
6414 %{
6415   predicate(Universe::narrow_oop_shift() == 0);
6416   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
6417 
6418   format %{ "movl    $dst, $src\t# compressed ptr -&gt; int" %}
6419   ins_encode %{
6420     __ movl($dst$$Register, $src$$Register);
6421   %}
6422   ins_pipe(ialu_reg_reg); // XXX
6423 %}
6424 
6425 // Convert oop pointer into compressed form
6426 instruct encodeHeapOop(rRegN dst, rRegP src, rFlagsReg cr) %{
6427   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull);
6428   match(Set dst (EncodeP src));
6429   effect(KILL cr);
6430   format %{ "encode_heap_oop $dst,$src" %}
6431   ins_encode %{
6432     Register s = $src$$Register;
6433     Register d = $dst$$Register;
6434     if (s != d) {
6435       __ movq(d, s);
6436     }
6437     __ encode_heap_oop(d);
6438   %}
6439   ins_pipe(ialu_reg_long);
6440 %}
6441 
6442 instruct encodeHeapOop_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6443   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull);
6444   match(Set dst (EncodeP src));
6445   effect(KILL cr);
6446   format %{ "encode_heap_oop_not_null $dst,$src" %}
6447   ins_encode %{
6448     __ encode_heap_oop_not_null($dst$$Register, $src$$Register);
6449   %}
6450   ins_pipe(ialu_reg_long);
6451 %}
6452 
6453 instruct decodeHeapOop(rRegP dst, rRegN src, rFlagsReg cr) %{
6454   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
6455             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() != TypePtr::Constant);
6456   match(Set dst (DecodeN src));
6457   effect(KILL cr);
6458   format %{ "decode_heap_oop $dst,$src" %}
6459   ins_encode %{
6460     Register s = $src$$Register;
6461     Register d = $dst$$Register;
6462     if (s != d) {
6463       __ movq(d, s);
6464     }
6465     __ decode_heap_oop(d);
6466   %}
6467   ins_pipe(ialu_reg_long);
6468 %}
6469 
6470 instruct decodeHeapOop_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6471   predicate(n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::NotNull ||
6472             n-&gt;bottom_type()-&gt;is_ptr()-&gt;ptr() == TypePtr::Constant);
6473   match(Set dst (DecodeN src));
6474   effect(KILL cr);
6475   format %{ "decode_heap_oop_not_null $dst,$src" %}
6476   ins_encode %{
6477     Register s = $src$$Register;
6478     Register d = $dst$$Register;
6479     if (s != d) {
6480       __ decode_heap_oop_not_null(d, s);
6481     } else {
6482       __ decode_heap_oop_not_null(d);
6483     }
6484   %}
6485   ins_pipe(ialu_reg_long);
6486 %}
6487 
6488 instruct encodeKlass_not_null(rRegN dst, rRegP src, rFlagsReg cr) %{
6489   match(Set dst (EncodePKlass src));
6490   effect(KILL cr);
6491   format %{ "encode_klass_not_null $dst,$src" %}
6492   ins_encode %{
6493     __ encode_klass_not_null($dst$$Register, $src$$Register);
6494   %}
6495   ins_pipe(ialu_reg_long);
6496 %}
6497 
6498 instruct decodeKlass_not_null(rRegP dst, rRegN src, rFlagsReg cr) %{
6499   match(Set dst (DecodeNKlass src));
6500   effect(KILL cr);
6501   format %{ "decode_klass_not_null $dst,$src" %}
6502   ins_encode %{
6503     Register s = $src$$Register;
6504     Register d = $dst$$Register;
6505     if (s != d) {
6506       __ decode_klass_not_null(d, s);
6507     } else {
6508       __ decode_klass_not_null(d);
6509     }
6510   %}
6511   ins_pipe(ialu_reg_long);
6512 %}
6513 
6514 
6515 //----------Conditional Move---------------------------------------------------
6516 // Jump
6517 // dummy instruction for generating temp registers
6518 instruct jumpXtnd_offset(rRegL switch_val, immI2 shift, rRegI dest) %{
6519   match(Jump (LShiftL switch_val shift));
6520   ins_cost(350);
6521   predicate(false);
6522   effect(TEMP dest);
6523 
6524   format %{ "leaq    $dest, [$constantaddress]\n\t"
6525             "jmp     [$dest + $switch_val &lt;&lt; $shift]\n\t" %}
6526   ins_encode %{
6527     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6528     // to do that and the compiler is using that register as one it can allocate.
6529     // So we build it all by hand.
6530     // Address index(noreg, switch_reg, (Address::ScaleFactor)$shift$$constant);
6531     // ArrayAddress dispatch(table, index);
6532     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant);
6533     __ lea($dest$$Register, $constantaddress);
6534     __ jmp(dispatch);
6535   %}
6536   ins_pipe(pipe_jmp);
6537 %}
6538 
6539 instruct jumpXtnd_addr(rRegL switch_val, immI2 shift, immL32 offset, rRegI dest) %{
6540   match(Jump (AddL (LShiftL switch_val shift) offset));
6541   ins_cost(350);
6542   effect(TEMP dest);
6543 
6544   format %{ "leaq    $dest, [$constantaddress]\n\t"
6545             "jmp     [$dest + $switch_val &lt;&lt; $shift + $offset]\n\t" %}
6546   ins_encode %{
6547     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6548     // to do that and the compiler is using that register as one it can allocate.
6549     // So we build it all by hand.
6550     // Address index(noreg, switch_reg, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6551     // ArrayAddress dispatch(table, index);
6552     Address dispatch($dest$$Register, $switch_val$$Register, (Address::ScaleFactor) $shift$$constant, (int) $offset$$constant);
6553     __ lea($dest$$Register, $constantaddress);
6554     __ jmp(dispatch);
6555   %}
6556   ins_pipe(pipe_jmp);
6557 %}
6558 
6559 instruct jumpXtnd(rRegL switch_val, rRegI dest) %{
6560   match(Jump switch_val);
6561   ins_cost(350);
6562   effect(TEMP dest);
6563 
6564   format %{ "leaq    $dest, [$constantaddress]\n\t"
6565             "jmp     [$dest + $switch_val]\n\t" %}
6566   ins_encode %{
6567     // We could use jump(ArrayAddress) except that the macro assembler needs to use r10
6568     // to do that and the compiler is using that register as one it can allocate.
6569     // So we build it all by hand.
6570     // Address index(noreg, switch_reg, Address::times_1);
6571     // ArrayAddress dispatch(table, index);
6572     Address dispatch($dest$$Register, $switch_val$$Register, Address::times_1);
6573     __ lea($dest$$Register, $constantaddress);
6574     __ jmp(dispatch);
6575   %}
6576   ins_pipe(pipe_jmp);
6577 %}
6578 
6579 // Conditional move
6580 instruct cmovI_reg(rRegI dst, rRegI src, rFlagsReg cr, cmpOp cop)
6581 %{
6582   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6583 
6584   ins_cost(200); // XXX
6585   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6586   opcode(0x0F, 0x40);
6587   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6588   ins_pipe(pipe_cmov_reg);
6589 %}
6590 
6591 instruct cmovI_regU(cmpOpU cop, rFlagsRegU cr, rRegI dst, rRegI src) %{
6592   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6593 
6594   ins_cost(200); // XXX
6595   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6596   opcode(0x0F, 0x40);
6597   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6598   ins_pipe(pipe_cmov_reg);
6599 %}
6600 
6601 instruct cmovI_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, rRegI src) %{
6602   match(Set dst (CMoveI (Binary cop cr) (Binary dst src)));
6603   ins_cost(200);
6604   expand %{
6605     cmovI_regU(cop, cr, dst, src);
6606   %}
6607 %}
6608 
6609 // Conditional move
6610 instruct cmovI_mem(cmpOp cop, rFlagsReg cr, rRegI dst, memory src) %{
6611   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6612 
6613   ins_cost(250); // XXX
6614   format %{ "cmovl$cop $dst, $src\t# signed, int" %}
6615   opcode(0x0F, 0x40);
6616   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6617   ins_pipe(pipe_cmov_mem);
6618 %}
6619 
6620 // Conditional move
6621 instruct cmovI_memU(cmpOpU cop, rFlagsRegU cr, rRegI dst, memory src)
6622 %{
6623   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6624 
6625   ins_cost(250); // XXX
6626   format %{ "cmovl$cop $dst, $src\t# unsigned, int" %}
6627   opcode(0x0F, 0x40);
6628   ins_encode(REX_reg_mem(dst, src), enc_cmov(cop), reg_mem(dst, src));
6629   ins_pipe(pipe_cmov_mem);
6630 %}
6631 
6632 instruct cmovI_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegI dst, memory src) %{
6633   match(Set dst (CMoveI (Binary cop cr) (Binary dst (LoadI src))));
6634   ins_cost(250);
6635   expand %{
6636     cmovI_memU(cop, cr, dst, src);
6637   %}
6638 %}
6639 
6640 // Conditional move
6641 instruct cmovN_reg(rRegN dst, rRegN src, rFlagsReg cr, cmpOp cop)
6642 %{
6643   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6644 
6645   ins_cost(200); // XXX
6646   format %{ "cmovl$cop $dst, $src\t# signed, compressed ptr" %}
6647   opcode(0x0F, 0x40);
6648   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6649   ins_pipe(pipe_cmov_reg);
6650 %}
6651 
6652 // Conditional move
6653 instruct cmovN_regU(cmpOpU cop, rFlagsRegU cr, rRegN dst, rRegN src)
6654 %{
6655   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6656 
6657   ins_cost(200); // XXX
6658   format %{ "cmovl$cop $dst, $src\t# unsigned, compressed ptr" %}
6659   opcode(0x0F, 0x40);
6660   ins_encode(REX_reg_reg(dst, src), enc_cmov(cop), reg_reg(dst, src));
6661   ins_pipe(pipe_cmov_reg);
6662 %}
6663 
6664 instruct cmovN_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegN dst, rRegN src) %{
6665   match(Set dst (CMoveN (Binary cop cr) (Binary dst src)));
6666   ins_cost(200);
6667   expand %{
6668     cmovN_regU(cop, cr, dst, src);
6669   %}
6670 %}
6671 
6672 // Conditional move
6673 instruct cmovP_reg(rRegP dst, rRegP src, rFlagsReg cr, cmpOp cop)
6674 %{
6675   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6676 
6677   ins_cost(200); // XXX
6678   format %{ "cmovq$cop $dst, $src\t# signed, ptr" %}
6679   opcode(0x0F, 0x40);
6680   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6681   ins_pipe(pipe_cmov_reg);  // XXX
6682 %}
6683 
6684 // Conditional move
6685 instruct cmovP_regU(cmpOpU cop, rFlagsRegU cr, rRegP dst, rRegP src)
6686 %{
6687   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6688 
6689   ins_cost(200); // XXX
6690   format %{ "cmovq$cop $dst, $src\t# unsigned, ptr" %}
6691   opcode(0x0F, 0x40);
6692   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6693   ins_pipe(pipe_cmov_reg); // XXX
6694 %}
6695 
6696 instruct cmovP_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegP dst, rRegP src) %{
6697   match(Set dst (CMoveP (Binary cop cr) (Binary dst src)));
6698   ins_cost(200);
6699   expand %{
6700     cmovP_regU(cop, cr, dst, src);
6701   %}
6702 %}
6703 
6704 // DISABLED: Requires the ADLC to emit a bottom_type call that
6705 // correctly meets the two pointer arguments; one is an incoming
6706 // register but the other is a memory operand.  ALSO appears to
6707 // be buggy with implicit null checks.
6708 //
6709 //// Conditional move
6710 //instruct cmovP_mem(cmpOp cop, rFlagsReg cr, rRegP dst, memory src)
6711 //%{
6712 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6713 //  ins_cost(250);
6714 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6715 //  opcode(0x0F,0x40);
6716 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6717 //  ins_pipe( pipe_cmov_mem );
6718 //%}
6719 //
6720 //// Conditional move
6721 //instruct cmovP_memU(cmpOpU cop, rFlagsRegU cr, rRegP dst, memory src)
6722 //%{
6723 //  match(Set dst (CMoveP (Binary cop cr) (Binary dst (LoadP src))));
6724 //  ins_cost(250);
6725 //  format %{ "CMOV$cop $dst,$src\t# ptr" %}
6726 //  opcode(0x0F,0x40);
6727 //  ins_encode( enc_cmov(cop), reg_mem( dst, src ) );
6728 //  ins_pipe( pipe_cmov_mem );
6729 //%}
6730 
6731 instruct cmovL_reg(cmpOp cop, rFlagsReg cr, rRegL dst, rRegL src)
6732 %{
6733   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6734 
6735   ins_cost(200); // XXX
6736   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6737   opcode(0x0F, 0x40);
6738   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6739   ins_pipe(pipe_cmov_reg);  // XXX
6740 %}
6741 
6742 instruct cmovL_mem(cmpOp cop, rFlagsReg cr, rRegL dst, memory src)
6743 %{
6744   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6745 
6746   ins_cost(200); // XXX
6747   format %{ "cmovq$cop $dst, $src\t# signed, long" %}
6748   opcode(0x0F, 0x40);
6749   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6750   ins_pipe(pipe_cmov_mem);  // XXX
6751 %}
6752 
6753 instruct cmovL_regU(cmpOpU cop, rFlagsRegU cr, rRegL dst, rRegL src)
6754 %{
6755   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6756 
6757   ins_cost(200); // XXX
6758   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6759   opcode(0x0F, 0x40);
6760   ins_encode(REX_reg_reg_wide(dst, src), enc_cmov(cop), reg_reg(dst, src));
6761   ins_pipe(pipe_cmov_reg); // XXX
6762 %}
6763 
6764 instruct cmovL_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, rRegL src) %{
6765   match(Set dst (CMoveL (Binary cop cr) (Binary dst src)));
6766   ins_cost(200);
6767   expand %{
6768     cmovL_regU(cop, cr, dst, src);
6769   %}
6770 %}
6771 
6772 instruct cmovL_memU(cmpOpU cop, rFlagsRegU cr, rRegL dst, memory src)
6773 %{
6774   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6775 
6776   ins_cost(200); // XXX
6777   format %{ "cmovq$cop $dst, $src\t# unsigned, long" %}
6778   opcode(0x0F, 0x40);
6779   ins_encode(REX_reg_mem_wide(dst, src), enc_cmov(cop), reg_mem(dst, src));
6780   ins_pipe(pipe_cmov_mem); // XXX
6781 %}
6782 
6783 instruct cmovL_memUCF(cmpOpUCF cop, rFlagsRegUCF cr, rRegL dst, memory src) %{
6784   match(Set dst (CMoveL (Binary cop cr) (Binary dst (LoadL src))));
6785   ins_cost(200);
6786   expand %{
6787     cmovL_memU(cop, cr, dst, src);
6788   %}
6789 %}
6790 
6791 instruct cmovF_reg(cmpOp cop, rFlagsReg cr, regF dst, regF src)
6792 %{
6793   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6794 
6795   ins_cost(200); // XXX
6796   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6797             "movss     $dst, $src\n"
6798     "skip:" %}
6799   ins_encode %{
6800     Label Lskip;
6801     // Invert sense of branch from sense of CMOV
6802     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6803     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6804     __ bind(Lskip);
6805   %}
6806   ins_pipe(pipe_slow);
6807 %}
6808 
6809 // instruct cmovF_mem(cmpOp cop, rFlagsReg cr, regF dst, memory src)
6810 // %{
6811 //   match(Set dst (CMoveF (Binary cop cr) (Binary dst (LoadL src))));
6812 
6813 //   ins_cost(200); // XXX
6814 //   format %{ "jn$cop    skip\t# signed cmove float\n\t"
6815 //             "movss     $dst, $src\n"
6816 //     "skip:" %}
6817 //   ins_encode(enc_cmovf_mem_branch(cop, dst, src));
6818 //   ins_pipe(pipe_slow);
6819 // %}
6820 
6821 instruct cmovF_regU(cmpOpU cop, rFlagsRegU cr, regF dst, regF src)
6822 %{
6823   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6824 
6825   ins_cost(200); // XXX
6826   format %{ "jn$cop    skip\t# unsigned cmove float\n\t"
6827             "movss     $dst, $src\n"
6828     "skip:" %}
6829   ins_encode %{
6830     Label Lskip;
6831     // Invert sense of branch from sense of CMOV
6832     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6833     __ movflt($dst$$XMMRegister, $src$$XMMRegister);
6834     __ bind(Lskip);
6835   %}
6836   ins_pipe(pipe_slow);
6837 %}
6838 
6839 instruct cmovF_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regF dst, regF src) %{
6840   match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));
6841   ins_cost(200);
6842   expand %{
6843     cmovF_regU(cop, cr, dst, src);
6844   %}
6845 %}
6846 
6847 instruct cmovD_reg(cmpOp cop, rFlagsReg cr, regD dst, regD src)
6848 %{
6849   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6850 
6851   ins_cost(200); // XXX
6852   format %{ "jn$cop    skip\t# signed cmove double\n\t"
6853             "movsd     $dst, $src\n"
6854     "skip:" %}
6855   ins_encode %{
6856     Label Lskip;
6857     // Invert sense of branch from sense of CMOV
6858     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6859     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6860     __ bind(Lskip);
6861   %}
6862   ins_pipe(pipe_slow);
6863 %}
6864 
6865 instruct cmovD_regU(cmpOpU cop, rFlagsRegU cr, regD dst, regD src)
6866 %{
6867   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6868 
6869   ins_cost(200); // XXX
6870   format %{ "jn$cop    skip\t# unsigned cmove double\n\t"
6871             "movsd     $dst, $src\n"
6872     "skip:" %}
6873   ins_encode %{
6874     Label Lskip;
6875     // Invert sense of branch from sense of CMOV
6876     __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);
6877     __ movdbl($dst$$XMMRegister, $src$$XMMRegister);
6878     __ bind(Lskip);
6879   %}
6880   ins_pipe(pipe_slow);
6881 %}
6882 
6883 instruct cmovD_regUCF(cmpOpUCF cop, rFlagsRegUCF cr, regD dst, regD src) %{
6884   match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));
6885   ins_cost(200);
6886   expand %{
6887     cmovD_regU(cop, cr, dst, src);
6888   %}
6889 %}
6890 
6891 //----------Arithmetic Instructions--------------------------------------------
6892 //----------Addition Instructions----------------------------------------------
6893 
6894 instruct addI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
6895 %{
6896   match(Set dst (AddI dst src));
6897   effect(KILL cr);
6898 
6899   format %{ "addl    $dst, $src\t# int" %}
6900   opcode(0x03);
6901   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
6902   ins_pipe(ialu_reg_reg);
6903 %}
6904 
6905 instruct addI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
6906 %{
6907   match(Set dst (AddI dst src));
6908   effect(KILL cr);
6909 
6910   format %{ "addl    $dst, $src\t# int" %}
6911   opcode(0x81, 0x00); /* /0 id */
6912   ins_encode(OpcSErm(dst, src), Con8or32(src));
6913   ins_pipe( ialu_reg );
6914 %}
6915 
6916 instruct addI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
6917 %{
6918   match(Set dst (AddI dst (LoadI src)));
6919   effect(KILL cr);
6920 
6921   ins_cost(125); // XXX
6922   format %{ "addl    $dst, $src\t# int" %}
6923   opcode(0x03);
6924   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
6925   ins_pipe(ialu_reg_mem);
6926 %}
6927 
6928 instruct addI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
6929 %{
6930   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6931   effect(KILL cr);
6932 
6933   ins_cost(150); // XXX
6934   format %{ "addl    $dst, $src\t# int" %}
6935   opcode(0x01); /* Opcode 01 /r */
6936   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
6937   ins_pipe(ialu_mem_reg);
6938 %}
6939 
6940 instruct addI_mem_imm(memory dst, immI src, rFlagsReg cr)
6941 %{
6942   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6943   effect(KILL cr);
6944 
6945   ins_cost(125); // XXX
6946   format %{ "addl    $dst, $src\t# int" %}
6947   opcode(0x81); /* Opcode 81 /0 id */
6948   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
6949   ins_pipe(ialu_mem_imm);
6950 %}
6951 
6952 instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
6953 %{
6954   predicate(UseIncDec);
6955   match(Set dst (AddI dst src));
6956   effect(KILL cr);
6957 
6958   format %{ "incl    $dst\t# int" %}
6959   opcode(0xFF, 0x00); // FF /0
6960   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6961   ins_pipe(ialu_reg);
6962 %}
6963 
6964 instruct incI_mem(memory dst, immI1 src, rFlagsReg cr)
6965 %{
6966   predicate(UseIncDec);
6967   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6968   effect(KILL cr);
6969 
6970   ins_cost(125); // XXX
6971   format %{ "incl    $dst\t# int" %}
6972   opcode(0xFF); /* Opcode FF /0 */
6973   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x00, dst));
6974   ins_pipe(ialu_mem_imm);
6975 %}
6976 
6977 // XXX why does that use AddI
6978 instruct decI_rReg(rRegI dst, immI_M1 src, rFlagsReg cr)
6979 %{
6980   predicate(UseIncDec);
6981   match(Set dst (AddI dst src));
6982   effect(KILL cr);
6983 
6984   format %{ "decl    $dst\t# int" %}
6985   opcode(0xFF, 0x01); // FF /1
6986   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
6987   ins_pipe(ialu_reg);
6988 %}
6989 
6990 // XXX why does that use AddI
6991 instruct decI_mem(memory dst, immI_M1 src, rFlagsReg cr)
6992 %{
6993   predicate(UseIncDec);
6994   match(Set dst (StoreI dst (AddI (LoadI dst) src)));
6995   effect(KILL cr);
6996 
6997   ins_cost(125); // XXX
6998   format %{ "decl    $dst\t# int" %}
6999   opcode(0xFF); /* Opcode FF /1 */
7000   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(0x01, dst));
7001   ins_pipe(ialu_mem_imm);
7002 %}
7003 
7004 instruct leaI_rReg_immI(rRegI dst, rRegI src0, immI src1)
7005 %{
7006   match(Set dst (AddI src0 src1));
7007 
7008   ins_cost(110);
7009   format %{ "addr32 leal $dst, [$src0 + $src1]\t# int" %}
7010   opcode(0x8D); /* 0x8D /r */
7011   ins_encode(Opcode(0x67), REX_reg_reg(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7012   ins_pipe(ialu_reg_reg);
7013 %}
7014 
7015 instruct addL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7016 %{
7017   match(Set dst (AddL dst src));
7018   effect(KILL cr);
7019 
7020   format %{ "addq    $dst, $src\t# long" %}
7021   opcode(0x03);
7022   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7023   ins_pipe(ialu_reg_reg);
7024 %}
7025 
7026 instruct addL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
7027 %{
7028   match(Set dst (AddL dst src));
7029   effect(KILL cr);
7030 
7031   format %{ "addq    $dst, $src\t# long" %}
7032   opcode(0x81, 0x00); /* /0 id */
7033   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7034   ins_pipe( ialu_reg );
7035 %}
7036 
7037 instruct addL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7038 %{
7039   match(Set dst (AddL dst (LoadL src)));
7040   effect(KILL cr);
7041 
7042   ins_cost(125); // XXX
7043   format %{ "addq    $dst, $src\t# long" %}
7044   opcode(0x03);
7045   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7046   ins_pipe(ialu_reg_mem);
7047 %}
7048 
7049 instruct addL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7050 %{
7051   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7052   effect(KILL cr);
7053 
7054   ins_cost(150); // XXX
7055   format %{ "addq    $dst, $src\t# long" %}
7056   opcode(0x01); /* Opcode 01 /r */
7057   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7058   ins_pipe(ialu_mem_reg);
7059 %}
7060 
7061 instruct addL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7062 %{
7063   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7064   effect(KILL cr);
7065 
7066   ins_cost(125); // XXX
7067   format %{ "addq    $dst, $src\t# long" %}
7068   opcode(0x81); /* Opcode 81 /0 id */
7069   ins_encode(REX_mem_wide(dst),
7070              OpcSE(src), RM_opc_mem(0x00, dst), Con8or32(src));
7071   ins_pipe(ialu_mem_imm);
7072 %}
7073 
7074 instruct incL_rReg(rRegI dst, immL1 src, rFlagsReg cr)
7075 %{
7076   predicate(UseIncDec);
7077   match(Set dst (AddL dst src));
7078   effect(KILL cr);
7079 
7080   format %{ "incq    $dst\t# long" %}
7081   opcode(0xFF, 0x00); // FF /0
7082   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7083   ins_pipe(ialu_reg);
7084 %}
7085 
7086 instruct incL_mem(memory dst, immL1 src, rFlagsReg cr)
7087 %{
7088   predicate(UseIncDec);
7089   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7090   effect(KILL cr);
7091 
7092   ins_cost(125); // XXX
7093   format %{ "incq    $dst\t# long" %}
7094   opcode(0xFF); /* Opcode FF /0 */
7095   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x00, dst));
7096   ins_pipe(ialu_mem_imm);
7097 %}
7098 
7099 // XXX why does that use AddL
7100 instruct decL_rReg(rRegL dst, immL_M1 src, rFlagsReg cr)
7101 %{
7102   predicate(UseIncDec);
7103   match(Set dst (AddL dst src));
7104   effect(KILL cr);
7105 
7106   format %{ "decq    $dst\t# long" %}
7107   opcode(0xFF, 0x01); // FF /1
7108   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7109   ins_pipe(ialu_reg);
7110 %}
7111 
7112 // XXX why does that use AddL
7113 instruct decL_mem(memory dst, immL_M1 src, rFlagsReg cr)
7114 %{
7115   predicate(UseIncDec);
7116   match(Set dst (StoreL dst (AddL (LoadL dst) src)));
7117   effect(KILL cr);
7118 
7119   ins_cost(125); // XXX
7120   format %{ "decq    $dst\t# long" %}
7121   opcode(0xFF); /* Opcode FF /1 */
7122   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(0x01, dst));
7123   ins_pipe(ialu_mem_imm);
7124 %}
7125 
7126 instruct leaL_rReg_immL(rRegL dst, rRegL src0, immL32 src1)
7127 %{
7128   match(Set dst (AddL src0 src1));
7129 
7130   ins_cost(110);
7131   format %{ "leaq    $dst, [$src0 + $src1]\t# long" %}
7132   opcode(0x8D); /* 0x8D /r */
7133   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1)); // XXX
7134   ins_pipe(ialu_reg_reg);
7135 %}
7136 
7137 instruct addP_rReg(rRegP dst, rRegL src, rFlagsReg cr)
7138 %{
7139   match(Set dst (AddP dst src));
7140   effect(KILL cr);
7141 
7142   format %{ "addq    $dst, $src\t# ptr" %}
7143   opcode(0x03);
7144   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7145   ins_pipe(ialu_reg_reg);
7146 %}
7147 
7148 instruct addP_rReg_imm(rRegP dst, immL32 src, rFlagsReg cr)
7149 %{
7150   match(Set dst (AddP dst src));
7151   effect(KILL cr);
7152 
7153   format %{ "addq    $dst, $src\t# ptr" %}
7154   opcode(0x81, 0x00); /* /0 id */
7155   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7156   ins_pipe( ialu_reg );
7157 %}
7158 
7159 // XXX addP mem ops ????
7160 
7161 instruct leaP_rReg_imm(rRegP dst, rRegP src0, immL32 src1)
7162 %{
7163   match(Set dst (AddP src0 src1));
7164 
7165   ins_cost(110);
7166   format %{ "leaq    $dst, [$src0 + $src1]\t# ptr" %}
7167   opcode(0x8D); /* 0x8D /r */
7168   ins_encode(REX_reg_reg_wide(dst, src0), OpcP, reg_lea(dst, src0, src1));// XXX
7169   ins_pipe(ialu_reg_reg);
7170 %}
7171 
7172 instruct checkCastPP(rRegP dst)
7173 %{
7174   match(Set dst (CheckCastPP dst));
7175 
7176   size(0);
7177   format %{ "# checkcastPP of $dst" %}
7178   ins_encode(/* empty encoding */);
7179   ins_pipe(empty);
7180 %}
7181 
7182 instruct castPP(rRegP dst)
7183 %{
7184   match(Set dst (CastPP dst));
7185 
7186   size(0);
7187   format %{ "# castPP of $dst" %}
7188   ins_encode(/* empty encoding */);
7189   ins_pipe(empty);
7190 %}
7191 
7192 instruct castII(rRegI dst)
7193 %{
7194   match(Set dst (CastII dst));
7195 
7196   size(0);
7197   format %{ "# castII of $dst" %}
7198   ins_encode(/* empty encoding */);
7199   ins_cost(0);
7200   ins_pipe(empty);
7201 %}
7202 
7203 // LoadP-locked same as a regular LoadP when used with compare-swap
7204 instruct loadPLocked(rRegP dst, memory mem)
7205 %{
7206   match(Set dst (LoadPLocked mem));
7207 
7208   ins_cost(125); // XXX
7209   format %{ "movq    $dst, $mem\t# ptr locked" %}
7210   opcode(0x8B);
7211   ins_encode(REX_reg_mem_wide(dst, mem), OpcP, reg_mem(dst, mem));
7212   ins_pipe(ialu_reg_mem); // XXX
7213 %}
7214 
7215 // Conditional-store of the updated heap-top.
7216 // Used during allocation of the shared heap.
7217 // Sets flags (EQ) on success.  Implemented with a CMPXCHG on Intel.
7218 
7219 instruct storePConditional(memory heap_top_ptr,
7220                            rax_RegP oldval, rRegP newval,
7221                            rFlagsReg cr)
7222 %{
7223   match(Set cr (StorePConditional heap_top_ptr (Binary oldval newval)));
7224 
7225   format %{ "cmpxchgq $heap_top_ptr, $newval\t# (ptr) "
7226             "If rax == $heap_top_ptr then store $newval into $heap_top_ptr" %}
7227   opcode(0x0F, 0xB1);
7228   ins_encode(lock_prefix,
7229              REX_reg_mem_wide(newval, heap_top_ptr),
7230              OpcP, OpcS,
7231              reg_mem(newval, heap_top_ptr));
7232   ins_pipe(pipe_cmpxchg);
7233 %}
7234 
7235 // Conditional-store of an int value.
7236 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7237 instruct storeIConditional(memory mem, rax_RegI oldval, rRegI newval, rFlagsReg cr)
7238 %{
7239   match(Set cr (StoreIConditional mem (Binary oldval newval)));
7240   effect(KILL oldval);
7241 
7242   format %{ "cmpxchgl $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7243   opcode(0x0F, 0xB1);
7244   ins_encode(lock_prefix,
7245              REX_reg_mem(newval, mem),
7246              OpcP, OpcS,
7247              reg_mem(newval, mem));
7248   ins_pipe(pipe_cmpxchg);
7249 %}
7250 
7251 // Conditional-store of a long value.
7252 // ZF flag is set on success, reset otherwise.  Implemented with a CMPXCHG.
7253 instruct storeLConditional(memory mem, rax_RegL oldval, rRegL newval, rFlagsReg cr)
7254 %{
7255   match(Set cr (StoreLConditional mem (Binary oldval newval)));
7256   effect(KILL oldval);
7257 
7258   format %{ "cmpxchgq $mem, $newval\t# If rax == $mem then store $newval into $mem" %}
7259   opcode(0x0F, 0xB1);
7260   ins_encode(lock_prefix,
7261              REX_reg_mem_wide(newval, mem),
7262              OpcP, OpcS,
7263              reg_mem(newval, mem));
7264   ins_pipe(pipe_cmpxchg);
7265 %}
7266 
7267 
7268 // XXX No flag versions for CompareAndSwap{P,I,L} because matcher can't match them
7269 instruct compareAndSwapP(rRegI res,
7270                          memory mem_ptr,
7271                          rax_RegP oldval, rRegP newval,
7272                          rFlagsReg cr)
7273 %{
7274   predicate(VM_Version::supports_cx8());
7275   match(Set res (CompareAndSwapP mem_ptr (Binary oldval newval)));
7276   effect(KILL cr, KILL oldval);
7277 
7278   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7279             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7280             "sete    $res\n\t"
7281             "movzbl  $res, $res" %}
7282   opcode(0x0F, 0xB1);
7283   ins_encode(lock_prefix,
7284              REX_reg_mem_wide(newval, mem_ptr),
7285              OpcP, OpcS,
7286              reg_mem(newval, mem_ptr),
7287              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7288              REX_reg_breg(res, res), // movzbl
7289              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7290   ins_pipe( pipe_cmpxchg );
7291 %}
7292 
7293 instruct compareAndSwapL(rRegI res,
7294                          memory mem_ptr,
7295                          rax_RegL oldval, rRegL newval,
7296                          rFlagsReg cr)
7297 %{
7298   predicate(VM_Version::supports_cx8());
7299   match(Set res (CompareAndSwapL mem_ptr (Binary oldval newval)));
7300   effect(KILL cr, KILL oldval);
7301 
7302   format %{ "cmpxchgq $mem_ptr,$newval\t# "
7303             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7304             "sete    $res\n\t"
7305             "movzbl  $res, $res" %}
7306   opcode(0x0F, 0xB1);
7307   ins_encode(lock_prefix,
7308              REX_reg_mem_wide(newval, mem_ptr),
7309              OpcP, OpcS,
7310              reg_mem(newval, mem_ptr),
7311              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7312              REX_reg_breg(res, res), // movzbl
7313              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7314   ins_pipe( pipe_cmpxchg );
7315 %}
7316 
7317 instruct compareAndSwapI(rRegI res,
7318                          memory mem_ptr,
7319                          rax_RegI oldval, rRegI newval,
7320                          rFlagsReg cr)
7321 %{
7322   match(Set res (CompareAndSwapI mem_ptr (Binary oldval newval)));
7323   effect(KILL cr, KILL oldval);
7324 
7325   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7326             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7327             "sete    $res\n\t"
7328             "movzbl  $res, $res" %}
7329   opcode(0x0F, 0xB1);
7330   ins_encode(lock_prefix,
7331              REX_reg_mem(newval, mem_ptr),
7332              OpcP, OpcS,
7333              reg_mem(newval, mem_ptr),
7334              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7335              REX_reg_breg(res, res), // movzbl
7336              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7337   ins_pipe( pipe_cmpxchg );
7338 %}
7339 
7340 
7341 instruct compareAndSwapN(rRegI res,
7342                           memory mem_ptr,
7343                           rax_RegN oldval, rRegN newval,
7344                           rFlagsReg cr) %{
7345   match(Set res (CompareAndSwapN mem_ptr (Binary oldval newval)));
7346   effect(KILL cr, KILL oldval);
7347 
7348   format %{ "cmpxchgl $mem_ptr,$newval\t# "
7349             "If rax == $mem_ptr then store $newval into $mem_ptr\n\t"
7350             "sete    $res\n\t"
7351             "movzbl  $res, $res" %}
7352   opcode(0x0F, 0xB1);
7353   ins_encode(lock_prefix,
7354              REX_reg_mem(newval, mem_ptr),
7355              OpcP, OpcS,
7356              reg_mem(newval, mem_ptr),
7357              REX_breg(res), Opcode(0x0F), Opcode(0x94), reg(res), // sete
7358              REX_reg_breg(res, res), // movzbl
7359              Opcode(0xF), Opcode(0xB6), reg_reg(res, res));
7360   ins_pipe( pipe_cmpxchg );
7361 %}
7362 
7363 instruct xaddI_no_res( memory mem, Universe dummy, immI add, rFlagsReg cr) %{
7364   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7365   match(Set dummy (GetAndAddI mem add));
7366   effect(KILL cr);
7367   format %{ "ADDL  [$mem],$add" %}
7368   ins_encode %{
7369     if (os::is_MP()) { __ lock(); }
7370     __ addl($mem$$Address, $add$$constant);
7371   %}
7372   ins_pipe( pipe_cmpxchg );
7373 %}
7374 
7375 instruct xaddI( memory mem, rRegI newval, rFlagsReg cr) %{
7376   match(Set newval (GetAndAddI mem newval));
7377   effect(KILL cr);
7378   format %{ "XADDL  [$mem],$newval" %}
7379   ins_encode %{
7380     if (os::is_MP()) { __ lock(); }
7381     __ xaddl($mem$$Address, $newval$$Register);
7382   %}
7383   ins_pipe( pipe_cmpxchg );
7384 %}
7385 
7386 instruct xaddL_no_res( memory mem, Universe dummy, immL32 add, rFlagsReg cr) %{
7387   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
7388   match(Set dummy (GetAndAddL mem add));
7389   effect(KILL cr);
7390   format %{ "ADDQ  [$mem],$add" %}
7391   ins_encode %{
7392     if (os::is_MP()) { __ lock(); }
7393     __ addq($mem$$Address, $add$$constant);
7394   %}
7395   ins_pipe( pipe_cmpxchg );
7396 %}
7397 
7398 instruct xaddL( memory mem, rRegL newval, rFlagsReg cr) %{
7399   match(Set newval (GetAndAddL mem newval));
7400   effect(KILL cr);
7401   format %{ "XADDQ  [$mem],$newval" %}
7402   ins_encode %{
7403     if (os::is_MP()) { __ lock(); }
7404     __ xaddq($mem$$Address, $newval$$Register);
7405   %}
7406   ins_pipe( pipe_cmpxchg );
7407 %}
7408 
7409 instruct xchgI( memory mem, rRegI newval) %{
7410   match(Set newval (GetAndSetI mem newval));
7411   format %{ "XCHGL  $newval,[$mem]" %}
7412   ins_encode %{
7413     __ xchgl($newval$$Register, $mem$$Address);
7414   %}
7415   ins_pipe( pipe_cmpxchg );
7416 %}
7417 
7418 instruct xchgL( memory mem, rRegL newval) %{
7419   match(Set newval (GetAndSetL mem newval));
7420   format %{ "XCHGL  $newval,[$mem]" %}
7421   ins_encode %{
7422     __ xchgq($newval$$Register, $mem$$Address);
7423   %}
7424   ins_pipe( pipe_cmpxchg );
7425 %}
7426 
7427 instruct xchgP( memory mem, rRegP newval) %{
7428   match(Set newval (GetAndSetP mem newval));
7429   format %{ "XCHGQ  $newval,[$mem]" %}
7430   ins_encode %{
7431     __ xchgq($newval$$Register, $mem$$Address);
7432   %}
7433   ins_pipe( pipe_cmpxchg );
7434 %}
7435 
7436 instruct xchgN( memory mem, rRegN newval) %{
7437   match(Set newval (GetAndSetN mem newval));
7438   format %{ "XCHGL  $newval,$mem]" %}
7439   ins_encode %{
7440     __ xchgl($newval$$Register, $mem$$Address);
7441   %}
7442   ins_pipe( pipe_cmpxchg );
7443 %}
7444 
7445 //----------Subtraction Instructions-------------------------------------------
7446 
7447 // Integer Subtraction Instructions
7448 instruct subI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7449 %{
7450   match(Set dst (SubI dst src));
7451   effect(KILL cr);
7452 
7453   format %{ "subl    $dst, $src\t# int" %}
7454   opcode(0x2B);
7455   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
7456   ins_pipe(ialu_reg_reg);
7457 %}
7458 
7459 instruct subI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
7460 %{
7461   match(Set dst (SubI dst src));
7462   effect(KILL cr);
7463 
7464   format %{ "subl    $dst, $src\t# int" %}
7465   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7466   ins_encode(OpcSErm(dst, src), Con8or32(src));
7467   ins_pipe(ialu_reg);
7468 %}
7469 
7470 instruct subI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
7471 %{
7472   match(Set dst (SubI dst (LoadI src)));
7473   effect(KILL cr);
7474 
7475   ins_cost(125);
7476   format %{ "subl    $dst, $src\t# int" %}
7477   opcode(0x2B);
7478   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
7479   ins_pipe(ialu_reg_mem);
7480 %}
7481 
7482 instruct subI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
7483 %{
7484   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7485   effect(KILL cr);
7486 
7487   ins_cost(150);
7488   format %{ "subl    $dst, $src\t# int" %}
7489   opcode(0x29); /* Opcode 29 /r */
7490   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
7491   ins_pipe(ialu_mem_reg);
7492 %}
7493 
7494 instruct subI_mem_imm(memory dst, immI src, rFlagsReg cr)
7495 %{
7496   match(Set dst (StoreI dst (SubI (LoadI dst) src)));
7497   effect(KILL cr);
7498 
7499   ins_cost(125); // XXX
7500   format %{ "subl    $dst, $src\t# int" %}
7501   opcode(0x81); /* Opcode 81 /5 id */
7502   ins_encode(REX_mem(dst), OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7503   ins_pipe(ialu_mem_imm);
7504 %}
7505 
7506 instruct subL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7507 %{
7508   match(Set dst (SubL dst src));
7509   effect(KILL cr);
7510 
7511   format %{ "subq    $dst, $src\t# long" %}
7512   opcode(0x2B);
7513   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7514   ins_pipe(ialu_reg_reg);
7515 %}
7516 
7517 instruct subL_rReg_imm(rRegI dst, immL32 src, rFlagsReg cr)
7518 %{
7519   match(Set dst (SubL dst src));
7520   effect(KILL cr);
7521 
7522   format %{ "subq    $dst, $src\t# long" %}
7523   opcode(0x81, 0x05);  /* Opcode 81 /5 */
7524   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
7525   ins_pipe(ialu_reg);
7526 %}
7527 
7528 instruct subL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
7529 %{
7530   match(Set dst (SubL dst (LoadL src)));
7531   effect(KILL cr);
7532 
7533   ins_cost(125);
7534   format %{ "subq    $dst, $src\t# long" %}
7535   opcode(0x2B);
7536   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
7537   ins_pipe(ialu_reg_mem);
7538 %}
7539 
7540 instruct subL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
7541 %{
7542   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7543   effect(KILL cr);
7544 
7545   ins_cost(150);
7546   format %{ "subq    $dst, $src\t# long" %}
7547   opcode(0x29); /* Opcode 29 /r */
7548   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
7549   ins_pipe(ialu_mem_reg);
7550 %}
7551 
7552 instruct subL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
7553 %{
7554   match(Set dst (StoreL dst (SubL (LoadL dst) src)));
7555   effect(KILL cr);
7556 
7557   ins_cost(125); // XXX
7558   format %{ "subq    $dst, $src\t# long" %}
7559   opcode(0x81); /* Opcode 81 /5 id */
7560   ins_encode(REX_mem_wide(dst),
7561              OpcSE(src), RM_opc_mem(0x05, dst), Con8or32(src));
7562   ins_pipe(ialu_mem_imm);
7563 %}
7564 
7565 // Subtract from a pointer
7566 // XXX hmpf???
7567 instruct subP_rReg(rRegP dst, rRegI src, immI0 zero, rFlagsReg cr)
7568 %{
7569   match(Set dst (AddP dst (SubI zero src)));
7570   effect(KILL cr);
7571 
7572   format %{ "subq    $dst, $src\t# ptr - int" %}
7573   opcode(0x2B);
7574   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
7575   ins_pipe(ialu_reg_reg);
7576 %}
7577 
7578 instruct negI_rReg(rRegI dst, immI0 zero, rFlagsReg cr)
7579 %{
7580   match(Set dst (SubI zero dst));
7581   effect(KILL cr);
7582 
7583   format %{ "negl    $dst\t# int" %}
7584   opcode(0xF7, 0x03);  // Opcode F7 /3
7585   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7586   ins_pipe(ialu_reg);
7587 %}
7588 
7589 instruct negI_mem(memory dst, immI0 zero, rFlagsReg cr)
7590 %{
7591   match(Set dst (StoreI dst (SubI zero (LoadI dst))));
7592   effect(KILL cr);
7593 
7594   format %{ "negl    $dst\t# int" %}
7595   opcode(0xF7, 0x03);  // Opcode F7 /3
7596   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7597   ins_pipe(ialu_reg);
7598 %}
7599 
7600 instruct negL_rReg(rRegL dst, immL0 zero, rFlagsReg cr)
7601 %{
7602   match(Set dst (SubL zero dst));
7603   effect(KILL cr);
7604 
7605   format %{ "negq    $dst\t# long" %}
7606   opcode(0xF7, 0x03);  // Opcode F7 /3
7607   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
7608   ins_pipe(ialu_reg);
7609 %}
7610 
7611 instruct negL_mem(memory dst, immL0 zero, rFlagsReg cr)
7612 %{
7613   match(Set dst (StoreL dst (SubL zero (LoadL dst))));
7614   effect(KILL cr);
7615 
7616   format %{ "negq    $dst\t# long" %}
7617   opcode(0xF7, 0x03);  // Opcode F7 /3
7618   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
7619   ins_pipe(ialu_reg);
7620 %}
7621 
7622 //----------Multiplication/Division Instructions-------------------------------
7623 // Integer Multiplication Instructions
7624 // Multiply Register
7625 
7626 instruct mulI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
7627 %{
7628   match(Set dst (MulI dst src));
7629   effect(KILL cr);
7630 
7631   ins_cost(300);
7632   format %{ "imull   $dst, $src\t# int" %}
7633   opcode(0x0F, 0xAF);
7634   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
7635   ins_pipe(ialu_reg_reg_alu0);
7636 %}
7637 
7638 instruct mulI_rReg_imm(rRegI dst, rRegI src, immI imm, rFlagsReg cr)
7639 %{
7640   match(Set dst (MulI src imm));
7641   effect(KILL cr);
7642 
7643   ins_cost(300);
7644   format %{ "imull   $dst, $src, $imm\t# int" %}
7645   opcode(0x69); /* 69 /r id */
7646   ins_encode(REX_reg_reg(dst, src),
7647              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7648   ins_pipe(ialu_reg_reg_alu0);
7649 %}
7650 
7651 instruct mulI_mem(rRegI dst, memory src, rFlagsReg cr)
7652 %{
7653   match(Set dst (MulI dst (LoadI src)));
7654   effect(KILL cr);
7655 
7656   ins_cost(350);
7657   format %{ "imull   $dst, $src\t# int" %}
7658   opcode(0x0F, 0xAF);
7659   ins_encode(REX_reg_mem(dst, src), OpcP, OpcS, reg_mem(dst, src));
7660   ins_pipe(ialu_reg_mem_alu0);
7661 %}
7662 
7663 instruct mulI_mem_imm(rRegI dst, memory src, immI imm, rFlagsReg cr)
7664 %{
7665   match(Set dst (MulI (LoadI src) imm));
7666   effect(KILL cr);
7667 
7668   ins_cost(300);
7669   format %{ "imull   $dst, $src, $imm\t# int" %}
7670   opcode(0x69); /* 69 /r id */
7671   ins_encode(REX_reg_mem(dst, src),
7672              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7673   ins_pipe(ialu_reg_mem_alu0);
7674 %}
7675 
7676 instruct mulL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
7677 %{
7678   match(Set dst (MulL dst src));
7679   effect(KILL cr);
7680 
7681   ins_cost(300);
7682   format %{ "imulq   $dst, $src\t# long" %}
7683   opcode(0x0F, 0xAF);
7684   ins_encode(REX_reg_reg_wide(dst, src), OpcP, OpcS, reg_reg(dst, src));
7685   ins_pipe(ialu_reg_reg_alu0);
7686 %}
7687 
7688 instruct mulL_rReg_imm(rRegL dst, rRegL src, immL32 imm, rFlagsReg cr)
7689 %{
7690   match(Set dst (MulL src imm));
7691   effect(KILL cr);
7692 
7693   ins_cost(300);
7694   format %{ "imulq   $dst, $src, $imm\t# long" %}
7695   opcode(0x69); /* 69 /r id */
7696   ins_encode(REX_reg_reg_wide(dst, src),
7697              OpcSE(imm), reg_reg(dst, src), Con8or32(imm));
7698   ins_pipe(ialu_reg_reg_alu0);
7699 %}
7700 
7701 instruct mulL_mem(rRegL dst, memory src, rFlagsReg cr)
7702 %{
7703   match(Set dst (MulL dst (LoadL src)));
7704   effect(KILL cr);
7705 
7706   ins_cost(350);
7707   format %{ "imulq   $dst, $src\t# long" %}
7708   opcode(0x0F, 0xAF);
7709   ins_encode(REX_reg_mem_wide(dst, src), OpcP, OpcS, reg_mem(dst, src));
7710   ins_pipe(ialu_reg_mem_alu0);
7711 %}
7712 
7713 instruct mulL_mem_imm(rRegL dst, memory src, immL32 imm, rFlagsReg cr)
7714 %{
7715   match(Set dst (MulL (LoadL src) imm));
7716   effect(KILL cr);
7717 
7718   ins_cost(300);
7719   format %{ "imulq   $dst, $src, $imm\t# long" %}
7720   opcode(0x69); /* 69 /r id */
7721   ins_encode(REX_reg_mem_wide(dst, src),
7722              OpcSE(imm), reg_mem(dst, src), Con8or32(imm));
7723   ins_pipe(ialu_reg_mem_alu0);
7724 %}
7725 
7726 instruct mulHiL_rReg(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7727 %{
7728   match(Set dst (MulHiL src rax));
7729   effect(USE_KILL rax, KILL cr);
7730 
7731   ins_cost(300);
7732   format %{ "imulq   RDX:RAX, RAX, $src\t# mulhi" %}
7733   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7734   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7735   ins_pipe(ialu_reg_reg_alu0);
7736 %}
7737 
7738 instruct divI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7739                    rFlagsReg cr)
7740 %{
7741   match(Set rax (DivI rax div));
7742   effect(KILL rdx, KILL cr);
7743 
7744   ins_cost(30*100+10*100); // XXX
7745   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7746             "jne,s   normal\n\t"
7747             "xorl    rdx, rdx\n\t"
7748             "cmpl    $div, -1\n\t"
7749             "je,s    done\n"
7750     "normal: cdql\n\t"
7751             "idivl   $div\n"
7752     "done:"        %}
7753   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7754   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7755   ins_pipe(ialu_reg_reg_alu0);
7756 %}
7757 
7758 instruct divL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7759                    rFlagsReg cr)
7760 %{
7761   match(Set rax (DivL rax div));
7762   effect(KILL rdx, KILL cr);
7763 
7764   ins_cost(30*100+10*100); // XXX
7765   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7766             "cmpq    rax, rdx\n\t"
7767             "jne,s   normal\n\t"
7768             "xorl    rdx, rdx\n\t"
7769             "cmpq    $div, -1\n\t"
7770             "je,s    done\n"
7771     "normal: cdqq\n\t"
7772             "idivq   $div\n"
7773     "done:"        %}
7774   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7775   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7776   ins_pipe(ialu_reg_reg_alu0);
7777 %}
7778 
7779 // Integer DIVMOD with Register, both quotient and mod results
7780 instruct divModI_rReg_divmod(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div,
7781                              rFlagsReg cr)
7782 %{
7783   match(DivModI rax div);
7784   effect(KILL cr);
7785 
7786   ins_cost(30*100+10*100); // XXX
7787   format %{ "cmpl    rax, 0x80000000\t# idiv\n\t"
7788             "jne,s   normal\n\t"
7789             "xorl    rdx, rdx\n\t"
7790             "cmpl    $div, -1\n\t"
7791             "je,s    done\n"
7792     "normal: cdql\n\t"
7793             "idivl   $div\n"
7794     "done:"        %}
7795   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7796   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7797   ins_pipe(pipe_slow);
7798 %}
7799 
7800 // Long DIVMOD with Register, both quotient and mod results
7801 instruct divModL_rReg_divmod(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div,
7802                              rFlagsReg cr)
7803 %{
7804   match(DivModL rax div);
7805   effect(KILL cr);
7806 
7807   ins_cost(30*100+10*100); // XXX
7808   format %{ "movq    rdx, 0x8000000000000000\t# ldiv\n\t"
7809             "cmpq    rax, rdx\n\t"
7810             "jne,s   normal\n\t"
7811             "xorl    rdx, rdx\n\t"
7812             "cmpq    $div, -1\n\t"
7813             "je,s    done\n"
7814     "normal: cdqq\n\t"
7815             "idivq   $div\n"
7816     "done:"        %}
7817   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7818   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7819   ins_pipe(pipe_slow);
7820 %}
7821 
7822 //----------- DivL-By-Constant-Expansions--------------------------------------
7823 // DivI cases are handled by the compiler
7824 
7825 // Magic constant, reciprocal of 10
7826 instruct loadConL_0x6666666666666667(rRegL dst)
7827 %{
7828   effect(DEF dst);
7829 
7830   format %{ "movq    $dst, #0x666666666666667\t# Used in div-by-10" %}
7831   ins_encode(load_immL(dst, 0x6666666666666667));
7832   ins_pipe(ialu_reg);
7833 %}
7834 
7835 instruct mul_hi(rdx_RegL dst, no_rax_RegL src, rax_RegL rax, rFlagsReg cr)
7836 %{
7837   effect(DEF dst, USE src, USE_KILL rax, KILL cr);
7838 
7839   format %{ "imulq   rdx:rax, rax, $src\t# Used in div-by-10" %}
7840   opcode(0xF7, 0x5); /* Opcode F7 /5 */
7841   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src));
7842   ins_pipe(ialu_reg_reg_alu0);
7843 %}
7844 
7845 instruct sarL_rReg_63(rRegL dst, rFlagsReg cr)
7846 %{
7847   effect(USE_DEF dst, KILL cr);
7848 
7849   format %{ "sarq    $dst, #63\t# Used in div-by-10" %}
7850   opcode(0xC1, 0x7); /* C1 /7 ib */
7851   ins_encode(reg_opc_imm_wide(dst, 0x3F));
7852   ins_pipe(ialu_reg);
7853 %}
7854 
7855 instruct sarL_rReg_2(rRegL dst, rFlagsReg cr)
7856 %{
7857   effect(USE_DEF dst, KILL cr);
7858 
7859   format %{ "sarq    $dst, #2\t# Used in div-by-10" %}
7860   opcode(0xC1, 0x7); /* C1 /7 ib */
7861   ins_encode(reg_opc_imm_wide(dst, 0x2));
7862   ins_pipe(ialu_reg);
7863 %}
7864 
7865 instruct divL_10(rdx_RegL dst, no_rax_RegL src, immL10 div)
7866 %{
7867   match(Set dst (DivL src div));
7868 
7869   ins_cost((5+8)*100);
7870   expand %{
7871     rax_RegL rax;                     // Killed temp
7872     rFlagsReg cr;                     // Killed
7873     loadConL_0x6666666666666667(rax); // movq  rax, 0x6666666666666667
7874     mul_hi(dst, src, rax, cr);        // mulq  rdx:rax &lt;= rax * $src
7875     sarL_rReg_63(src, cr);            // sarq  src, 63
7876     sarL_rReg_2(dst, cr);             // sarq  rdx, 2
7877     subL_rReg(dst, src, cr);          // subl  rdx, src
7878   %}
7879 %}
7880 
7881 //-----------------------------------------------------------------------------
7882 
7883 instruct modI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div,
7884                    rFlagsReg cr)
7885 %{
7886   match(Set rdx (ModI rax div));
7887   effect(KILL rax, KILL cr);
7888 
7889   ins_cost(300); // XXX
7890   format %{ "cmpl    rax, 0x80000000\t# irem\n\t"
7891             "jne,s   normal\n\t"
7892             "xorl    rdx, rdx\n\t"
7893             "cmpl    $div, -1\n\t"
7894             "je,s    done\n"
7895     "normal: cdql\n\t"
7896             "idivl   $div\n"
7897     "done:"        %}
7898   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7899   ins_encode(cdql_enc(div), REX_reg(div), OpcP, reg_opc(div));
7900   ins_pipe(ialu_reg_reg_alu0);
7901 %}
7902 
7903 instruct modL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div,
7904                    rFlagsReg cr)
7905 %{
7906   match(Set rdx (ModL rax div));
7907   effect(KILL rax, KILL cr);
7908 
7909   ins_cost(300); // XXX
7910   format %{ "movq    rdx, 0x8000000000000000\t# lrem\n\t"
7911             "cmpq    rax, rdx\n\t"
7912             "jne,s   normal\n\t"
7913             "xorl    rdx, rdx\n\t"
7914             "cmpq    $div, -1\n\t"
7915             "je,s    done\n"
7916     "normal: cdqq\n\t"
7917             "idivq   $div\n"
7918     "done:"        %}
7919   opcode(0xF7, 0x7);  /* Opcode F7 /7 */
7920   ins_encode(cdqq_enc(div), REX_reg_wide(div), OpcP, reg_opc(div));
7921   ins_pipe(ialu_reg_reg_alu0);
7922 %}
7923 
7924 // Integer Shift Instructions
7925 // Shift Left by one
7926 instruct salI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7927 %{
7928   match(Set dst (LShiftI dst shift));
7929   effect(KILL cr);
7930 
7931   format %{ "sall    $dst, $shift" %}
7932   opcode(0xD1, 0x4); /* D1 /4 */
7933   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7934   ins_pipe(ialu_reg);
7935 %}
7936 
7937 // Shift Left by one
7938 instruct salI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
7939 %{
7940   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7941   effect(KILL cr);
7942 
7943   format %{ "sall    $dst, $shift\t" %}
7944   opcode(0xD1, 0x4); /* D1 /4 */
7945   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7946   ins_pipe(ialu_mem_imm);
7947 %}
7948 
7949 // Shift Left by 8-bit immediate
7950 instruct salI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
7951 %{
7952   match(Set dst (LShiftI dst shift));
7953   effect(KILL cr);
7954 
7955   format %{ "sall    $dst, $shift" %}
7956   opcode(0xC1, 0x4); /* C1 /4 ib */
7957   ins_encode(reg_opc_imm(dst, shift));
7958   ins_pipe(ialu_reg);
7959 %}
7960 
7961 // Shift Left by 8-bit immediate
7962 instruct salI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
7963 %{
7964   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7965   effect(KILL cr);
7966 
7967   format %{ "sall    $dst, $shift" %}
7968   opcode(0xC1, 0x4); /* C1 /4 ib */
7969   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
7970   ins_pipe(ialu_mem_imm);
7971 %}
7972 
7973 // Shift Left by variable
7974 instruct salI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
7975 %{
7976   match(Set dst (LShiftI dst shift));
7977   effect(KILL cr);
7978 
7979   format %{ "sall    $dst, $shift" %}
7980   opcode(0xD3, 0x4); /* D3 /4 */
7981   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
7982   ins_pipe(ialu_reg_reg);
7983 %}
7984 
7985 // Shift Left by variable
7986 instruct salI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
7987 %{
7988   match(Set dst (StoreI dst (LShiftI (LoadI dst) shift)));
7989   effect(KILL cr);
7990 
7991   format %{ "sall    $dst, $shift" %}
7992   opcode(0xD3, 0x4); /* D3 /4 */
7993   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
7994   ins_pipe(ialu_mem_reg);
7995 %}
7996 
7997 // Arithmetic shift right by one
7998 instruct sarI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
7999 %{
8000   match(Set dst (RShiftI dst shift));
8001   effect(KILL cr);
8002 
8003   format %{ "sarl    $dst, $shift" %}
8004   opcode(0xD1, 0x7); /* D1 /7 */
8005   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8006   ins_pipe(ialu_reg);
8007 %}
8008 
8009 // Arithmetic shift right by one
8010 instruct sarI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8011 %{
8012   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8013   effect(KILL cr);
8014 
8015   format %{ "sarl    $dst, $shift" %}
8016   opcode(0xD1, 0x7); /* D1 /7 */
8017   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8018   ins_pipe(ialu_mem_imm);
8019 %}
8020 
8021 // Arithmetic Shift Right by 8-bit immediate
8022 instruct sarI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8023 %{
8024   match(Set dst (RShiftI dst shift));
8025   effect(KILL cr);
8026 
8027   format %{ "sarl    $dst, $shift" %}
8028   opcode(0xC1, 0x7); /* C1 /7 ib */
8029   ins_encode(reg_opc_imm(dst, shift));
8030   ins_pipe(ialu_mem_imm);
8031 %}
8032 
8033 // Arithmetic Shift Right by 8-bit immediate
8034 instruct sarI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8035 %{
8036   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8037   effect(KILL cr);
8038 
8039   format %{ "sarl    $dst, $shift" %}
8040   opcode(0xC1, 0x7); /* C1 /7 ib */
8041   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8042   ins_pipe(ialu_mem_imm);
8043 %}
8044 
8045 // Arithmetic Shift Right by variable
8046 instruct sarI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8047 %{
8048   match(Set dst (RShiftI dst shift));
8049   effect(KILL cr);
8050 
8051   format %{ "sarl    $dst, $shift" %}
8052   opcode(0xD3, 0x7); /* D3 /7 */
8053   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8054   ins_pipe(ialu_reg_reg);
8055 %}
8056 
8057 // Arithmetic Shift Right by variable
8058 instruct sarI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8059 %{
8060   match(Set dst (StoreI dst (RShiftI (LoadI dst) shift)));
8061   effect(KILL cr);
8062 
8063   format %{ "sarl    $dst, $shift" %}
8064   opcode(0xD3, 0x7); /* D3 /7 */
8065   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8066   ins_pipe(ialu_mem_reg);
8067 %}
8068 
8069 // Logical shift right by one
8070 instruct shrI_rReg_1(rRegI dst, immI1 shift, rFlagsReg cr)
8071 %{
8072   match(Set dst (URShiftI dst shift));
8073   effect(KILL cr);
8074 
8075   format %{ "shrl    $dst, $shift" %}
8076   opcode(0xD1, 0x5); /* D1 /5 */
8077   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8078   ins_pipe(ialu_reg);
8079 %}
8080 
8081 // Logical shift right by one
8082 instruct shrI_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8083 %{
8084   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8085   effect(KILL cr);
8086 
8087   format %{ "shrl    $dst, $shift" %}
8088   opcode(0xD1, 0x5); /* D1 /5 */
8089   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8090   ins_pipe(ialu_mem_imm);
8091 %}
8092 
8093 // Logical Shift Right by 8-bit immediate
8094 instruct shrI_rReg_imm(rRegI dst, immI8 shift, rFlagsReg cr)
8095 %{
8096   match(Set dst (URShiftI dst shift));
8097   effect(KILL cr);
8098 
8099   format %{ "shrl    $dst, $shift" %}
8100   opcode(0xC1, 0x5); /* C1 /5 ib */
8101   ins_encode(reg_opc_imm(dst, shift));
8102   ins_pipe(ialu_reg);
8103 %}
8104 
8105 // Logical Shift Right by 8-bit immediate
8106 instruct shrI_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8107 %{
8108   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8109   effect(KILL cr);
8110 
8111   format %{ "shrl    $dst, $shift" %}
8112   opcode(0xC1, 0x5); /* C1 /5 ib */
8113   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst), Con8or32(shift));
8114   ins_pipe(ialu_mem_imm);
8115 %}
8116 
8117 // Logical Shift Right by variable
8118 instruct shrI_rReg_CL(rRegI dst, rcx_RegI shift, rFlagsReg cr)
8119 %{
8120   match(Set dst (URShiftI dst shift));
8121   effect(KILL cr);
8122 
8123   format %{ "shrl    $dst, $shift" %}
8124   opcode(0xD3, 0x5); /* D3 /5 */
8125   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8126   ins_pipe(ialu_reg_reg);
8127 %}
8128 
8129 // Logical Shift Right by variable
8130 instruct shrI_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8131 %{
8132   match(Set dst (StoreI dst (URShiftI (LoadI dst) shift)));
8133   effect(KILL cr);
8134 
8135   format %{ "shrl    $dst, $shift" %}
8136   opcode(0xD3, 0x5); /* D3 /5 */
8137   ins_encode(REX_mem(dst), OpcP, RM_opc_mem(secondary, dst));
8138   ins_pipe(ialu_mem_reg);
8139 %}
8140 
8141 // Long Shift Instructions
8142 // Shift Left by one
8143 instruct salL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8144 %{
8145   match(Set dst (LShiftL dst shift));
8146   effect(KILL cr);
8147 
8148   format %{ "salq    $dst, $shift" %}
8149   opcode(0xD1, 0x4); /* D1 /4 */
8150   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8151   ins_pipe(ialu_reg);
8152 %}
8153 
8154 // Shift Left by one
8155 instruct salL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8156 %{
8157   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8158   effect(KILL cr);
8159 
8160   format %{ "salq    $dst, $shift" %}
8161   opcode(0xD1, 0x4); /* D1 /4 */
8162   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8163   ins_pipe(ialu_mem_imm);
8164 %}
8165 
8166 // Shift Left by 8-bit immediate
8167 instruct salL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8168 %{
8169   match(Set dst (LShiftL dst shift));
8170   effect(KILL cr);
8171 
8172   format %{ "salq    $dst, $shift" %}
8173   opcode(0xC1, 0x4); /* C1 /4 ib */
8174   ins_encode(reg_opc_imm_wide(dst, shift));
8175   ins_pipe(ialu_reg);
8176 %}
8177 
8178 // Shift Left by 8-bit immediate
8179 instruct salL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8180 %{
8181   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8182   effect(KILL cr);
8183 
8184   format %{ "salq    $dst, $shift" %}
8185   opcode(0xC1, 0x4); /* C1 /4 ib */
8186   ins_encode(REX_mem_wide(dst), OpcP,
8187              RM_opc_mem(secondary, dst), Con8or32(shift));
8188   ins_pipe(ialu_mem_imm);
8189 %}
8190 
8191 // Shift Left by variable
8192 instruct salL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8193 %{
8194   match(Set dst (LShiftL dst shift));
8195   effect(KILL cr);
8196 
8197   format %{ "salq    $dst, $shift" %}
8198   opcode(0xD3, 0x4); /* D3 /4 */
8199   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8200   ins_pipe(ialu_reg_reg);
8201 %}
8202 
8203 // Shift Left by variable
8204 instruct salL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8205 %{
8206   match(Set dst (StoreL dst (LShiftL (LoadL dst) shift)));
8207   effect(KILL cr);
8208 
8209   format %{ "salq    $dst, $shift" %}
8210   opcode(0xD3, 0x4); /* D3 /4 */
8211   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8212   ins_pipe(ialu_mem_reg);
8213 %}
8214 
8215 // Arithmetic shift right by one
8216 instruct sarL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8217 %{
8218   match(Set dst (RShiftL dst shift));
8219   effect(KILL cr);
8220 
8221   format %{ "sarq    $dst, $shift" %}
8222   opcode(0xD1, 0x7); /* D1 /7 */
8223   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8224   ins_pipe(ialu_reg);
8225 %}
8226 
8227 // Arithmetic shift right by one
8228 instruct sarL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8229 %{
8230   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8231   effect(KILL cr);
8232 
8233   format %{ "sarq    $dst, $shift" %}
8234   opcode(0xD1, 0x7); /* D1 /7 */
8235   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8236   ins_pipe(ialu_mem_imm);
8237 %}
8238 
8239 // Arithmetic Shift Right by 8-bit immediate
8240 instruct sarL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8241 %{
8242   match(Set dst (RShiftL dst shift));
8243   effect(KILL cr);
8244 
8245   format %{ "sarq    $dst, $shift" %}
8246   opcode(0xC1, 0x7); /* C1 /7 ib */
8247   ins_encode(reg_opc_imm_wide(dst, shift));
8248   ins_pipe(ialu_mem_imm);
8249 %}
8250 
8251 // Arithmetic Shift Right by 8-bit immediate
8252 instruct sarL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8253 %{
8254   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8255   effect(KILL cr);
8256 
8257   format %{ "sarq    $dst, $shift" %}
8258   opcode(0xC1, 0x7); /* C1 /7 ib */
8259   ins_encode(REX_mem_wide(dst), OpcP,
8260              RM_opc_mem(secondary, dst), Con8or32(shift));
8261   ins_pipe(ialu_mem_imm);
8262 %}
8263 
8264 // Arithmetic Shift Right by variable
8265 instruct sarL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8266 %{
8267   match(Set dst (RShiftL dst shift));
8268   effect(KILL cr);
8269 
8270   format %{ "sarq    $dst, $shift" %}
8271   opcode(0xD3, 0x7); /* D3 /7 */
8272   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8273   ins_pipe(ialu_reg_reg);
8274 %}
8275 
8276 // Arithmetic Shift Right by variable
8277 instruct sarL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8278 %{
8279   match(Set dst (StoreL dst (RShiftL (LoadL dst) shift)));
8280   effect(KILL cr);
8281 
8282   format %{ "sarq    $dst, $shift" %}
8283   opcode(0xD3, 0x7); /* D3 /7 */
8284   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8285   ins_pipe(ialu_mem_reg);
8286 %}
8287 
8288 // Logical shift right by one
8289 instruct shrL_rReg_1(rRegL dst, immI1 shift, rFlagsReg cr)
8290 %{
8291   match(Set dst (URShiftL dst shift));
8292   effect(KILL cr);
8293 
8294   format %{ "shrq    $dst, $shift" %}
8295   opcode(0xD1, 0x5); /* D1 /5 */
8296   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst ));
8297   ins_pipe(ialu_reg);
8298 %}
8299 
8300 // Logical shift right by one
8301 instruct shrL_mem_1(memory dst, immI1 shift, rFlagsReg cr)
8302 %{
8303   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8304   effect(KILL cr);
8305 
8306   format %{ "shrq    $dst, $shift" %}
8307   opcode(0xD1, 0x5); /* D1 /5 */
8308   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8309   ins_pipe(ialu_mem_imm);
8310 %}
8311 
8312 // Logical Shift Right by 8-bit immediate
8313 instruct shrL_rReg_imm(rRegL dst, immI8 shift, rFlagsReg cr)
8314 %{
8315   match(Set dst (URShiftL dst shift));
8316   effect(KILL cr);
8317 
8318   format %{ "shrq    $dst, $shift" %}
8319   opcode(0xC1, 0x5); /* C1 /5 ib */
8320   ins_encode(reg_opc_imm_wide(dst, shift));
8321   ins_pipe(ialu_reg);
8322 %}
8323 
8324 
8325 // Logical Shift Right by 8-bit immediate
8326 instruct shrL_mem_imm(memory dst, immI8 shift, rFlagsReg cr)
8327 %{
8328   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8329   effect(KILL cr);
8330 
8331   format %{ "shrq    $dst, $shift" %}
8332   opcode(0xC1, 0x5); /* C1 /5 ib */
8333   ins_encode(REX_mem_wide(dst), OpcP,
8334              RM_opc_mem(secondary, dst), Con8or32(shift));
8335   ins_pipe(ialu_mem_imm);
8336 %}
8337 
8338 // Logical Shift Right by variable
8339 instruct shrL_rReg_CL(rRegL dst, rcx_RegI shift, rFlagsReg cr)
8340 %{
8341   match(Set dst (URShiftL dst shift));
8342   effect(KILL cr);
8343 
8344   format %{ "shrq    $dst, $shift" %}
8345   opcode(0xD3, 0x5); /* D3 /5 */
8346   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8347   ins_pipe(ialu_reg_reg);
8348 %}
8349 
8350 // Logical Shift Right by variable
8351 instruct shrL_mem_CL(memory dst, rcx_RegI shift, rFlagsReg cr)
8352 %{
8353   match(Set dst (StoreL dst (URShiftL (LoadL dst) shift)));
8354   effect(KILL cr);
8355 
8356   format %{ "shrq    $dst, $shift" %}
8357   opcode(0xD3, 0x5); /* D3 /5 */
8358   ins_encode(REX_mem_wide(dst), OpcP, RM_opc_mem(secondary, dst));
8359   ins_pipe(ialu_mem_reg);
8360 %}
8361 
8362 // Logical Shift Right by 24, followed by Arithmetic Shift Left by 24.
8363 // This idiom is used by the compiler for the i2b bytecode.
8364 instruct i2b(rRegI dst, rRegI src, immI_24 twentyfour)
8365 %{
8366   match(Set dst (RShiftI (LShiftI src twentyfour) twentyfour));
8367 
8368   format %{ "movsbl  $dst, $src\t# i2b" %}
8369   opcode(0x0F, 0xBE);
8370   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8371   ins_pipe(ialu_reg_reg);
8372 %}
8373 
8374 // Logical Shift Right by 16, followed by Arithmetic Shift Left by 16.
8375 // This idiom is used by the compiler the i2s bytecode.
8376 instruct i2s(rRegI dst, rRegI src, immI_16 sixteen)
8377 %{
8378   match(Set dst (RShiftI (LShiftI src sixteen) sixteen));
8379 
8380   format %{ "movswl  $dst, $src\t# i2s" %}
8381   opcode(0x0F, 0xBF);
8382   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8383   ins_pipe(ialu_reg_reg);
8384 %}
8385 
8386 // ROL/ROR instructions
8387 
8388 // ROL expand
8389 instruct rolI_rReg_imm1(rRegI dst, rFlagsReg cr) %{
8390   effect(KILL cr, USE_DEF dst);
8391 
8392   format %{ "roll    $dst" %}
8393   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8394   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8395   ins_pipe(ialu_reg);
8396 %}
8397 
8398 instruct rolI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr) %{
8399   effect(USE_DEF dst, USE shift, KILL cr);
8400 
8401   format %{ "roll    $dst, $shift" %}
8402   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8403   ins_encode( reg_opc_imm(dst, shift) );
8404   ins_pipe(ialu_reg);
8405 %}
8406 
8407 instruct rolI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8408 %{
8409   effect(USE_DEF dst, USE shift, KILL cr);
8410 
8411   format %{ "roll    $dst, $shift" %}
8412   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8413   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8414   ins_pipe(ialu_reg_reg);
8415 %}
8416 // end of ROL expand
8417 
8418 // Rotate Left by one
8419 instruct rolI_rReg_i1(rRegI dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8420 %{
8421   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8422 
8423   expand %{
8424     rolI_rReg_imm1(dst, cr);
8425   %}
8426 %}
8427 
8428 // Rotate Left by 8-bit immediate
8429 instruct rolI_rReg_i8(rRegI dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8430 %{
8431   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8432   match(Set dst (OrI (LShiftI dst lshift) (URShiftI dst rshift)));
8433 
8434   expand %{
8435     rolI_rReg_imm8(dst, lshift, cr);
8436   %}
8437 %}
8438 
8439 // Rotate Left by variable
8440 instruct rolI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8441 %{
8442   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI zero shift))));
8443 
8444   expand %{
8445     rolI_rReg_CL(dst, shift, cr);
8446   %}
8447 %}
8448 
8449 // Rotate Left by variable
8450 instruct rolI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8451 %{
8452   match(Set dst (OrI (LShiftI dst shift) (URShiftI dst (SubI c32 shift))));
8453 
8454   expand %{
8455     rolI_rReg_CL(dst, shift, cr);
8456   %}
8457 %}
8458 
8459 // ROR expand
8460 instruct rorI_rReg_imm1(rRegI dst, rFlagsReg cr)
8461 %{
8462   effect(USE_DEF dst, KILL cr);
8463 
8464   format %{ "rorl    $dst" %}
8465   opcode(0xD1, 0x1); /* D1 /1 */
8466   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8467   ins_pipe(ialu_reg);
8468 %}
8469 
8470 instruct rorI_rReg_imm8(rRegI dst, immI8 shift, rFlagsReg cr)
8471 %{
8472   effect(USE_DEF dst, USE shift, KILL cr);
8473 
8474   format %{ "rorl    $dst, $shift" %}
8475   opcode(0xC1, 0x1); /* C1 /1 ib */
8476   ins_encode(reg_opc_imm(dst, shift));
8477   ins_pipe(ialu_reg);
8478 %}
8479 
8480 instruct rorI_rReg_CL(no_rcx_RegI dst, rcx_RegI shift, rFlagsReg cr)
8481 %{
8482   effect(USE_DEF dst, USE shift, KILL cr);
8483 
8484   format %{ "rorl    $dst, $shift" %}
8485   opcode(0xD3, 0x1); /* D3 /1 */
8486   ins_encode(REX_reg(dst), OpcP, reg_opc(dst));
8487   ins_pipe(ialu_reg_reg);
8488 %}
8489 // end of ROR expand
8490 
8491 // Rotate Right by one
8492 instruct rorI_rReg_i1(rRegI dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8493 %{
8494   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8495 
8496   expand %{
8497     rorI_rReg_imm1(dst, cr);
8498   %}
8499 %}
8500 
8501 // Rotate Right by 8-bit immediate
8502 instruct rorI_rReg_i8(rRegI dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8503 %{
8504   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
8505   match(Set dst (OrI (URShiftI dst rshift) (LShiftI dst lshift)));
8506 
8507   expand %{
8508     rorI_rReg_imm8(dst, rshift, cr);
8509   %}
8510 %}
8511 
8512 // Rotate Right by variable
8513 instruct rorI_rReg_Var_C0(no_rcx_RegI dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8514 %{
8515   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI zero shift))));
8516 
8517   expand %{
8518     rorI_rReg_CL(dst, shift, cr);
8519   %}
8520 %}
8521 
8522 // Rotate Right by variable
8523 instruct rorI_rReg_Var_C32(no_rcx_RegI dst, rcx_RegI shift, immI_32 c32, rFlagsReg cr)
8524 %{
8525   match(Set dst (OrI (URShiftI dst shift) (LShiftI dst (SubI c32 shift))));
8526 
8527   expand %{
8528     rorI_rReg_CL(dst, shift, cr);
8529   %}
8530 %}
8531 
8532 // for long rotate
8533 // ROL expand
8534 instruct rolL_rReg_imm1(rRegL dst, rFlagsReg cr) %{
8535   effect(USE_DEF dst, KILL cr);
8536 
8537   format %{ "rolq    $dst" %}
8538   opcode(0xD1, 0x0); /* Opcode  D1 /0 */
8539   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8540   ins_pipe(ialu_reg);
8541 %}
8542 
8543 instruct rolL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr) %{
8544   effect(USE_DEF dst, USE shift, KILL cr);
8545 
8546   format %{ "rolq    $dst, $shift" %}
8547   opcode(0xC1, 0x0); /* Opcode C1 /0 ib */
8548   ins_encode( reg_opc_imm_wide(dst, shift) );
8549   ins_pipe(ialu_reg);
8550 %}
8551 
8552 instruct rolL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8553 %{
8554   effect(USE_DEF dst, USE shift, KILL cr);
8555 
8556   format %{ "rolq    $dst, $shift" %}
8557   opcode(0xD3, 0x0); /* Opcode D3 /0 */
8558   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8559   ins_pipe(ialu_reg_reg);
8560 %}
8561 // end of ROL expand
8562 
8563 // Rotate Left by one
8564 instruct rolL_rReg_i1(rRegL dst, immI1 lshift, immI_M1 rshift, rFlagsReg cr)
8565 %{
8566   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8567 
8568   expand %{
8569     rolL_rReg_imm1(dst, cr);
8570   %}
8571 %}
8572 
8573 // Rotate Left by 8-bit immediate
8574 instruct rolL_rReg_i8(rRegL dst, immI8 lshift, immI8 rshift, rFlagsReg cr)
8575 %{
8576   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8577   match(Set dst (OrL (LShiftL dst lshift) (URShiftL dst rshift)));
8578 
8579   expand %{
8580     rolL_rReg_imm8(dst, lshift, cr);
8581   %}
8582 %}
8583 
8584 // Rotate Left by variable
8585 instruct rolL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8586 %{
8587   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI zero shift))));
8588 
8589   expand %{
8590     rolL_rReg_CL(dst, shift, cr);
8591   %}
8592 %}
8593 
8594 // Rotate Left by variable
8595 instruct rolL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8596 %{
8597   match(Set dst (OrL (LShiftL dst shift) (URShiftL dst (SubI c64 shift))));
8598 
8599   expand %{
8600     rolL_rReg_CL(dst, shift, cr);
8601   %}
8602 %}
8603 
8604 // ROR expand
8605 instruct rorL_rReg_imm1(rRegL dst, rFlagsReg cr)
8606 %{
8607   effect(USE_DEF dst, KILL cr);
8608 
8609   format %{ "rorq    $dst" %}
8610   opcode(0xD1, 0x1); /* D1 /1 */
8611   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8612   ins_pipe(ialu_reg);
8613 %}
8614 
8615 instruct rorL_rReg_imm8(rRegL dst, immI8 shift, rFlagsReg cr)
8616 %{
8617   effect(USE_DEF dst, USE shift, KILL cr);
8618 
8619   format %{ "rorq    $dst, $shift" %}
8620   opcode(0xC1, 0x1); /* C1 /1 ib */
8621   ins_encode(reg_opc_imm_wide(dst, shift));
8622   ins_pipe(ialu_reg);
8623 %}
8624 
8625 instruct rorL_rReg_CL(no_rcx_RegL dst, rcx_RegI shift, rFlagsReg cr)
8626 %{
8627   effect(USE_DEF dst, USE shift, KILL cr);
8628 
8629   format %{ "rorq    $dst, $shift" %}
8630   opcode(0xD3, 0x1); /* D3 /1 */
8631   ins_encode(REX_reg_wide(dst), OpcP, reg_opc(dst));
8632   ins_pipe(ialu_reg_reg);
8633 %}
8634 // end of ROR expand
8635 
8636 // Rotate Right by one
8637 instruct rorL_rReg_i1(rRegL dst, immI1 rshift, immI_M1 lshift, rFlagsReg cr)
8638 %{
8639   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8640 
8641   expand %{
8642     rorL_rReg_imm1(dst, cr);
8643   %}
8644 %}
8645 
8646 // Rotate Right by 8-bit immediate
8647 instruct rorL_rReg_i8(rRegL dst, immI8 rshift, immI8 lshift, rFlagsReg cr)
8648 %{
8649   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x3f));
8650   match(Set dst (OrL (URShiftL dst rshift) (LShiftL dst lshift)));
8651 
8652   expand %{
8653     rorL_rReg_imm8(dst, rshift, cr);
8654   %}
8655 %}
8656 
8657 // Rotate Right by variable
8658 instruct rorL_rReg_Var_C0(no_rcx_RegL dst, rcx_RegI shift, immI0 zero, rFlagsReg cr)
8659 %{
8660   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI zero shift))));
8661 
8662   expand %{
8663     rorL_rReg_CL(dst, shift, cr);
8664   %}
8665 %}
8666 
8667 // Rotate Right by variable
8668 instruct rorL_rReg_Var_C64(no_rcx_RegL dst, rcx_RegI shift, immI_64 c64, rFlagsReg cr)
8669 %{
8670   match(Set dst (OrL (URShiftL dst shift) (LShiftL dst (SubI c64 shift))));
8671 
8672   expand %{
8673     rorL_rReg_CL(dst, shift, cr);
8674   %}
8675 %}
8676 
8677 // Logical Instructions
8678 
8679 // Integer Logical Instructions
8680 
8681 // And Instructions
8682 // And Register with Register
8683 instruct andI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8684 %{
8685   match(Set dst (AndI dst src));
8686   effect(KILL cr);
8687 
8688   format %{ "andl    $dst, $src\t# int" %}
8689   opcode(0x23);
8690   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8691   ins_pipe(ialu_reg_reg);
8692 %}
8693 
8694 // And Register with Immediate 255
8695 instruct andI_rReg_imm255(rRegI dst, immI_255 src)
8696 %{
8697   match(Set dst (AndI dst src));
8698 
8699   format %{ "movzbl  $dst, $dst\t# int &amp; 0xFF" %}
8700   opcode(0x0F, 0xB6);
8701   ins_encode(REX_reg_breg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8702   ins_pipe(ialu_reg);
8703 %}
8704 
8705 // And Register with Immediate 255 and promote to long
8706 instruct andI2L_rReg_imm255(rRegL dst, rRegI src, immI_255 mask)
8707 %{
8708   match(Set dst (ConvI2L (AndI src mask)));
8709 
8710   format %{ "movzbl  $dst, $src\t# int &amp; 0xFF -&gt; long" %}
8711   opcode(0x0F, 0xB6);
8712   ins_encode(REX_reg_breg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8713   ins_pipe(ialu_reg);
8714 %}
8715 
8716 // And Register with Immediate 65535
8717 instruct andI_rReg_imm65535(rRegI dst, immI_65535 src)
8718 %{
8719   match(Set dst (AndI dst src));
8720 
8721   format %{ "movzwl  $dst, $dst\t# int &amp; 0xFFFF" %}
8722   opcode(0x0F, 0xB7);
8723   ins_encode(REX_reg_reg(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
8724   ins_pipe(ialu_reg);
8725 %}
8726 
8727 // And Register with Immediate 65535 and promote to long
8728 instruct andI2L_rReg_imm65535(rRegL dst, rRegI src, immI_65535 mask)
8729 %{
8730   match(Set dst (ConvI2L (AndI src mask)));
8731 
8732   format %{ "movzwl  $dst, $src\t# int &amp; 0xFFFF -&gt; long" %}
8733   opcode(0x0F, 0xB7);
8734   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
8735   ins_pipe(ialu_reg);
8736 %}
8737 
8738 // And Register with Immediate
8739 instruct andI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8740 %{
8741   match(Set dst (AndI dst src));
8742   effect(KILL cr);
8743 
8744   format %{ "andl    $dst, $src\t# int" %}
8745   opcode(0x81, 0x04); /* Opcode 81 /4 */
8746   ins_encode(OpcSErm(dst, src), Con8or32(src));
8747   ins_pipe(ialu_reg);
8748 %}
8749 
8750 // And Register with Memory
8751 instruct andI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8752 %{
8753   match(Set dst (AndI dst (LoadI src)));
8754   effect(KILL cr);
8755 
8756   ins_cost(125);
8757   format %{ "andl    $dst, $src\t# int" %}
8758   opcode(0x23);
8759   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8760   ins_pipe(ialu_reg_mem);
8761 %}
8762 
8763 // And Memory with Register
8764 instruct andI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8765 %{
8766   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8767   effect(KILL cr);
8768 
8769   ins_cost(150);
8770   format %{ "andl    $dst, $src\t# int" %}
8771   opcode(0x21); /* Opcode 21 /r */
8772   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8773   ins_pipe(ialu_mem_reg);
8774 %}
8775 
8776 // And Memory with Immediate
8777 instruct andI_mem_imm(memory dst, immI src, rFlagsReg cr)
8778 %{
8779   match(Set dst (StoreI dst (AndI (LoadI dst) src)));
8780   effect(KILL cr);
8781 
8782   ins_cost(125);
8783   format %{ "andl    $dst, $src\t# int" %}
8784   opcode(0x81, 0x4); /* Opcode 81 /4 id */
8785   ins_encode(REX_mem(dst), OpcSE(src),
8786              RM_opc_mem(secondary, dst), Con8or32(src));
8787   ins_pipe(ialu_mem_imm);
8788 %}
8789 
8790 // BMI1 instructions
8791 instruct andnI_rReg_rReg_mem(rRegI dst, rRegI src1, memory src2, immI_M1 minus_1, rFlagsReg cr) %{
8792   match(Set dst (AndI (XorI src1 minus_1) (LoadI src2)));
8793   predicate(UseBMI1Instructions);
8794   effect(KILL cr);
8795 
8796   ins_cost(125);
8797   format %{ "andnl  $dst, $src1, $src2" %}
8798 
8799   ins_encode %{
8800     __ andnl($dst$$Register, $src1$$Register, $src2$$Address);
8801   %}
8802   ins_pipe(ialu_reg_mem);
8803 %}
8804 
8805 instruct andnI_rReg_rReg_rReg(rRegI dst, rRegI src1, rRegI src2, immI_M1 minus_1, rFlagsReg cr) %{
8806   match(Set dst (AndI (XorI src1 minus_1) src2));
8807   predicate(UseBMI1Instructions);
8808   effect(KILL cr);
8809 
8810   format %{ "andnl  $dst, $src1, $src2" %}
8811 
8812   ins_encode %{
8813     __ andnl($dst$$Register, $src1$$Register, $src2$$Register);
8814   %}
8815   ins_pipe(ialu_reg);
8816 %}
8817 
8818 instruct blsiI_rReg_rReg(rRegI dst, rRegI src, immI0 imm_zero, rFlagsReg cr) %{
8819   match(Set dst (AndI (SubI imm_zero src) src));
8820   predicate(UseBMI1Instructions);
8821   effect(KILL cr);
8822 
8823   format %{ "blsil  $dst, $src" %}
8824 
8825   ins_encode %{
8826     __ blsil($dst$$Register, $src$$Register);
8827   %}
8828   ins_pipe(ialu_reg);
8829 %}
8830 
8831 instruct blsiI_rReg_mem(rRegI dst, memory src, immI0 imm_zero, rFlagsReg cr) %{
8832   match(Set dst (AndI (SubI imm_zero (LoadI src) ) (LoadI src) ));
8833   predicate(UseBMI1Instructions);
8834   effect(KILL cr);
8835 
8836   ins_cost(125);
8837   format %{ "blsil  $dst, $src" %}
8838 
8839   ins_encode %{
8840     __ blsil($dst$$Register, $src$$Address);
8841   %}
8842   ins_pipe(ialu_reg_mem);
8843 %}
8844 
8845 instruct blsmskI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8846 %{
8847   match(Set dst (XorI (AddI (LoadI src) minus_1) (LoadI src) ) );
8848   predicate(UseBMI1Instructions);
8849   effect(KILL cr);
8850 
8851   ins_cost(125);
8852   format %{ "blsmskl $dst, $src" %}
8853 
8854   ins_encode %{
8855     __ blsmskl($dst$$Register, $src$$Address);
8856   %}
8857   ins_pipe(ialu_reg_mem);
8858 %}
8859 
8860 instruct blsmskI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8861 %{
8862   match(Set dst (XorI (AddI src minus_1) src));
8863   predicate(UseBMI1Instructions);
8864   effect(KILL cr);
8865 
8866   format %{ "blsmskl $dst, $src" %}
8867 
8868   ins_encode %{
8869     __ blsmskl($dst$$Register, $src$$Register);
8870   %}
8871 
8872   ins_pipe(ialu_reg);
8873 %}
8874 
8875 instruct blsrI_rReg_rReg(rRegI dst, rRegI src, immI_M1 minus_1, rFlagsReg cr)
8876 %{
8877   match(Set dst (AndI (AddI src minus_1) src) );
8878   predicate(UseBMI1Instructions);
8879   effect(KILL cr);
8880 
8881   format %{ "blsrl  $dst, $src" %}
8882 
8883   ins_encode %{
8884     __ blsrl($dst$$Register, $src$$Register);
8885   %}
8886 
8887   ins_pipe(ialu_reg_mem);
8888 %}
8889 
8890 instruct blsrI_rReg_mem(rRegI dst, memory src, immI_M1 minus_1, rFlagsReg cr)
8891 %{
8892   match(Set dst (AndI (AddI (LoadI src) minus_1) (LoadI src) ) );
8893   predicate(UseBMI1Instructions);
8894   effect(KILL cr);
8895 
8896   ins_cost(125);
8897   format %{ "blsrl  $dst, $src" %}
8898 
8899   ins_encode %{
8900     __ blsrl($dst$$Register, $src$$Address);
8901   %}
8902 
8903   ins_pipe(ialu_reg);
8904 %}
8905 
8906 // Or Instructions
8907 // Or Register with Register
8908 instruct orI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8909 %{
8910   match(Set dst (OrI dst src));
8911   effect(KILL cr);
8912 
8913   format %{ "orl     $dst, $src\t# int" %}
8914   opcode(0x0B);
8915   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8916   ins_pipe(ialu_reg_reg);
8917 %}
8918 
8919 // Or Register with Immediate
8920 instruct orI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8921 %{
8922   match(Set dst (OrI dst src));
8923   effect(KILL cr);
8924 
8925   format %{ "orl     $dst, $src\t# int" %}
8926   opcode(0x81, 0x01); /* Opcode 81 /1 id */
8927   ins_encode(OpcSErm(dst, src), Con8or32(src));
8928   ins_pipe(ialu_reg);
8929 %}
8930 
8931 // Or Register with Memory
8932 instruct orI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
8933 %{
8934   match(Set dst (OrI dst (LoadI src)));
8935   effect(KILL cr);
8936 
8937   ins_cost(125);
8938   format %{ "orl     $dst, $src\t# int" %}
8939   opcode(0x0B);
8940   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
8941   ins_pipe(ialu_reg_mem);
8942 %}
8943 
8944 // Or Memory with Register
8945 instruct orI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
8946 %{
8947   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8948   effect(KILL cr);
8949 
8950   ins_cost(150);
8951   format %{ "orl     $dst, $src\t# int" %}
8952   opcode(0x09); /* Opcode 09 /r */
8953   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
8954   ins_pipe(ialu_mem_reg);
8955 %}
8956 
8957 // Or Memory with Immediate
8958 instruct orI_mem_imm(memory dst, immI src, rFlagsReg cr)
8959 %{
8960   match(Set dst (StoreI dst (OrI (LoadI dst) src)));
8961   effect(KILL cr);
8962 
8963   ins_cost(125);
8964   format %{ "orl     $dst, $src\t# int" %}
8965   opcode(0x81, 0x1); /* Opcode 81 /1 id */
8966   ins_encode(REX_mem(dst), OpcSE(src),
8967              RM_opc_mem(secondary, dst), Con8or32(src));
8968   ins_pipe(ialu_mem_imm);
8969 %}
8970 
8971 // Xor Instructions
8972 // Xor Register with Register
8973 instruct xorI_rReg(rRegI dst, rRegI src, rFlagsReg cr)
8974 %{
8975   match(Set dst (XorI dst src));
8976   effect(KILL cr);
8977 
8978   format %{ "xorl    $dst, $src\t# int" %}
8979   opcode(0x33);
8980   ins_encode(REX_reg_reg(dst, src), OpcP, reg_reg(dst, src));
8981   ins_pipe(ialu_reg_reg);
8982 %}
8983 
8984 // Xor Register with Immediate -1
8985 instruct xorI_rReg_im1(rRegI dst, immI_M1 imm) %{
8986   match(Set dst (XorI dst imm));
8987 
8988   format %{ "not    $dst" %}
8989   ins_encode %{
8990      __ notl($dst$$Register);
8991   %}
8992   ins_pipe(ialu_reg);
8993 %}
8994 
8995 // Xor Register with Immediate
8996 instruct xorI_rReg_imm(rRegI dst, immI src, rFlagsReg cr)
8997 %{
8998   match(Set dst (XorI dst src));
8999   effect(KILL cr);
9000 
9001   format %{ "xorl    $dst, $src\t# int" %}
9002   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9003   ins_encode(OpcSErm(dst, src), Con8or32(src));
9004   ins_pipe(ialu_reg);
9005 %}
9006 
9007 // Xor Register with Memory
9008 instruct xorI_rReg_mem(rRegI dst, memory src, rFlagsReg cr)
9009 %{
9010   match(Set dst (XorI dst (LoadI src)));
9011   effect(KILL cr);
9012 
9013   ins_cost(125);
9014   format %{ "xorl    $dst, $src\t# int" %}
9015   opcode(0x33);
9016   ins_encode(REX_reg_mem(dst, src), OpcP, reg_mem(dst, src));
9017   ins_pipe(ialu_reg_mem);
9018 %}
9019 
9020 // Xor Memory with Register
9021 instruct xorI_mem_rReg(memory dst, rRegI src, rFlagsReg cr)
9022 %{
9023   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9024   effect(KILL cr);
9025 
9026   ins_cost(150);
9027   format %{ "xorl    $dst, $src\t# int" %}
9028   opcode(0x31); /* Opcode 31 /r */
9029   ins_encode(REX_reg_mem(src, dst), OpcP, reg_mem(src, dst));
9030   ins_pipe(ialu_mem_reg);
9031 %}
9032 
9033 // Xor Memory with Immediate
9034 instruct xorI_mem_imm(memory dst, immI src, rFlagsReg cr)
9035 %{
9036   match(Set dst (StoreI dst (XorI (LoadI dst) src)));
9037   effect(KILL cr);
9038 
9039   ins_cost(125);
9040   format %{ "xorl    $dst, $src\t# int" %}
9041   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9042   ins_encode(REX_mem(dst), OpcSE(src),
9043              RM_opc_mem(secondary, dst), Con8or32(src));
9044   ins_pipe(ialu_mem_imm);
9045 %}
9046 
9047 
9048 // Long Logical Instructions
9049 
9050 // And Instructions
9051 // And Register with Register
9052 instruct andL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9053 %{
9054   match(Set dst (AndL dst src));
9055   effect(KILL cr);
9056 
9057   format %{ "andq    $dst, $src\t# long" %}
9058   opcode(0x23);
9059   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9060   ins_pipe(ialu_reg_reg);
9061 %}
9062 
9063 // And Register with Immediate 255
9064 instruct andL_rReg_imm255(rRegL dst, immL_255 src)
9065 %{
9066   match(Set dst (AndL dst src));
9067 
9068   format %{ "movzbq  $dst, $dst\t# long &amp; 0xFF" %}
9069   opcode(0x0F, 0xB6);
9070   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9071   ins_pipe(ialu_reg);
9072 %}
9073 
9074 // And Register with Immediate 65535
9075 instruct andL_rReg_imm65535(rRegL dst, immL_65535 src)
9076 %{
9077   match(Set dst (AndL dst src));
9078 
9079   format %{ "movzwq  $dst, $dst\t# long &amp; 0xFFFF" %}
9080   opcode(0x0F, 0xB7);
9081   ins_encode(REX_reg_reg_wide(dst, dst), OpcP, OpcS, reg_reg(dst, dst));
9082   ins_pipe(ialu_reg);
9083 %}
9084 
9085 // And Register with Immediate
9086 instruct andL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9087 %{
9088   match(Set dst (AndL dst src));
9089   effect(KILL cr);
9090 
9091   format %{ "andq    $dst, $src\t# long" %}
9092   opcode(0x81, 0x04); /* Opcode 81 /4 */
9093   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9094   ins_pipe(ialu_reg);
9095 %}
9096 
9097 // And Register with Memory
9098 instruct andL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9099 %{
9100   match(Set dst (AndL dst (LoadL src)));
9101   effect(KILL cr);
9102 
9103   ins_cost(125);
9104   format %{ "andq    $dst, $src\t# long" %}
9105   opcode(0x23);
9106   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9107   ins_pipe(ialu_reg_mem);
9108 %}
9109 
9110 // And Memory with Register
9111 instruct andL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9112 %{
9113   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9114   effect(KILL cr);
9115 
9116   ins_cost(150);
9117   format %{ "andq    $dst, $src\t# long" %}
9118   opcode(0x21); /* Opcode 21 /r */
9119   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9120   ins_pipe(ialu_mem_reg);
9121 %}
9122 
9123 // And Memory with Immediate
9124 instruct andL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9125 %{
9126   match(Set dst (StoreL dst (AndL (LoadL dst) src)));
9127   effect(KILL cr);
9128 
9129   ins_cost(125);
9130   format %{ "andq    $dst, $src\t# long" %}
9131   opcode(0x81, 0x4); /* Opcode 81 /4 id */
9132   ins_encode(REX_mem_wide(dst), OpcSE(src),
9133              RM_opc_mem(secondary, dst), Con8or32(src));
9134   ins_pipe(ialu_mem_imm);
9135 %}
9136 
9137 // BMI1 instructions
9138 instruct andnL_rReg_rReg_mem(rRegL dst, rRegL src1, memory src2, immL_M1 minus_1, rFlagsReg cr) %{
9139   match(Set dst (AndL (XorL src1 minus_1) (LoadL src2)));
9140   predicate(UseBMI1Instructions);
9141   effect(KILL cr);
9142 
9143   ins_cost(125);
9144   format %{ "andnq  $dst, $src1, $src2" %}
9145 
9146   ins_encode %{
9147     __ andnq($dst$$Register, $src1$$Register, $src2$$Address);
9148   %}
9149   ins_pipe(ialu_reg_mem);
9150 %}
9151 
9152 instruct andnL_rReg_rReg_rReg(rRegL dst, rRegL src1, rRegL src2, immL_M1 minus_1, rFlagsReg cr) %{
9153   match(Set dst (AndL (XorL src1 minus_1) src2));
9154   predicate(UseBMI1Instructions);
9155   effect(KILL cr);
9156 
9157   format %{ "andnq  $dst, $src1, $src2" %}
9158 
9159   ins_encode %{
9160   __ andnq($dst$$Register, $src1$$Register, $src2$$Register);
9161   %}
9162   ins_pipe(ialu_reg_mem);
9163 %}
9164 
9165 instruct blsiL_rReg_rReg(rRegL dst, rRegL src, immL0 imm_zero, rFlagsReg cr) %{
9166   match(Set dst (AndL (SubL imm_zero src) src));
9167   predicate(UseBMI1Instructions);
9168   effect(KILL cr);
9169 
9170   format %{ "blsiq  $dst, $src" %}
9171 
9172   ins_encode %{
9173     __ blsiq($dst$$Register, $src$$Register);
9174   %}
9175   ins_pipe(ialu_reg);
9176 %}
9177 
9178 instruct blsiL_rReg_mem(rRegL dst, memory src, immL0 imm_zero, rFlagsReg cr) %{
9179   match(Set dst (AndL (SubL imm_zero (LoadL src) ) (LoadL src) ));
9180   predicate(UseBMI1Instructions);
9181   effect(KILL cr);
9182 
9183   ins_cost(125);
9184   format %{ "blsiq  $dst, $src" %}
9185 
9186   ins_encode %{
9187     __ blsiq($dst$$Register, $src$$Address);
9188   %}
9189   ins_pipe(ialu_reg_mem);
9190 %}
9191 
9192 instruct blsmskL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9193 %{
9194   match(Set dst (XorL (AddL (LoadL src) minus_1) (LoadL src) ) );
9195   predicate(UseBMI1Instructions);
9196   effect(KILL cr);
9197 
9198   ins_cost(125);
9199   format %{ "blsmskq $dst, $src" %}
9200 
9201   ins_encode %{
9202     __ blsmskq($dst$$Register, $src$$Address);
9203   %}
9204   ins_pipe(ialu_reg_mem);
9205 %}
9206 
9207 instruct blsmskL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9208 %{
9209   match(Set dst (XorL (AddL src minus_1) src));
9210   predicate(UseBMI1Instructions);
9211   effect(KILL cr);
9212 
9213   format %{ "blsmskq $dst, $src" %}
9214 
9215   ins_encode %{
9216     __ blsmskq($dst$$Register, $src$$Register);
9217   %}
9218 
9219   ins_pipe(ialu_reg);
9220 %}
9221 
9222 instruct blsrL_rReg_rReg(rRegL dst, rRegL src, immL_M1 minus_1, rFlagsReg cr)
9223 %{
9224   match(Set dst (AndL (AddL src minus_1) src) );
9225   predicate(UseBMI1Instructions);
9226   effect(KILL cr);
9227 
9228   format %{ "blsrq  $dst, $src" %}
9229 
9230   ins_encode %{
9231     __ blsrq($dst$$Register, $src$$Register);
9232   %}
9233 
9234   ins_pipe(ialu_reg);
9235 %}
9236 
9237 instruct blsrL_rReg_mem(rRegL dst, memory src, immL_M1 minus_1, rFlagsReg cr)
9238 %{
9239   match(Set dst (AndL (AddL (LoadL src) minus_1) (LoadL src)) );
9240   predicate(UseBMI1Instructions);
9241   effect(KILL cr);
9242 
9243   ins_cost(125);
9244   format %{ "blsrq  $dst, $src" %}
9245 
9246   ins_encode %{
9247     __ blsrq($dst$$Register, $src$$Address);
9248   %}
9249 
9250   ins_pipe(ialu_reg);
9251 %}
9252 
9253 // Or Instructions
9254 // Or Register with Register
9255 instruct orL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9256 %{
9257   match(Set dst (OrL dst src));
9258   effect(KILL cr);
9259 
9260   format %{ "orq     $dst, $src\t# long" %}
9261   opcode(0x0B);
9262   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9263   ins_pipe(ialu_reg_reg);
9264 %}
9265 
9266 // Use any_RegP to match R15 (TLS register) without spilling.
9267 instruct orL_rReg_castP2X(rRegL dst, any_RegP src, rFlagsReg cr) %{
9268   match(Set dst (OrL dst (CastP2X src)));
9269   effect(KILL cr);
9270 
9271   format %{ "orq     $dst, $src\t# long" %}
9272   opcode(0x0B);
9273   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9274   ins_pipe(ialu_reg_reg);
9275 %}
9276 
9277 
9278 // Or Register with Immediate
9279 instruct orL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9280 %{
9281   match(Set dst (OrL dst src));
9282   effect(KILL cr);
9283 
9284   format %{ "orq     $dst, $src\t# long" %}
9285   opcode(0x81, 0x01); /* Opcode 81 /1 id */
9286   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9287   ins_pipe(ialu_reg);
9288 %}
9289 
9290 // Or Register with Memory
9291 instruct orL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9292 %{
9293   match(Set dst (OrL dst (LoadL src)));
9294   effect(KILL cr);
9295 
9296   ins_cost(125);
9297   format %{ "orq     $dst, $src\t# long" %}
9298   opcode(0x0B);
9299   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9300   ins_pipe(ialu_reg_mem);
9301 %}
9302 
9303 // Or Memory with Register
9304 instruct orL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9305 %{
9306   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9307   effect(KILL cr);
9308 
9309   ins_cost(150);
9310   format %{ "orq     $dst, $src\t# long" %}
9311   opcode(0x09); /* Opcode 09 /r */
9312   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9313   ins_pipe(ialu_mem_reg);
9314 %}
9315 
9316 // Or Memory with Immediate
9317 instruct orL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9318 %{
9319   match(Set dst (StoreL dst (OrL (LoadL dst) src)));
9320   effect(KILL cr);
9321 
9322   ins_cost(125);
9323   format %{ "orq     $dst, $src\t# long" %}
9324   opcode(0x81, 0x1); /* Opcode 81 /1 id */
9325   ins_encode(REX_mem_wide(dst), OpcSE(src),
9326              RM_opc_mem(secondary, dst), Con8or32(src));
9327   ins_pipe(ialu_mem_imm);
9328 %}
9329 
9330 // Xor Instructions
9331 // Xor Register with Register
9332 instruct xorL_rReg(rRegL dst, rRegL src, rFlagsReg cr)
9333 %{
9334   match(Set dst (XorL dst src));
9335   effect(KILL cr);
9336 
9337   format %{ "xorq    $dst, $src\t# long" %}
9338   opcode(0x33);
9339   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst, src));
9340   ins_pipe(ialu_reg_reg);
9341 %}
9342 
9343 // Xor Register with Immediate -1
9344 instruct xorL_rReg_im1(rRegL dst, immL_M1 imm) %{
9345   match(Set dst (XorL dst imm));
9346 
9347   format %{ "notq   $dst" %}
9348   ins_encode %{
9349      __ notq($dst$$Register);
9350   %}
9351   ins_pipe(ialu_reg);
9352 %}
9353 
9354 // Xor Register with Immediate
9355 instruct xorL_rReg_imm(rRegL dst, immL32 src, rFlagsReg cr)
9356 %{
9357   match(Set dst (XorL dst src));
9358   effect(KILL cr);
9359 
9360   format %{ "xorq    $dst, $src\t# long" %}
9361   opcode(0x81, 0x06); /* Opcode 81 /6 id */
9362   ins_encode(OpcSErm_wide(dst, src), Con8or32(src));
9363   ins_pipe(ialu_reg);
9364 %}
9365 
9366 // Xor Register with Memory
9367 instruct xorL_rReg_mem(rRegL dst, memory src, rFlagsReg cr)
9368 %{
9369   match(Set dst (XorL dst (LoadL src)));
9370   effect(KILL cr);
9371 
9372   ins_cost(125);
9373   format %{ "xorq    $dst, $src\t# long" %}
9374   opcode(0x33);
9375   ins_encode(REX_reg_mem_wide(dst, src), OpcP, reg_mem(dst, src));
9376   ins_pipe(ialu_reg_mem);
9377 %}
9378 
9379 // Xor Memory with Register
9380 instruct xorL_mem_rReg(memory dst, rRegL src, rFlagsReg cr)
9381 %{
9382   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9383   effect(KILL cr);
9384 
9385   ins_cost(150);
9386   format %{ "xorq    $dst, $src\t# long" %}
9387   opcode(0x31); /* Opcode 31 /r */
9388   ins_encode(REX_reg_mem_wide(src, dst), OpcP, reg_mem(src, dst));
9389   ins_pipe(ialu_mem_reg);
9390 %}
9391 
9392 // Xor Memory with Immediate
9393 instruct xorL_mem_imm(memory dst, immL32 src, rFlagsReg cr)
9394 %{
9395   match(Set dst (StoreL dst (XorL (LoadL dst) src)));
9396   effect(KILL cr);
9397 
9398   ins_cost(125);
9399   format %{ "xorq    $dst, $src\t# long" %}
9400   opcode(0x81, 0x6); /* Opcode 81 /6 id */
9401   ins_encode(REX_mem_wide(dst), OpcSE(src),
9402              RM_opc_mem(secondary, dst), Con8or32(src));
9403   ins_pipe(ialu_mem_imm);
9404 %}
9405 
9406 // Convert Int to Boolean
9407 instruct convI2B(rRegI dst, rRegI src, rFlagsReg cr)
9408 %{
9409   match(Set dst (Conv2B src));
9410   effect(KILL cr);
9411 
9412   format %{ "testl   $src, $src\t# ci2b\n\t"
9413             "setnz   $dst\n\t"
9414             "movzbl  $dst, $dst" %}
9415   ins_encode(REX_reg_reg(src, src), opc_reg_reg(0x85, src, src), // testl
9416              setNZ_reg(dst),
9417              REX_reg_breg(dst, dst), // movzbl
9418              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9419   ins_pipe(pipe_slow); // XXX
9420 %}
9421 
9422 // Convert Pointer to Boolean
9423 instruct convP2B(rRegI dst, rRegP src, rFlagsReg cr)
9424 %{
9425   match(Set dst (Conv2B src));
9426   effect(KILL cr);
9427 
9428   format %{ "testq   $src, $src\t# cp2b\n\t"
9429             "setnz   $dst\n\t"
9430             "movzbl  $dst, $dst" %}
9431   ins_encode(REX_reg_reg_wide(src, src), opc_reg_reg(0x85, src, src), // testq
9432              setNZ_reg(dst),
9433              REX_reg_breg(dst, dst), // movzbl
9434              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst));
9435   ins_pipe(pipe_slow); // XXX
9436 %}
9437 
9438 instruct cmpLTMask(rRegI dst, rRegI p, rRegI q, rFlagsReg cr)
9439 %{
9440   match(Set dst (CmpLTMask p q));
9441   effect(KILL cr);
9442 
9443   ins_cost(400);
9444   format %{ "cmpl    $p, $q\t# cmpLTMask\n\t"
9445             "setlt   $dst\n\t"
9446             "movzbl  $dst, $dst\n\t"
9447             "negl    $dst" %}
9448   ins_encode(REX_reg_reg(p, q), opc_reg_reg(0x3B, p, q), // cmpl
9449              setLT_reg(dst),
9450              REX_reg_breg(dst, dst), // movzbl
9451              Opcode(0x0F), Opcode(0xB6), reg_reg(dst, dst),
9452              neg_reg(dst));
9453   ins_pipe(pipe_slow);
9454 %}
9455 
9456 instruct cmpLTMask0(rRegI dst, immI0 zero, rFlagsReg cr)
9457 %{
9458   match(Set dst (CmpLTMask dst zero));
9459   effect(KILL cr);
9460 
9461   ins_cost(100);
9462   format %{ "sarl    $dst, #31\t# cmpLTMask0" %}
9463   ins_encode %{
9464   __ sarl($dst$$Register, 31);
9465   %}
9466   ins_pipe(ialu_reg);
9467 %}
9468 
9469 /* Better to save a register than avoid a branch */
9470 instruct cadd_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9471 %{
9472   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
9473   effect(KILL cr);
9474   ins_cost(300);
9475   format %{ "subl   $p,$q\t# cadd_cmpLTMask\n\t"
9476             "jge    done\n\t"
9477             "addl   $p,$y\n"
9478             "done:  " %}
9479   ins_encode %{
9480     Register Rp = $p$$Register;
9481     Register Rq = $q$$Register;
9482     Register Ry = $y$$Register;
9483     Label done;
9484     __ subl(Rp, Rq);
9485     __ jccb(Assembler::greaterEqual, done);
9486     __ addl(Rp, Ry);
9487     __ bind(done);
9488   %}
9489   ins_pipe(pipe_cmplt);
9490 %}
9491 
9492 /* Better to save a register than avoid a branch */
9493 instruct and_cmpLTMask(rRegI p, rRegI q, rRegI y, rFlagsReg cr)
9494 %{
9495   match(Set y (AndI (CmpLTMask p q) y));
9496   effect(KILL cr);
9497 
9498   ins_cost(300);
9499 
9500   format %{ "cmpl     $p, $q\t# and_cmpLTMask\n\t"
9501             "jlt      done\n\t"
9502             "xorl     $y, $y\n"
9503             "done:  " %}
9504   ins_encode %{
9505     Register Rp = $p$$Register;
9506     Register Rq = $q$$Register;
9507     Register Ry = $y$$Register;
9508     Label done;
9509     __ cmpl(Rp, Rq);
9510     __ jccb(Assembler::less, done);
9511     __ xorl(Ry, Ry);
9512     __ bind(done);
9513   %}
9514   ins_pipe(pipe_cmplt);
9515 %}
9516 
9517 
9518 //---------- FP Instructions------------------------------------------------
9519 
9520 instruct cmpF_cc_reg(rFlagsRegU cr, regF src1, regF src2)
9521 %{
9522   match(Set cr (CmpF src1 src2));
9523 
9524   ins_cost(145);
9525   format %{ "ucomiss $src1, $src2\n\t"
9526             "jnp,s   exit\n\t"
9527             "pushfq\t# saw NaN, set CF\n\t"
9528             "andq    [rsp], #0xffffff2b\n\t"
9529             "popfq\n"
9530     "exit:" %}
9531   ins_encode %{
9532     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9533     emit_cmpfp_fixup(_masm);
9534   %}
9535   ins_pipe(pipe_slow);
9536 %}
9537 
9538 instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{
9539   match(Set cr (CmpF src1 src2));
9540 
9541   ins_cost(100);
9542   format %{ "ucomiss $src1, $src2" %}
9543   ins_encode %{
9544     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9545   %}
9546   ins_pipe(pipe_slow);
9547 %}
9548 
9549 instruct cmpF_cc_mem(rFlagsRegU cr, regF src1, memory src2)
9550 %{
9551   match(Set cr (CmpF src1 (LoadF src2)));
9552 
9553   ins_cost(145);
9554   format %{ "ucomiss $src1, $src2\n\t"
9555             "jnp,s   exit\n\t"
9556             "pushfq\t# saw NaN, set CF\n\t"
9557             "andq    [rsp], #0xffffff2b\n\t"
9558             "popfq\n"
9559     "exit:" %}
9560   ins_encode %{
9561     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9562     emit_cmpfp_fixup(_masm);
9563   %}
9564   ins_pipe(pipe_slow);
9565 %}
9566 
9567 instruct cmpF_cc_memCF(rFlagsRegUCF cr, regF src1, memory src2) %{
9568   match(Set cr (CmpF src1 (LoadF src2)));
9569 
9570   ins_cost(100);
9571   format %{ "ucomiss $src1, $src2" %}
9572   ins_encode %{
9573     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9574   %}
9575   ins_pipe(pipe_slow);
9576 %}
9577 
9578 instruct cmpF_cc_imm(rFlagsRegU cr, regF src, immF con) %{
9579   match(Set cr (CmpF src con));
9580 
9581   ins_cost(145);
9582   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9583             "jnp,s   exit\n\t"
9584             "pushfq\t# saw NaN, set CF\n\t"
9585             "andq    [rsp], #0xffffff2b\n\t"
9586             "popfq\n"
9587     "exit:" %}
9588   ins_encode %{
9589     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9590     emit_cmpfp_fixup(_masm);
9591   %}
9592   ins_pipe(pipe_slow);
9593 %}
9594 
9595 instruct cmpF_cc_immCF(rFlagsRegUCF cr, regF src, immF con) %{
9596   match(Set cr (CmpF src con));
9597   ins_cost(100);
9598   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con" %}
9599   ins_encode %{
9600     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9601   %}
9602   ins_pipe(pipe_slow);
9603 %}
9604 
9605 instruct cmpD_cc_reg(rFlagsRegU cr, regD src1, regD src2)
9606 %{
9607   match(Set cr (CmpD src1 src2));
9608 
9609   ins_cost(145);
9610   format %{ "ucomisd $src1, $src2\n\t"
9611             "jnp,s   exit\n\t"
9612             "pushfq\t# saw NaN, set CF\n\t"
9613             "andq    [rsp], #0xffffff2b\n\t"
9614             "popfq\n"
9615     "exit:" %}
9616   ins_encode %{
9617     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9618     emit_cmpfp_fixup(_masm);
9619   %}
9620   ins_pipe(pipe_slow);
9621 %}
9622 
9623 instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{
9624   match(Set cr (CmpD src1 src2));
9625 
9626   ins_cost(100);
9627   format %{ "ucomisd $src1, $src2 test" %}
9628   ins_encode %{
9629     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9630   %}
9631   ins_pipe(pipe_slow);
9632 %}
9633 
9634 instruct cmpD_cc_mem(rFlagsRegU cr, regD src1, memory src2)
9635 %{
9636   match(Set cr (CmpD src1 (LoadD src2)));
9637 
9638   ins_cost(145);
9639   format %{ "ucomisd $src1, $src2\n\t"
9640             "jnp,s   exit\n\t"
9641             "pushfq\t# saw NaN, set CF\n\t"
9642             "andq    [rsp], #0xffffff2b\n\t"
9643             "popfq\n"
9644     "exit:" %}
9645   ins_encode %{
9646     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9647     emit_cmpfp_fixup(_masm);
9648   %}
9649   ins_pipe(pipe_slow);
9650 %}
9651 
9652 instruct cmpD_cc_memCF(rFlagsRegUCF cr, regD src1, memory src2) %{
9653   match(Set cr (CmpD src1 (LoadD src2)));
9654 
9655   ins_cost(100);
9656   format %{ "ucomisd $src1, $src2" %}
9657   ins_encode %{
9658     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9659   %}
9660   ins_pipe(pipe_slow);
9661 %}
9662 
9663 instruct cmpD_cc_imm(rFlagsRegU cr, regD src, immD con) %{
9664   match(Set cr (CmpD src con));
9665 
9666   ins_cost(145);
9667   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9668             "jnp,s   exit\n\t"
9669             "pushfq\t# saw NaN, set CF\n\t"
9670             "andq    [rsp], #0xffffff2b\n\t"
9671             "popfq\n"
9672     "exit:" %}
9673   ins_encode %{
9674     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9675     emit_cmpfp_fixup(_masm);
9676   %}
9677   ins_pipe(pipe_slow);
9678 %}
9679 
9680 instruct cmpD_cc_immCF(rFlagsRegUCF cr, regD src, immD con) %{
9681   match(Set cr (CmpD src con));
9682   ins_cost(100);
9683   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con" %}
9684   ins_encode %{
9685     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9686   %}
9687   ins_pipe(pipe_slow);
9688 %}
9689 
9690 // Compare into -1,0,1
9691 instruct cmpF_reg(rRegI dst, regF src1, regF src2, rFlagsReg cr)
9692 %{
9693   match(Set dst (CmpF3 src1 src2));
9694   effect(KILL cr);
9695 
9696   ins_cost(275);
9697   format %{ "ucomiss $src1, $src2\n\t"
9698             "movl    $dst, #-1\n\t"
9699             "jp,s    done\n\t"
9700             "jb,s    done\n\t"
9701             "setne   $dst\n\t"
9702             "movzbl  $dst, $dst\n"
9703     "done:" %}
9704   ins_encode %{
9705     __ ucomiss($src1$$XMMRegister, $src2$$XMMRegister);
9706     emit_cmpfp3(_masm, $dst$$Register);
9707   %}
9708   ins_pipe(pipe_slow);
9709 %}
9710 
9711 // Compare into -1,0,1
9712 instruct cmpF_mem(rRegI dst, regF src1, memory src2, rFlagsReg cr)
9713 %{
9714   match(Set dst (CmpF3 src1 (LoadF src2)));
9715   effect(KILL cr);
9716 
9717   ins_cost(275);
9718   format %{ "ucomiss $src1, $src2\n\t"
9719             "movl    $dst, #-1\n\t"
9720             "jp,s    done\n\t"
9721             "jb,s    done\n\t"
9722             "setne   $dst\n\t"
9723             "movzbl  $dst, $dst\n"
9724     "done:" %}
9725   ins_encode %{
9726     __ ucomiss($src1$$XMMRegister, $src2$$Address);
9727     emit_cmpfp3(_masm, $dst$$Register);
9728   %}
9729   ins_pipe(pipe_slow);
9730 %}
9731 
9732 // Compare into -1,0,1
9733 instruct cmpF_imm(rRegI dst, regF src, immF con, rFlagsReg cr) %{
9734   match(Set dst (CmpF3 src con));
9735   effect(KILL cr);
9736 
9737   ins_cost(275);
9738   format %{ "ucomiss $src, [$constantaddress]\t# load from constant table: float=$con\n\t"
9739             "movl    $dst, #-1\n\t"
9740             "jp,s    done\n\t"
9741             "jb,s    done\n\t"
9742             "setne   $dst\n\t"
9743             "movzbl  $dst, $dst\n"
9744     "done:" %}
9745   ins_encode %{
9746     __ ucomiss($src$$XMMRegister, $constantaddress($con));
9747     emit_cmpfp3(_masm, $dst$$Register);
9748   %}
9749   ins_pipe(pipe_slow);
9750 %}
9751 
9752 // Compare into -1,0,1
9753 instruct cmpD_reg(rRegI dst, regD src1, regD src2, rFlagsReg cr)
9754 %{
9755   match(Set dst (CmpD3 src1 src2));
9756   effect(KILL cr);
9757 
9758   ins_cost(275);
9759   format %{ "ucomisd $src1, $src2\n\t"
9760             "movl    $dst, #-1\n\t"
9761             "jp,s    done\n\t"
9762             "jb,s    done\n\t"
9763             "setne   $dst\n\t"
9764             "movzbl  $dst, $dst\n"
9765     "done:" %}
9766   ins_encode %{
9767     __ ucomisd($src1$$XMMRegister, $src2$$XMMRegister);
9768     emit_cmpfp3(_masm, $dst$$Register);
9769   %}
9770   ins_pipe(pipe_slow);
9771 %}
9772 
9773 // Compare into -1,0,1
9774 instruct cmpD_mem(rRegI dst, regD src1, memory src2, rFlagsReg cr)
9775 %{
9776   match(Set dst (CmpD3 src1 (LoadD src2)));
9777   effect(KILL cr);
9778 
9779   ins_cost(275);
9780   format %{ "ucomisd $src1, $src2\n\t"
9781             "movl    $dst, #-1\n\t"
9782             "jp,s    done\n\t"
9783             "jb,s    done\n\t"
9784             "setne   $dst\n\t"
9785             "movzbl  $dst, $dst\n"
9786     "done:" %}
9787   ins_encode %{
9788     __ ucomisd($src1$$XMMRegister, $src2$$Address);
9789     emit_cmpfp3(_masm, $dst$$Register);
9790   %}
9791   ins_pipe(pipe_slow);
9792 %}
9793 
9794 // Compare into -1,0,1
9795 instruct cmpD_imm(rRegI dst, regD src, immD con, rFlagsReg cr) %{
9796   match(Set dst (CmpD3 src con));
9797   effect(KILL cr);
9798 
9799   ins_cost(275);
9800   format %{ "ucomisd $src, [$constantaddress]\t# load from constant table: double=$con\n\t"
9801             "movl    $dst, #-1\n\t"
9802             "jp,s    done\n\t"
9803             "jb,s    done\n\t"
9804             "setne   $dst\n\t"
9805             "movzbl  $dst, $dst\n"
9806     "done:" %}
9807   ins_encode %{
9808     __ ucomisd($src$$XMMRegister, $constantaddress($con));
9809     emit_cmpfp3(_masm, $dst$$Register);
9810   %}
9811   ins_pipe(pipe_slow);
9812 %}
9813 
9814 // -----------Trig and Trancendental Instructions------------------------------
9815 instruct cosD_reg(regD dst) %{
9816   match(Set dst (CosD dst));
9817 
9818   format %{ "dcos   $dst\n\t" %}
9819   opcode(0xD9, 0xFF);
9820   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9821   ins_pipe( pipe_slow );
9822 %}
9823 
9824 instruct sinD_reg(regD dst) %{
9825   match(Set dst (SinD dst));
9826 
9827   format %{ "dsin   $dst\n\t" %}
9828   opcode(0xD9, 0xFE);
9829   ins_encode( Push_SrcXD(dst), OpcP, OpcS, Push_ResultXD(dst) );
9830   ins_pipe( pipe_slow );
9831 %}
9832 
9833 instruct tanD_reg(regD dst) %{
9834   match(Set dst (TanD dst));
9835 
9836   format %{ "dtan   $dst\n\t" %}
9837   ins_encode( Push_SrcXD(dst),
9838               Opcode(0xD9), Opcode(0xF2),   //fptan
9839               Opcode(0xDD), Opcode(0xD8),   //fstp st
9840               Push_ResultXD(dst) );
9841   ins_pipe( pipe_slow );
9842 %}
9843 
9844 instruct log10D_reg(regD dst) %{
9845   // The source and result Double operands in XMM registers
9846   match(Set dst (Log10D dst));
9847   // fldlg2       ; push log_10(2) on the FPU stack; full 80-bit number
9848   // fyl2x        ; compute log_10(2) * log_2(x)
9849   format %{ "fldlg2\t\t\t#Log10\n\t"
9850             "fyl2x\t\t\t# Q=Log10*Log_2(x)\n\t"
9851          %}
9852    ins_encode(Opcode(0xD9), Opcode(0xEC),   // fldlg2
9853               Push_SrcXD(dst),
9854               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9855               Push_ResultXD(dst));
9856 
9857   ins_pipe( pipe_slow );
9858 %}
9859 
9860 instruct logD_reg(regD dst) %{
9861   // The source and result Double operands in XMM registers
9862   match(Set dst (LogD dst));
9863   // fldln2       ; push log_e(2) on the FPU stack; full 80-bit number
9864   // fyl2x        ; compute log_e(2) * log_2(x)
9865   format %{ "fldln2\t\t\t#Log_e\n\t"
9866             "fyl2x\t\t\t# Q=Log_e*Log_2(x)\n\t"
9867          %}
9868   ins_encode( Opcode(0xD9), Opcode(0xED),   // fldln2
9869               Push_SrcXD(dst),
9870               Opcode(0xD9), Opcode(0xF1),   // fyl2x
9871               Push_ResultXD(dst));
9872   ins_pipe( pipe_slow );
9873 %}
9874 
9875 instruct powD_reg(regD dst, regD src0, regD src1, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9876   match(Set dst (PowD src0 src1));  // Raise src0 to the src1'th power
9877   effect(KILL rax, KILL rdx, KILL rcx, KILL cr);
9878   format %{ "fast_pow $src0 $src1 -&gt; $dst  // KILL $rax, $rcx, $rdx" %}
9879   ins_encode %{
9880     __ subptr(rsp, 8);
9881     __ movdbl(Address(rsp, 0), $src1$$XMMRegister);
9882     __ fld_d(Address(rsp, 0));
9883     __ movdbl(Address(rsp, 0), $src0$$XMMRegister);
9884     __ fld_d(Address(rsp, 0));
9885     __ fast_pow();
9886     __ fstp_d(Address(rsp, 0));
9887     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9888     __ addptr(rsp, 8);
9889   %}
9890   ins_pipe( pipe_slow );
9891 %}
9892 
9893 instruct expD_reg(regD dst, regD src, rax_RegI rax, rdx_RegI rdx, rcx_RegI rcx, rFlagsReg cr) %{
9894   match(Set dst (ExpD src));
9895   effect(KILL rax, KILL rcx, KILL rdx, KILL cr);
9896   format %{ "fast_exp $dst -&gt; $src  // KILL $rax, $rcx, $rdx" %}
9897   ins_encode %{
9898     __ subptr(rsp, 8);
9899     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
9900     __ fld_d(Address(rsp, 0));
9901     __ fast_exp();
9902     __ fstp_d(Address(rsp, 0));
9903     __ movdbl($dst$$XMMRegister, Address(rsp, 0));
9904     __ addptr(rsp, 8);
9905   %}
9906   ins_pipe( pipe_slow );
9907 %}
9908 
9909 //----------Arithmetic Conversion Instructions---------------------------------
9910 
9911 instruct roundFloat_nop(regF dst)
9912 %{
9913   match(Set dst (RoundFloat dst));
9914 
9915   ins_cost(0);
9916   ins_encode();
9917   ins_pipe(empty);
9918 %}
9919 
9920 instruct roundDouble_nop(regD dst)
9921 %{
9922   match(Set dst (RoundDouble dst));
9923 
9924   ins_cost(0);
9925   ins_encode();
9926   ins_pipe(empty);
9927 %}
9928 
9929 instruct convF2D_reg_reg(regD dst, regF src)
9930 %{
9931   match(Set dst (ConvF2D src));
9932 
9933   format %{ "cvtss2sd $dst, $src" %}
9934   ins_encode %{
9935     __ cvtss2sd ($dst$$XMMRegister, $src$$XMMRegister);
9936   %}
9937   ins_pipe(pipe_slow); // XXX
9938 %}
9939 
9940 instruct convF2D_reg_mem(regD dst, memory src)
9941 %{
9942   match(Set dst (ConvF2D (LoadF src)));
9943 
9944   format %{ "cvtss2sd $dst, $src" %}
9945   ins_encode %{
9946     __ cvtss2sd ($dst$$XMMRegister, $src$$Address);
9947   %}
9948   ins_pipe(pipe_slow); // XXX
9949 %}
9950 
9951 instruct convD2F_reg_reg(regF dst, regD src)
9952 %{
9953   match(Set dst (ConvD2F src));
9954 
9955   format %{ "cvtsd2ss $dst, $src" %}
9956   ins_encode %{
9957     __ cvtsd2ss ($dst$$XMMRegister, $src$$XMMRegister);
9958   %}
9959   ins_pipe(pipe_slow); // XXX
9960 %}
9961 
9962 instruct convD2F_reg_mem(regF dst, memory src)
9963 %{
9964   match(Set dst (ConvD2F (LoadD src)));
9965 
9966   format %{ "cvtsd2ss $dst, $src" %}
9967   ins_encode %{
9968     __ cvtsd2ss ($dst$$XMMRegister, $src$$Address);
9969   %}
9970   ins_pipe(pipe_slow); // XXX
9971 %}
9972 
9973 // XXX do mem variants
9974 instruct convF2I_reg_reg(rRegI dst, regF src, rFlagsReg cr)
9975 %{
9976   match(Set dst (ConvF2I src));
9977   effect(KILL cr);
9978 
9979   format %{ "cvttss2sil $dst, $src\t# f2i\n\t"
9980             "cmpl    $dst, #0x80000000\n\t"
9981             "jne,s   done\n\t"
9982             "subq    rsp, #8\n\t"
9983             "movss   [rsp], $src\n\t"
9984             "call    f2i_fixup\n\t"
9985             "popq    $dst\n"
9986     "done:   "%}
9987   ins_encode %{
9988     Label done;
9989     __ cvttss2sil($dst$$Register, $src$$XMMRegister);
9990     __ cmpl($dst$$Register, 0x80000000);
9991     __ jccb(Assembler::notEqual, done);
9992     __ subptr(rsp, 8);
9993     __ movflt(Address(rsp, 0), $src$$XMMRegister);
9994     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2i_fixup())));
9995     __ pop($dst$$Register);
9996     __ bind(done);
9997   %}
9998   ins_pipe(pipe_slow);
9999 %}
10000 
10001 instruct convF2L_reg_reg(rRegL dst, regF src, rFlagsReg cr)
10002 %{
10003   match(Set dst (ConvF2L src));
10004   effect(KILL cr);
10005 
10006   format %{ "cvttss2siq $dst, $src\t# f2l\n\t"
10007             "cmpq    $dst, [0x8000000000000000]\n\t"
10008             "jne,s   done\n\t"
10009             "subq    rsp, #8\n\t"
10010             "movss   [rsp], $src\n\t"
10011             "call    f2l_fixup\n\t"
10012             "popq    $dst\n"
10013     "done:   "%}
10014   ins_encode %{
10015     Label done;
10016     __ cvttss2siq($dst$$Register, $src$$XMMRegister);
10017     __ cmp64($dst$$Register,
10018              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10019     __ jccb(Assembler::notEqual, done);
10020     __ subptr(rsp, 8);
10021     __ movflt(Address(rsp, 0), $src$$XMMRegister);
10022     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::f2l_fixup())));
10023     __ pop($dst$$Register);
10024     __ bind(done);
10025   %}
10026   ins_pipe(pipe_slow);
10027 %}
10028 
10029 instruct convD2I_reg_reg(rRegI dst, regD src, rFlagsReg cr)
10030 %{
10031   match(Set dst (ConvD2I src));
10032   effect(KILL cr);
10033 
10034   format %{ "cvttsd2sil $dst, $src\t# d2i\n\t"
10035             "cmpl    $dst, #0x80000000\n\t"
10036             "jne,s   done\n\t"
10037             "subq    rsp, #8\n\t"
10038             "movsd   [rsp], $src\n\t"
10039             "call    d2i_fixup\n\t"
10040             "popq    $dst\n"
10041     "done:   "%}
10042   ins_encode %{
10043     Label done;
10044     __ cvttsd2sil($dst$$Register, $src$$XMMRegister);
10045     __ cmpl($dst$$Register, 0x80000000);
10046     __ jccb(Assembler::notEqual, done);
10047     __ subptr(rsp, 8);
10048     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10049     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2i_fixup())));
10050     __ pop($dst$$Register);
10051     __ bind(done);
10052   %}
10053   ins_pipe(pipe_slow);
10054 %}
10055 
10056 instruct convD2L_reg_reg(rRegL dst, regD src, rFlagsReg cr)
10057 %{
10058   match(Set dst (ConvD2L src));
10059   effect(KILL cr);
10060 
10061   format %{ "cvttsd2siq $dst, $src\t# d2l\n\t"
10062             "cmpq    $dst, [0x8000000000000000]\n\t"
10063             "jne,s   done\n\t"
10064             "subq    rsp, #8\n\t"
10065             "movsd   [rsp], $src\n\t"
10066             "call    d2l_fixup\n\t"
10067             "popq    $dst\n"
10068     "done:   "%}
10069   ins_encode %{
10070     Label done;
10071     __ cvttsd2siq($dst$$Register, $src$$XMMRegister);
10072     __ cmp64($dst$$Register,
10073              ExternalAddress((address) StubRoutines::x86::double_sign_flip()));
10074     __ jccb(Assembler::notEqual, done);
10075     __ subptr(rsp, 8);
10076     __ movdbl(Address(rsp, 0), $src$$XMMRegister);
10077     __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, StubRoutines::x86::d2l_fixup())));
10078     __ pop($dst$$Register);
10079     __ bind(done);
10080   %}
10081   ins_pipe(pipe_slow);
10082 %}
10083 
10084 instruct convI2F_reg_reg(regF dst, rRegI src)
10085 %{
10086   predicate(!UseXmmI2F);
10087   match(Set dst (ConvI2F src));
10088 
10089   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10090   ins_encode %{
10091     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Register);
10092   %}
10093   ins_pipe(pipe_slow); // XXX
10094 %}
10095 
10096 instruct convI2F_reg_mem(regF dst, memory src)
10097 %{
10098   match(Set dst (ConvI2F (LoadI src)));
10099 
10100   format %{ "cvtsi2ssl $dst, $src\t# i2f" %}
10101   ins_encode %{
10102     __ cvtsi2ssl ($dst$$XMMRegister, $src$$Address);
10103   %}
10104   ins_pipe(pipe_slow); // XXX
10105 %}
10106 
10107 instruct convI2D_reg_reg(regD dst, rRegI src)
10108 %{
10109   predicate(!UseXmmI2D);
10110   match(Set dst (ConvI2D src));
10111 
10112   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10113   ins_encode %{
10114     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Register);
10115   %}
10116   ins_pipe(pipe_slow); // XXX
10117 %}
10118 
10119 instruct convI2D_reg_mem(regD dst, memory src)
10120 %{
10121   match(Set dst (ConvI2D (LoadI src)));
10122 
10123   format %{ "cvtsi2sdl $dst, $src\t# i2d" %}
10124   ins_encode %{
10125     __ cvtsi2sdl ($dst$$XMMRegister, $src$$Address);
10126   %}
10127   ins_pipe(pipe_slow); // XXX
10128 %}
10129 
10130 instruct convXI2F_reg(regF dst, rRegI src)
10131 %{
10132   predicate(UseXmmI2F);
10133   match(Set dst (ConvI2F src));
10134 
10135   format %{ "movdl $dst, $src\n\t"
10136             "cvtdq2psl $dst, $dst\t# i2f" %}
10137   ins_encode %{
10138     __ movdl($dst$$XMMRegister, $src$$Register);
10139     __ cvtdq2ps($dst$$XMMRegister, $dst$$XMMRegister);
10140   %}
10141   ins_pipe(pipe_slow); // XXX
10142 %}
10143 
10144 instruct convXI2D_reg(regD dst, rRegI src)
10145 %{
10146   predicate(UseXmmI2D);
10147   match(Set dst (ConvI2D src));
10148 
10149   format %{ "movdl $dst, $src\n\t"
10150             "cvtdq2pdl $dst, $dst\t# i2d" %}
10151   ins_encode %{
10152     __ movdl($dst$$XMMRegister, $src$$Register);
10153     __ cvtdq2pd($dst$$XMMRegister, $dst$$XMMRegister);
10154   %}
10155   ins_pipe(pipe_slow); // XXX
10156 %}
10157 
10158 instruct convL2F_reg_reg(regF dst, rRegL src)
10159 %{
10160   match(Set dst (ConvL2F src));
10161 
10162   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10163   ins_encode %{
10164     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Register);
10165   %}
10166   ins_pipe(pipe_slow); // XXX
10167 %}
10168 
10169 instruct convL2F_reg_mem(regF dst, memory src)
10170 %{
10171   match(Set dst (ConvL2F (LoadL src)));
10172 
10173   format %{ "cvtsi2ssq $dst, $src\t# l2f" %}
10174   ins_encode %{
10175     __ cvtsi2ssq ($dst$$XMMRegister, $src$$Address);
10176   %}
10177   ins_pipe(pipe_slow); // XXX
10178 %}
10179 
10180 instruct convL2D_reg_reg(regD dst, rRegL src)
10181 %{
10182   match(Set dst (ConvL2D src));
10183 
10184   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10185   ins_encode %{
10186     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Register);
10187   %}
10188   ins_pipe(pipe_slow); // XXX
10189 %}
10190 
10191 instruct convL2D_reg_mem(regD dst, memory src)
10192 %{
10193   match(Set dst (ConvL2D (LoadL src)));
10194 
10195   format %{ "cvtsi2sdq $dst, $src\t# l2d" %}
10196   ins_encode %{
10197     __ cvtsi2sdq ($dst$$XMMRegister, $src$$Address);
10198   %}
10199   ins_pipe(pipe_slow); // XXX
10200 %}
10201 
10202 instruct convI2L_reg_reg(rRegL dst, rRegI src)
10203 %{
10204   match(Set dst (ConvI2L src));
10205 
10206   ins_cost(125);
10207   format %{ "movslq  $dst, $src\t# i2l" %}
10208   ins_encode %{
10209     __ movslq($dst$$Register, $src$$Register);
10210   %}
10211   ins_pipe(ialu_reg_reg);
10212 %}
10213 
10214 // instruct convI2L_reg_reg_foo(rRegL dst, rRegI src)
10215 // %{
10216 //   match(Set dst (ConvI2L src));
10217 // //   predicate(_kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_lo &gt;= 0 &amp;&amp;
10218 // //             _kids[0]-&gt;_leaf-&gt;as_Type()-&gt;type()-&gt;is_int()-&gt;_hi &gt;= 0);
10219 //   predicate(((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi ==
10220 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_hi &amp;&amp;
10221 //             ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo ==
10222 //             (unsigned int) ((const TypeNode*) n)-&gt;type()-&gt;is_long()-&gt;_lo);
10223 
10224 //   format %{ "movl    $dst, $src\t# unsigned i2l" %}
10225 //   ins_encode(enc_copy(dst, src));
10226 // //   opcode(0x63); // needs REX.W
10227 // //   ins_encode(REX_reg_reg_wide(dst, src), OpcP, reg_reg(dst,src));
10228 //   ins_pipe(ialu_reg_reg);
10229 // %}
10230 
10231 // Zero-extend convert int to long
10232 instruct convI2L_reg_reg_zex(rRegL dst, rRegI src, immL_32bits mask)
10233 %{
10234   match(Set dst (AndL (ConvI2L src) mask));
10235 
10236   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10237   ins_encode %{
10238     if ($dst$$reg != $src$$reg) {
10239       __ movl($dst$$Register, $src$$Register);
10240     }
10241   %}
10242   ins_pipe(ialu_reg_reg);
10243 %}
10244 
10245 // Zero-extend convert int to long
10246 instruct convI2L_reg_mem_zex(rRegL dst, memory src, immL_32bits mask)
10247 %{
10248   match(Set dst (AndL (ConvI2L (LoadI src)) mask));
10249 
10250   format %{ "movl    $dst, $src\t# i2l zero-extend\n\t" %}
10251   ins_encode %{
10252     __ movl($dst$$Register, $src$$Address);
10253   %}
10254   ins_pipe(ialu_reg_mem);
10255 %}
10256 
10257 instruct zerox_long_reg_reg(rRegL dst, rRegL src, immL_32bits mask)
10258 %{
10259   match(Set dst (AndL src mask));
10260 
10261   format %{ "movl    $dst, $src\t# zero-extend long" %}
10262   ins_encode %{
10263     __ movl($dst$$Register, $src$$Register);
10264   %}
10265   ins_pipe(ialu_reg_reg);
10266 %}
10267 
10268 instruct convL2I_reg_reg(rRegI dst, rRegL src)
10269 %{
10270   match(Set dst (ConvL2I src));
10271 
10272   format %{ "movl    $dst, $src\t# l2i" %}
10273   ins_encode %{
10274     __ movl($dst$$Register, $src$$Register);
10275   %}
10276   ins_pipe(ialu_reg_reg);
10277 %}
10278 
10279 
10280 instruct MoveF2I_stack_reg(rRegI dst, stackSlotF src) %{
10281   match(Set dst (MoveF2I src));
10282   effect(DEF dst, USE src);
10283 
10284   ins_cost(125);
10285   format %{ "movl    $dst, $src\t# MoveF2I_stack_reg" %}
10286   ins_encode %{
10287     __ movl($dst$$Register, Address(rsp, $src$$disp));
10288   %}
10289   ins_pipe(ialu_reg_mem);
10290 %}
10291 
10292 instruct MoveI2F_stack_reg(regF dst, stackSlotI src) %{
10293   match(Set dst (MoveI2F src));
10294   effect(DEF dst, USE src);
10295 
10296   ins_cost(125);
10297   format %{ "movss   $dst, $src\t# MoveI2F_stack_reg" %}
10298   ins_encode %{
10299     __ movflt($dst$$XMMRegister, Address(rsp, $src$$disp));
10300   %}
10301   ins_pipe(pipe_slow);
10302 %}
10303 
10304 instruct MoveD2L_stack_reg(rRegL dst, stackSlotD src) %{
10305   match(Set dst (MoveD2L src));
10306   effect(DEF dst, USE src);
10307 
10308   ins_cost(125);
10309   format %{ "movq    $dst, $src\t# MoveD2L_stack_reg" %}
10310   ins_encode %{
10311     __ movq($dst$$Register, Address(rsp, $src$$disp));
10312   %}
10313   ins_pipe(ialu_reg_mem);
10314 %}
10315 
10316 instruct MoveL2D_stack_reg_partial(regD dst, stackSlotL src) %{
10317   predicate(!UseXmmLoadAndClearUpper);
10318   match(Set dst (MoveL2D src));
10319   effect(DEF dst, USE src);
10320 
10321   ins_cost(125);
10322   format %{ "movlpd  $dst, $src\t# MoveL2D_stack_reg" %}
10323   ins_encode %{
10324     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10325   %}
10326   ins_pipe(pipe_slow);
10327 %}
10328 
10329 instruct MoveL2D_stack_reg(regD dst, stackSlotL src) %{
10330   predicate(UseXmmLoadAndClearUpper);
10331   match(Set dst (MoveL2D src));
10332   effect(DEF dst, USE src);
10333 
10334   ins_cost(125);
10335   format %{ "movsd   $dst, $src\t# MoveL2D_stack_reg" %}
10336   ins_encode %{
10337     __ movdbl($dst$$XMMRegister, Address(rsp, $src$$disp));
10338   %}
10339   ins_pipe(pipe_slow);
10340 %}
10341 
10342 
10343 instruct MoveF2I_reg_stack(stackSlotI dst, regF src) %{
10344   match(Set dst (MoveF2I src));
10345   effect(DEF dst, USE src);
10346 
10347   ins_cost(95); // XXX
10348   format %{ "movss   $dst, $src\t# MoveF2I_reg_stack" %}
10349   ins_encode %{
10350     __ movflt(Address(rsp, $dst$$disp), $src$$XMMRegister);
10351   %}
10352   ins_pipe(pipe_slow);
10353 %}
10354 
10355 instruct MoveI2F_reg_stack(stackSlotF dst, rRegI src) %{
10356   match(Set dst (MoveI2F src));
10357   effect(DEF dst, USE src);
10358 
10359   ins_cost(100);
10360   format %{ "movl    $dst, $src\t# MoveI2F_reg_stack" %}
10361   ins_encode %{
10362     __ movl(Address(rsp, $dst$$disp), $src$$Register);
10363   %}
10364   ins_pipe( ialu_mem_reg );
10365 %}
10366 
10367 instruct MoveD2L_reg_stack(stackSlotL dst, regD src) %{
10368   match(Set dst (MoveD2L src));
10369   effect(DEF dst, USE src);
10370 
10371   ins_cost(95); // XXX
10372   format %{ "movsd   $dst, $src\t# MoveL2D_reg_stack" %}
10373   ins_encode %{
10374     __ movdbl(Address(rsp, $dst$$disp), $src$$XMMRegister);
10375   %}
10376   ins_pipe(pipe_slow);
10377 %}
10378 
10379 instruct MoveL2D_reg_stack(stackSlotD dst, rRegL src) %{
10380   match(Set dst (MoveL2D src));
10381   effect(DEF dst, USE src);
10382 
10383   ins_cost(100);
10384   format %{ "movq    $dst, $src\t# MoveL2D_reg_stack" %}
10385   ins_encode %{
10386     __ movq(Address(rsp, $dst$$disp), $src$$Register);
10387   %}
10388   ins_pipe(ialu_mem_reg);
10389 %}
10390 
10391 instruct MoveF2I_reg_reg(rRegI dst, regF src) %{
10392   match(Set dst (MoveF2I src));
10393   effect(DEF dst, USE src);
10394   ins_cost(85);
10395   format %{ "movd    $dst,$src\t# MoveF2I" %}
10396   ins_encode %{
10397     __ movdl($dst$$Register, $src$$XMMRegister);
10398   %}
10399   ins_pipe( pipe_slow );
10400 %}
10401 
10402 instruct MoveD2L_reg_reg(rRegL dst, regD src) %{
10403   match(Set dst (MoveD2L src));
10404   effect(DEF dst, USE src);
10405   ins_cost(85);
10406   format %{ "movd    $dst,$src\t# MoveD2L" %}
10407   ins_encode %{
10408     __ movdq($dst$$Register, $src$$XMMRegister);
10409   %}
10410   ins_pipe( pipe_slow );
10411 %}
10412 
10413 instruct MoveI2F_reg_reg(regF dst, rRegI src) %{
10414   match(Set dst (MoveI2F src));
10415   effect(DEF dst, USE src);
10416   ins_cost(100);
10417   format %{ "movd    $dst,$src\t# MoveI2F" %}
10418   ins_encode %{
10419     __ movdl($dst$$XMMRegister, $src$$Register);
10420   %}
10421   ins_pipe( pipe_slow );
10422 %}
10423 
10424 instruct MoveL2D_reg_reg(regD dst, rRegL src) %{
10425   match(Set dst (MoveL2D src));
10426   effect(DEF dst, USE src);
10427   ins_cost(100);
10428   format %{ "movd    $dst,$src\t# MoveL2D" %}
10429   ins_encode %{
10430      __ movdq($dst$$XMMRegister, $src$$Register);
10431   %}
10432   ins_pipe( pipe_slow );
10433 %}
10434 
10435 
10436 // =======================================================================
10437 // fast clearing of an array
10438 instruct rep_stos(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10439                   rFlagsReg cr)
10440 %{
10441   predicate(!UseFastStosb);
10442   match(Set dummy (ClearArray cnt base));
10443   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10444 
10445   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10446             "rep     stosq\t# Store rax to *rdi++ while rcx--" %}
10447   ins_encode %{
10448     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10449   %}
10450   ins_pipe(pipe_slow);
10451 %}
10452 
10453 instruct rep_fast_stosb(rcx_RegL cnt, rdi_RegP base, rax_RegI zero, Universe dummy,
10454                         rFlagsReg cr)
10455 %{
10456   predicate(UseFastStosb);
10457   match(Set dummy (ClearArray cnt base));
10458   effect(USE_KILL cnt, USE_KILL base, KILL zero, KILL cr);
10459   format %{ "xorq    rax, rax\t# ClearArray:\n\t"
10460             "shlq    rcx,3\t# Convert doublewords to bytes\n\t"
10461             "rep     stosb\t# Store rax to *rdi++ while rcx--" %}
10462   ins_encode %{
10463     __ clear_mem($base$$Register, $cnt$$Register, $zero$$Register);
10464   %}
10465   ins_pipe( pipe_slow );
10466 %}
10467 
10468 instruct string_compare(rdi_RegP str1, rcx_RegI cnt1, rsi_RegP str2, rdx_RegI cnt2,
10469                         rax_RegI result, regD tmp1, rFlagsReg cr)
10470 %{
10471   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
10472   effect(TEMP tmp1, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);
10473 
10474   format %{ "String Compare $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL $tmp1" %}
10475   ins_encode %{
10476     __ string_compare($str1$$Register, $str2$$Register,
10477                       $cnt1$$Register, $cnt2$$Register, $result$$Register,
10478                       $tmp1$$XMMRegister);
10479   %}
10480   ins_pipe( pipe_slow );
10481 %}
10482 
10483 // fast search of substring with known size.
10484 instruct string_indexof_con(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, immI int_cnt2,
10485                             rbx_RegI result, regD vec, rax_RegI cnt2, rcx_RegI tmp, rFlagsReg cr)
10486 %{
10487   predicate(UseSSE42Intrinsics);
10488   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 int_cnt2)));
10489   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, KILL cnt2, KILL tmp, KILL cr);
10490 
10491   format %{ "String IndexOf $str1,$cnt1,$str2,$int_cnt2 -&gt; $result   // KILL $vec, $cnt1, $cnt2, $tmp" %}
10492   ins_encode %{
10493     int icnt2 = (int)$int_cnt2$$constant;
10494     if (icnt2 &gt;= 8) {
10495       // IndexOf for constant substrings with size &gt;= 8 elements
10496       // which don't need to be loaded through stack.
10497       __ string_indexofC8($str1$$Register, $str2$$Register,
10498                           $cnt1$$Register, $cnt2$$Register,
10499                           icnt2, $result$$Register,
10500                           $vec$$XMMRegister, $tmp$$Register);
10501     } else {
10502       // Small strings are loaded through stack if they cross page boundary.
10503       __ string_indexof($str1$$Register, $str2$$Register,
10504                         $cnt1$$Register, $cnt2$$Register,
10505                         icnt2, $result$$Register,
10506                         $vec$$XMMRegister, $tmp$$Register);
10507     }
10508   %}
10509   ins_pipe( pipe_slow );
10510 %}
10511 
10512 instruct string_indexof(rdi_RegP str1, rdx_RegI cnt1, rsi_RegP str2, rax_RegI cnt2,
10513                         rbx_RegI result, regD vec, rcx_RegI tmp, rFlagsReg cr)
10514 %{
10515   predicate(UseSSE42Intrinsics);
10516   match(Set result (StrIndexOf (Binary str1 cnt1) (Binary str2 cnt2)));
10517   effect(TEMP vec, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL tmp, KILL cr);
10518 
10519   format %{ "String IndexOf $str1,$cnt1,$str2,$cnt2 -&gt; $result   // KILL all" %}
10520   ins_encode %{
10521     __ string_indexof($str1$$Register, $str2$$Register,
10522                       $cnt1$$Register, $cnt2$$Register,
10523                       (-1), $result$$Register,
10524                       $vec$$XMMRegister, $tmp$$Register);
10525   %}
10526   ins_pipe( pipe_slow );
10527 %}
10528 
10529 // fast string equals
10530 instruct string_equals(rdi_RegP str1, rsi_RegP str2, rcx_RegI cnt, rax_RegI result,
10531                        regD tmp1, regD tmp2, rbx_RegI tmp3, rFlagsReg cr)
10532 %{
10533   match(Set result (StrEquals (Binary str1 str2) cnt));
10534   effect(TEMP tmp1, TEMP tmp2, USE_KILL str1, USE_KILL str2, USE_KILL cnt, KILL tmp3, KILL cr);
10535 
10536   format %{ "String Equals $str1,$str2,$cnt -&gt; $result    // KILL $tmp1, $tmp2, $tmp3" %}
10537   ins_encode %{
10538     __ char_arrays_equals(false, $str1$$Register, $str2$$Register,
10539                           $cnt$$Register, $result$$Register, $tmp3$$Register,
10540                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10541   %}
10542   ins_pipe( pipe_slow );
10543 %}
10544 
10545 // fast array equals
10546 instruct array_equals(rdi_RegP ary1, rsi_RegP ary2, rax_RegI result,
10547                       regD tmp1, regD tmp2, rcx_RegI tmp3, rbx_RegI tmp4, rFlagsReg cr)
10548 %{
10549   match(Set result (AryEq ary1 ary2));
10550   effect(TEMP tmp1, TEMP tmp2, USE_KILL ary1, USE_KILL ary2, KILL tmp3, KILL tmp4, KILL cr);
10551   //ins_cost(300);
10552 
10553   format %{ "Array Equals $ary1,$ary2 -&gt; $result   // KILL $tmp1, $tmp2, $tmp3, $tmp4" %}
10554   ins_encode %{
10555     __ char_arrays_equals(true, $ary1$$Register, $ary2$$Register,
10556                           $tmp3$$Register, $result$$Register, $tmp4$$Register,
10557                           $tmp1$$XMMRegister, $tmp2$$XMMRegister);
10558   %}
10559   ins_pipe( pipe_slow );
10560 %}
10561 
10562 // encode char[] to byte[] in ISO_8859_1
10563 instruct encode_iso_array(rsi_RegP src, rdi_RegP dst, rdx_RegI len,
10564                           regD tmp1, regD tmp2, regD tmp3, regD tmp4,
10565                           rcx_RegI tmp5, rax_RegI result, rFlagsReg cr) %{
10566   match(Set result (EncodeISOArray src (Binary dst len)));
10567   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL src, USE_KILL dst, USE_KILL len, KILL tmp5, KILL cr);
10568 
10569   format %{ "Encode array $src,$dst,$len -&gt; $result    // KILL RCX, RDX, $tmp1, $tmp2, $tmp3, $tmp4, RSI, RDI " %}
10570   ins_encode %{
10571     __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register,
10572                         $tmp1$$XMMRegister, $tmp2$$XMMRegister, $tmp3$$XMMRegister,
10573                         $tmp4$$XMMRegister, $tmp5$$Register, $result$$Register);
10574   %}
10575   ins_pipe( pipe_slow );
10576 %}
10577 
10578 //----------Overflow Math Instructions-----------------------------------------
10579 
10580 instruct overflowAddI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10581 %{
10582   match(Set cr (OverflowAddI op1 op2));
10583   effect(DEF cr, USE_KILL op1, USE op2);
10584 
10585   format %{ "addl    $op1, $op2\t# overflow check int" %}
10586 
10587   ins_encode %{
10588     __ addl($op1$$Register, $op2$$Register);
10589   %}
10590   ins_pipe(ialu_reg_reg);
10591 %}
10592 
10593 instruct overflowAddI_rReg_imm(rFlagsReg cr, rax_RegI op1, immI op2)
10594 %{
10595   match(Set cr (OverflowAddI op1 op2));
10596   effect(DEF cr, USE_KILL op1, USE op2);
10597 
10598   format %{ "addl    $op1, $op2\t# overflow check int" %}
10599 
10600   ins_encode %{
10601     __ addl($op1$$Register, $op2$$constant);
10602   %}
10603   ins_pipe(ialu_reg_reg);
10604 %}
10605 
10606 instruct overflowAddL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10607 %{
10608   match(Set cr (OverflowAddL op1 op2));
10609   effect(DEF cr, USE_KILL op1, USE op2);
10610 
10611   format %{ "addq    $op1, $op2\t# overflow check long" %}
10612   ins_encode %{
10613     __ addq($op1$$Register, $op2$$Register);
10614   %}
10615   ins_pipe(ialu_reg_reg);
10616 %}
10617 
10618 instruct overflowAddL_rReg_imm(rFlagsReg cr, rax_RegL op1, immL32 op2)
10619 %{
10620   match(Set cr (OverflowAddL op1 op2));
10621   effect(DEF cr, USE_KILL op1, USE op2);
10622 
10623   format %{ "addq    $op1, $op2\t# overflow check long" %}
10624   ins_encode %{
10625     __ addq($op1$$Register, $op2$$constant);
10626   %}
10627   ins_pipe(ialu_reg_reg);
10628 %}
10629 
10630 instruct overflowSubI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10631 %{
10632   match(Set cr (OverflowSubI op1 op2));
10633 
10634   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10635   ins_encode %{
10636     __ cmpl($op1$$Register, $op2$$Register);
10637   %}
10638   ins_pipe(ialu_reg_reg);
10639 %}
10640 
10641 instruct overflowSubI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10642 %{
10643   match(Set cr (OverflowSubI op1 op2));
10644 
10645   format %{ "cmpl    $op1, $op2\t# overflow check int" %}
10646   ins_encode %{
10647     __ cmpl($op1$$Register, $op2$$constant);
10648   %}
10649   ins_pipe(ialu_reg_reg);
10650 %}
10651 
10652 instruct overflowSubL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
10653 %{
10654   match(Set cr (OverflowSubL op1 op2));
10655 
10656   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10657   ins_encode %{
10658     __ cmpq($op1$$Register, $op2$$Register);
10659   %}
10660   ins_pipe(ialu_reg_reg);
10661 %}
10662 
10663 instruct overflowSubL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
10664 %{
10665   match(Set cr (OverflowSubL op1 op2));
10666 
10667   format %{ "cmpq    $op1, $op2\t# overflow check long" %}
10668   ins_encode %{
10669     __ cmpq($op1$$Register, $op2$$constant);
10670   %}
10671   ins_pipe(ialu_reg_reg);
10672 %}
10673 
10674 instruct overflowNegI_rReg(rFlagsReg cr, immI0 zero, rax_RegI op2)
10675 %{
10676   match(Set cr (OverflowSubI zero op2));
10677   effect(DEF cr, USE_KILL op2);
10678 
10679   format %{ "negl    $op2\t# overflow check int" %}
10680   ins_encode %{
10681     __ negl($op2$$Register);
10682   %}
10683   ins_pipe(ialu_reg_reg);
10684 %}
10685 
10686 instruct overflowNegL_rReg(rFlagsReg cr, immL0 zero, rax_RegL op2)
10687 %{
10688   match(Set cr (OverflowSubL zero op2));
10689   effect(DEF cr, USE_KILL op2);
10690 
10691   format %{ "negq    $op2\t# overflow check long" %}
10692   ins_encode %{
10693     __ negq($op2$$Register);
10694   %}
10695   ins_pipe(ialu_reg_reg);
10696 %}
10697 
10698 instruct overflowMulI_rReg(rFlagsReg cr, rax_RegI op1, rRegI op2)
10699 %{
10700   match(Set cr (OverflowMulI op1 op2));
10701   effect(DEF cr, USE_KILL op1, USE op2);
10702 
10703   format %{ "imull    $op1, $op2\t# overflow check int" %}
10704   ins_encode %{
10705     __ imull($op1$$Register, $op2$$Register);
10706   %}
10707   ins_pipe(ialu_reg_reg_alu0);
10708 %}
10709 
10710 instruct overflowMulI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2, rRegI tmp)
10711 %{
10712   match(Set cr (OverflowMulI op1 op2));
10713   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10714 
10715   format %{ "imull    $tmp, $op1, $op2\t# overflow check int" %}
10716   ins_encode %{
10717     __ imull($tmp$$Register, $op1$$Register, $op2$$constant);
10718   %}
10719   ins_pipe(ialu_reg_reg_alu0);
10720 %}
10721 
10722 instruct overflowMulL_rReg(rFlagsReg cr, rax_RegL op1, rRegL op2)
10723 %{
10724   match(Set cr (OverflowMulL op1 op2));
10725   effect(DEF cr, USE_KILL op1, USE op2);
10726 
10727   format %{ "imulq    $op1, $op2\t# overflow check long" %}
10728   ins_encode %{
10729     __ imulq($op1$$Register, $op2$$Register);
10730   %}
10731   ins_pipe(ialu_reg_reg_alu0);
10732 %}
10733 
10734 instruct overflowMulL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2, rRegL tmp)
10735 %{
10736   match(Set cr (OverflowMulL op1 op2));
10737   effect(DEF cr, TEMP tmp, USE op1, USE op2);
10738 
10739   format %{ "imulq    $tmp, $op1, $op2\t# overflow check long" %}
10740   ins_encode %{
10741     __ imulq($tmp$$Register, $op1$$Register, $op2$$constant);
10742   %}
10743   ins_pipe(ialu_reg_reg_alu0);
10744 %}
10745 
10746 
10747 //----------Control Flow Instructions------------------------------------------
10748 // Signed compare Instructions
10749 
10750 // XXX more variants!!
10751 instruct compI_rReg(rFlagsReg cr, rRegI op1, rRegI op2)
10752 %{
10753   match(Set cr (CmpI op1 op2));
10754   effect(DEF cr, USE op1, USE op2);
10755 
10756   format %{ "cmpl    $op1, $op2" %}
10757   opcode(0x3B);  /* Opcode 3B /r */
10758   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10759   ins_pipe(ialu_cr_reg_reg);
10760 %}
10761 
10762 instruct compI_rReg_imm(rFlagsReg cr, rRegI op1, immI op2)
10763 %{
10764   match(Set cr (CmpI op1 op2));
10765 
10766   format %{ "cmpl    $op1, $op2" %}
10767   opcode(0x81, 0x07); /* Opcode 81 /7 */
10768   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10769   ins_pipe(ialu_cr_reg_imm);
10770 %}
10771 
10772 instruct compI_rReg_mem(rFlagsReg cr, rRegI op1, memory op2)
10773 %{
10774   match(Set cr (CmpI op1 (LoadI op2)));
10775 
10776   ins_cost(500); // XXX
10777   format %{ "cmpl    $op1, $op2" %}
10778   opcode(0x3B); /* Opcode 3B /r */
10779   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10780   ins_pipe(ialu_cr_reg_mem);
10781 %}
10782 
10783 instruct testI_reg(rFlagsReg cr, rRegI src, immI0 zero)
10784 %{
10785   match(Set cr (CmpI src zero));
10786 
10787   format %{ "testl   $src, $src" %}
10788   opcode(0x85);
10789   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10790   ins_pipe(ialu_cr_reg_imm);
10791 %}
10792 
10793 instruct testI_reg_imm(rFlagsReg cr, rRegI src, immI con, immI0 zero)
10794 %{
10795   match(Set cr (CmpI (AndI src con) zero));
10796 
10797   format %{ "testl   $src, $con" %}
10798   opcode(0xF7, 0x00);
10799   ins_encode(REX_reg(src), OpcP, reg_opc(src), Con32(con));
10800   ins_pipe(ialu_cr_reg_imm);
10801 %}
10802 
10803 instruct testI_reg_mem(rFlagsReg cr, rRegI src, memory mem, immI0 zero)
10804 %{
10805   match(Set cr (CmpI (AndI src (LoadI mem)) zero));
10806 
10807   format %{ "testl   $src, $mem" %}
10808   opcode(0x85);
10809   ins_encode(REX_reg_mem(src, mem), OpcP, reg_mem(src, mem));
10810   ins_pipe(ialu_cr_reg_mem);
10811 %}
10812 
10813 // Unsigned compare Instructions; really, same as signed except they
10814 // produce an rFlagsRegU instead of rFlagsReg.
10815 instruct compU_rReg(rFlagsRegU cr, rRegI op1, rRegI op2)
10816 %{
10817   match(Set cr (CmpU op1 op2));
10818 
10819   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10820   opcode(0x3B); /* Opcode 3B /r */
10821   ins_encode(REX_reg_reg(op1, op2), OpcP, reg_reg(op1, op2));
10822   ins_pipe(ialu_cr_reg_reg);
10823 %}
10824 
10825 instruct compU_rReg_imm(rFlagsRegU cr, rRegI op1, immI op2)
10826 %{
10827   match(Set cr (CmpU op1 op2));
10828 
10829   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10830   opcode(0x81,0x07); /* Opcode 81 /7 */
10831   ins_encode(OpcSErm(op1, op2), Con8or32(op2));
10832   ins_pipe(ialu_cr_reg_imm);
10833 %}
10834 
10835 instruct compU_rReg_mem(rFlagsRegU cr, rRegI op1, memory op2)
10836 %{
10837   match(Set cr (CmpU op1 (LoadI op2)));
10838 
10839   ins_cost(500); // XXX
10840   format %{ "cmpl    $op1, $op2\t# unsigned" %}
10841   opcode(0x3B); /* Opcode 3B /r */
10842   ins_encode(REX_reg_mem(op1, op2), OpcP, reg_mem(op1, op2));
10843   ins_pipe(ialu_cr_reg_mem);
10844 %}
10845 
10846 // // // Cisc-spilled version of cmpU_rReg
10847 // //instruct compU_mem_rReg(rFlagsRegU cr, memory op1, rRegI op2)
10848 // //%{
10849 // //  match(Set cr (CmpU (LoadI op1) op2));
10850 // //
10851 // //  format %{ "CMPu   $op1,$op2" %}
10852 // //  ins_cost(500);
10853 // //  opcode(0x39);  /* Opcode 39 /r */
10854 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10855 // //%}
10856 
10857 instruct testU_reg(rFlagsRegU cr, rRegI src, immI0 zero)
10858 %{
10859   match(Set cr (CmpU src zero));
10860 
10861   format %{ "testl  $src, $src\t# unsigned" %}
10862   opcode(0x85);
10863   ins_encode(REX_reg_reg(src, src), OpcP, reg_reg(src, src));
10864   ins_pipe(ialu_cr_reg_imm);
10865 %}
10866 
10867 instruct compP_rReg(rFlagsRegU cr, rRegP op1, rRegP op2)
10868 %{
10869   match(Set cr (CmpP op1 op2));
10870 
10871   format %{ "cmpq    $op1, $op2\t# ptr" %}
10872   opcode(0x3B); /* Opcode 3B /r */
10873   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
10874   ins_pipe(ialu_cr_reg_reg);
10875 %}
10876 
10877 instruct compP_rReg_mem(rFlagsRegU cr, rRegP op1, memory op2)
10878 %{
10879   match(Set cr (CmpP op1 (LoadP op2)));
10880 
10881   ins_cost(500); // XXX
10882   format %{ "cmpq    $op1, $op2\t# ptr" %}
10883   opcode(0x3B); /* Opcode 3B /r */
10884   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10885   ins_pipe(ialu_cr_reg_mem);
10886 %}
10887 
10888 // // // Cisc-spilled version of cmpP_rReg
10889 // //instruct compP_mem_rReg(rFlagsRegU cr, memory op1, rRegP op2)
10890 // //%{
10891 // //  match(Set cr (CmpP (LoadP op1) op2));
10892 // //
10893 // //  format %{ "CMPu   $op1,$op2" %}
10894 // //  ins_cost(500);
10895 // //  opcode(0x39);  /* Opcode 39 /r */
10896 // //  ins_encode( OpcP, reg_mem( op1, op2) );
10897 // //%}
10898 
10899 // XXX this is generalized by compP_rReg_mem???
10900 // Compare raw pointer (used in out-of-heap check).
10901 // Only works because non-oop pointers must be raw pointers
10902 // and raw pointers have no anti-dependencies.
10903 instruct compP_mem_rReg(rFlagsRegU cr, rRegP op1, memory op2)
10904 %{
10905   predicate(n-&gt;in(2)-&gt;in(2)-&gt;bottom_type()-&gt;reloc() == relocInfo::none);
10906   match(Set cr (CmpP op1 (LoadP op2)));
10907 
10908   format %{ "cmpq    $op1, $op2\t# raw ptr" %}
10909   opcode(0x3B); /* Opcode 3B /r */
10910   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
10911   ins_pipe(ialu_cr_reg_mem);
10912 %}
10913 
10914 // This will generate a signed flags result. This should be OK since
10915 // any compare to a zero should be eq/neq.
10916 instruct testP_reg(rFlagsReg cr, rRegP src, immP0 zero)
10917 %{
10918   match(Set cr (CmpP src zero));
10919 
10920   format %{ "testq   $src, $src\t# ptr" %}
10921   opcode(0x85);
10922   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
10923   ins_pipe(ialu_cr_reg_imm);
10924 %}
10925 
10926 // This will generate a signed flags result. This should be OK since
10927 // any compare to a zero should be eq/neq.
10928 instruct testP_mem(rFlagsReg cr, memory op, immP0 zero)
10929 %{
10930   predicate(!UseCompressedOops || (Universe::narrow_oop_base() != NULL));
10931   match(Set cr (CmpP (LoadP op) zero));
10932 
10933   ins_cost(500); // XXX
10934   format %{ "testq   $op, 0xffffffffffffffff\t# ptr" %}
10935   opcode(0xF7); /* Opcode F7 /0 */
10936   ins_encode(REX_mem_wide(op),
10937              OpcP, RM_opc_mem(0x00, op), Con_d32(0xFFFFFFFF));
10938   ins_pipe(ialu_cr_reg_imm);
10939 %}
10940 
10941 instruct testP_mem_reg0(rFlagsReg cr, memory mem, immP0 zero)
10942 %{
10943   predicate(UseCompressedOops &amp;&amp; (Universe::narrow_oop_base() == NULL) &amp;&amp; (Universe::narrow_klass_base() == NULL));
10944   match(Set cr (CmpP (LoadP mem) zero));
10945 
10946   format %{ "cmpq    R12, $mem\t# ptr (R12_heapbase==0)" %}
10947   ins_encode %{
10948     __ cmpq(r12, $mem$$Address);
10949   %}
10950   ins_pipe(ialu_cr_reg_mem);
10951 %}
10952 
10953 instruct compN_rReg(rFlagsRegU cr, rRegN op1, rRegN op2)
10954 %{
10955   match(Set cr (CmpN op1 op2));
10956 
10957   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10958   ins_encode %{ __ cmpl($op1$$Register, $op2$$Register); %}
10959   ins_pipe(ialu_cr_reg_reg);
10960 %}
10961 
10962 instruct compN_rReg_mem(rFlagsRegU cr, rRegN src, memory mem)
10963 %{
10964   match(Set cr (CmpN src (LoadN mem)));
10965 
10966   format %{ "cmpl    $src, $mem\t# compressed ptr" %}
10967   ins_encode %{
10968     __ cmpl($src$$Register, $mem$$Address);
10969   %}
10970   ins_pipe(ialu_cr_reg_mem);
10971 %}
10972 
10973 instruct compN_rReg_imm(rFlagsRegU cr, rRegN op1, immN op2) %{
10974   match(Set cr (CmpN op1 op2));
10975 
10976   format %{ "cmpl    $op1, $op2\t# compressed ptr" %}
10977   ins_encode %{
10978     __ cmp_narrow_oop($op1$$Register, (jobject)$op2$$constant);
10979   %}
10980   ins_pipe(ialu_cr_reg_imm);
10981 %}
10982 
10983 instruct compN_mem_imm(rFlagsRegU cr, memory mem, immN src)
10984 %{
10985   match(Set cr (CmpN src (LoadN mem)));
10986 
10987   format %{ "cmpl    $mem, $src\t# compressed ptr" %}
10988   ins_encode %{
10989     __ cmp_narrow_oop($mem$$Address, (jobject)$src$$constant);
10990   %}
10991   ins_pipe(ialu_cr_reg_mem);
10992 %}
10993 
10994 instruct compN_rReg_imm_klass(rFlagsRegU cr, rRegN op1, immNKlass op2) %{
10995   match(Set cr (CmpN op1 op2));
10996 
10997   format %{ "cmpl    $op1, $op2\t# compressed klass ptr" %}
10998   ins_encode %{
10999     __ cmp_narrow_klass($op1$$Register, (Klass*)$op2$$constant);
11000   %}
11001   ins_pipe(ialu_cr_reg_imm);
11002 %}
11003 
11004 instruct compN_mem_imm_klass(rFlagsRegU cr, memory mem, immNKlass src)
11005 %{
11006   match(Set cr (CmpN src (LoadNKlass mem)));
11007 
11008   format %{ "cmpl    $mem, $src\t# compressed klass ptr" %}
11009   ins_encode %{
11010     __ cmp_narrow_klass($mem$$Address, (Klass*)$src$$constant);
11011   %}
11012   ins_pipe(ialu_cr_reg_mem);
11013 %}
11014 
11015 instruct testN_reg(rFlagsReg cr, rRegN src, immN0 zero) %{
11016   match(Set cr (CmpN src zero));
11017 
11018   format %{ "testl   $src, $src\t# compressed ptr" %}
11019   ins_encode %{ __ testl($src$$Register, $src$$Register); %}
11020   ins_pipe(ialu_cr_reg_imm);
11021 %}
11022 
11023 instruct testN_mem(rFlagsReg cr, memory mem, immN0 zero)
11024 %{
11025   predicate(Universe::narrow_oop_base() != NULL);
11026   match(Set cr (CmpN (LoadN mem) zero));
11027 
11028   ins_cost(500); // XXX
11029   format %{ "testl   $mem, 0xffffffff\t# compressed ptr" %}
11030   ins_encode %{
11031     __ cmpl($mem$$Address, (int)0xFFFFFFFF);
11032   %}
11033   ins_pipe(ialu_cr_reg_mem);
11034 %}
11035 
11036 instruct testN_mem_reg0(rFlagsReg cr, memory mem, immN0 zero)
11037 %{
11038   predicate(Universe::narrow_oop_base() == NULL &amp;&amp; (Universe::narrow_klass_base() == NULL));
11039   match(Set cr (CmpN (LoadN mem) zero));
11040 
11041   format %{ "cmpl    R12, $mem\t# compressed ptr (R12_heapbase==0)" %}
11042   ins_encode %{
11043     __ cmpl(r12, $mem$$Address);
11044   %}
11045   ins_pipe(ialu_cr_reg_mem);
11046 %}
11047 
11048 // Yanked all unsigned pointer compare operations.
11049 // Pointer compares are done with CmpP which is already unsigned.
11050 
11051 instruct compL_rReg(rFlagsReg cr, rRegL op1, rRegL op2)
11052 %{
11053   match(Set cr (CmpL op1 op2));
11054 
11055   format %{ "cmpq    $op1, $op2" %}
11056   opcode(0x3B);  /* Opcode 3B /r */
11057   ins_encode(REX_reg_reg_wide(op1, op2), OpcP, reg_reg(op1, op2));
11058   ins_pipe(ialu_cr_reg_reg);
11059 %}
11060 
11061 instruct compL_rReg_imm(rFlagsReg cr, rRegL op1, immL32 op2)
11062 %{
11063   match(Set cr (CmpL op1 op2));
11064 
11065   format %{ "cmpq    $op1, $op2" %}
11066   opcode(0x81, 0x07); /* Opcode 81 /7 */
11067   ins_encode(OpcSErm_wide(op1, op2), Con8or32(op2));
11068   ins_pipe(ialu_cr_reg_imm);
11069 %}
11070 
11071 instruct compL_rReg_mem(rFlagsReg cr, rRegL op1, memory op2)
11072 %{
11073   match(Set cr (CmpL op1 (LoadL op2)));
11074 
11075   format %{ "cmpq    $op1, $op2" %}
11076   opcode(0x3B); /* Opcode 3B /r */
11077   ins_encode(REX_reg_mem_wide(op1, op2), OpcP, reg_mem(op1, op2));
11078   ins_pipe(ialu_cr_reg_mem);
11079 %}
11080 
11081 instruct testL_reg(rFlagsReg cr, rRegL src, immL0 zero)
11082 %{
11083   match(Set cr (CmpL src zero));
11084 
11085   format %{ "testq   $src, $src" %}
11086   opcode(0x85);
11087   ins_encode(REX_reg_reg_wide(src, src), OpcP, reg_reg(src, src));
11088   ins_pipe(ialu_cr_reg_imm);
11089 %}
11090 
11091 instruct testL_reg_imm(rFlagsReg cr, rRegL src, immL32 con, immL0 zero)
11092 %{
11093   match(Set cr (CmpL (AndL src con) zero));
11094 
11095   format %{ "testq   $src, $con\t# long" %}
11096   opcode(0xF7, 0x00);
11097   ins_encode(REX_reg_wide(src), OpcP, reg_opc(src), Con32(con));
11098   ins_pipe(ialu_cr_reg_imm);
11099 %}
11100 
11101 instruct testL_reg_mem(rFlagsReg cr, rRegL src, memory mem, immL0 zero)
11102 %{
11103   match(Set cr (CmpL (AndL src (LoadL mem)) zero));
11104 
11105   format %{ "testq   $src, $mem" %}
11106   opcode(0x85);
11107   ins_encode(REX_reg_mem_wide(src, mem), OpcP, reg_mem(src, mem));
11108   ins_pipe(ialu_cr_reg_mem);
11109 %}
11110 
11111 // Manifest a CmpL result in an integer register.  Very painful.
11112 // This is the test to avoid.
11113 instruct cmpL3_reg_reg(rRegI dst, rRegL src1, rRegL src2, rFlagsReg flags)
11114 %{
11115   match(Set dst (CmpL3 src1 src2));
11116   effect(KILL flags);
11117 
11118   ins_cost(275); // XXX
11119   format %{ "cmpq    $src1, $src2\t# CmpL3\n\t"
11120             "movl    $dst, -1\n\t"
11121             "jl,s    done\n\t"
11122             "setne   $dst\n\t"
11123             "movzbl  $dst, $dst\n\t"
11124     "done:" %}
11125   ins_encode(cmpl3_flag(src1, src2, dst));
11126   ins_pipe(pipe_slow);
11127 %}
11128 
11129 //----------Max and Min--------------------------------------------------------
11130 // Min Instructions
11131 
11132 instruct cmovI_reg_g(rRegI dst, rRegI src, rFlagsReg cr)
11133 %{
11134   effect(USE_DEF dst, USE src, USE cr);
11135 
11136   format %{ "cmovlgt $dst, $src\t# min" %}
11137   opcode(0x0F, 0x4F);
11138   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11139   ins_pipe(pipe_cmov_reg);
11140 %}
11141 
11142 
11143 instruct minI_rReg(rRegI dst, rRegI src)
11144 %{
11145   match(Set dst (MinI dst src));
11146 
11147   ins_cost(200);
11148   expand %{
11149     rFlagsReg cr;
11150     compI_rReg(cr, dst, src);
11151     cmovI_reg_g(dst, src, cr);
11152   %}
11153 %}
11154 
11155 instruct cmovI_reg_l(rRegI dst, rRegI src, rFlagsReg cr)
11156 %{
11157   effect(USE_DEF dst, USE src, USE cr);
11158 
11159   format %{ "cmovllt $dst, $src\t# max" %}
11160   opcode(0x0F, 0x4C);
11161   ins_encode(REX_reg_reg(dst, src), OpcP, OpcS, reg_reg(dst, src));
11162   ins_pipe(pipe_cmov_reg);
11163 %}
11164 
11165 
11166 instruct maxI_rReg(rRegI dst, rRegI src)
11167 %{
11168   match(Set dst (MaxI dst src));
11169 
11170   ins_cost(200);
11171   expand %{
11172     rFlagsReg cr;
11173     compI_rReg(cr, dst, src);
11174     cmovI_reg_l(dst, src, cr);
11175   %}
11176 %}
11177 
11178 // ============================================================================
11179 // Branch Instructions
11180 
11181 // Jump Direct - Label defines a relative address from JMP+1
11182 instruct jmpDir(label labl)
11183 %{
11184   match(Goto);
11185   effect(USE labl);
11186 
11187   ins_cost(300);
11188   format %{ "jmp     $labl" %}
11189   size(5);
11190   ins_encode %{
11191     Label* L = $labl$$label;
11192     __ jmp(*L, false); // Always long jump
11193   %}
11194   ins_pipe(pipe_jmp);
11195 %}
11196 
11197 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11198 instruct jmpCon(cmpOp cop, rFlagsReg cr, label labl)
11199 %{
11200   match(If cop cr);
11201   effect(USE labl);
11202 
11203   ins_cost(300);
11204   format %{ "j$cop     $labl" %}
11205   size(6);
11206   ins_encode %{
11207     Label* L = $labl$$label;
11208     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11209   %}
11210   ins_pipe(pipe_jcc);
11211 %}
11212 
11213 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11214 instruct jmpLoopEnd(cmpOp cop, rFlagsReg cr, label labl)
11215 %{
11216   match(CountedLoopEnd cop cr);
11217   effect(USE labl);
11218 
11219   ins_cost(300);
11220   format %{ "j$cop     $labl\t# loop end" %}
11221   size(6);
11222   ins_encode %{
11223     Label* L = $labl$$label;
11224     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11225   %}
11226   ins_pipe(pipe_jcc);
11227 %}
11228 
11229 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11230 instruct jmpLoopEndU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11231   match(CountedLoopEnd cop cmp);
11232   effect(USE labl);
11233 
11234   ins_cost(300);
11235   format %{ "j$cop,u   $labl\t# loop end" %}
11236   size(6);
11237   ins_encode %{
11238     Label* L = $labl$$label;
11239     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11240   %}
11241   ins_pipe(pipe_jcc);
11242 %}
11243 
11244 instruct jmpLoopEndUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11245   match(CountedLoopEnd cop cmp);
11246   effect(USE labl);
11247 
11248   ins_cost(200);
11249   format %{ "j$cop,u   $labl\t# loop end" %}
11250   size(6);
11251   ins_encode %{
11252     Label* L = $labl$$label;
11253     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11254   %}
11255   ins_pipe(pipe_jcc);
11256 %}
11257 
11258 // Jump Direct Conditional - using unsigned comparison
11259 instruct jmpConU(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11260   match(If cop cmp);
11261   effect(USE labl);
11262 
11263   ins_cost(300);
11264   format %{ "j$cop,u  $labl" %}
11265   size(6);
11266   ins_encode %{
11267     Label* L = $labl$$label;
11268     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11269   %}
11270   ins_pipe(pipe_jcc);
11271 %}
11272 
11273 instruct jmpConUCF(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11274   match(If cop cmp);
11275   effect(USE labl);
11276 
11277   ins_cost(200);
11278   format %{ "j$cop,u  $labl" %}
11279   size(6);
11280   ins_encode %{
11281     Label* L = $labl$$label;
11282     __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); // Always long jump
11283   %}
11284   ins_pipe(pipe_jcc);
11285 %}
11286 
11287 instruct jmpConUCF2(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11288   match(If cop cmp);
11289   effect(USE labl);
11290 
11291   ins_cost(200);
11292   format %{ $$template
11293     if ($cop$$cmpcode == Assembler::notEqual) {
11294       $$emit$$"jp,u   $labl\n\t"
11295       $$emit$$"j$cop,u   $labl"
11296     } else {
11297       $$emit$$"jp,u   done\n\t"
11298       $$emit$$"j$cop,u   $labl\n\t"
11299       $$emit$$"done:"
11300     }
11301   %}
11302   ins_encode %{
11303     Label* l = $labl$$label;
11304     if ($cop$$cmpcode == Assembler::notEqual) {
11305       __ jcc(Assembler::parity, *l, false);
11306       __ jcc(Assembler::notEqual, *l, false);
11307     } else if ($cop$$cmpcode == Assembler::equal) {
11308       Label done;
11309       __ jccb(Assembler::parity, done);
11310       __ jcc(Assembler::equal, *l, false);
11311       __ bind(done);
11312     } else {
11313        ShouldNotReachHere();
11314     }
11315   %}
11316   ins_pipe(pipe_jcc);
11317 %}
11318 
11319 // ============================================================================
11320 // The 2nd slow-half of a subtype check.  Scan the subklass's 2ndary
11321 // superklass array for an instance of the superklass.  Set a hidden
11322 // internal cache on a hit (cache is checked with exposed code in
11323 // gen_subtype_check()).  Return NZ for a miss or zero for a hit.  The
11324 // encoding ALSO sets flags.
11325 
11326 instruct partialSubtypeCheck(rdi_RegP result,
11327                              rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11328                              rFlagsReg cr)
11329 %{
11330   match(Set result (PartialSubtypeCheck sub super));
11331   effect(KILL rcx, KILL cr);
11332 
11333   ins_cost(1100);  // slightly larger than the next version
11334   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11335             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11336             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11337             "repne   scasq\t# Scan *rdi++ for a match with rax while rcx--\n\t"
11338             "jne,s   miss\t\t# Missed: rdi not-zero\n\t"
11339             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11340             "xorq    $result, $result\t\t Hit: rdi zero\n\t"
11341     "miss:\t" %}
11342 
11343   opcode(0x1); // Force a XOR of RDI
11344   ins_encode(enc_PartialSubtypeCheck());
11345   ins_pipe(pipe_slow);
11346 %}
11347 
11348 instruct partialSubtypeCheck_vs_Zero(rFlagsReg cr,
11349                                      rsi_RegP sub, rax_RegP super, rcx_RegI rcx,
11350                                      immP0 zero,
11351                                      rdi_RegP result)
11352 %{
11353   match(Set cr (CmpP (PartialSubtypeCheck sub super) zero));
11354   effect(KILL rcx, KILL result);
11355 
11356   ins_cost(1000);
11357   format %{ "movq    rdi, [$sub + in_bytes(Klass::secondary_supers_offset())]\n\t"
11358             "movl    rcx, [rdi + Array&lt;Klass*&gt;::length_offset_in_bytes()]\t# length to scan\n\t"
11359             "addq    rdi, Array&lt;Klass*&gt;::base_offset_in_bytes()\t# Skip to start of data; set NZ in case count is zero\n\t"
11360             "repne   scasq\t# Scan *rdi++ for a match with rax while cx-- != 0\n\t"
11361             "jne,s   miss\t\t# Missed: flags nz\n\t"
11362             "movq    [$sub + in_bytes(Klass::secondary_super_cache_offset())], $super\t# Hit: update cache\n\t"
11363     "miss:\t" %}
11364 
11365   opcode(0x0); // No need to XOR RDI
11366   ins_encode(enc_PartialSubtypeCheck());
11367   ins_pipe(pipe_slow);
11368 %}
11369 
11370 // ============================================================================
11371 // Branch Instructions -- short offset versions
11372 //
11373 // These instructions are used to replace jumps of a long offset (the default
11374 // match) with jumps of a shorter offset.  These instructions are all tagged
11375 // with the ins_short_branch attribute, which causes the ADLC to suppress the
11376 // match rules in general matching.  Instead, the ADLC generates a conversion
11377 // method in the MachNode which can be used to do in-place replacement of the
11378 // long variant with the shorter variant.  The compiler will determine if a
11379 // branch can be taken by the is_short_branch_offset() predicate in the machine
11380 // specific code section of the file.
11381 
11382 // Jump Direct - Label defines a relative address from JMP+1
11383 instruct jmpDir_short(label labl) %{
11384   match(Goto);
11385   effect(USE labl);
11386 
11387   ins_cost(300);
11388   format %{ "jmp,s   $labl" %}
11389   size(2);
11390   ins_encode %{
11391     Label* L = $labl$$label;
11392     __ jmpb(*L);
11393   %}
11394   ins_pipe(pipe_jmp);
11395   ins_short_branch(1);
11396 %}
11397 
11398 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11399 instruct jmpCon_short(cmpOp cop, rFlagsReg cr, label labl) %{
11400   match(If cop cr);
11401   effect(USE labl);
11402 
11403   ins_cost(300);
11404   format %{ "j$cop,s   $labl" %}
11405   size(2);
11406   ins_encode %{
11407     Label* L = $labl$$label;
11408     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11409   %}
11410   ins_pipe(pipe_jcc);
11411   ins_short_branch(1);
11412 %}
11413 
11414 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11415 instruct jmpLoopEnd_short(cmpOp cop, rFlagsReg cr, label labl) %{
11416   match(CountedLoopEnd cop cr);
11417   effect(USE labl);
11418 
11419   ins_cost(300);
11420   format %{ "j$cop,s   $labl\t# loop end" %}
11421   size(2);
11422   ins_encode %{
11423     Label* L = $labl$$label;
11424     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11425   %}
11426   ins_pipe(pipe_jcc);
11427   ins_short_branch(1);
11428 %}
11429 
11430 // Jump Direct Conditional - Label defines a relative address from Jcc+1
11431 instruct jmpLoopEndU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11432   match(CountedLoopEnd cop cmp);
11433   effect(USE labl);
11434 
11435   ins_cost(300);
11436   format %{ "j$cop,us  $labl\t# loop end" %}
11437   size(2);
11438   ins_encode %{
11439     Label* L = $labl$$label;
11440     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11441   %}
11442   ins_pipe(pipe_jcc);
11443   ins_short_branch(1);
11444 %}
11445 
11446 instruct jmpLoopEndUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11447   match(CountedLoopEnd cop cmp);
11448   effect(USE labl);
11449 
11450   ins_cost(300);
11451   format %{ "j$cop,us  $labl\t# loop end" %}
11452   size(2);
11453   ins_encode %{
11454     Label* L = $labl$$label;
11455     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11456   %}
11457   ins_pipe(pipe_jcc);
11458   ins_short_branch(1);
11459 %}
11460 
11461 // Jump Direct Conditional - using unsigned comparison
11462 instruct jmpConU_short(cmpOpU cop, rFlagsRegU cmp, label labl) %{
11463   match(If cop cmp);
11464   effect(USE labl);
11465 
11466   ins_cost(300);
11467   format %{ "j$cop,us  $labl" %}
11468   size(2);
11469   ins_encode %{
11470     Label* L = $labl$$label;
11471     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11472   %}
11473   ins_pipe(pipe_jcc);
11474   ins_short_branch(1);
11475 %}
11476 
11477 instruct jmpConUCF_short(cmpOpUCF cop, rFlagsRegUCF cmp, label labl) %{
11478   match(If cop cmp);
11479   effect(USE labl);
11480 
11481   ins_cost(300);
11482   format %{ "j$cop,us  $labl" %}
11483   size(2);
11484   ins_encode %{
11485     Label* L = $labl$$label;
11486     __ jccb((Assembler::Condition)($cop$$cmpcode), *L);
11487   %}
11488   ins_pipe(pipe_jcc);
11489   ins_short_branch(1);
11490 %}
11491 
11492 instruct jmpConUCF2_short(cmpOpUCF2 cop, rFlagsRegUCF cmp, label labl) %{
11493   match(If cop cmp);
11494   effect(USE labl);
11495 
11496   ins_cost(300);
11497   format %{ $$template
11498     if ($cop$$cmpcode == Assembler::notEqual) {
11499       $$emit$$"jp,u,s   $labl\n\t"
11500       $$emit$$"j$cop,u,s   $labl"
11501     } else {
11502       $$emit$$"jp,u,s   done\n\t"
11503       $$emit$$"j$cop,u,s  $labl\n\t"
11504       $$emit$$"done:"
11505     }
11506   %}
11507   size(4);
11508   ins_encode %{
11509     Label* l = $labl$$label;
11510     if ($cop$$cmpcode == Assembler::notEqual) {
11511       __ jccb(Assembler::parity, *l);
11512       __ jccb(Assembler::notEqual, *l);
11513     } else if ($cop$$cmpcode == Assembler::equal) {
11514       Label done;
11515       __ jccb(Assembler::parity, done);
11516       __ jccb(Assembler::equal, *l);
11517       __ bind(done);
11518     } else {
11519        ShouldNotReachHere();
11520     }
11521   %}
11522   ins_pipe(pipe_jcc);
11523   ins_short_branch(1);
11524 %}
11525 
11526 // ============================================================================
11527 // inlined locking and unlocking
11528 
11529 instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{
11530   predicate(Compile::current()-&gt;use_rtm());
11531   match(Set cr (FastLock object box));
11532   effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);
11533   ins_cost(300);
11534   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr,$cx1,$cx2" %}
11535   ins_encode %{
11536     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11537                  $scr$$Register, $cx1$$Register, $cx2$$Register,
11538                  _counters, _rtm_counters, _stack_rtm_counters,
11539                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
11540                  true, ra_-&gt;C-&gt;profile_rtm());
11541   %}
11542   ins_pipe(pipe_slow);
11543 %}
11544 
11545 instruct cmpFastLock(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rRegP scr) %{
11546   predicate(!Compile::current()-&gt;use_rtm());
11547   match(Set cr (FastLock object box));
11548   effect(TEMP tmp, TEMP scr, USE_KILL box);
11549   ins_cost(300);
11550   format %{ "fastlock $object,$box\t! kills $box,$tmp,$scr" %}
11551   ins_encode %{
11552     __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,
11553                  $scr$$Register, noreg, noreg, _counters, NULL, NULL, NULL, false, false);
11554   %}
11555   ins_pipe(pipe_slow);
11556 %}
11557 
11558 instruct cmpFastUnlock(rFlagsReg cr, rRegP object, rax_RegP box, rRegP tmp) %{
11559   match(Set cr (FastUnlock object box));
11560   effect(TEMP tmp, USE_KILL box);
11561   ins_cost(300);
11562   format %{ "fastunlock $object,$box\t! kills $box,$tmp" %}
11563   ins_encode %{
11564     __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_-&gt;C-&gt;use_rtm());
11565   %}
11566   ins_pipe(pipe_slow);
11567 %}
11568 
11569 
11570 // ============================================================================
11571 // Safepoint Instructions
11572 instruct safePoint_poll(rFlagsReg cr)
11573 %{
11574   predicate(!Assembler::is_polling_page_far());
11575   match(SafePoint);
11576   effect(KILL cr);
11577 
11578   format %{ "testl  rax, [rip + #offset_to_poll_page]\t"
11579             "# Safepoint: poll for GC" %}
11580   ins_cost(125);
11581   ins_encode %{
11582     AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
11583     __ testl(rax, addr);
11584   %}
11585   ins_pipe(ialu_reg_mem);
11586 %}
11587 
11588 instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
11589 %{
11590   predicate(Assembler::is_polling_page_far());
11591   match(SafePoint poll);
11592   effect(KILL cr, USE poll);
11593 
11594   format %{ "testl  rax, [$poll]\t"
11595             "# Safepoint: poll for GC" %}
11596   ins_cost(125);
11597   ins_encode %{
11598     __ relocate(relocInfo::poll_type);
11599     __ testl(rax, Address($poll$$Register, 0));
11600   %}
11601   ins_pipe(ialu_reg_mem);
11602 %}
11603 
11604 // ============================================================================
11605 // Procedure Call/Return Instructions
11606 // Call Java Static Instruction
11607 // Note: If this code changes, the corresponding ret_addr_offset() and
11608 //       compute_padding() functions will have to be adjusted.
11609 instruct CallStaticJavaDirect(method meth) %{
11610   match(CallStaticJava);
11611   effect(USE meth);
11612 
11613   ins_cost(300);
11614   format %{ "call,static " %}
11615   opcode(0xE8); /* E8 cd */
11616   ins_encode(clear_avx, Java_Static_Call(meth), call_epilog);
11617   ins_pipe(pipe_slow);
11618   ins_alignment(4);
11619 %}
11620 
11621 // Call Java Dynamic Instruction
11622 // Note: If this code changes, the corresponding ret_addr_offset() and
11623 //       compute_padding() functions will have to be adjusted.
11624 instruct CallDynamicJavaDirect(method meth)
11625 %{
11626   match(CallDynamicJava);
11627   effect(USE meth);
11628 
11629   ins_cost(300);
11630   format %{ "movq    rax, #Universe::non_oop_word()\n\t"
11631             "call,dynamic " %}
11632   ins_encode(clear_avx, Java_Dynamic_Call(meth), call_epilog);
11633   ins_pipe(pipe_slow);
11634   ins_alignment(4);
11635 %}
11636 
11637 // Call Runtime Instruction
11638 instruct CallRuntimeDirect(method meth)
11639 %{
11640   match(CallRuntime);
11641   effect(USE meth);
11642 
11643   ins_cost(300);
11644   format %{ "call,runtime " %}
11645   ins_encode(clear_avx, Java_To_Runtime(meth));
11646   ins_pipe(pipe_slow);
11647 %}
11648 
11649 // Call runtime without safepoint
11650 instruct CallLeafDirect(method meth)
11651 %{
11652   match(CallLeaf);
11653   effect(USE meth);
11654 
11655   ins_cost(300);
11656   format %{ "call_leaf,runtime " %}
11657   ins_encode(clear_avx, Java_To_Runtime(meth));
11658   ins_pipe(pipe_slow);
11659 %}
11660 
11661 // Call runtime without safepoint
11662 instruct CallLeafNoFPDirect(method meth)
11663 %{
11664   match(CallLeafNoFP);
11665   effect(USE meth);
11666 
11667   ins_cost(300);
11668   format %{ "call_leaf_nofp,runtime " %}
11669   ins_encode(Java_To_Runtime(meth));
11670   ins_pipe(pipe_slow);
11671 %}
11672 
11673 // Return Instruction
11674 // Remove the return address &amp; jump to it.
11675 // Notice: We always emit a nop after a ret to make sure there is room
11676 // for safepoint patching
11677 instruct Ret()
11678 %{
11679   match(Return);
11680 
11681   format %{ "ret" %}
11682   opcode(0xC3);
11683   ins_encode(OpcP);
11684   ins_pipe(pipe_jmp);
11685 %}
11686 
11687 // Tail Call; Jump from runtime stub to Java code.
11688 // Also known as an 'interprocedural jump'.
11689 // Target of jump will eventually return to caller.
11690 // TailJump below removes the return address.
11691 instruct TailCalljmpInd(no_rbp_RegP jump_target, rbx_RegP method_oop)
11692 %{
11693   match(TailCall jump_target method_oop);
11694 
11695   ins_cost(300);
11696   format %{ "jmp     $jump_target\t# rbx holds method oop" %}
11697   opcode(0xFF, 0x4); /* Opcode FF /4 */
11698   ins_encode(REX_reg(jump_target), OpcP, reg_opc(jump_target));
11699   ins_pipe(pipe_jmp);
11700 %}
11701 
11702 // Tail Jump; remove the return address; jump to target.
11703 // TailCall above leaves the return address around.
11704 instruct tailjmpInd(no_rbp_RegP jump_target, rax_RegP ex_oop)
11705 %{
11706   match(TailJump jump_target ex_oop);
11707 
11708   ins_cost(300);
11709   format %{ "popq    rdx\t# pop return address\n\t"
11710             "jmp     $jump_target" %}
11711   opcode(0xFF, 0x4); /* Opcode FF /4 */
11712   ins_encode(Opcode(0x5a), // popq rdx
11713              REX_reg(jump_target), OpcP, reg_opc(jump_target));
11714   ins_pipe(pipe_jmp);
11715 %}
11716 
11717 // Create exception oop: created by stack-crawling runtime code.
11718 // Created exception is now available to this handler, and is setup
11719 // just prior to jumping to this handler.  No code emitted.
11720 instruct CreateException(rax_RegP ex_oop)
11721 %{
11722   match(Set ex_oop (CreateEx));
11723 
11724   size(0);
11725   // use the following format syntax
11726   format %{ "# exception oop is in rax; no code emitted" %}
11727   ins_encode();
11728   ins_pipe(empty);
11729 %}
11730 
11731 // Rethrow exception:
11732 // The exception oop will come in the first argument position.
11733 // Then JUMP (not call) to the rethrow stub code.
11734 instruct RethrowException()
11735 %{
11736   match(Rethrow);
11737 
11738   // use the following format syntax
11739   format %{ "jmp     rethrow_stub" %}
11740   ins_encode(enc_rethrow);
11741   ins_pipe(pipe_jmp);
11742 %}
11743 
11744 
11745 // ============================================================================
11746 // This name is KNOWN by the ADLC and cannot be changed.
11747 // The ADLC forces a 'TypeRawPtr::BOTTOM' output type
11748 // for this guy.
11749 instruct tlsLoadP(r15_RegP dst) %{
11750   match(Set dst (ThreadLocal));
11751   effect(DEF dst);
11752 
11753   size(0);
11754   format %{ "# TLS is in R15" %}
11755   ins_encode( /*empty encoding*/ );
11756   ins_pipe(ialu_reg_reg);
11757 %}
11758 
11759 
11760 //----------PEEPHOLE RULES-----------------------------------------------------
11761 // These must follow all instruction definitions as they use the names
11762 // defined in the instructions definitions.
11763 //
11764 // peepmatch ( root_instr_name [preceding_instruction]* );
11765 //
11766 // peepconstraint %{
11767 // (instruction_number.operand_name relational_op instruction_number.operand_name
11768 //  [, ...] );
11769 // // instruction numbers are zero-based using left to right order in peepmatch
11770 //
11771 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
11772 // // provide an instruction_number.operand_name for each operand that appears
11773 // // in the replacement instruction's match rule
11774 //
11775 // ---------VM FLAGS---------------------------------------------------------
11776 //
11777 // All peephole optimizations can be turned off using -XX:-OptoPeephole
11778 //
11779 // Each peephole rule is given an identifying number starting with zero and
11780 // increasing by one in the order seen by the parser.  An individual peephole
11781 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
11782 // on the command-line.
11783 //
11784 // ---------CURRENT LIMITATIONS----------------------------------------------
11785 //
11786 // Only match adjacent instructions in same basic block
11787 // Only equality constraints
11788 // Only constraints between operands, not (0.dest_reg == RAX_enc)
11789 // Only one replacement instruction
11790 //
11791 // ---------EXAMPLE----------------------------------------------------------
11792 //
11793 // // pertinent parts of existing instructions in architecture description
11794 // instruct movI(rRegI dst, rRegI src)
11795 // %{
11796 //   match(Set dst (CopyI src));
11797 // %}
11798 //
11799 // instruct incI_rReg(rRegI dst, immI1 src, rFlagsReg cr)
11800 // %{
11801 //   match(Set dst (AddI dst src));
11802 //   effect(KILL cr);
11803 // %}
11804 //
11805 // // Change (inc mov) to lea
11806 // peephole %{
11807 //   // increment preceeded by register-register move
11808 //   peepmatch ( incI_rReg movI );
11809 //   // require that the destination register of the increment
11810 //   // match the destination register of the move
11811 //   peepconstraint ( 0.dst == 1.dst );
11812 //   // construct a replacement instruction that sets
11813 //   // the destination to ( move's source register + one )
11814 //   peepreplace ( leaI_rReg_immI( 0.dst 1.src 0.src ) );
11815 // %}
11816 //
11817 
11818 // Implementation no longer uses movX instructions since
11819 // machine-independent system no longer uses CopyX nodes.
11820 //
11821 // peephole
11822 // %{
11823 //   peepmatch (incI_rReg movI);
11824 //   peepconstraint (0.dst == 1.dst);
11825 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11826 // %}
11827 
11828 // peephole
11829 // %{
11830 //   peepmatch (decI_rReg movI);
11831 //   peepconstraint (0.dst == 1.dst);
11832 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11833 // %}
11834 
11835 // peephole
11836 // %{
11837 //   peepmatch (addI_rReg_imm movI);
11838 //   peepconstraint (0.dst == 1.dst);
11839 //   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));
11840 // %}
11841 
11842 // peephole
11843 // %{
11844 //   peepmatch (incL_rReg movL);
11845 //   peepconstraint (0.dst == 1.dst);
11846 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11847 // %}
11848 
11849 // peephole
11850 // %{
11851 //   peepmatch (decL_rReg movL);
11852 //   peepconstraint (0.dst == 1.dst);
11853 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11854 // %}
11855 
11856 // peephole
11857 // %{
11858 //   peepmatch (addL_rReg_imm movL);
11859 //   peepconstraint (0.dst == 1.dst);
11860 //   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));
11861 // %}
11862 
11863 // peephole
11864 // %{
11865 //   peepmatch (addP_rReg_imm movP);
11866 //   peepconstraint (0.dst == 1.dst);
11867 //   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));
11868 // %}
11869 
11870 // // Change load of spilled value to only a spill
11871 // instruct storeI(memory mem, rRegI src)
11872 // %{
11873 //   match(Set mem (StoreI mem src));
11874 // %}
11875 //
11876 // instruct loadI(rRegI dst, memory mem)
11877 // %{
11878 //   match(Set dst (LoadI mem));
11879 // %}
11880 //
11881 
11882 peephole
11883 %{
11884   peepmatch (loadI storeI);
11885   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11886   peepreplace (storeI(1.mem 1.mem 1.src));
11887 %}
11888 
11889 peephole
11890 %{
11891   peepmatch (loadL storeL);
11892   peepconstraint (1.src == 0.dst, 1.mem == 0.mem);
11893   peepreplace (storeL(1.mem 1.mem 1.src));
11894 %}
11895 
11896 //----------SMARTSPILL RULES---------------------------------------------------
11897 // These must follow all instruction definitions as they use the names
11898 // defined in the instructions definitions.
</pre></body></html>
