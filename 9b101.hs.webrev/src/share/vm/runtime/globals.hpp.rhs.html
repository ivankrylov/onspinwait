<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre></pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 1997, 2015, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_VM_RUNTIME_GLOBALS_HPP
  26 #define SHARE_VM_RUNTIME_GLOBALS_HPP
  27 
  28 #include "utilities/debug.hpp"
  29 #include &lt;float.h&gt; // for DBL_MAX
  30 
  31 // use this for flags that are true per default in the tiered build
  32 // but false in non-tiered builds, and vice versa
  33 #ifdef TIERED
  34 #define  trueInTiered true
  35 #define falseInTiered false
  36 #else
  37 #define  trueInTiered false
  38 #define falseInTiered true
  39 #endif
  40 
  41 #ifdef TARGET_ARCH_x86
  42 # include "globals_x86.hpp"
  43 #endif
  44 #ifdef TARGET_ARCH_sparc
  45 # include "globals_sparc.hpp"
  46 #endif
  47 #ifdef TARGET_ARCH_zero
  48 # include "globals_zero.hpp"
  49 #endif
  50 #ifdef TARGET_ARCH_arm
  51 # include "globals_arm.hpp"
  52 #endif
  53 #ifdef TARGET_ARCH_ppc
  54 # include "globals_ppc.hpp"
  55 #endif
  56 #ifdef TARGET_ARCH_aarch64
  57 # include "globals_aarch64.hpp"
  58 #endif
  59 #ifdef TARGET_OS_FAMILY_linux
  60 # include "globals_linux.hpp"
  61 #endif
  62 #ifdef TARGET_OS_FAMILY_solaris
  63 # include "globals_solaris.hpp"
  64 #endif
  65 #ifdef TARGET_OS_FAMILY_windows
  66 # include "globals_windows.hpp"
  67 #endif
  68 #ifdef TARGET_OS_FAMILY_aix
  69 # include "globals_aix.hpp"
  70 #endif
  71 #ifdef TARGET_OS_FAMILY_bsd
  72 # include "globals_bsd.hpp"
  73 #endif
  74 #ifdef TARGET_OS_ARCH_linux_x86
  75 # include "globals_linux_x86.hpp"
  76 #endif
  77 #ifdef TARGET_OS_ARCH_linux_sparc
  78 # include "globals_linux_sparc.hpp"
  79 #endif
  80 #ifdef TARGET_OS_ARCH_linux_zero
  81 # include "globals_linux_zero.hpp"
  82 #endif
  83 #ifdef TARGET_OS_ARCH_solaris_x86
  84 # include "globals_solaris_x86.hpp"
  85 #endif
  86 #ifdef TARGET_OS_ARCH_solaris_sparc
  87 # include "globals_solaris_sparc.hpp"
  88 #endif
  89 #ifdef TARGET_OS_ARCH_windows_x86
  90 # include "globals_windows_x86.hpp"
  91 #endif
  92 #ifdef TARGET_OS_ARCH_linux_arm
  93 # include "globals_linux_arm.hpp"
  94 #endif
  95 #ifdef TARGET_OS_ARCH_linux_ppc
  96 # include "globals_linux_ppc.hpp"
  97 #endif
  98 #ifdef TARGET_OS_ARCH_linux_aarch64
  99 # include "globals_linux_aarch64.hpp"
 100 #endif
 101 #ifdef TARGET_OS_ARCH_aix_ppc
 102 # include "globals_aix_ppc.hpp"
 103 #endif
 104 #ifdef TARGET_OS_ARCH_bsd_x86
 105 # include "globals_bsd_x86.hpp"
 106 #endif
 107 #ifdef TARGET_OS_ARCH_bsd_zero
 108 # include "globals_bsd_zero.hpp"
 109 #endif
 110 #ifdef COMPILER1
 111 #ifdef TARGET_ARCH_x86
 112 # include "c1_globals_x86.hpp"
 113 #endif
 114 #ifdef TARGET_ARCH_sparc
 115 # include "c1_globals_sparc.hpp"
 116 #endif
 117 #ifdef TARGET_ARCH_arm
 118 # include "c1_globals_arm.hpp"
 119 #endif
 120 #ifdef TARGET_ARCH_aarch64
 121 # include "c1_globals_aarch64.hpp"
 122 #endif
 123 #ifdef TARGET_OS_FAMILY_linux
 124 # include "c1_globals_linux.hpp"
 125 #endif
 126 #ifdef TARGET_OS_FAMILY_solaris
 127 # include "c1_globals_solaris.hpp"
 128 #endif
 129 #ifdef TARGET_OS_FAMILY_windows
 130 # include "c1_globals_windows.hpp"
 131 #endif
 132 #ifdef TARGET_OS_FAMILY_aix
 133 # include "c1_globals_aix.hpp"
 134 #endif
 135 #ifdef TARGET_OS_FAMILY_bsd
 136 # include "c1_globals_bsd.hpp"
 137 #endif
 138 #ifdef TARGET_ARCH_ppc
 139 # include "c1_globals_ppc.hpp"
 140 #endif
 141 #endif
 142 #ifdef COMPILER2
 143 #ifdef TARGET_ARCH_x86
 144 # include "c2_globals_x86.hpp"
 145 #endif
 146 #ifdef TARGET_ARCH_sparc
 147 # include "c2_globals_sparc.hpp"
 148 #endif
 149 #ifdef TARGET_ARCH_arm
 150 # include "c2_globals_arm.hpp"
 151 #endif
 152 #ifdef TARGET_ARCH_ppc
 153 # include "c2_globals_ppc.hpp"
 154 #endif
 155 #ifdef TARGET_ARCH_aarch64
 156 # include "c2_globals_aarch64.hpp"
 157 #endif
 158 #ifdef TARGET_OS_FAMILY_linux
 159 # include "c2_globals_linux.hpp"
 160 #endif
 161 #ifdef TARGET_OS_FAMILY_solaris
 162 # include "c2_globals_solaris.hpp"
 163 #endif
 164 #ifdef TARGET_OS_FAMILY_windows
 165 # include "c2_globals_windows.hpp"
 166 #endif
 167 #ifdef TARGET_OS_FAMILY_aix
 168 # include "c2_globals_aix.hpp"
 169 #endif
 170 #ifdef TARGET_OS_FAMILY_bsd
 171 # include "c2_globals_bsd.hpp"
 172 #endif
 173 #endif
 174 #ifdef SHARK
 175 #ifdef TARGET_ARCH_zero
 176 # include "shark_globals_zero.hpp"
 177 #endif
 178 #endif
 179 
 180 #if !defined(COMPILER1) &amp;&amp; !defined(COMPILER2) &amp;&amp; !defined(SHARK) &amp;&amp; !INCLUDE_JVMCI
 181 define_pd_global(bool, BackgroundCompilation,        false);
 182 define_pd_global(bool, UseTLAB,                      false);
 183 define_pd_global(bool, CICompileOSR,                 false);
 184 define_pd_global(bool, UseTypeProfile,               false);
 185 define_pd_global(bool, UseOnStackReplacement,        false);
 186 define_pd_global(bool, InlineIntrinsics,             false);
 187 define_pd_global(bool, PreferInterpreterNativeStubs, true);
 188 define_pd_global(bool, ProfileInterpreter,           false);
 189 define_pd_global(bool, ProfileTraps,                 false);
 190 define_pd_global(bool, TieredCompilation,            false);
 191 
 192 define_pd_global(intx, CompileThreshold,             0);
 193 
 194 define_pd_global(intx, OnStackReplacePercentage,     0);
 195 define_pd_global(bool, ResizeTLAB,                   false);
 196 define_pd_global(intx, FreqInlineSize,               0);
 197 define_pd_global(size_t, NewSizeThreadIncrease,      4*K);
 198 define_pd_global(intx, InlineClassNatives,           true);
 199 define_pd_global(intx, InlineUnsafeOps,              true);
 200 define_pd_global(intx, InitialCodeCacheSize,         160*K);
 201 define_pd_global(intx, ReservedCodeCacheSize,        32*M);
 202 define_pd_global(intx, NonProfiledCodeHeapSize,      0);
 203 define_pd_global(intx, ProfiledCodeHeapSize,         0);
 204 define_pd_global(intx, NonNMethodCodeHeapSize,       32*M);
 205 
 206 define_pd_global(intx, CodeCacheExpansionSize,       32*K);
 207 define_pd_global(intx, CodeCacheMinBlockLength,      1);
 208 define_pd_global(intx, CodeCacheMinimumUseSpace,     200*K);
 209 define_pd_global(size_t, MetaspaceSize,              ScaleForWordSize(4*M));
 210 define_pd_global(bool, NeverActAsServerClassMachine, true);
 211 define_pd_global(uint64_t,MaxRAM,                    1ULL*G);
 212 #define CI_COMPILER_COUNT 0
 213 #else
 214 
 215 #if defined(COMPILER2) || INCLUDE_JVMCI
 216 #define CI_COMPILER_COUNT 2
 217 #else
 218 #define CI_COMPILER_COUNT 1
 219 #endif // COMPILER2 || INCLUDE_JVMCI
 220 
 221 #endif // no compilers
 222 
 223 // string type aliases used only in this file
 224 typedef const char* ccstr;
 225 typedef const char* ccstrlist;   // represents string arguments which accumulate
 226 
 227 struct Flag {
 228   enum Flags {
 229     // value origin
 230     DEFAULT          = 0,
 231     COMMAND_LINE     = 1,
 232     ENVIRON_VAR      = 2,
 233     CONFIG_FILE      = 3,
 234     MANAGEMENT       = 4,
 235     ERGONOMIC        = 5,
 236     ATTACH_ON_DEMAND = 6,
 237     INTERNAL         = 7,
 238 
 239     LAST_VALUE_ORIGIN = INTERNAL,
 240     VALUE_ORIGIN_BITS = 4,
 241     VALUE_ORIGIN_MASK = right_n_bits(VALUE_ORIGIN_BITS),
 242 
 243     // flag kind
 244     KIND_PRODUCT            = 1 &lt;&lt; 4,
 245     KIND_MANAGEABLE         = 1 &lt;&lt; 5,
 246     KIND_DIAGNOSTIC         = 1 &lt;&lt; 6,
 247     KIND_EXPERIMENTAL       = 1 &lt;&lt; 7,
 248     KIND_NOT_PRODUCT        = 1 &lt;&lt; 8,
 249     KIND_DEVELOP            = 1 &lt;&lt; 9,
 250     KIND_PLATFORM_DEPENDENT = 1 &lt;&lt; 10,
 251     KIND_READ_WRITE         = 1 &lt;&lt; 11,
 252     KIND_C1                 = 1 &lt;&lt; 12,
 253     KIND_C2                 = 1 &lt;&lt; 13,
 254     KIND_ARCH               = 1 &lt;&lt; 14,
 255     KIND_SHARK              = 1 &lt;&lt; 15,
 256     KIND_LP64_PRODUCT       = 1 &lt;&lt; 16,
 257     KIND_COMMERCIAL         = 1 &lt;&lt; 17,
 258     KIND_JVMCI              = 1 &lt;&lt; 18,
 259 
 260     KIND_MASK = ~VALUE_ORIGIN_MASK
 261   };
 262 
 263   enum Error {
 264     // no error
 265     SUCCESS = 0,
 266     // flag name is missing
 267     MISSING_NAME,
 268     // flag value is missing
 269     MISSING_VALUE,
 270     // error parsing the textual form of the value
 271     WRONG_FORMAT,
 272     // flag is not writeable
 273     NON_WRITABLE,
 274     // flag value is outside of its bounds
 275     OUT_OF_BOUNDS,
 276     // flag value violates its constraint
 277     VIOLATES_CONSTRAINT,
 278     // there is no flag with the given name
 279     INVALID_FLAG,
 280     // other, unspecified error related to setting the flag
 281     ERR_OTHER
 282   };
 283 
 284   enum MsgType {
 285     NONE = 0,
 286     DIAGNOSTIC_FLAG_BUT_LOCKED,
 287     EXPERIMENTAL_FLAG_BUT_LOCKED,
 288     DEVELOPER_FLAG_BUT_PRODUCT_BUILD,
 289     NOTPRODUCT_FLAG_BUT_PRODUCT_BUILD
 290   };
 291 
 292   const char* _type;
 293   const char* _name;
 294   void* _addr;
 295   NOT_PRODUCT(const char* _doc;)
 296   Flags _flags;
 297 
 298   // points to all Flags static array
 299   static Flag* flags;
 300 
 301   // number of flags
 302   static size_t numFlags;
 303 
 304   static Flag* find_flag(const char* name) { return find_flag(name, strlen(name), true, true); };
 305   static Flag* find_flag(const char* name, size_t length, bool allow_locked = false, bool return_flag = false);
 306   static Flag* fuzzy_match(const char* name, size_t length, bool allow_locked = false);
 307 
 308   void check_writable();
 309 
 310   bool is_bool() const;
 311   bool get_bool() const;
 312   void set_bool(bool value);
 313 
 314   bool is_int() const;
 315   int get_int() const;
 316   void set_int(int value);
 317 
 318   bool is_uint() const;
 319   uint get_uint() const;
 320   void set_uint(uint value);
 321 
 322   bool is_intx() const;
 323   intx get_intx() const;
 324   void set_intx(intx value);
 325 
 326   bool is_uintx() const;
 327   uintx get_uintx() const;
 328   void set_uintx(uintx value);
 329 
 330   bool is_uint64_t() const;
 331   uint64_t get_uint64_t() const;
 332   void set_uint64_t(uint64_t value);
 333 
 334   bool is_size_t() const;
 335   size_t get_size_t() const;
 336   void set_size_t(size_t value);
 337 
 338   bool is_double() const;
 339   double get_double() const;
 340   void set_double(double value);
 341 
 342   bool is_ccstr() const;
 343   bool ccstr_accumulates() const;
 344   ccstr get_ccstr() const;
 345   void set_ccstr(ccstr value);
 346 
 347   Flags get_origin();
 348   void set_origin(Flags origin);
 349 
 350   bool is_default();
 351   bool is_ergonomic();
 352   bool is_command_line();
 353 
 354   bool is_product() const;
 355   bool is_manageable() const;
 356   bool is_diagnostic() const;
 357   bool is_experimental() const;
 358   bool is_notproduct() const;
 359   bool is_develop() const;
 360   bool is_read_write() const;
 361   bool is_commercial() const;
 362 
 363   bool is_constant_in_binary() const;
 364 
 365   bool is_unlocker() const;
 366   bool is_unlocked() const;
 367   bool is_writeable() const;
 368   bool is_external() const;
 369 
 370   bool is_unlocker_ext() const;
 371   bool is_unlocked_ext() const;
 372   bool is_writeable_ext() const;
 373   bool is_external_ext() const;
 374 
 375   void unlock_diagnostic();
 376 
 377   Flag::MsgType get_locked_message(char*, int) const;
 378   void get_locked_message_ext(char*, int) const;
 379 
 380   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 381   void print_on(outputStream* st, bool withComments = false, bool printRanges = false);
 382   void print_kind(outputStream* st);
 383   void print_as_flag(outputStream* st);
 384 
 385   static const char* flag_error_str(Flag::Error error);
 386 };
 387 
 388 // debug flags control various aspects of the VM and are global accessible
 389 
 390 // use FlagSetting to temporarily change some debug flag
 391 // e.g. FlagSetting fs(DebugThisAndThat, true);
 392 // restored to previous value upon leaving scope
 393 class FlagSetting {
 394   bool val;
 395   bool* flag;
 396  public:
 397   FlagSetting(bool&amp; fl, bool newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 398   ~FlagSetting()                       { *flag = val; }
 399 };
 400 
 401 
 402 class CounterSetting {
 403   intx* counter;
 404  public:
 405   CounterSetting(intx* cnt) { counter = cnt; (*counter)++; }
 406   ~CounterSetting()         { (*counter)--; }
 407 };
 408 
 409 class IntFlagSetting {
 410   int val;
 411   int* flag;
 412  public:
 413   IntFlagSetting(int&amp; fl, int newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 414   ~IntFlagSetting()                     { *flag = val; }
 415 };
 416 
 417 class UIntFlagSetting {
 418   uint val;
 419   uint* flag;
 420  public:
 421   UIntFlagSetting(uint&amp; fl, uint newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 422   ~UIntFlagSetting()                       { *flag = val; }
 423 };
 424 
 425 class UIntXFlagSetting {
 426   uintx val;
 427   uintx* flag;
 428  public:
 429   UIntXFlagSetting(uintx&amp; fl, uintx newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 430   ~UIntXFlagSetting()                         { *flag = val; }
 431 };
 432 
 433 class DoubleFlagSetting {
 434   double val;
 435   double* flag;
 436  public:
 437   DoubleFlagSetting(double&amp; fl, double newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 438   ~DoubleFlagSetting()                           { *flag = val; }
 439 };
 440 
 441 class SizeTFlagSetting {
 442   size_t val;
 443   size_t* flag;
 444  public:
 445   SizeTFlagSetting(size_t&amp; fl, size_t newValue) { flag = &amp;fl; val = fl; fl = newValue; }
 446   ~SizeTFlagSetting()                           { *flag = val; }
 447 };
 448 
 449 
 450 class CommandLineFlags {
 451 public:
 452   static Flag::Error boolAt(const char* name, size_t len, bool* value, bool allow_locked = false, bool return_flag = false);
 453   static Flag::Error boolAt(const char* name, bool* value, bool allow_locked = false, bool return_flag = false)      { return boolAt(name, strlen(name), value, allow_locked, return_flag); }
 454   static Flag::Error boolAtPut(Flag* flag, bool* value, Flag::Flags origin);
 455   static Flag::Error boolAtPut(const char* name, size_t len, bool* value, Flag::Flags origin);
 456   static Flag::Error boolAtPut(const char* name, bool* value, Flag::Flags origin)   { return boolAtPut(name, strlen(name), value, origin); }
 457 
 458   static Flag::Error intAt(const char* name, size_t len, int* value, bool allow_locked = false, bool return_flag = false);
 459   static Flag::Error intAt(const char* name, int* value, bool allow_locked = false, bool return_flag = false)      { return intAt(name, strlen(name), value, allow_locked, return_flag); }
 460   static Flag::Error intAtPut(Flag* flag, int* value, Flag::Flags origin);
 461   static Flag::Error intAtPut(const char* name, size_t len, int* value, Flag::Flags origin);
 462   static Flag::Error intAtPut(const char* name, int* value, Flag::Flags origin)   { return intAtPut(name, strlen(name), value, origin); }
 463 
 464   static Flag::Error uintAt(const char* name, size_t len, uint* value, bool allow_locked = false, bool return_flag = false);
 465   static Flag::Error uintAt(const char* name, uint* value, bool allow_locked = false, bool return_flag = false)      { return uintAt(name, strlen(name), value, allow_locked, return_flag); }
 466   static Flag::Error uintAtPut(Flag* flag, uint* value, Flag::Flags origin);
 467   static Flag::Error uintAtPut(const char* name, size_t len, uint* value, Flag::Flags origin);
 468   static Flag::Error uintAtPut(const char* name, uint* value, Flag::Flags origin)   { return uintAtPut(name, strlen(name), value, origin); }
 469 
 470   static Flag::Error intxAt(const char* name, size_t len, intx* value, bool allow_locked = false, bool return_flag = false);
 471   static Flag::Error intxAt(const char* name, intx* value, bool allow_locked = false, bool return_flag = false)      { return intxAt(name, strlen(name), value, allow_locked, return_flag); }
 472   static Flag::Error intxAtPut(Flag* flag, intx* value, Flag::Flags origin);
 473   static Flag::Error intxAtPut(const char* name, size_t len, intx* value, Flag::Flags origin);
 474   static Flag::Error intxAtPut(const char* name, intx* value, Flag::Flags origin)   { return intxAtPut(name, strlen(name), value, origin); }
 475 
 476   static Flag::Error uintxAt(const char* name, size_t len, uintx* value, bool allow_locked = false, bool return_flag = false);
 477   static Flag::Error uintxAt(const char* name, uintx* value, bool allow_locked = false, bool return_flag = false)    { return uintxAt(name, strlen(name), value, allow_locked, return_flag); }
 478   static Flag::Error uintxAtPut(Flag* flag, uintx* value, Flag::Flags origin);
 479   static Flag::Error uintxAtPut(const char* name, size_t len, uintx* value, Flag::Flags origin);
 480   static Flag::Error uintxAtPut(const char* name, uintx* value, Flag::Flags origin) { return uintxAtPut(name, strlen(name), value, origin); }
 481 
 482   static Flag::Error size_tAt(const char* name, size_t len, size_t* value, bool allow_locked = false, bool return_flag = false);
 483   static Flag::Error size_tAt(const char* name, size_t* value, bool allow_locked = false, bool return_flag = false)    { return size_tAt(name, strlen(name), value, allow_locked, return_flag); }
 484   static Flag::Error size_tAtPut(Flag* flag, size_t* value, Flag::Flags origin);
 485   static Flag::Error size_tAtPut(const char* name, size_t len, size_t* value, Flag::Flags origin);
 486   static Flag::Error size_tAtPut(const char* name, size_t* value, Flag::Flags origin) { return size_tAtPut(name, strlen(name), value, origin); }
 487 
 488   static Flag::Error uint64_tAt(const char* name, size_t len, uint64_t* value, bool allow_locked = false, bool return_flag = false);
 489   static Flag::Error uint64_tAt(const char* name, uint64_t* value, bool allow_locked = false, bool return_flag = false) { return uint64_tAt(name, strlen(name), value, allow_locked, return_flag); }
 490   static Flag::Error uint64_tAtPut(Flag* flag, uint64_t* value, Flag::Flags origin);
 491   static Flag::Error uint64_tAtPut(const char* name, size_t len, uint64_t* value, Flag::Flags origin);
 492   static Flag::Error uint64_tAtPut(const char* name, uint64_t* value, Flag::Flags origin) { return uint64_tAtPut(name, strlen(name), value, origin); }
 493 
 494   static Flag::Error doubleAt(const char* name, size_t len, double* value, bool allow_locked = false, bool return_flag = false);
 495   static Flag::Error doubleAt(const char* name, double* value, bool allow_locked = false, bool return_flag = false)    { return doubleAt(name, strlen(name), value, allow_locked, return_flag); }
 496   static Flag::Error doubleAtPut(Flag* flag, double* value, Flag::Flags origin);
 497   static Flag::Error doubleAtPut(const char* name, size_t len, double* value, Flag::Flags origin);
 498   static Flag::Error doubleAtPut(const char* name, double* value, Flag::Flags origin) { return doubleAtPut(name, strlen(name), value, origin); }
 499 
 500   static Flag::Error ccstrAt(const char* name, size_t len, ccstr* value, bool allow_locked = false, bool return_flag = false);
 501   static Flag::Error ccstrAt(const char* name, ccstr* value, bool allow_locked = false, bool return_flag = false)    { return ccstrAt(name, strlen(name), value, allow_locked, return_flag); }
 502   // Contract:  Flag will make private copy of the incoming value.
 503   // Outgoing value is always malloc-ed, and caller MUST call free.
 504   static Flag::Error ccstrAtPut(const char* name, size_t len, ccstr* value, Flag::Flags origin);
 505   static Flag::Error ccstrAtPut(const char* name, ccstr* value, Flag::Flags origin) { return ccstrAtPut(name, strlen(name), value, origin); }
 506 
 507   // Returns false if name is not a command line flag.
 508   static bool wasSetOnCmdline(const char* name, bool* value);
 509   static void printSetFlags(outputStream* out);
 510 
 511   // printRanges will print out flags type, name and range values as expected by -XX:+PrintFlagsRanges
 512   static void printFlags(outputStream* out, bool withComments, bool printRanges = false);
 513 
 514   static void verify() PRODUCT_RETURN;
 515 };
 516 
 517 // use this for flags that are true by default in the debug version but
 518 // false in the optimized version, and vice versa
 519 #ifdef ASSERT
 520 #define trueInDebug  true
 521 #define falseInDebug false
 522 #else
 523 #define trueInDebug  false
 524 #define falseInDebug true
 525 #endif
 526 
 527 // use this for flags that are true per default in the product build
 528 // but false in development builds, and vice versa
 529 #ifdef PRODUCT
 530 #define trueInProduct  true
 531 #define falseInProduct false
 532 #else
 533 #define trueInProduct  false
 534 #define falseInProduct true
 535 #endif
 536 
 537 #ifdef JAVASE_EMBEDDED
 538 #define falseInEmbedded false
 539 #else
 540 #define falseInEmbedded true
 541 #endif
 542 
 543 // develop flags are settable / visible only during development and are constant in the PRODUCT version
 544 // product flags are always settable / visible
 545 // notproduct flags are settable / visible only during development and are not declared in the PRODUCT version
 546 
 547 // A flag must be declared with one of the following types:
 548 // bool, int, uint, intx, uintx, size_t, ccstr, double, or uint64_t.
 549 // The type "ccstr" is an alias for "const char*" and is used
 550 // only in this file, because the macrology requires single-token type names.
 551 
 552 // Note: Diagnostic options not meant for VM tuning or for product modes.
 553 // They are to be used for VM quality assurance or field diagnosis
 554 // of VM bugs.  They are hidden so that users will not be encouraged to
 555 // try them as if they were VM ordinary execution options.  However, they
 556 // are available in the product version of the VM.  Under instruction
 557 // from support engineers, VM customers can turn them on to collect
 558 // diagnostic information about VM problems.  To use a VM diagnostic
 559 // option, you must first specify +UnlockDiagnosticVMOptions.
 560 // (This master switch also affects the behavior of -Xprintflags.)
 561 //
 562 // experimental flags are in support of features that are not
 563 //    part of the officially supported product, but are available
 564 //    for experimenting with. They could, for example, be performance
 565 //    features that may not have undergone full or rigorous QA, but which may
 566 //    help performance in some cases and released for experimentation
 567 //    by the community of users and developers. This flag also allows one to
 568 //    be able to build a fully supported product that nonetheless also
 569 //    ships with some unsupported, lightly tested, experimental features.
 570 //    Like the UnlockDiagnosticVMOptions flag above, there is a corresponding
 571 //    UnlockExperimentalVMOptions flag, which allows the control and
 572 //    modification of the experimental flags.
 573 //
 574 // Nota bene: neither diagnostic nor experimental options should be used casually,
 575 //    and they are not supported on production loads, except under explicit
 576 //    direction from support engineers.
 577 //
 578 // manageable flags are writeable external product flags.
 579 //    They are dynamically writeable through the JDK management interface
 580 //    (com.sun.management.HotSpotDiagnosticMXBean API) and also through JConsole.
 581 //    These flags are external exported interface (see CCC).  The list of
 582 //    manageable flags can be queried programmatically through the management
 583 //    interface.
 584 //
 585 //    A flag can be made as "manageable" only if
 586 //    - the flag is defined in a CCC as an external exported interface.
 587 //    - the VM implementation supports dynamic setting of the flag.
 588 //      This implies that the VM must *always* query the flag variable
 589 //      and not reuse state related to the flag state at any given time.
 590 //    - you want the flag to be queried programmatically by the customers.
 591 //
 592 // product_rw flags are writeable internal product flags.
 593 //    They are like "manageable" flags but for internal/private use.
 594 //    The list of product_rw flags are internal/private flags which
 595 //    may be changed/removed in a future release.  It can be set
 596 //    through the management interface to get/set value
 597 //    when the name of flag is supplied.
 598 //
 599 //    A flag can be made as "product_rw" only if
 600 //    - the VM implementation supports dynamic setting of the flag.
 601 //      This implies that the VM must *always* query the flag variable
 602 //      and not reuse state related to the flag state at any given time.
 603 //
 604 // Note that when there is a need to support develop flags to be writeable,
 605 // it can be done in the same way as product_rw.
 606 //
 607 // range is a macro that will expand to min and max arguments for range
 608 //    checking code if provided - see commandLineFlagRangeList.hpp
 609 //
 610 // constraint is a macro that will expand to custom function call
 611 //    for constraint checking if provided - see commandLineFlagConstraintList.hpp
 612 //
 613 
 614 #define RUNTIME_FLAGS(develop, develop_pd, product, product_pd, diagnostic, experimental, notproduct, manageable, product_rw, lp64_product, range, constraint) \
 615                                                                             \
 616   lp64_product(bool, UseCompressedOops, false,                              \
 617           "Use 32-bit object references in 64-bit VM. "                     \
 618           "lp64_product means flag is always constant in 32 bit VM")        \
 619                                                                             \
 620   lp64_product(bool, UseCompressedClassPointers, false,                     \
 621           "Use 32-bit class pointers in 64-bit VM. "                        \
 622           "lp64_product means flag is always constant in 32 bit VM")        \
 623                                                                             \
 624   notproduct(bool, CheckCompressedOops, true,                               \
 625           "Generate checks in encoding/decoding code in debug VM")          \
 626                                                                             \
 627   product(uintx, HeapSearchSteps, 3 PPC64_ONLY(+17),                        \
 628           "Heap allocation steps through preferred address regions to find" \
 629           " where it can allocate the heap. Number of steps to take per "   \
 630           "region.")                                                        \
 631           range(1, max_uintx)                                               \
 632                                                                             \
 633   diagnostic(bool, PrintCompressedOopsMode, false,                          \
 634           "Print compressed oops base address and encoding mode")           \
 635                                                                             \
 636   lp64_product(intx, ObjectAlignmentInBytes, 8,                             \
 637           "Default object alignment in bytes, 8 is minimum")                \
 638           range(8, 256)                                                     \
 639           constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \
 640                                                                             \
 641   product(bool, AssumeMP, false,                                            \
 642           "Instruct the VM to assume multiple processors are available")    \
 643                                                                             \
 644   /* UseMembar is theoretically a temp flag used for memory barrier      */ \
 645   /* removal testing.  It was supposed to be removed before FCS but has  */ \
 646   /* been re-added (see 6401008)                                         */ \
 647   product_pd(bool, UseMembar,                                               \
 648           "(Unstable) Issues membars on thread state transitions")          \
 649                                                                             \
 650   develop(bool, CleanChunkPoolAsync, falseInEmbedded,                       \
 651           "Clean the chunk pool asynchronously")                            \
 652                                                                             \
 653   experimental(bool, AlwaysSafeConstructors, false,                         \
 654           "Force safe construction, as if all fields are final.")           \
 655                                                                             \
 656   diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \
 657           "Enable normal processing of flags relating to field diagnostics")\
 658                                                                             \
 659   experimental(bool, UnlockExperimentalVMOptions, false,                    \
 660           "Enable normal processing of flags relating to experimental "     \
 661           "features")                                                       \
 662                                                                             \
 663   product(bool, JavaMonitorsInStackTrace, true,                             \
 664           "Print information about Java monitor locks when the stacks are"  \
 665           "dumped")                                                         \
 666                                                                             \
 667   product_pd(bool, UseLargePages,                                           \
 668           "Use large page memory")                                          \
 669                                                                             \
 670   product_pd(bool, UseLargePagesIndividualAllocation,                       \
 671           "Allocate large pages individually for better affinity")          \
 672                                                                             \
 673   develop(bool, LargePagesIndividualAllocationInjectError, false,           \
 674           "Fail large pages individual allocation")                         \
 675                                                                             \
 676   product(bool, UseLargePagesInMetaspace, false,                            \
 677           "Use large page memory in metaspace. "                            \
 678           "Only used if UseLargePages is enabled.")                         \
 679                                                                             \
 680   develop(bool, TracePageSizes, false,                                      \
 681           "Trace page size selection and usage")                            \
 682                                                                             \
 683   product(bool, UseNUMA, false,                                             \
 684           "Use NUMA if available")                                          \
 685                                                                             \
 686   product(bool, UseNUMAInterleaving, false,                                 \
 687           "Interleave memory across NUMA nodes if available")               \
 688                                                                             \
 689   product(size_t, NUMAInterleaveGranularity, 2*M,                           \
 690           "Granularity to use for NUMA interleaving on Windows OS")         \
 691           range(os::vm_allocation_granularity(), max_uintx)                 \
 692           constraint(NUMAInterleaveGranularityConstraintFunc,AfterErgo)     \
 693                                                                             \
 694   product(bool, ForceNUMA, false,                                           \
 695           "Force NUMA optimizations on single-node/UMA systems")            \
 696                                                                             \
 697   product(uintx, NUMAChunkResizeWeight, 20,                                 \
 698           "Percentage (0-100) used to weight the current sample when "      \
 699           "computing exponentially decaying average for "                   \
 700           "AdaptiveNUMAChunkSizing")                                        \
 701           range(0, 100)                                                     \
 702                                                                             \
 703   product(size_t, NUMASpaceResizeRate, 1*G,                                 \
 704           "Do not reallocate more than this amount per collection")         \
 705           range(0, max_uintx)                                               \
 706                                                                             \
 707   product(bool, UseAdaptiveNUMAChunkSizing, true,                           \
 708           "Enable adaptive chunk sizing for NUMA")                          \
 709                                                                             \
 710   product(bool, NUMAStats, false,                                           \
 711           "Print NUMA stats in detailed heap information")                  \
 712                                                                             \
 713   product(uintx, NUMAPageScanRate, 256,                                     \
 714           "Maximum number of pages to include in the page scan procedure")  \
 715           range(0, max_uintx)                                               \
 716                                                                             \
 717   product_pd(bool, NeedsDeoptSuspend,                                       \
 718           "True for register window machines (sparc/ia64)")                 \
 719                                                                             \
 720   product(intx, UseSSE, 99,                                                 \
 721           "Highest supported SSE instructions set on x86/x64")              \
 722           range(0, 99)                                                      \
 723                                                                             \
 724   product(bool, UseAES, false,                                              \
 725           "Control whether AES instructions can be used on x86/x64")        \
 726                                                                             \
 727   product(bool, UseSHA, false,                                              \
 728           "Control whether SHA instructions can be used "                   \
 729           "on SPARC and on ARM")                                            \
 730                                                                             \
 731   product(bool, UseGHASHIntrinsics, false,                                  \
 732           "Use intrinsics for GHASH versions of crypto")                    \
 733                                                                             \
 734   product(size_t, LargePageSizeInBytes, 0,                                  \
 735           "Large page size (0 to let VM choose the page size)")             \
 736           range(0, max_uintx)                                               \
 737                                                                             \
 738   product(size_t, LargePageHeapSizeThreshold, 128*M,                        \
 739           "Use large pages if maximum heap is at least this big")           \
 740           range(0, max_uintx)                                               \
 741                                                                             \
 742   product(bool, ForceTimeHighResolution, false,                             \
 743           "Using high time resolution (for Win32 only)")                    \
 744                                                                             \
 745   develop(bool, TraceItables, false,                                        \
 746           "Trace initialization and use of itables")                        \
 747                                                                             \
 748   develop(bool, TracePcPatching, false,                                     \
 749           "Trace usage of frame::patch_pc")                                 \
 750                                                                             \
 751   develop(bool, TraceJumps, false,                                          \
 752           "Trace assembly jumps in thread ring buffer")                     \
 753                                                                             \
 754   develop(bool, TraceRelocator, false,                                      \
 755           "Trace the bytecode relocator")                                   \
 756                                                                             \
 757   develop(bool, TraceLongCompiles, false,                                   \
 758           "Print out every time compilation is longer than "                \
 759           "a given threshold")                                              \
 760                                                                             \
 761   develop(bool, SafepointALot, false,                                       \
 762           "Generate a lot of safepoints. This works with "                  \
 763           "GuaranteedSafepointInterval")                                    \
 764                                                                             \
 765   product_pd(bool, BackgroundCompilation,                                   \
 766           "A thread requesting compilation is not blocked during "          \
 767           "compilation")                                                    \
 768                                                                             \
 769   product(bool, PrintVMQWaitTime, false,                                    \
 770           "Print out the waiting time in VM operation queue")               \
 771                                                                             \
 772   develop(bool, TraceOopMapGeneration, false,                               \
 773           "Show OopMapGeneration")                                          \
 774                                                                             \
 775   product(bool, MethodFlushing, true,                                       \
 776           "Reclamation of zombie and not-entrant methods")                  \
 777                                                                             \
 778   develop(bool, VerifyStack, false,                                         \
 779           "Verify stack of each thread when it is entering a runtime call") \
 780                                                                             \
 781   diagnostic(bool, ForceUnreachable, false,                                 \
 782           "Make all non code cache addresses to be unreachable by "         \
 783           "forcing use of 64bit literal fixups")                            \
 784                                                                             \
 785   notproduct(bool, StressDerivedPointers, false,                            \
 786           "Force scavenge when a derived pointer is detected on stack "     \
 787           "after rtm call")                                                 \
 788                                                                             \
 789   develop(bool, TraceDerivedPointers, false,                                \
 790           "Trace traversal of derived pointers on stack")                   \
 791                                                                             \
 792   notproduct(bool, TraceCodeBlobStacks, false,                              \
 793           "Trace stack-walk of codeblobs")                                  \
 794                                                                             \
 795   product(bool, PrintJNIResolving, false,                                   \
 796           "Used to implement -v:jni")                                       \
 797                                                                             \
 798   notproduct(bool, PrintRewrites, false,                                    \
 799           "Print methods that are being rewritten")                         \
 800                                                                             \
 801   product(bool, UseInlineCaches, true,                                      \
 802           "Use Inline Caches for virtual calls ")                           \
 803                                                                             \
 804   develop(bool, InlineArrayCopy, true,                                      \
 805           "Inline arraycopy native that is known to be part of "            \
 806           "base library DLL")                                               \
 807                                                                             \
 808   develop(bool, InlineObjectHash, true,                                     \
 809           "Inline Object::hashCode() native that is known to be part "      \
 810           "of base library DLL")                                            \
 811                                                                             \
 812   develop(bool, InlineNatives, true,                                        \
 813           "Inline natives that are known to be part of base library DLL")   \
 814                                                                             \
 815   develop(bool, InlineMathNatives, true,                                    \
 816           "Inline SinD, CosD, etc.")                                        \
 817                                                                             \
 818   develop(bool, InlineClassNatives, true,                                   \
 819           "Inline Class.isInstance, etc")                                   \
 820                                                                             \
 821   develop(bool, InlineThreadNatives, true,                                  \
 822           "Inline Thread.currentThread, etc")                               \
 823                                                                             \
 824   develop(bool, InlineUnsafeOps, true,                                      \
 825           "Inline memory ops (native methods) from Unsafe")                 \
 826                                                                             \
 827   product(bool, CriticalJNINatives, true,                                   \
 828           "Check for critical JNI entry points")                            \
 829                                                                             \
 830   notproduct(bool, StressCriticalJNINatives, false,                         \
 831           "Exercise register saving code in critical natives")              \
 832                                                                             \
 833   product(bool, UseSSE42Intrinsics, false,                                  \
 834           "SSE4.2 versions of intrinsics")                                  \
 835                                                                             \
 836   product(bool, UseAESIntrinsics, false,                                    \
 837           "Use intrinsics for AES versions of crypto")                      \
 838                                                                             \
 839   product(bool, UseSHA1Intrinsics, false,                                   \
 840           "Use intrinsics for SHA-1 crypto hash function. "                 \
 841           "Requires that UseSHA is enabled.")                               \
 842                                                                             \
 843   product(bool, UseSHA256Intrinsics, false,                                 \
 844           "Use intrinsics for SHA-224 and SHA-256 crypto hash functions. "  \
 845           "Requires that UseSHA is enabled.")                               \
 846                                                                             \
 847   product(bool, UseSHA512Intrinsics, false,                                 \
 848           "Use intrinsics for SHA-384 and SHA-512 crypto hash functions. "  \
 849           "Requires that UseSHA is enabled.")                               \
 850                                                                             \
 851   product(bool, UseCRC32Intrinsics, false,                                  \
 852           "use intrinsics for java.util.zip.CRC32")                         \
 853                                                                             \
 854   product(bool, UseCRC32CIntrinsics, false,                                 \
 855           "use intrinsics for java.util.zip.CRC32C")                        \
 856                                                                             \
 857   product(bool, UseAdler32Intrinsics, false,                                \
 858           "use intrinsics for java.util.zip.Adler32")                       \
 859                                                                             \
 860   diagnostic(ccstrlist, DisableIntrinsic, "",                               \
 861          "do not expand intrinsics whose (internal) names appear here")     \
 862                                                                             \
<a name="1" id="anc1"></a><span class="new"> 863   product(bool, UseOnSpinWaitIntrinsic, false,                              \</span>
<span class="new"> 864           "Use intrinsic for onSpinWait")                                   \</span>
<span class="new"> 865                                                                             \</span>
 866   develop(bool, TraceCallFixup, false,                                      \
 867           "Trace all call fixups")                                          \
 868                                                                             \
 869   develop(bool, DeoptimizeALot, false,                                      \
 870           "Deoptimize at every exit from the runtime system")               \
 871                                                                             \
 872   notproduct(ccstrlist, DeoptimizeOnlyAt, "",                               \
 873           "A comma separated list of bcis to deoptimize at")                \
 874                                                                             \
 875   product(bool, DeoptimizeRandom, false,                                    \
 876           "Deoptimize random frames on random exit from the runtime system")\
 877                                                                             \
 878   notproduct(bool, ZombieALot, false,                                       \
 879           "Create zombies (non-entrant) at exit from the runtime system")   \
 880                                                                             \
 881   product(bool, UnlinkSymbolsALot, false,                                   \
 882           "Unlink unreferenced symbols from the symbol table at safepoints")\
 883                                                                             \
 884   notproduct(bool, WalkStackALot, false,                                    \
 885           "Trace stack (no print) at every exit from the runtime system")   \
 886                                                                             \
 887   product(bool, Debugging, false,                                           \
 888           "Set when executing debug methods in debug.cpp "                  \
 889           "(to prevent triggering assertions)")                             \
 890                                                                             \
 891   notproduct(bool, StrictSafepointChecks, trueInDebug,                      \
 892           "Enable strict checks that safepoints cannot happen for threads " \
 893           "that use No_Safepoint_Verifier")                                 \
 894                                                                             \
 895   notproduct(bool, VerifyLastFrame, false,                                  \
 896           "Verify oops on last frame on entry to VM")                       \
 897                                                                             \
 898   develop(bool, TraceHandleAllocation, false,                               \
 899           "Print out warnings when suspiciously many handles are allocated")\
 900                                                                             \
 901   product(bool, FailOverToOldVerifier, true,                                \
 902           "Fail over to old verifier when split verifier fails")            \
 903                                                                             \
 904   develop(bool, ShowSafepointMsgs, false,                                   \
 905           "Show message about safepoint synchronization")                   \
 906                                                                             \
 907   product(bool, SafepointTimeout, false,                                    \
 908           "Time out and warn or fail after SafepointTimeoutDelay "          \
 909           "milliseconds if failed to reach safepoint")                      \
 910                                                                             \
 911   develop(bool, DieOnSafepointTimeout, false,                               \
 912           "Die upon failure to reach safepoint (see SafepointTimeout)")     \
 913                                                                             \
 914   /* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds */      \
 915   /* typically, at most a few retries are needed                    */      \
 916   product(intx, SuspendRetryCount, 50,                                      \
 917           "Maximum retry count for an external suspend request")            \
 918           range(0, max_intx)                                                \
 919                                                                             \
 920   product(intx, SuspendRetryDelay, 5,                                       \
 921           "Milliseconds to delay per retry (* current_retry_count)")        \
 922           range(0, max_intx)                                                \
 923                                                                             \
 924   product(bool, AssertOnSuspendWaitFailure, false,                          \
 925           "Assert/Guarantee on external suspend wait failure")              \
 926                                                                             \
 927   product(bool, TraceSuspendWaitFailures, false,                            \
 928           "Trace external suspend wait failures")                           \
 929                                                                             \
 930   product(bool, MaxFDLimit, true,                                           \
 931           "Bump the number of file descriptors to maximum in Solaris")      \
 932                                                                             \
 933   diagnostic(bool, LogEvents, true,                                         \
 934           "Enable the various ring buffer event logs")                      \
 935                                                                             \
 936   diagnostic(uintx, LogEventsBufferEntries, 10,                             \
 937           "Number of ring buffer event logs")                               \
 938           range(1, NOT_LP64(1*K) LP64_ONLY(1*M))                            \
 939                                                                             \
 940   product(bool, BytecodeVerificationRemote, true,                           \
 941           "Enable the Java bytecode verifier for remote classes")           \
 942                                                                             \
 943   product(bool, BytecodeVerificationLocal, false,                           \
 944           "Enable the Java bytecode verifier for local classes")            \
 945                                                                             \
 946   develop(bool, ForceFloatExceptions, trueInDebug,                          \
 947           "Force exceptions on FP stack under/overflow")                    \
 948                                                                             \
 949   develop(bool, VerifyStackAtCalls, false,                                  \
 950           "Verify that the stack pointer is unchanged after calls")         \
 951                                                                             \
 952   develop(bool, TraceJavaAssertions, false,                                 \
 953           "Trace java language assertions")                                 \
 954                                                                             \
 955   notproduct(bool, CheckAssertionStatusDirectives, false,                   \
 956           "Temporary - see javaClasses.cpp")                                \
 957                                                                             \
 958   notproduct(bool, PrintMallocFree, false,                                  \
 959           "Trace calls to C heap malloc/free allocation")                   \
 960                                                                             \
 961   product(bool, PrintOopAddress, false,                                     \
 962           "Always print the location of the oop")                           \
 963                                                                             \
 964   notproduct(bool, VerifyCodeCache, false,                                  \
 965           "Verify code cache on memory allocation/deallocation")            \
 966                                                                             \
 967   develop(bool, UseMallocOnly, false,                                       \
 968           "Use only malloc/free for allocation (no resource area/arena)")   \
 969                                                                             \
 970   develop(bool, PrintMalloc, false,                                         \
 971           "Print all malloc/free calls")                                    \
 972                                                                             \
 973   develop(bool, PrintMallocStatistics, false,                               \
 974           "Print malloc/free statistics")                                   \
 975                                                                             \
 976   develop(bool, ZapResourceArea, trueInDebug,                               \
 977           "Zap freed resource/arena space with 0xABABABAB")                 \
 978                                                                             \
 979   notproduct(bool, ZapVMHandleArea, trueInDebug,                            \
 980           "Zap freed VM handle space with 0xBCBCBCBC")                      \
 981                                                                             \
 982   develop(bool, ZapJNIHandleArea, trueInDebug,                              \
 983           "Zap freed JNI handle space with 0xFEFEFEFE")                     \
 984                                                                             \
 985   notproduct(bool, ZapStackSegments, trueInDebug,                           \
 986           "Zap allocated/freed stack segments with 0xFADFADED")             \
 987                                                                             \
 988   develop(bool, ZapUnusedHeapArea, trueInDebug,                             \
 989           "Zap unused heap space with 0xBAADBABE")                          \
 990                                                                             \
 991   develop(bool, TraceZapUnusedHeapArea, false,                              \
 992           "Trace zapping of unused heap space")                             \
 993                                                                             \
 994   develop(bool, CheckZapUnusedHeapArea, false,                              \
 995           "Check zapping of unused heap space")                             \
 996                                                                             \
 997   develop(bool, ZapFillerObjects, trueInDebug,                              \
 998           "Zap filler objects with 0xDEAFBABE")                             \
 999                                                                             \
1000   develop(bool, PrintVMMessages, true,                                      \
1001           "Print VM messages on console")                                   \
1002                                                                             \
1003   product(bool, PrintGCApplicationConcurrentTime, false,                    \
1004           "Print the time the application has been running")                \
1005                                                                             \
1006   product(bool, PrintGCApplicationStoppedTime, false,                       \
1007           "Print the time the application has been stopped")                \
1008                                                                             \
1009   diagnostic(bool, VerboseVerification, false,                              \
1010           "Display detailed verification details")                          \
1011                                                                             \
1012   notproduct(uintx, ErrorHandlerTest, 0,                                    \
1013           "If &gt; 0, provokes an error after VM initialization; the value "   \
1014           "determines which error to provoke. See test_error_handler() "    \
1015           "in debug.cpp.")                                                  \
1016                                                                             \
1017   notproduct(uintx, TestCrashInErrorHandler, 0,                             \
1018           "If &gt; 0, provokes an error inside VM error handler (a secondary " \
1019           "crash). see test_error_handler() in debug.cpp.")                 \
1020                                                                             \
1021   notproduct(bool, TestSafeFetchInErrorHandler, false,                      \
1022           "If true, tests SafeFetch inside error handler.")                 \
1023                                                                             \
1024   develop(bool, Verbose, false,                                             \
1025           "Print additional debugging information from other modes")        \
1026                                                                             \
1027   develop(bool, PrintMiscellaneous, false,                                  \
1028           "Print uncategorized debugging information (requires +Verbose)")  \
1029                                                                             \
1030   develop(bool, WizardMode, false,                                          \
1031           "Print much more debugging information")                          \
1032                                                                             \
1033   product(bool, ShowMessageBoxOnError, false,                               \
1034           "Keep process alive on VM fatal error")                           \
1035                                                                             \
1036   product(bool, CreateCoredumpOnCrash, true,                                \
1037           "Create core/mini dump on VM fatal error")                        \
1038                                                                             \
1039   product(uint64_t, ErrorLogTimeout, 2 * 60,                                \
1040           "Timeout, in seconds, to limit the time spent on writing an "     \
1041           "error log in case of a crash.")                                  \
1042           range(0, (uint64_t)max_jlong/1000)                                \
1043                                                                             \
1044   product_pd(bool, UseOSErrorReporting,                                     \
1045           "Let VM fatal error propagate to the OS (ie. WER on Windows)")    \
1046                                                                             \
1047   product(bool, SuppressFatalErrorMessage, false,                           \
1048           "Report NO fatal error message (avoid deadlock)")                 \
1049                                                                             \
1050   product(ccstrlist, OnError, "",                                           \
1051           "Run user-defined commands on fatal error; see VMError.cpp "      \
1052           "for examples")                                                   \
1053                                                                             \
1054   product(ccstrlist, OnOutOfMemoryError, "",                                \
1055           "Run user-defined commands on first java.lang.OutOfMemoryError")  \
1056                                                                             \
1057   manageable(bool, HeapDumpBeforeFullGC, false,                             \
1058           "Dump heap to file before any major stop-the-world GC")           \
1059                                                                             \
1060   manageable(bool, HeapDumpAfterFullGC, false,                              \
1061           "Dump heap to file after any major stop-the-world GC")            \
1062                                                                             \
1063   manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \
1064           "Dump heap to file when java.lang.OutOfMemoryError is thrown")    \
1065                                                                             \
1066   manageable(ccstr, HeapDumpPath, NULL,                                     \
1067           "When HeapDumpOnOutOfMemoryError is on, the path (filename or "   \
1068           "directory) of the dump file (defaults to java_pid&lt;pid&gt;.hprof "   \
1069           "in the working directory)")                                      \
1070                                                                             \
1071   develop(size_t, SegmentedHeapDumpThreshold, 2*G,                          \
1072           "Generate a segmented heap dump (JAVA PROFILE 1.0.2 format) "     \
1073           "when the heap usage is larger than this")                        \
1074                                                                             \
1075   develop(size_t, HeapDumpSegmentSize, 1*G,                                 \
1076           "Approximate segment size when generating a segmented heap dump") \
1077                                                                             \
1078   develop(bool, BreakAtWarning, false,                                      \
1079           "Execute breakpoint upon encountering VM warning")                \
1080                                                                             \
1081   develop(bool, UseFakeTimers, false,                                       \
1082           "Tell whether the VM should use system time or a fake timer")     \
1083                                                                             \
1084   product(ccstr, NativeMemoryTracking, "off",                               \
1085           "Native memory tracking options")                                 \
1086                                                                             \
1087   diagnostic(bool, PrintNMTStatistics, false,                               \
1088           "Print native memory tracking summary data if it is on")          \
1089                                                                             \
1090   diagnostic(bool, LogCompilation, false,                                   \
1091           "Log compilation activity in detail to LogFile")                  \
1092                                                                             \
1093   product(bool, PrintCompilation, false,                                    \
1094           "Print compilations")                                             \
1095                                                                             \
1096   diagnostic(bool, TraceNMethodInstalls, false,                             \
1097           "Trace nmethod installation")                                     \
1098                                                                             \
1099   diagnostic(intx, ScavengeRootsInCode, 2,                                  \
1100           "0: do not allow scavengable oops in the code cache; "            \
1101           "1: allow scavenging from the code cache; "                       \
1102           "2: emit as many constants as the compiler can see")              \
1103           range(0, 2)                                                       \
1104                                                                             \
1105   product(bool, AlwaysRestoreFPU, false,                                    \
1106           "Restore the FPU control word after every JNI call (expensive)")  \
1107                                                                             \
1108   diagnostic(bool, PrintCompilation2, false,                                \
1109           "Print additional statistics per compilation")                    \
1110                                                                             \
1111   diagnostic(bool, PrintAdapterHandlers, false,                             \
1112           "Print code generated for i2c/c2i adapters")                      \
1113                                                                             \
1114   diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \
1115           "Verify that i2c/c2i adapters are called properly")               \
1116                                                                             \
1117   develop(bool, VerifyAdapterSharing, false,                                \
1118           "Verify that the code for shared adapters is the equivalent")     \
1119                                                                             \
1120   diagnostic(bool, PrintAssembly, false,                                    \
1121           "Print assembly code (using external disassembler.so)")           \
1122                                                                             \
1123   diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \
1124           "Print options string passed to disassembler.so")                 \
1125                                                                             \
1126   notproduct(bool, PrintNMethodStatistics, false,                           \
1127           "Print a summary statistic for the generated nmethods")           \
1128                                                                             \
1129   diagnostic(bool, PrintNMethods, false,                                    \
1130           "Print assembly code for nmethods when generated")                \
1131                                                                             \
1132   diagnostic(bool, PrintNativeNMethods, false,                              \
1133           "Print assembly code for native nmethods when generated")         \
1134                                                                             \
1135   develop(bool, PrintDebugInfo, false,                                      \
1136           "Print debug information for all nmethods when generated")        \
1137                                                                             \
1138   develop(bool, PrintRelocations, false,                                    \
1139           "Print relocation information for all nmethods when generated")   \
1140                                                                             \
1141   develop(bool, PrintDependencies, false,                                   \
1142           "Print dependency information for all nmethods when generated")   \
1143                                                                             \
1144   develop(bool, PrintExceptionHandlers, false,                              \
1145           "Print exception handler tables for all nmethods when generated") \
1146                                                                             \
1147   develop(bool, StressCompiledExceptionHandlers, false,                     \
1148           "Exercise compiled exception handlers")                           \
1149                                                                             \
1150   develop(bool, InterceptOSException, false,                                \
1151           "Start debugger when an implicit OS (e.g. NULL) "                 \
1152           "exception happens")                                              \
1153                                                                             \
1154   product(bool, PrintCodeCache, false,                                      \
1155           "Print the code cache memory usage when exiting")                 \
1156                                                                             \
1157   develop(bool, PrintCodeCache2, false,                                     \
1158           "Print detailed usage information on the code cache when exiting")\
1159                                                                             \
1160   product(bool, PrintCodeCacheOnCompilation, false,                         \
1161           "Print the code cache memory usage each time a method is "        \
1162           "compiled")                                                       \
1163                                                                             \
1164   diagnostic(bool, PrintStubCode, false,                                    \
1165           "Print generated stub code")                                      \
1166                                                                             \
1167   product(bool, StackTraceInThrowable, true,                                \
1168           "Collect backtrace in throwable when exception happens")          \
1169                                                                             \
1170   product(bool, OmitStackTraceInFastThrow, true,                            \
1171           "Omit backtraces for some 'hot' exceptions in optimized code")    \
1172                                                                             \
1173   product(bool, ProfilerPrintByteCodeStatistics, false,                     \
1174           "Print bytecode statistics when dumping profiler output")         \
1175                                                                             \
1176   product(bool, ProfilerRecordPC, false,                                    \
1177           "Collect ticks for each 16 byte interval of compiled code")       \
1178                                                                             \
1179   product(bool, ProfileVM, false,                                           \
1180           "Profile ticks that fall within VM (either in the VM Thread "     \
1181           "or VM code called through stubs)")                               \
1182                                                                             \
1183   product(bool, ProfileIntervals, false,                                    \
1184           "Print profiles for each interval (see ProfileIntervalsTicks)")   \
1185                                                                             \
1186   notproduct(bool, ProfilerCheckIntervals, false,                           \
1187           "Collect and print information on spacing of profiler ticks")     \
1188                                                                             \
1189   product(bool, PrintWarnings, true,                                        \
1190           "Print JVM warnings to output stream")                            \
1191                                                                             \
1192   notproduct(uintx, WarnOnStalledSpinLock, 0,                               \
1193           "Print warnings for stalled SpinLocks")                           \
1194                                                                             \
1195   product(bool, RegisterFinalizersAtInit, true,                             \
1196           "Register finalizable objects at end of Object.&lt;init&gt; or "        \
1197           "after allocation")                                               \
1198                                                                             \
1199   develop(bool, RegisterReferences, true,                                   \
1200           "Tell whether the VM should register soft/weak/final/phantom "    \
1201           "references")                                                     \
1202                                                                             \
1203   develop(bool, IgnoreRewrites, false,                                      \
1204           "Suppress rewrites of bytecodes in the oopmap generator. "        \
1205           "This is unsafe!")                                                \
1206                                                                             \
1207   develop(bool, PrintCodeCacheExtension, false,                             \
1208           "Print extension of code cache")                                  \
1209                                                                             \
1210   develop(bool, UsePrivilegedStack, true,                                   \
1211           "Enable the security JVM functions")                              \
1212                                                                             \
1213   develop(bool, ProtectionDomainVerification, true,                         \
1214           "Verify protection domain before resolution in system dictionary")\
1215                                                                             \
1216   product(bool, ClassUnloading, true,                                       \
1217           "Do unloading of classes")                                        \
1218                                                                             \
1219   product(bool, ClassUnloadingWithConcurrentMark, true,                     \
1220           "Do unloading of classes with a concurrent marking cycle")        \
1221                                                                             \
1222   develop(bool, DisableStartThread, false,                                  \
1223           "Disable starting of additional Java threads "                    \
1224           "(for debugging only)")                                           \
1225                                                                             \
1226   develop(bool, MemProfiling, false,                                        \
1227           "Write memory usage profiling to log file")                       \
1228                                                                             \
1229   notproduct(bool, PrintSystemDictionaryAtExit, false,                      \
1230           "Print the system dictionary at exit")                            \
1231                                                                             \
1232   experimental(intx, PredictedLoadedClassCount, 0,                          \
1233           "Experimental: Tune loaded class cache starting size")            \
1234                                                                             \
1235   diagnostic(bool, UnsyncloadClass, false,                                  \
1236           "Unstable: VM calls loadClass unsynchronized. Custom "            \
1237           "class loader must call VM synchronized for findClass "           \
1238           "and defineClass.")                                               \
1239                                                                             \
1240   product(bool, AlwaysLockClassLoader, false,                               \
1241           "Require the VM to acquire the class loader lock before calling " \
1242           "loadClass() even for class loaders registering "                 \
1243           "as parallel capable")                                            \
1244                                                                             \
1245   product(bool, AllowParallelDefineClass, false,                            \
1246           "Allow parallel defineClass requests for class loaders "          \
1247           "registering as parallel capable")                                \
1248                                                                             \
1249   product(bool, MustCallLoadClassInternal, false,                           \
1250           "Call loadClassInternal() rather than loadClass()")               \
1251                                                                             \
1252   product_pd(bool, DontYieldALot,                                           \
1253           "Throw away obvious excess yield calls")                          \
1254                                                                             \
1255   product_pd(bool, ConvertSleepToYield,                                     \
1256           "Convert sleep(0) to thread yield "                               \
1257           "(may be off for Solaris to improve GUI)")                        \
1258                                                                             \
1259   product(bool, ConvertYieldToSleep, false,                                 \
1260           "Convert yield to a sleep of MinSleepInterval to simulate Win32 " \
1261           "behavior")                                                       \
1262                                                                             \
1263   develop(bool, UseDetachedThreads, true,                                   \
1264           "Use detached threads that are recycled upon termination "        \
1265           "(for Solaris only)")                                             \
1266                                                                             \
1267   product(bool, UseLWPSynchronization, true,                                \
1268           "Use LWP-based instead of libthread-based synchronization "       \
1269           "(SPARC only)")                                                   \
1270                                                                             \
1271   experimental(ccstr, SyncKnobs, NULL,                                      \
1272                "(Unstable) Various monitor synchronization tunables")       \
1273                                                                             \
1274   experimental(intx, EmitSync, 0,                                           \
1275                "(Unsafe, Unstable) "                                        \
1276                "Control emission of inline sync fast-path code")            \
1277                                                                             \
1278   product(intx, MonitorBound, 0, "Bound Monitor population")                \
1279           range(0, max_jint)                                                \
1280                                                                             \
1281   product(bool, MonitorInUseLists, false, "Track Monitors for Deflation")   \
1282                                                                             \
1283   experimental(intx, SyncFlags, 0, "(Unsafe, Unstable) "                    \
1284                "Experimental Sync flags")                                   \
1285                                                                             \
1286   experimental(intx, SyncVerbose, 0, "(Unstable)")                          \
1287                                                                             \
1288   diagnostic(bool, InlineNotify, true, "intrinsify subset of notify")       \
1289                                                                             \
1290   experimental(intx, ClearFPUAtPark, 0, "(Unsafe, Unstable)")               \
1291                                                                             \
1292   experimental(intx, hashCode, 5,                                           \
1293                "(Unstable) select hashCode generation algorithm")           \
1294                                                                             \
1295   experimental(intx, WorkAroundNPTLTimedWaitHang, 0,                        \
1296                "(Unstable, Linux-specific) "                                \
1297                "avoid NPTL-FUTEX hang pthread_cond_timedwait")              \
1298                                                                             \
1299   product(bool, FilterSpuriousWakeups, true,                                \
1300           "When true prevents OS-level spurious, or premature, wakeups "    \
1301           "from Object.wait (Ignored for Windows)")                         \
1302                                                                             \
1303   experimental(intx, NativeMonitorTimeout, -1, "(Unstable)")                \
1304                                                                             \
1305   experimental(intx, NativeMonitorFlags, 0, "(Unstable)")                   \
1306                                                                             \
1307   experimental(intx, NativeMonitorSpinLimit, 20, "(Unstable)")              \
1308                                                                             \
1309   develop(bool, UsePthreads, false,                                         \
1310           "Use pthread-based instead of libthread-based synchronization "   \
1311           "(SPARC only)")                                                   \
1312                                                                             \
1313   product(bool, ReduceSignalUsage, false,                                   \
1314           "Reduce the use of OS signals in Java and/or the VM")             \
1315                                                                             \
1316   develop_pd(bool, ShareVtableStubs,                                        \
1317           "Share vtable stubs (smaller code but worse branch prediction")   \
1318                                                                             \
1319   develop(bool, LoadLineNumberTables, true,                                 \
1320           "Tell whether the class file parser loads line number tables")    \
1321                                                                             \
1322   develop(bool, LoadLocalVariableTables, true,                              \
1323           "Tell whether the class file parser loads local variable tables") \
1324                                                                             \
1325   develop(bool, LoadLocalVariableTypeTables, true,                          \
1326           "Tell whether the class file parser loads local variable type"    \
1327           "tables")                                                         \
1328                                                                             \
1329   product(bool, AllowUserSignalHandlers, false,                             \
1330           "Do not complain if the application installs signal handlers "    \
1331           "(Solaris &amp; Linux only)")                                         \
1332                                                                             \
1333   product(bool, UseSignalChaining, true,                                    \
1334           "Use signal-chaining to invoke signal handlers installed "        \
1335           "by the application (Solaris &amp; Linux only)")                      \
1336                                                                             \
1337   product(bool, AllowJNIEnvProxy, false,                                    \
1338           "Allow JNIEnv proxies for jdbx")                                  \
1339                                                                             \
1340   product(bool, RestoreMXCSROnJNICalls, false,                              \
1341           "Restore MXCSR when returning from JNI calls")                    \
1342                                                                             \
1343   product(bool, CheckJNICalls, false,                                       \
1344           "Verify all arguments to JNI calls")                              \
1345                                                                             \
1346   product(bool, CheckEndorsedAndExtDirs, false,                             \
1347           "Verify the endorsed and extension directories are not used")     \
1348                                                                             \
1349   product(bool, UseFastJNIAccessors, true,                                  \
1350           "Use optimized versions of Get&lt;Primitive&gt;Field")                  \
1351                                                                             \
1352   product(intx, MaxJNILocalCapacity, 65536,                                 \
1353           "Maximum allowable local JNI handle capacity to "                 \
1354           "EnsureLocalCapacity() and PushLocalFrame(), "                    \
1355           "where &lt;= 0 is unlimited, default: 65536")                        \
1356           range(min_intx, max_intx)                                         \
1357                                                                             \
1358   product(bool, EagerXrunInit, false,                                       \
1359           "Eagerly initialize -Xrun libraries; allows startup profiling, "  \
1360           "but not all -Xrun libraries may support the state of the VM "    \
1361           "at this time")                                                   \
1362                                                                             \
1363   product(bool, PreserveAllAnnotations, false,                              \
1364           "Preserve RuntimeInvisibleAnnotations as well "                   \
1365           "as RuntimeVisibleAnnotations")                                   \
1366                                                                             \
1367   develop(uintx, PreallocatedOutOfMemoryErrorCount, 4,                      \
1368           "Number of OutOfMemoryErrors preallocated with backtrace")        \
1369                                                                             \
1370   product(bool, UseXMMForArrayCopy, false,                                  \
1371           "Use SSE2 MOVQ instruction for Arraycopy")                        \
1372                                                                             \
1373   product(intx, FieldsAllocationStyle, 1,                                   \
1374           "0 - type based with oops first, "                                \
1375           "1 - with oops last, "                                            \
1376           "2 - oops in super and sub classes are together")                 \
1377           range(0, 2)                                                       \
1378                                                                             \
1379   product(bool, CompactFields, true,                                        \
1380           "Allocate nonstatic fields in gaps between previous fields")      \
1381                                                                             \
1382   notproduct(bool, PrintFieldLayout, false,                                 \
1383           "Print field layout for each class")                              \
1384                                                                             \
1385   /* Need to limit the extent of the padding to reasonable size.          */\
1386   /* 8K is well beyond the reasonable HW cache line size, even with       */\
1387   /* aggressive prefetching, while still leaving the room for segregating */\
1388   /* among the distinct pages.                                            */\
1389   product(intx, ContendedPaddingWidth, 128,                                 \
1390           "How many bytes to pad the fields/classes marked @Contended with")\
1391           range(0, 8192)                                                    \
1392           constraint(ContendedPaddingWidthConstraintFunc,AfterErgo)         \
1393                                                                             \
1394   product(bool, EnableContended, true,                                      \
1395           "Enable @Contended annotation support")                           \
1396                                                                             \
1397   product(bool, RestrictContended, true,                                    \
1398           "Restrict @Contended to trusted classes")                         \
1399                                                                             \
1400   product(bool, UseBiasedLocking, true,                                     \
1401           "Enable biased locking in JVM")                                   \
1402                                                                             \
1403   product(intx, BiasedLockingStartupDelay, 4000,                            \
1404           "Number of milliseconds to wait before enabling biased locking")  \
1405           range(0, (intx)(max_jint-(max_jint%PeriodicTask::interval_gran))) \
1406           constraint(BiasedLockingStartupDelayFunc,AfterErgo)               \
1407                                                                             \
1408   diagnostic(bool, PrintBiasedLockingStatistics, false,                     \
1409           "Print statistics of biased locking in JVM")                      \
1410                                                                             \
1411   product(intx, BiasedLockingBulkRebiasThreshold, 20,                       \
1412           "Threshold of number of revocations per type to try to "          \
1413           "rebias all objects in the heap of that type")                    \
1414           range(0, max_intx)                                                \
1415           constraint(BiasedLockingBulkRebiasThresholdFunc,AfterErgo)        \
1416                                                                             \
1417   product(intx, BiasedLockingBulkRevokeThreshold, 40,                       \
1418           "Threshold of number of revocations per type to permanently "     \
1419           "revoke biases of all objects in the heap of that type")          \
1420           range(0, max_intx)                                                \
1421           constraint(BiasedLockingBulkRevokeThresholdFunc,AfterErgo)        \
1422                                                                             \
1423   product(intx, BiasedLockingDecayTime, 25000,                              \
1424           "Decay time (in milliseconds) to re-enable bulk rebiasing of a "  \
1425           "type after previous bulk rebias")                                \
1426           range(500, max_intx)                                              \
1427           constraint(BiasedLockingDecayTimeFunc,AfterErgo)                  \
1428                                                                             \
1429   product(bool, ExitOnOutOfMemoryError, false,                              \
1430           "JVM exits on the first occurrence of an out-of-memory error")    \
1431                                                                             \
1432   product(bool, CrashOnOutOfMemoryError, false,                             \
1433           "JVM aborts, producing an error log and core/mini dump, on the "  \
1434           "first occurrence of an out-of-memory error")                     \
1435                                                                             \
1436   /* tracing */                                                             \
1437                                                                             \
1438   develop(bool, StressRewriter, false,                                      \
1439           "Stress linktime bytecode rewriting")                             \
1440                                                                             \
1441   product(ccstr, TraceJVMTI, NULL,                                          \
1442           "Trace flags for JVMTI functions and events")                     \
1443                                                                             \
1444   /* This option can change an EMCP method into an obsolete method. */      \
1445   /* This can affect tests that except specific methods to be EMCP. */      \
1446   /* This option should be used with caution.                       */      \
1447   product(bool, StressLdcRewrite, false,                                    \
1448           "Force ldc -&gt; ldc_w rewrite during RedefineClasses")              \
1449                                                                             \
1450   product(uintx, TraceRedefineClasses, 0,                                   \
1451           "Trace level for JVMTI RedefineClasses")                          \
1452           range(0, 0xFFFFFFFF)                                              \
1453                                                                             \
1454   /* change to false by default sometime after Mustang */                   \
1455   product(bool, VerifyMergedCPBytecodes, true,                              \
1456           "Verify bytecodes after RedefineClasses constant pool merging")   \
1457                                                                             \
1458   develop(bool, TraceJNIHandleAllocation, false,                            \
1459           "Trace allocation/deallocation of JNI handle blocks")             \
1460                                                                             \
1461   develop(bool, TraceBytecodes, false,                                      \
1462           "Trace bytecode execution")                                       \
1463                                                                             \
1464   product(bool, TraceExceptions, false,                                     \
1465           "Trace exceptions")                                               \
1466                                                                             \
1467   develop(bool, TraceICs, false,                                            \
1468           "Trace inline cache changes")                                     \
1469                                                                             \
1470   notproduct(bool, TraceInvocationCounterOverflow, false,                   \
1471           "Trace method invocation counter overflow")                       \
1472                                                                             \
1473   develop(bool, TraceInlineCacheClearing, false,                            \
1474           "Trace clearing of inline caches in nmethods")                    \
1475                                                                             \
1476   develop(bool, TraceDependencies, false,                                   \
1477           "Trace dependencies")                                             \
1478                                                                             \
1479   develop(bool, VerifyDependencies, trueInDebug,                            \
1480           "Exercise and verify the compilation dependency mechanism")       \
1481                                                                             \
1482   develop(bool, TraceNewOopMapGeneration, false,                            \
1483           "Trace OopMapGeneration")                                         \
1484                                                                             \
1485   develop(bool, TraceNewOopMapGenerationDetailed, false,                    \
1486           "Trace OopMapGeneration: print detailed cell states")             \
1487                                                                             \
1488   develop(bool, TimeOopMap, false,                                          \
1489           "Time calls to GenerateOopMap::compute_map() in sum")             \
1490                                                                             \
1491   develop(bool, TimeOopMap2, false,                                         \
1492           "Time calls to GenerateOopMap::compute_map() individually")       \
1493                                                                             \
1494   develop(bool, TraceMonitorMismatch, false,                                \
1495           "Trace monitor matching failures during OopMapGeneration")        \
1496                                                                             \
1497   develop(bool, TraceOopMapRewrites, false,                                 \
1498           "Trace rewriting of method oops during oop map generation")       \
1499                                                                             \
1500   develop(bool, TraceICBuffer, false,                                       \
1501           "Trace usage of IC buffer")                                       \
1502                                                                             \
1503   develop(bool, TraceCompiledIC, false,                                     \
1504           "Trace changes of compiled IC")                                   \
1505                                                                             \
1506   develop(bool, TraceStartupTime, false,                                    \
1507           "Trace setup time")                                               \
1508                                                                             \
1509   develop(bool, TraceProtectionDomainVerification, false,                   \
1510           "Trace protection domain verification")                           \
1511                                                                             \
1512   develop(bool, TraceClearedExceptions, false,                              \
1513           "Print when an exception is forcibly cleared")                    \
1514                                                                             \
1515   product(bool, TraceClassResolution, false,                                \
1516           "Trace all constant pool resolutions (for debugging)")            \
1517                                                                             \
1518   product(bool, TraceBiasedLocking, false,                                  \
1519           "Trace biased locking in JVM")                                    \
1520                                                                             \
1521   product(bool, TraceMonitorInflation, false,                               \
1522           "Trace monitor inflation in JVM")                                 \
1523                                                                             \
1524   /* gc */                                                                  \
1525                                                                             \
1526   product(bool, UseSerialGC, false,                                         \
1527           "Use the Serial garbage collector")                               \
1528                                                                             \
1529   product(bool, UseG1GC, false,                                             \
1530           "Use the Garbage-First garbage collector")                        \
1531                                                                             \
1532   product(bool, UseParallelGC, false,                                       \
1533           "Use the Parallel Scavenge garbage collector")                    \
1534                                                                             \
1535   product(bool, UseParallelOldGC, false,                                    \
1536           "Use the Parallel Old garbage collector")                         \
1537                                                                             \
1538   product(uintx, HeapMaximumCompactionInterval, 20,                         \
1539           "How often should we maximally compact the heap (not allowing "   \
1540           "any dead space)")                                                \
1541           range(0, max_uintx)                                               \
1542                                                                             \
1543   product(uintx, HeapFirstMaximumCompactionCount, 3,                        \
1544           "The collection count for the first maximum compaction")          \
1545           range(0, max_uintx)                                               \
1546                                                                             \
1547   product(bool, UseMaximumCompactionOnSystemGC, true,                       \
1548           "Use maximum compaction in the Parallel Old garbage collector "   \
1549           "for a system GC")                                                \
1550                                                                             \
1551   product(uintx, ParallelOldDeadWoodLimiterMean, 50,                        \
1552           "The mean used by the parallel compact dead wood "                \
1553           "limiter (a number between 0-100)")                               \
1554           range(0, 100)                                                     \
1555                                                                             \
1556   product(uintx, ParallelOldDeadWoodLimiterStdDev, 80,                      \
1557           "The standard deviation used by the parallel compact dead wood "  \
1558           "limiter (a number between 0-100)")                               \
1559           range(0, 100)                                                     \
1560                                                                             \
1561   product(uint, ParallelGCThreads, 0,                                       \
1562           "Number of parallel threads parallel gc will use")                \
1563           constraint(ParallelGCThreadsConstraintFunc,AfterErgo)             \
1564                                                                             \
1565   diagnostic(bool, UseSemaphoreGCThreadsSynchronization, true,              \
1566             "Use semaphore synchronization for the GC Threads, "            \
1567             "instead of synchronization based on mutexes")                  \
1568                                                                             \
1569   product(bool, UseDynamicNumberOfGCThreads, false,                         \
1570           "Dynamically choose the number of parallel threads "              \
1571           "parallel gc will use")                                           \
1572                                                                             \
1573   diagnostic(bool, ForceDynamicNumberOfGCThreads, false,                    \
1574           "Force dynamic selection of the number of "                       \
1575           "parallel threads parallel gc will use to aid debugging")         \
1576                                                                             \
1577   product(size_t, HeapSizePerGCThread, ScaleForWordSize(64*M),              \
1578           "Size of heap (bytes) per GC thread used in calculating the "     \
1579           "number of GC threads")                                           \
1580           range((size_t)os::vm_page_size(), (size_t)max_uintx)              \
1581                                                                             \
1582   product(bool, TraceDynamicGCThreads, false,                               \
1583           "Trace the dynamic GC thread usage")                              \
1584                                                                             \
1585   product(uint, ConcGCThreads, 0,                                           \
1586           "Number of threads concurrent gc will use")                       \
1587           constraint(ConcGCThreadsConstraintFunc,AfterErgo)                 \
1588                                                                             \
1589   product(uintx, GCTaskTimeStampEntries, 200,                               \
1590           "Number of time stamp entries per gc worker thread")              \
1591           range(1, max_uintx)                                               \
1592                                                                             \
1593   product(bool, AlwaysTenure, false,                                        \
1594           "Always tenure objects in eden (ParallelGC only)")                \
1595                                                                             \
1596   product(bool, NeverTenure, false,                                         \
1597           "Never tenure objects in eden, may tenure on overflow "           \
1598           "(ParallelGC only)")                                              \
1599                                                                             \
1600   product(bool, ScavengeBeforeFullGC, true,                                 \
1601           "Scavenge youngest generation before each full GC.")              \
1602                                                                             \
1603   product(bool, UseConcMarkSweepGC, false,                                  \
1604           "Use Concurrent Mark-Sweep GC in the old generation")             \
1605                                                                             \
1606   product(bool, ExplicitGCInvokesConcurrent, false,                         \
1607           "A System.gc() request invokes a concurrent collection; "         \
1608           "(effective only when using concurrent collectors)")              \
1609                                                                             \
1610   product(bool, ExplicitGCInvokesConcurrentAndUnloadsClasses, false,        \
1611           "A System.gc() request invokes a concurrent collection and "      \
1612           "also unloads classes during such a concurrent gc cycle "         \
1613           "(effective only when UseConcMarkSweepGC)")                       \
1614                                                                             \
1615   product(bool, GCLockerInvokesConcurrent, false,                           \
1616           "The exit of a JNI critical section necessitating a scavenge, "   \
1617           "also kicks off a background concurrent collection")              \
1618                                                                             \
1619   product(uintx, GCLockerEdenExpansionPercent, 5,                           \
1620           "How much the GC can expand the eden by while the GC locker "     \
1621           "is active (as a percentage)")                                    \
1622           range(0, 100)                                                     \
1623                                                                             \
1624   diagnostic(uintx, GCLockerRetryAllocationCount, 2,                        \
1625           "Number of times to retry allocations when "                      \
1626           "blocked by the GC locker")                                       \
1627           range(0, max_uintx)                                               \
1628                                                                             \
1629   product(bool, UseCMSBestFit, true,                                        \
1630           "Use CMS best fit allocation strategy")                           \
1631                                                                             \
1632   product(bool, UseParNewGC, false,                                         \
1633           "Use parallel threads in the new generation")                     \
1634                                                                             \
1635   product(bool, PrintTaskqueue, false,                                      \
1636           "Print taskqueue statistics for parallel collectors")             \
1637                                                                             \
1638   product(bool, PrintTerminationStats, false,                               \
1639           "Print termination statistics for parallel collectors")           \
1640                                                                             \
1641   product(uintx, ParallelGCBufferWastePct, 10,                              \
1642           "Wasted fraction of parallel allocation buffer")                  \
1643           range(0, 100)                                                     \
1644                                                                             \
1645   product(uintx, TargetPLABWastePct, 10,                                    \
1646           "Target wasted space in last buffer as percent of overall "       \
1647           "allocation")                                                     \
1648           range(1, 100)                                                     \
1649                                                                             \
1650   product(uintx, PLABWeight, 75,                                            \
1651           "Percentage (0-100) used to weight the current sample when "      \
1652           "computing exponentially decaying average for ResizePLAB")        \
1653           range(0, 100)                                                     \
1654                                                                             \
1655   product(bool, ResizePLAB, true,                                           \
1656           "Dynamically resize (survivor space) promotion LAB's")            \
1657                                                                             \
1658   product(bool, PrintPLAB, false,                                           \
1659           "Print (survivor space) promotion LAB's sizing decisions")        \
1660                                                                             \
1661   product(intx, ParGCArrayScanChunk, 50,                                    \
1662           "Scan a subset of object array and push remainder, if array is "  \
1663           "bigger than this")                                               \
1664           range(1, max_intx)                                                \
1665                                                                             \
1666   product(bool, ParGCUseLocalOverflow, false,                               \
1667           "Instead of a global overflow list, use local overflow stacks")   \
1668                                                                             \
1669   product(bool, ParGCTrimOverflow, true,                                    \
1670           "Eagerly trim the local overflow lists "                          \
1671           "(when ParGCUseLocalOverflow)")                                   \
1672                                                                             \
1673   notproduct(bool, ParGCWorkQueueOverflowALot, false,                       \
1674           "Simulate work queue overflow in ParNew")                         \
1675                                                                             \
1676   notproduct(uintx, ParGCWorkQueueOverflowInterval, 1000,                   \
1677           "An `interval' counter that determines how frequently "           \
1678           "we simulate overflow; a smaller number increases frequency")     \
1679                                                                             \
1680   product(uintx, ParGCDesiredObjsFromOverflowList, 20,                      \
1681           "The desired number of objects to claim from the overflow list")  \
1682           range(0, max_uintx)                                               \
1683                                                                             \
1684   diagnostic(uintx, ParGCStridesPerThread, 2,                               \
1685           "The number of strides per worker thread that we divide up the "  \
1686           "card table scanning work into")                                  \
1687           range(1, max_uintx)                                               \
1688           constraint(ParGCStridesPerThreadConstraintFunc,AfterErgo)         \
1689                                                                             \
1690   diagnostic(intx, ParGCCardsPerStrideChunk, 256,                           \
1691           "The number of cards in each chunk of the parallel chunks used "  \
1692           "during card table scanning")                                     \
1693           range(1, max_intx)                                                \
1694                                                                             \
1695   product(uintx, OldPLABWeight, 50,                                         \
1696           "Percentage (0-100) used to weight the current sample when "      \
1697           "computing exponentially decaying average for resizing "          \
1698           "OldPLABSize")                                                    \
1699           range(0, 100)                                                     \
1700                                                                             \
1701   product(bool, ResizeOldPLAB, true,                                        \
1702           "Dynamically resize (old gen) promotion LAB's")                   \
1703                                                                             \
1704   product(bool, PrintOldPLAB, false,                                        \
1705           "Print (old gen) promotion LAB's sizing decisions")               \
1706                                                                             \
1707   product(size_t, CMSOldPLABMax, 1024,                                      \
1708           "Maximum size of CMS gen promotion LAB caches per worker "        \
1709           "per block size")                                                 \
1710           range(1, max_uintx)                                               \
1711           constraint(CMSOldPLABMaxConstraintFunc,AfterMemoryInit)           \
1712                                                                             \
1713   product(size_t, CMSOldPLABMin, 16,                                        \
1714           "Minimum size of CMS gen promotion LAB caches per worker "        \
1715           "per block size")                                                 \
1716           range(1, max_uintx)                                               \
1717           constraint(CMSOldPLABMinConstraintFunc,AfterMemoryInit)           \
1718                                                                             \
1719   product(uintx, CMSOldPLABNumRefills, 4,                                   \
1720           "Nominal number of refills of CMS gen promotion LAB cache "       \
1721           "per worker per block size")                                      \
1722           range(1, max_uintx)                                               \
1723                                                                             \
1724   product(bool, CMSOldPLABResizeQuicker, false,                             \
1725           "React on-the-fly during a scavenge to a sudden "                 \
1726           "change in block demand rate")                                    \
1727                                                                             \
1728   product(uintx, CMSOldPLABToleranceFactor, 4,                              \
1729           "The tolerance of the phase-change detector for on-the-fly "      \
1730           "PLAB resizing during a scavenge")                                \
1731           range(1, max_uintx)                                               \
1732                                                                             \
1733   product(uintx, CMSOldPLABReactivityFactor, 2,                             \
1734           "The gain in the feedback loop for on-the-fly PLAB resizing "     \
1735           "during a scavenge")                                              \
1736           range(1, max_uintx)                                               \
1737                                                                             \
1738   product(bool, AlwaysPreTouch, false,                                      \
1739           "Force all freshly committed pages to be pre-touched")            \
1740                                                                             \
1741   product_pd(size_t, CMSYoungGenPerWorker,                                  \
1742           "The maximum size of young gen chosen by default per GC worker "  \
1743           "thread available")                                               \
1744           range(1, max_uintx)                                               \
1745                                                                             \
1746   product(uintx, CMSIncrementalSafetyFactor, 10,                            \
1747           "Percentage (0-100) used to add conservatism when computing the " \
1748           "duty cycle")                                                     \
1749           range(0, 100)                                                     \
1750                                                                             \
1751   product(uintx, CMSExpAvgFactor, 50,                                       \
1752           "Percentage (0-100) used to weight the current sample when "      \
1753           "computing exponential averages for CMS statistics")              \
1754           range(0, 100)                                                     \
1755                                                                             \
1756   product(uintx, CMS_FLSWeight, 75,                                         \
1757           "Percentage (0-100) used to weight the current sample when "      \
1758           "computing exponentially decaying averages for CMS FLS "          \
1759           "statistics")                                                     \
1760           range(0, 100)                                                     \
1761                                                                             \
1762   product(uintx, CMS_FLSPadding, 1,                                         \
1763           "The multiple of deviation from mean to use for buffering "       \
1764           "against volatility in free list demand")                         \
1765           range(0, max_juint)                                               \
1766                                                                             \
1767   product(uintx, FLSCoalescePolicy, 2,                                      \
1768           "CMS: aggressiveness level for coalescing, increasing "           \
1769           "from 0 to 4")                                                    \
1770           range(0, 4)                                                       \
1771                                                                             \
1772   product(bool, FLSAlwaysCoalesceLarge, false,                              \
1773           "CMS: larger free blocks are always available for coalescing")    \
1774                                                                             \
1775   product(double, FLSLargestBlockCoalesceProximity, 0.99,                   \
1776           "CMS: the smaller the percentage the greater the coalescing "     \
1777           "force")                                                          \
1778           range(0.0, 1.0)                                                   \
1779                                                                             \
1780   product(double, CMSSmallCoalSurplusPercent, 1.05,                         \
1781           "CMS: the factor by which to inflate estimated demand of small "  \
1782           "block sizes to prevent coalescing with an adjoining block")      \
1783           range(0.0, DBL_MAX)                                               \
1784                                                                             \
1785   product(double, CMSLargeCoalSurplusPercent, 0.95,                         \
1786           "CMS: the factor by which to inflate estimated demand of large "  \
1787           "block sizes to prevent coalescing with an adjoining block")      \
1788           range(0.0, DBL_MAX)                                               \
1789                                                                             \
1790   product(double, CMSSmallSplitSurplusPercent, 1.10,                        \
1791           "CMS: the factor by which to inflate estimated demand of small "  \
1792           "block sizes to prevent splitting to supply demand for smaller "  \
1793           "blocks")                                                         \
1794           range(0.0, DBL_MAX)                                               \
1795                                                                             \
1796   product(double, CMSLargeSplitSurplusPercent, 1.00,                        \
1797           "CMS: the factor by which to inflate estimated demand of large "  \
1798           "block sizes to prevent splitting to supply demand for smaller "  \
1799           "blocks")                                                         \
1800           range(0.0, DBL_MAX)                                               \
1801                                                                             \
1802   product(bool, CMSExtrapolateSweep, false,                                 \
1803           "CMS: cushion for block demand during sweep")                     \
1804                                                                             \
1805   product(uintx, CMS_SweepWeight, 75,                                       \
1806           "Percentage (0-100) used to weight the current sample when "      \
1807           "computing exponentially decaying average for inter-sweep "       \
1808           "duration")                                                       \
1809           range(0, 100)                                                     \
1810                                                                             \
1811   product(uintx, CMS_SweepPadding, 1,                                       \
1812           "The multiple of deviation from mean to use for buffering "       \
1813           "against volatility in inter-sweep duration")                     \
1814           range(0, max_juint)                                               \
1815                                                                             \
1816   product(uintx, CMS_SweepTimerThresholdMillis, 10,                         \
1817           "Skip block flux-rate sampling for an epoch unless inter-sweep "  \
1818           "duration exceeds this threshold in milliseconds")                \
1819           range(0, max_uintx)                                               \
1820                                                                             \
1821   product(bool, CMSClassUnloadingEnabled, true,                             \
1822           "Whether class unloading enabled when using CMS GC")              \
1823                                                                             \
1824   product(uintx, CMSClassUnloadingMaxInterval, 0,                           \
1825           "When CMS class unloading is enabled, the maximum CMS cycle "     \
1826           "count for which classes may not be unloaded")                    \
1827           range(0, max_uintx)                                               \
1828                                                                             \
1829   product(uintx, CMSIndexedFreeListReplenish, 4,                            \
1830           "Replenish an indexed free list with this number of chunks")      \
1831           range(1, max_uintx)                                               \
1832                                                                             \
1833   product(bool, CMSReplenishIntermediate, true,                             \
1834           "Replenish all intermediate free-list caches")                    \
1835                                                                             \
1836   product(bool, CMSSplitIndexedFreeListBlocks, true,                        \
1837           "When satisfying batched demand, split blocks from the "          \
1838           "IndexedFreeList whose size is a multiple of requested size")     \
1839                                                                             \
1840   product(bool, CMSLoopWarn, false,                                         \
1841           "Warn in case of excessive CMS looping")                          \
1842                                                                             \
1843   /* where does the range max value of (max_jint - 1) come from? */         \
1844   product(size_t, MarkStackSizeMax, NOT_LP64(4*M) LP64_ONLY(512*M),         \
1845           "Maximum size of marking stack")                                  \
1846           range(1, (max_jint - 1))                                          \
1847                                                                             \
1848   product(size_t, MarkStackSize, NOT_LP64(32*K) LP64_ONLY(4*M),             \
1849           "Size of marking stack")                                          \
1850           constraint(MarkStackSizeConstraintFunc,AfterErgo)                 \
1851                                                                             \
1852   notproduct(bool, CMSMarkStackOverflowALot, false,                         \
1853           "Simulate frequent marking stack / work queue overflow")          \
1854                                                                             \
1855   notproduct(uintx, CMSMarkStackOverflowInterval, 1000,                     \
1856           "An \"interval\" counter that determines how frequently "         \
1857           "to simulate overflow; a smaller number increases frequency")     \
1858                                                                             \
1859   product(uintx, CMSMaxAbortablePrecleanLoops, 0,                           \
1860           "Maximum number of abortable preclean iterations, if &gt; 0")        \
1861           range(0, max_uintx)                                               \
1862                                                                             \
1863   product(intx, CMSMaxAbortablePrecleanTime, 5000,                          \
1864           "Maximum time in abortable preclean (in milliseconds)")           \
1865           range(0, max_intx)                                                \
1866                                                                             \
1867   product(uintx, CMSAbortablePrecleanMinWorkPerIteration, 100,              \
1868           "Nominal minimum work per abortable preclean iteration")          \
1869           range(0, max_uintx)                                               \
1870                                                                             \
1871   manageable(intx, CMSAbortablePrecleanWaitMillis, 100,                     \
1872           "Time that we sleep between iterations when not given "           \
1873           "enough work per iteration")                                      \
1874           range(0, max_intx)                                                \
1875                                                                             \
1876   product(size_t, CMSRescanMultiple, 32,                                    \
1877           "Size (in cards) of CMS parallel rescan task")                    \
1878           range(1, max_uintx)                                               \
1879                                                                             \
1880   product(size_t, CMSConcMarkMultiple, 32,                                  \
1881           "Size (in cards) of CMS concurrent MT marking task")              \
1882           range(1, max_uintx)                                               \
1883                                                                             \
1884   product(bool, CMSAbortSemantics, false,                                   \
1885           "Whether abort-on-overflow semantics is implemented")             \
1886                                                                             \
1887   product(bool, CMSParallelInitialMarkEnabled, true,                        \
1888           "Use the parallel initial mark.")                                 \
1889                                                                             \
1890   product(bool, CMSParallelRemarkEnabled, true,                             \
1891           "Whether parallel remark enabled (only if ParNewGC)")             \
1892                                                                             \
1893   product(bool, CMSParallelSurvivorRemarkEnabled, true,                     \
1894           "Whether parallel remark of survivor space "                      \
1895           "enabled (effective only if CMSParallelRemarkEnabled)")           \
1896                                                                             \
1897   product(bool, CMSPLABRecordAlways, true,                                  \
1898           "Always record survivor space PLAB boundaries (effective only "   \
1899           "if CMSParallelSurvivorRemarkEnabled)")                           \
1900                                                                             \
1901   product(bool, CMSEdenChunksRecordAlways, true,                            \
1902           "Always record eden chunks used for the parallel initial mark "   \
1903           "or remark of eden")                                              \
1904                                                                             \
1905   product(bool, CMSPrintEdenSurvivorChunks, false,                          \
1906           "Print the eden and the survivor chunks used for the parallel "   \
1907           "initial mark or remark of the eden/survivor spaces")             \
1908                                                                             \
1909   product(bool, CMSConcurrentMTEnabled, true,                               \
1910           "Whether multi-threaded concurrent work enabled "                 \
1911           "(effective only if ParNewGC)")                                   \
1912                                                                             \
1913   product(bool, CMSPrecleaningEnabled, true,                                \
1914           "Whether concurrent precleaning enabled")                         \
1915                                                                             \
1916   product(uintx, CMSPrecleanIter, 3,                                        \
1917           "Maximum number of precleaning iteration passes")                 \
1918           range(0, 9)                                                       \
1919                                                                             \
1920   product(uintx, CMSPrecleanDenominator, 3,                                 \
1921           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1922           "ratio")                                                          \
1923           range(1, max_uintx)                                               \
1924           constraint(CMSPrecleanDenominatorConstraintFunc,AfterErgo)        \
1925                                                                             \
1926   product(uintx, CMSPrecleanNumerator, 2,                                   \
1927           "CMSPrecleanNumerator:CMSPrecleanDenominator yields convergence " \
1928           "ratio")                                                          \
1929           range(0, max_uintx-1)                                             \
1930           constraint(CMSPrecleanNumeratorConstraintFunc,AfterErgo)          \
1931                                                                             \
1932   product(bool, CMSPrecleanRefLists1, true,                                 \
1933           "Preclean ref lists during (initial) preclean phase")             \
1934                                                                             \
1935   product(bool, CMSPrecleanRefLists2, false,                                \
1936           "Preclean ref lists during abortable preclean phase")             \
1937                                                                             \
1938   product(bool, CMSPrecleanSurvivors1, false,                               \
1939           "Preclean survivors during (initial) preclean phase")             \
1940                                                                             \
1941   product(bool, CMSPrecleanSurvivors2, true,                                \
1942           "Preclean survivors during abortable preclean phase")             \
1943                                                                             \
1944   product(uintx, CMSPrecleanThreshold, 1000,                                \
1945           "Do not iterate again if number of dirty cards is less than this")\
1946           range(100, max_uintx)                                             \
1947                                                                             \
1948   product(bool, CMSCleanOnEnter, true,                                      \
1949           "Clean-on-enter optimization for reducing number of dirty cards") \
1950                                                                             \
1951   product(uintx, CMSRemarkVerifyVariant, 1,                                 \
1952           "Choose variant (1,2) of verification following remark")          \
1953           range(1, 2)                                                       \
1954                                                                             \
1955   product(size_t, CMSScheduleRemarkEdenSizeThreshold, 2*M,                  \
1956           "If Eden size is below this, do not try to schedule remark")      \
1957           range(0, max_uintx)                                               \
1958                                                                             \
1959   product(uintx, CMSScheduleRemarkEdenPenetration, 50,                      \
1960           "The Eden occupancy percentage (0-100) at which "                 \
1961           "to try and schedule remark pause")                               \
1962           range(0, 100)                                                     \
1963                                                                             \
1964   product(uintx, CMSScheduleRemarkSamplingRatio, 5,                         \
1965           "Start sampling eden top at least before young gen "              \
1966           "occupancy reaches 1/&lt;ratio&gt; of the size at which "               \
1967           "we plan to schedule remark")                                     \
1968           range(1, max_uintx)                                               \
1969                                                                             \
1970   product(uintx, CMSSamplingGrain, 16*K,                                    \
1971           "The minimum distance between eden samples for CMS (see above)")  \
1972           range(1, max_uintx)                                               \
1973                                                                             \
1974   product(bool, CMSScavengeBeforeRemark, false,                             \
1975           "Attempt scavenge before the CMS remark step")                    \
1976                                                                             \
1977   develop(bool, CMSTraceSweeper, false,                                     \
1978           "Trace some actions of the CMS sweeper")                          \
1979                                                                             \
1980   product(uintx, CMSWorkQueueDrainThreshold, 10,                            \
1981           "Don't drain below this size per parallel worker/thief")          \
1982           range(1, max_juint)                                               \
1983           constraint(CMSWorkQueueDrainThresholdConstraintFunc,AfterErgo)    \
1984                                                                             \
1985   manageable(intx, CMSWaitDuration, 2000,                                   \
1986           "Time in milliseconds that CMS thread waits for young GC")        \
1987           range(min_jint, max_jint)                                         \
1988                                                                             \
1989   develop(uintx, CMSCheckInterval, 1000,                                    \
1990           "Interval in milliseconds that CMS thread checks if it "          \
1991           "should start a collection cycle")                                \
1992                                                                             \
1993   product(bool, CMSYield, true,                                             \
1994           "Yield between steps of CMS")                                     \
1995                                                                             \
1996   product(size_t, CMSBitMapYieldQuantum, 10*M,                              \
1997           "Bitmap operations should process at most this many bits "        \
1998           "between yields")                                                 \
1999           range(1, max_uintx)                                               \
2000                                                                             \
2001   product(bool, CMSDumpAtPromotionFailure, false,                           \
2002           "Dump useful information about the state of the CMS old "         \
2003           "generation upon a promotion failure")                            \
2004                                                                             \
2005   product(bool, CMSPrintChunksInDump, false,                                \
2006           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
2007           "more detailed information about the free chunks")                \
2008                                                                             \
2009   product(bool, CMSPrintObjectsInDump, false,                               \
2010           "In a dump enabled by CMSDumpAtPromotionFailure, include "        \
2011           "more detailed information about the allocated objects")          \
2012                                                                             \
2013   diagnostic(bool, FLSVerifyAllHeapReferences, false,                       \
2014           "Verify that all references across the FLS boundary "             \
2015           "are to valid objects")                                           \
2016                                                                             \
2017   diagnostic(bool, FLSVerifyLists, false,                                   \
2018           "Do lots of (expensive) FreeListSpace verification")              \
2019                                                                             \
2020   diagnostic(bool, FLSVerifyIndexTable, false,                              \
2021           "Do lots of (expensive) FLS index table verification")            \
2022                                                                             \
2023   develop(bool, FLSVerifyDictionary, false,                                 \
2024           "Do lots of (expensive) FLS dictionary verification")             \
2025                                                                             \
2026   develop(bool, VerifyBlockOffsetArray, false,                              \
2027           "Do (expensive) block offset array verification")                 \
2028                                                                             \
2029   diagnostic(bool, BlockOffsetArrayUseUnallocatedBlock, false,              \
2030           "Maintain _unallocated_block in BlockOffsetArray "                \
2031           "(currently applicable only to CMS collector)")                   \
2032                                                                             \
2033   develop(bool, TraceCMSState, false,                                       \
2034           "Trace the state of the CMS collection")                          \
2035                                                                             \
2036   product(intx, RefDiscoveryPolicy, 0,                                      \
2037           "Select type of reference discovery policy: "                     \
2038           "reference-based(0) or referent-based(1)")                        \
2039           range(ReferenceProcessor::DiscoveryPolicyMin,                     \
2040                 ReferenceProcessor::DiscoveryPolicyMax)                     \
2041                                                                             \
2042   product(bool, ParallelRefProcEnabled, false,                              \
2043           "Enable parallel reference processing whenever possible")         \
2044                                                                             \
2045   product(bool, ParallelRefProcBalancingEnabled, true,                      \
2046           "Enable balancing of reference processing queues")                \
2047                                                                             \
2048   product(uintx, CMSTriggerRatio, 80,                                       \
2049           "Percentage of MinHeapFreeRatio in CMS generation that is "       \
2050           "allocated before a CMS collection cycle commences")              \
2051           range(0, 100)                                                     \
2052                                                                             \
2053   product(uintx, CMSBootstrapOccupancy, 50,                                 \
2054           "Percentage CMS generation occupancy at which to "                \
2055           "initiate CMS collection for bootstrapping collection stats")     \
2056           range(0, 100)                                                     \
2057                                                                             \
2058   product(intx, CMSInitiatingOccupancyFraction, -1,                         \
2059           "Percentage CMS generation occupancy to start a CMS collection "  \
2060           "cycle. A negative value means that CMSTriggerRatio is used")     \
2061           range(min_intx, 100)                                              \
2062                                                                             \
2063   product(uintx, InitiatingHeapOccupancyPercent, 45,                        \
2064           "Percentage of the (entire) heap occupancy to start a "           \
2065           "concurrent GC cycle. It is used by GCs that trigger a "          \
2066           "concurrent GC cycle based on the occupancy of the entire heap, " \
2067           "not just one of the generations (e.g., G1). A value of 0 "       \
2068           "denotes 'do constant GC cycles'.")                               \
2069           range(0, 100)                                                     \
2070                                                                             \
2071   manageable(intx, CMSTriggerInterval, -1,                                  \
2072           "Commence a CMS collection cycle (at least) every so many "       \
2073           "milliseconds (0 permanently, -1 disabled)")                      \
2074           range(-1, max_intx)                                               \
2075                                                                             \
2076   product(bool, UseCMSInitiatingOccupancyOnly, false,                       \
2077           "Only use occupancy as a criterion for starting a CMS collection")\
2078                                                                             \
2079   product(uintx, CMSIsTooFullPercentage, 98,                                \
2080           "An absolute ceiling above which CMS will always consider the "   \
2081           "unloading of classes when class unloading is enabled")           \
2082           range(0, 100)                                                     \
2083                                                                             \
2084   develop(bool, CMSTestInFreeList, false,                                   \
2085           "Check if the coalesced range is already in the "                 \
2086           "free lists as claimed")                                          \
2087                                                                             \
2088   notproduct(bool, CMSVerifyReturnedBytes, false,                           \
2089           "Check that all the garbage collected was returned to the "       \
2090           "free lists")                                                     \
2091                                                                             \
2092   notproduct(bool, ScavengeALot, false,                                     \
2093           "Force scavenge at every Nth exit from the runtime system "       \
2094           "(N=ScavengeALotInterval)")                                       \
2095                                                                             \
2096   develop(bool, FullGCALot, false,                                          \
2097           "Force full gc at every Nth exit from the runtime system "        \
2098           "(N=FullGCALotInterval)")                                         \
2099                                                                             \
2100   notproduct(bool, GCALotAtAllSafepoints, false,                            \
2101           "Enforce ScavengeALot/GCALot at all potential safepoints")        \
2102                                                                             \
2103   product(bool, PrintPromotionFailure, false,                               \
2104           "Print additional diagnostic information following "              \
2105           "promotion failure")                                              \
2106                                                                             \
2107   notproduct(bool, PromotionFailureALot, false,                             \
2108           "Use promotion failure handling on every youngest generation "    \
2109           "collection")                                                     \
2110                                                                             \
2111   develop(uintx, PromotionFailureALotCount, 1000,                           \
2112           "Number of promotion failures occurring at PLAB "                 \
2113           "refill attempts (ParNew) or promotion attempts "                 \
2114           "(other young collectors)")                                       \
2115                                                                             \
2116   develop(uintx, PromotionFailureALotInterval, 5,                           \
2117           "Total collections between promotion failures a lot")             \
2118                                                                             \
2119   experimental(uintx, WorkStealingSleepMillis, 1,                           \
2120           "Sleep time when sleep is used for yields")                       \
2121                                                                             \
2122   experimental(uintx, WorkStealingYieldsBeforeSleep, 5000,                  \
2123           "Number of yields before a sleep is done during work stealing")   \
2124                                                                             \
2125   experimental(uintx, WorkStealingHardSpins, 4096,                          \
2126           "Number of iterations in a spin loop between checks on "          \
2127           "time out of hard spin")                                          \
2128                                                                             \
2129   experimental(uintx, WorkStealingSpinToYieldRatio, 10,                     \
2130           "Ratio of hard spins to calls to yield")                          \
2131                                                                             \
2132   develop(uintx, ObjArrayMarkingStride, 512,                                \
2133           "Number of object array elements to push onto the marking stack " \
2134           "before pushing a continuation entry")                            \
2135                                                                             \
2136   develop(bool, MetadataAllocationFailALot, false,                          \
2137           "Fail metadata allocations at intervals controlled by "           \
2138           "MetadataAllocationFailALotInterval")                             \
2139                                                                             \
2140   develop(uintx, MetadataAllocationFailALotInterval, 1000,                  \
2141           "Metadata allocation failure a lot interval")                     \
2142                                                                             \
2143   develop(bool, TraceMetadataChunkAllocation, false,                        \
2144           "Trace chunk metadata allocations")                               \
2145                                                                             \
2146   product(bool, TraceMetadataHumongousAllocation, false,                    \
2147           "Trace humongous metadata allocations")                           \
2148                                                                             \
2149   develop(bool, TraceMetavirtualspaceAllocation, false,                     \
2150           "Trace virtual space metadata allocations")                       \
2151                                                                             \
2152   notproduct(bool, ExecuteInternalVMTests, false,                           \
2153           "Enable execution of internal VM tests")                          \
2154                                                                             \
2155   notproduct(bool, VerboseInternalVMTests, false,                           \
2156           "Turn on logging for internal VM tests.")                         \
2157                                                                             \
2158   product_pd(bool, UseTLAB, "Use thread-local object allocation")           \
2159                                                                             \
2160   product_pd(bool, ResizeTLAB,                                              \
2161           "Dynamically resize TLAB size for threads")                       \
2162                                                                             \
2163   product(bool, ZeroTLAB, false,                                            \
2164           "Zero out the newly created TLAB")                                \
2165                                                                             \
2166   product(bool, FastTLABRefill, true,                                       \
2167           "Use fast TLAB refill code")                                      \
2168                                                                             \
2169   product(bool, PrintTLAB, false,                                           \
2170           "Print various TLAB related information")                         \
2171                                                                             \
2172   product(bool, TLABStats, true,                                            \
2173           "Provide more detailed and expensive TLAB statistics "            \
2174           "(with PrintTLAB)")                                               \
2175                                                                             \
2176   product_pd(bool, NeverActAsServerClassMachine,                            \
2177           "Never act like a server-class machine")                          \
2178                                                                             \
2179   product(bool, AlwaysActAsServerClassMachine, false,                       \
2180           "Always act like a server-class machine")                         \
2181                                                                             \
2182   product_pd(uint64_t, MaxRAM,                                              \
2183           "Real memory size (in bytes) used to set maximum heap size")      \
2184           range(0, 0XFFFFFFFFFFFFFFFF)                                      \
2185                                                                             \
2186   product(size_t, ErgoHeapSizeLimit, 0,                                     \
2187           "Maximum ergonomically set heap size (in bytes); zero means use " \
2188           "MaxRAM / MaxRAMFraction")                                        \
2189           range(0, max_uintx)                                               \
2190                                                                             \
2191   product(uintx, MaxRAMFraction, 4,                                         \
2192           "Maximum fraction (1/n) of real memory used for maximum heap "    \
2193           "size")                                                           \
2194           range(1, max_uintx)                                               \
2195                                                                             \
2196   product(uintx, MinRAMFraction, 2,                                         \
2197           "Minimum fraction (1/n) of real memory used for maximum heap "    \
2198           "size on systems with small physical memory size")                \
2199           range(1, max_uintx)                                               \
2200                                                                             \
2201   product(uintx, InitialRAMFraction, 64,                                    \
2202           "Fraction (1/n) of real memory used for initial heap size")       \
2203           range(1, max_uintx)                                               \
2204                                                                             \
2205   develop(uintx, MaxVirtMemFraction, 2,                                     \
2206           "Maximum fraction (1/n) of virtual memory used for ergonomically "\
2207           "determining maximum heap size")                                  \
2208                                                                             \
2209   product(bool, UseAutoGCSelectPolicy, false,                               \
2210           "Use automatic collection selection policy")                      \
2211                                                                             \
2212   product(uintx, AutoGCSelectPauseMillis, 5000,                             \
2213           "Automatic GC selection pause threshold in milliseconds")         \
2214           range(0, max_uintx)                                               \
2215                                                                             \
2216   product(bool, UseAdaptiveSizePolicy, true,                                \
2217           "Use adaptive generation sizing policies")                        \
2218                                                                             \
2219   product(bool, UsePSAdaptiveSurvivorSizePolicy, true,                      \
2220           "Use adaptive survivor sizing policies")                          \
2221                                                                             \
2222   product(bool, UseAdaptiveGenerationSizePolicyAtMinorCollection, true,     \
2223           "Use adaptive young-old sizing policies at minor collections")    \
2224                                                                             \
2225   product(bool, UseAdaptiveGenerationSizePolicyAtMajorCollection, true,     \
2226           "Use adaptive young-old sizing policies at major collections")    \
2227                                                                             \
2228   product(bool, UseAdaptiveSizePolicyWithSystemGC, false,                   \
2229           "Include statistics from System.gc() for adaptive size policy")   \
2230                                                                             \
2231   product(bool, UseAdaptiveGCBoundary, false,                               \
2232           "Allow young-old boundary to move")                               \
2233                                                                             \
2234   develop(bool, TraceAdaptiveGCBoundary, false,                             \
2235           "Trace young-old boundary moves")                                 \
2236                                                                             \
2237   develop(intx, PSAdaptiveSizePolicyResizeVirtualSpaceAlot, -1,             \
2238           "Resize the virtual spaces of the young or old generations")      \
2239           range(-1, 1)                                                      \
2240                                                                             \
2241   product(uintx, AdaptiveSizeThroughPutPolicy, 0,                           \
2242           "Policy for changing generation size for throughput goals")       \
2243           range(0, 1)                                                       \
2244                                                                             \
2245   product(uintx, AdaptiveSizePolicyInitializingSteps, 20,                   \
2246           "Number of steps where heuristics is used before data is used")   \
2247           range(0, max_uintx)                                               \
2248                                                                             \
2249   develop(uintx, AdaptiveSizePolicyReadyThreshold, 5,                       \
2250           "Number of collections before the adaptive sizing is started")    \
2251                                                                             \
2252   product(uintx, AdaptiveSizePolicyOutputInterval, 0,                       \
2253           "Collection interval for printing information; zero means never") \
2254           range(0, max_uintx)                                               \
2255                                                                             \
2256   product(bool, UseAdaptiveSizePolicyFootprintGoal, true,                   \
2257           "Use adaptive minimum footprint as a goal")                       \
2258                                                                             \
2259   product(uintx, AdaptiveSizePolicyWeight, 10,                              \
2260           "Weight given to exponential resizing, between 0 and 100")        \
2261           range(0, 100)                                                     \
2262                                                                             \
2263   product(uintx, AdaptiveTimeWeight,       25,                              \
2264           "Weight given to time in adaptive policy, between 0 and 100")     \
2265           range(0, 100)                                                     \
2266                                                                             \
2267   product(uintx, PausePadding, 1,                                           \
2268           "How much buffer to keep for pause time")                         \
2269           range(0, max_juint)                                               \
2270                                                                             \
2271   product(uintx, PromotedPadding, 3,                                        \
2272           "How much buffer to keep for promotion failure")                  \
2273           range(0, max_juint)                                               \
2274                                                                             \
2275   product(uintx, SurvivorPadding, 3,                                        \
2276           "How much buffer to keep for survivor overflow")                  \
2277           range(0, max_juint)                                               \
2278                                                                             \
2279   product(uintx, ThresholdTolerance, 10,                                    \
2280           "Allowed collection cost difference between generations")         \
2281           range(0, 100)                                                     \
2282                                                                             \
2283   product(uintx, AdaptiveSizePolicyCollectionCostMargin, 50,                \
2284           "If collection costs are within margin, reduce both by full "     \
2285           "delta")                                                          \
2286           range(0, 100)                                                     \
2287                                                                             \
2288   product(uintx, YoungGenerationSizeIncrement, 20,                          \
2289           "Adaptive size percentage change in young generation")            \
2290           range(0, 100)                                                     \
2291                                                                             \
2292   product(uintx, YoungGenerationSizeSupplement, 80,                         \
2293           "Supplement to YoungedGenerationSizeIncrement used at startup")   \
2294           range(0, 100)                                                     \
2295                                                                             \
2296   product(uintx, YoungGenerationSizeSupplementDecay, 8,                     \
2297           "Decay factor to YoungedGenerationSizeSupplement")                \
2298           range(1, max_uintx)                                               \
2299                                                                             \
2300   product(uintx, TenuredGenerationSizeIncrement, 20,                        \
2301           "Adaptive size percentage change in tenured generation")          \
2302           range(0, 100)                                                     \
2303                                                                             \
2304   product(uintx, TenuredGenerationSizeSupplement, 80,                       \
2305           "Supplement to TenuredGenerationSizeIncrement used at startup")   \
2306           range(0, 100)                                                     \
2307                                                                             \
2308   product(uintx, TenuredGenerationSizeSupplementDecay, 2,                   \
2309           "Decay factor to TenuredGenerationSizeIncrement")                 \
2310           range(1, max_uintx)                                               \
2311                                                                             \
2312   product(uintx, MaxGCPauseMillis, max_uintx,                               \
2313           "Adaptive size policy maximum GC pause time goal in millisecond, "\
2314           "or (G1 Only) the maximum GC time per MMU time slice")            \
2315           range(1, max_uintx)                                               \
2316           constraint(MaxGCPauseMillisConstraintFunc,AfterMemoryInit)        \
2317                                                                             \
2318   product(uintx, GCPauseIntervalMillis, 0,                                  \
2319           "Time slice for MMU specification")                               \
2320           constraint(GCPauseIntervalMillisConstraintFunc,AfterMemoryInit)   \
2321                                                                             \
2322   product(uintx, MaxGCMinorPauseMillis, max_uintx,                          \
2323           "Adaptive size policy maximum GC minor pause time goal "          \
2324           "in millisecond")                                                 \
2325           range(0, max_uintx)                                               \
2326                                                                             \
2327   product(uintx, GCTimeRatio, 99,                                           \
2328           "Adaptive size policy application time to GC time ratio")         \
2329           range(0, max_juint)                                               \
2330                                                                             \
2331   product(uintx, AdaptiveSizeDecrementScaleFactor, 4,                       \
2332           "Adaptive size scale down factor for shrinking")                  \
2333           range(1, max_uintx)                                               \
2334                                                                             \
2335   product(bool, UseAdaptiveSizeDecayMajorGCCost, true,                      \
2336           "Adaptive size decays the major cost for long major intervals")   \
2337                                                                             \
2338   product(uintx, AdaptiveSizeMajorGCDecayTimeScale, 10,                     \
2339           "Time scale over which major costs decay")                        \
2340           range(0, max_uintx)                                               \
2341                                                                             \
2342   product(uintx, MinSurvivorRatio, 3,                                       \
2343           "Minimum ratio of young generation/survivor space size")          \
2344           range(3, max_uintx)                                               \
2345                                                                             \
2346   product(uintx, InitialSurvivorRatio, 8,                                   \
2347           "Initial ratio of young generation/survivor space size")          \
2348           range(0, max_uintx)                                               \
2349                                                                             \
2350   product(size_t, BaseFootPrintEstimate, 256*M,                             \
2351           "Estimate of footprint other than Java Heap")                     \
2352           range(0, max_uintx)                                               \
2353                                                                             \
2354   product(bool, UseGCOverheadLimit, true,                                   \
2355           "Use policy to limit of proportion of time spent in GC "          \
2356           "before an OutOfMemory error is thrown")                          \
2357                                                                             \
2358   product(uintx, GCTimeLimit, 98,                                           \
2359           "Limit of the proportion of time spent in GC before "             \
2360           "an OutOfMemoryError is thrown (used with GCHeapFreeLimit)")      \
2361           range(0, 100)                                                     \
2362                                                                             \
2363   product(uintx, GCHeapFreeLimit, 2,                                        \
2364           "Minimum percentage of free space after a full GC before an "     \
2365           "OutOfMemoryError is thrown (used with GCTimeLimit)")             \
2366           range(0, 100)                                                     \
2367                                                                             \
2368   develop(uintx, AdaptiveSizePolicyGCTimeLimitThreshold, 5,                 \
2369           "Number of consecutive collections before gc time limit fires")   \
2370           range(1, max_uintx)                                               \
2371                                                                             \
2372   product(bool, PrintAdaptiveSizePolicy, false,                             \
2373           "Print information about AdaptiveSizePolicy")                     \
2374                                                                             \
2375   product(intx, PrefetchCopyIntervalInBytes, -1,                            \
2376           "How far ahead to prefetch destination area (&lt;= 0 means off)")    \
2377           range(-1, max_jint)                                               \
2378                                                                             \
2379   product(intx, PrefetchScanIntervalInBytes, -1,                            \
2380           "How far ahead to prefetch scan area (&lt;= 0 means off)")           \
2381           range(-1, max_jint)                                               \
2382                                                                             \
2383   product(intx, PrefetchFieldsAhead, -1,                                    \
2384           "How many fields ahead to prefetch in oop scan (&lt;= 0 means off)") \
2385           range(-1, max_jint)                                               \
2386                                                                             \
2387   diagnostic(bool, VerifySilently, false,                                   \
2388           "Do not print the verification progress")                         \
2389                                                                             \
2390   diagnostic(bool, VerifyDuringStartup, false,                              \
2391           "Verify memory system before executing any Java code "            \
2392           "during VM initialization")                                       \
2393                                                                             \
2394   diagnostic(bool, VerifyBeforeExit, trueInDebug,                           \
2395           "Verify system before exiting")                                   \
2396                                                                             \
2397   diagnostic(bool, VerifyBeforeGC, false,                                   \
2398           "Verify memory system before GC")                                 \
2399                                                                             \
2400   diagnostic(bool, VerifyAfterGC, false,                                    \
2401           "Verify memory system after GC")                                  \
2402                                                                             \
2403   diagnostic(bool, VerifyDuringGC, false,                                   \
2404           "Verify memory system during GC (between phases)")                \
2405                                                                             \
2406   diagnostic(bool, GCParallelVerificationEnabled, true,                     \
2407           "Enable parallel memory system verification")                     \
2408                                                                             \
2409   diagnostic(bool, DeferInitialCardMark, false,                             \
2410           "When +ReduceInitialCardMarks, explicitly defer any that "        \
2411           "may arise from new_pre_store_barrier")                           \
2412                                                                             \
2413   product(bool, UseCondCardMark, false,                                     \
2414           "Check for already marked card before updating card table")       \
2415                                                                             \
2416   diagnostic(bool, VerifyRememberedSets, false,                             \
2417           "Verify GC remembered sets")                                      \
2418                                                                             \
2419   diagnostic(bool, VerifyObjectStartArray, true,                            \
2420           "Verify GC object start array if verify before/after")            \
2421                                                                             \
2422   product(bool, DisableExplicitGC, false,                                   \
2423           "Ignore calls to System.gc()")                                    \
2424                                                                             \
2425   notproduct(bool, CheckMemoryInitialization, false,                        \
2426           "Check memory initialization")                                    \
2427                                                                             \
2428   diagnostic(bool, BindCMSThreadToCPU, false,                               \
2429           "Bind CMS Thread to CPU if possible")                             \
2430                                                                             \
2431   diagnostic(uintx, CPUForCMSThread, 0,                                     \
2432           "When BindCMSThreadToCPU is true, the CPU to bind CMS thread to") \
2433           range(0, max_juint)                                               \
2434                                                                             \
2435   product(bool, BindGCTaskThreadsToCPUs, false,                             \
2436           "Bind GCTaskThreads to CPUs if possible")                         \
2437                                                                             \
2438   product(bool, UseGCTaskAffinity, false,                                   \
2439           "Use worker affinity when asking for GCTasks")                    \
2440                                                                             \
2441   product(uintx, ProcessDistributionStride, 4,                              \
2442           "Stride through processors when distributing processes")          \
2443           range(0, max_juint)                                               \
2444                                                                             \
2445   product(uintx, CMSCoordinatorYieldSleepCount, 10,                         \
2446           "Number of times the coordinator GC thread will sleep while "     \
2447           "yielding before giving up and resuming GC")                      \
2448           range(0, max_juint)                                               \
2449                                                                             \
2450   product(uintx, CMSYieldSleepCount, 0,                                     \
2451           "Number of times a GC thread (minus the coordinator) "            \
2452           "will sleep while yielding before giving up and resuming GC")     \
2453           range(0, max_juint)                                               \
2454                                                                             \
2455   /* gc tracing */                                                          \
2456   manageable(bool, PrintGC, false,                                          \
2457           "Print message at garbage collection")                            \
2458                                                                             \
2459   manageable(bool, PrintGCDetails, false,                                   \
2460           "Print more details at garbage collection")                       \
2461                                                                             \
2462   manageable(bool, PrintGCDateStamps, false,                                \
2463           "Print date stamps at garbage collection")                        \
2464                                                                             \
2465   manageable(bool, PrintGCTimeStamps, false,                                \
2466           "Print timestamps at garbage collection")                         \
2467                                                                             \
2468   manageable(bool, PrintGCID, true,                                         \
2469           "Print an identifier for each garbage collection")                \
2470                                                                             \
2471   product(bool, PrintGCTaskTimeStamps, false,                               \
2472           "Print timestamps for individual gc worker thread tasks")         \
2473                                                                             \
2474   develop(intx, ConcGCYieldTimeout, 0,                                      \
2475           "If non-zero, assert that GC threads yield within this "          \
2476           "number of milliseconds")                                         \
2477           range(0, max_intx)                                                \
2478                                                                             \
2479   product(bool, PrintReferenceGC, false,                                    \
2480           "Print times spent handling reference objects during GC "         \
2481           "(enabled only when PrintGCDetails)")                             \
2482                                                                             \
2483   develop(bool, TraceReferenceGC, false,                                    \
2484           "Trace handling of soft/weak/final/phantom references")           \
2485                                                                             \
2486   develop(bool, TraceFinalizerRegistration, false,                          \
2487           "Trace registration of final references")                         \
2488                                                                             \
2489   notproduct(bool, TraceScavenge, false,                                    \
2490           "Trace scavenge")                                                 \
2491                                                                             \
2492   product(bool, IgnoreEmptyClassPaths, false,                               \
2493           "Ignore empty path elements in -classpath")                       \
2494                                                                             \
2495   product(bool, TraceClassPaths, false,                                     \
2496           "Trace processing of class paths")                                \
2497                                                                             \
2498   product_rw(bool, TraceClassLoading, false,                                \
2499           "Trace all classes loaded")                                       \
2500                                                                             \
2501   product(bool, TraceClassLoadingPreorder, false,                           \
2502           "Trace all classes loaded in order referenced (not loaded)")      \
2503                                                                             \
2504   product_rw(bool, TraceClassUnloading, false,                              \
2505           "Trace unloading of classes")                                     \
2506                                                                             \
2507   product_rw(bool, TraceLoaderConstraints, false,                           \
2508           "Trace loader constraints")                                       \
2509                                                                             \
2510   develop(bool, TraceClassLoaderData, false,                                \
2511           "Trace class loader loader_data lifetime")                        \
2512                                                                             \
2513   product(size_t, InitialBootClassLoaderMetaspaceSize,                      \
2514           NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \
2515           "Initial size of the boot class loader data metaspace")           \
2516           range(30*K, max_uintx/BytesPerWord)                               \
2517           constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\
2518                                                                             \
2519   product(bool, TraceYoungGenTime, false,                                   \
2520           "Trace accumulated time for young collection")                    \
2521                                                                             \
2522   product(bool, TraceOldGenTime, false,                                     \
2523           "Trace accumulated time for old collection")                      \
2524                                                                             \
2525   product(bool, PrintTenuringDistribution, false,                           \
2526           "Print tenuring age information")                                 \
2527                                                                             \
2528   product_rw(bool, PrintHeapAtGC, false,                                    \
2529           "Print heap layout before and after each GC")                     \
2530                                                                             \
2531   product_rw(bool, PrintHeapAtGCExtended, false,                            \
2532           "Print extended information about the layout of the heap "        \
2533           "when -XX:+PrintHeapAtGC is set")                                 \
2534                                                                             \
2535   product(bool, PrintHeapAtSIGBREAK, true,                                  \
2536           "Print heap layout in response to SIGBREAK")                      \
2537                                                                             \
2538   manageable(bool, PrintClassHistogramBeforeFullGC, false,                  \
2539           "Print a class histogram before any major stop-world GC")         \
2540                                                                             \
2541   manageable(bool, PrintClassHistogramAfterFullGC, false,                   \
2542           "Print a class histogram after any major stop-world GC")          \
2543                                                                             \
2544   manageable(bool, PrintClassHistogram, false,                              \
2545           "Print a histogram of class instances")                           \
2546                                                                             \
2547   develop(bool, TraceWorkGang, false,                                       \
2548           "Trace activities of work gangs")                                 \
2549                                                                             \
2550   develop(bool, TraceBlockOffsetTable, false,                               \
2551           "Print BlockOffsetTable maps")                                    \
2552                                                                             \
2553   develop(bool, TraceCardTableModRefBS, false,                              \
2554           "Print CardTableModRefBS maps")                                   \
2555                                                                             \
2556   develop(bool, TraceGCTaskManager, false,                                  \
2557           "Trace actions of the GC task manager")                           \
2558                                                                             \
2559   develop(bool, TraceGCTaskQueue, false,                                    \
2560           "Trace actions of the GC task queues")                            \
2561                                                                             \
2562   diagnostic(bool, TraceGCTaskThread, false,                                \
2563           "Trace actions of the GC task threads")                           \
2564                                                                             \
2565   product(bool, PrintParallelOldGCPhaseTimes, false,                        \
2566           "Print the time taken by each phase in ParallelOldGC "            \
2567           "(PrintGCDetails must also be enabled)")                          \
2568                                                                             \
2569   develop(bool, TraceParallelOldGCMarkingPhase, false,                      \
2570           "Trace marking phase in ParallelOldGC")                           \
2571                                                                             \
2572   develop(bool, TraceParallelOldGCSummaryPhase, false,                      \
2573           "Trace summary phase in ParallelOldGC")                           \
2574                                                                             \
2575   develop(bool, TraceParallelOldGCCompactionPhase, false,                   \
2576           "Trace compaction phase in ParallelOldGC")                        \
2577                                                                             \
2578   develop(bool, TraceParallelOldGCDensePrefix, false,                       \
2579           "Trace dense prefix computation for ParallelOldGC")               \
2580                                                                             \
2581   develop(bool, IgnoreLibthreadGPFault, false,                              \
2582           "Suppress workaround for libthread GP fault")                     \
2583                                                                             \
2584   product(bool, PrintJNIGCStalls, false,                                    \
2585           "Print diagnostic message when GC is stalled "                    \
2586           "by JNI critical section")                                        \
2587                                                                             \
2588   experimental(double, ObjectCountCutOffPercent, 0.5,                       \
2589           "The percentage of the used heap that the instances of a class "  \
2590           "must occupy for the class to generate a trace event")            \
2591           range(0.0, 100.0)                                                 \
2592                                                                             \
2593   /* GC log rotation setting */                                             \
2594                                                                             \
2595   product(bool, UseGCLogFileRotation, false,                                \
2596           "Rotate gclog files (for long running applications). It requires "\
2597           "-Xloggc:&lt;filename&gt;")                                             \
2598                                                                             \
2599   product(uintx, NumberOfGCLogFiles, 0,                                     \
2600           "Number of gclog files in rotation "                              \
2601           "(default: 0, no rotation)")                                      \
2602           range(0, max_uintx)                                               \
2603                                                                             \
2604   product(size_t, GCLogFileSize, 8*K,                                       \
2605           "GC log file size, requires UseGCLogFileRotation. "               \
2606           "Set to 0 to only trigger rotation via jcmd")                     \
2607           range(0, max_uintx)                                               \
2608                                                                             \
2609   /* JVMTI heap profiling */                                                \
2610                                                                             \
2611   diagnostic(bool, TraceJVMTIObjectTagging, false,                          \
2612           "Trace JVMTI object tagging calls")                               \
2613                                                                             \
2614   diagnostic(bool, VerifyBeforeIteration, false,                            \
2615           "Verify memory system before JVMTI iteration")                    \
2616                                                                             \
2617   /* compiler interface */                                                  \
2618                                                                             \
2619   develop(bool, CIPrintCompilerName, false,                                 \
2620           "when CIPrint is active, print the name of the active compiler")  \
2621                                                                             \
2622   diagnostic(bool, CIPrintCompileQueue, false,                              \
2623           "display the contents of the compile queue whenever a "           \
2624           "compilation is enqueued")                                        \
2625                                                                             \
2626   develop(bool, CIPrintRequests, false,                                     \
2627           "display every request for compilation")                          \
2628                                                                             \
2629   product(bool, CITime, false,                                              \
2630           "collect timing information for compilation")                     \
2631                                                                             \
2632   develop(bool, CITimeVerbose, false,                                       \
2633           "be more verbose in compilation timings")                         \
2634                                                                             \
2635   develop(bool, CITimeEach, false,                                          \
2636           "display timing information after each successful compilation")   \
2637                                                                             \
2638   develop(bool, CICountOSR, false,                                          \
2639           "use a separate counter when assigning ids to osr compilations")  \
2640                                                                             \
2641   develop(bool, CICompileNatives, true,                                     \
2642           "compile native methods if supported by the compiler")            \
2643                                                                             \
2644   develop_pd(bool, CICompileOSR,                                            \
2645           "compile on stack replacement methods if supported by the "       \
2646           "compiler")                                                       \
2647                                                                             \
2648   develop(bool, CIPrintMethodCodes, false,                                  \
2649           "print method bytecodes of the compiled code")                    \
2650                                                                             \
2651   develop(bool, CIPrintTypeFlow, false,                                     \
2652           "print the results of ciTypeFlow analysis")                       \
2653                                                                             \
2654   develop(bool, CITraceTypeFlow, false,                                     \
2655           "detailed per-bytecode tracing of ciTypeFlow analysis")           \
2656                                                                             \
2657   develop(intx, OSROnlyBCI, -1,                                             \
2658           "OSR only at this bci.  Negative values mean exclude that bci")   \
2659                                                                             \
2660   /* compiler */                                                            \
2661                                                                             \
2662   /* notice: the max range value here is max_jint, not max_intx  */         \
2663   /* because of overflow issue                                   */         \
2664   product(intx, CICompilerCount, CI_COMPILER_COUNT,                         \
2665           "Number of compiler threads to run")                              \
2666           range(0, max_jint)                                                \
2667           constraint(CICompilerCountConstraintFunc, AtParse)                \
2668                                                                             \
2669   product(intx, CompilationPolicyChoice, 0,                                 \
2670           "which compilation policy (0-3)")                                 \
2671           range(0, 3)                                                       \
2672                                                                             \
2673   develop(bool, UseStackBanging, true,                                      \
2674           "use stack banging for stack overflow checks (required for "      \
2675           "proper StackOverflow handling; disable only to measure cost "    \
2676           "of stackbanging)")                                               \
2677                                                                             \
2678   develop(bool, UseStrictFP, true,                                          \
2679           "use strict fp if modifier strictfp is set")                      \
2680                                                                             \
2681   develop(bool, GenerateSynchronizationCode, true,                          \
2682           "generate locking/unlocking code for synchronized methods and "   \
2683           "monitors")                                                       \
2684                                                                             \
2685   develop(bool, GenerateCompilerNullChecks, true,                           \
2686           "Generate explicit null checks for loads/stores/calls")           \
2687                                                                             \
2688   develop(bool, GenerateRangeChecks, true,                                  \
2689           "Generate range checks for array accesses")                       \
2690                                                                             \
2691   develop_pd(bool, ImplicitNullChecks,                                      \
2692           "Generate code for implicit null checks")                         \
2693                                                                             \
2694   product_pd(bool, TrapBasedNullChecks,                                     \
2695           "Generate code for null checks that uses a cmp and trap "         \
2696           "instruction raising SIGTRAP.  This is only used if an access to" \
2697           "null (+offset) will not raise a SIGSEGV, i.e.,"                  \
2698           "ImplicitNullChecks don't work (PPC64).")                         \
2699                                                                             \
2700   product(bool, PrintSafepointStatistics, false,                            \
2701           "Print statistics about safepoint synchronization")               \
2702                                                                             \
2703   product(intx, PrintSafepointStatisticsCount, 300,                         \
2704           "Total number of safepoint statistics collected "                 \
2705           "before printing them out")                                       \
2706           range(1, max_intx)                                                \
2707                                                                             \
2708   product(intx, PrintSafepointStatisticsTimeout,  -1,                       \
2709           "Print safepoint statistics only when safepoint takes "           \
2710           "more than PrintSafepointSatisticsTimeout in millis")             \
2711   LP64_ONLY(range(-1, max_intx/MICROUNITS))                                 \
2712   NOT_LP64(range(-1, max_intx))                                             \
2713                                                                             \
2714   product(bool, TraceSafepointCleanupTime, false,                           \
2715           "Print the break down of clean up tasks performed during "        \
2716           "safepoint")                                                      \
2717                                                                             \
2718   product(bool, Inline, true,                                               \
2719           "Enable inlining")                                                \
2720                                                                             \
2721   product(bool, ClipInlining, true,                                         \
2722           "Clip inlining if aggregate method exceeds DesiredMethodLimit")   \
2723                                                                             \
2724   develop(bool, UseCHA, true,                                               \
2725           "Enable CHA")                                                     \
2726                                                                             \
2727   product(bool, UseTypeProfile, true,                                       \
2728           "Check interpreter profile for historically monomorphic calls")   \
2729                                                                             \
2730   diagnostic(bool, PrintInlining, false,                                    \
2731           "Print inlining optimizations")                                   \
2732                                                                             \
2733   product(bool, UsePopCountInstruction, false,                              \
2734           "Use population count instruction")                               \
2735                                                                             \
2736   develop(bool, EagerInitialization, false,                                 \
2737           "Eagerly initialize classes if possible")                         \
2738                                                                             \
2739   diagnostic(bool, LogTouchedMethods, false,                                \
2740           "Log methods which have been ever touched in runtime")            \
2741                                                                             \
2742   diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \
2743           "Print all methods that have been ever touched in runtime")       \
2744                                                                             \
2745   develop(bool, TraceMethodReplacement, false,                              \
2746           "Print when methods are replaced do to recompilation")            \
2747                                                                             \
2748   develop(bool, PrintMethodFlushing, false,                                 \
2749           "Print the nmethods being flushed")                               \
2750                                                                             \
2751   diagnostic(bool, PrintMethodFlushingStatistics, false,                    \
2752           "print statistics about method flushing")                         \
2753                                                                             \
2754   diagnostic(intx, HotMethodDetectionLimit, 100000,                         \
2755           "Number of compiled code invocations after which "                \
2756           "the method is considered as hot by the flusher")                 \
2757           range(1, max_jint)                                                \
2758                                                                             \
2759   diagnostic(intx, MinPassesBeforeFlush, 10,                                \
2760           "Minimum number of sweeper passes before an nmethod "             \
2761           "can be flushed")                                                 \
2762           range(0, max_intx)                                                \
2763                                                                             \
2764   product(bool, UseCodeAging, true,                                         \
2765           "Insert counter to detect warm methods")                          \
2766                                                                             \
2767   diagnostic(bool, StressCodeAging, false,                                  \
2768           "Start with counters compiled in")                                \
2769                                                                             \
2770   develop(bool, UseRelocIndex, false,                                       \
2771           "Use an index to speed random access to relocations")             \
2772                                                                             \
2773   develop(bool, StressCodeBuffers, false,                                   \
2774           "Exercise code buffer expansion and other rare state changes")    \
2775                                                                             \
2776   diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \
2777           "Generate extra debugging information for non-safepoints in "     \
2778           "nmethods")                                                       \
2779                                                                             \
2780   product(bool, PrintVMOptions, false,                                      \
2781           "Print flags that appeared on the command line")                  \
2782                                                                             \
2783   product(bool, IgnoreUnrecognizedVMOptions, false,                         \
2784           "Ignore unrecognized VM options")                                 \
2785                                                                             \
2786   product(bool, PrintCommandLineFlags, false,                               \
2787           "Print flags specified on command line or set by ergonomics")     \
2788                                                                             \
2789   product(bool, PrintFlagsInitial, false,                                   \
2790           "Print all VM flags before argument processing and exit VM")      \
2791                                                                             \
2792   product(bool, PrintFlagsFinal, false,                                     \
2793           "Print all VM flags after argument and ergonomic processing")     \
2794                                                                             \
2795   notproduct(bool, PrintFlagsWithComments, false,                           \
2796           "Print all VM flags with default values and descriptions and "    \
2797           "exit")                                                           \
2798                                                                             \
2799   product(bool, PrintFlagsRanges, false,                                    \
2800           "Print VM flags and their ranges and exit VM")                    \
2801                                                                             \
2802   diagnostic(bool, SerializeVMOutput, true,                                 \
2803           "Use a mutex to serialize output to tty and LogFile")             \
2804                                                                             \
2805   diagnostic(bool, DisplayVMOutput, true,                                   \
2806           "Display all VM output on the tty, independently of LogVMOutput") \
2807                                                                             \
2808   diagnostic(bool, LogVMOutput, false,                                      \
2809           "Save VM output to LogFile")                                      \
2810                                                                             \
2811   diagnostic(ccstr, LogFile, NULL,                                          \
2812           "If LogVMOutput or LogCompilation is on, save VM output to "      \
2813           "this file [default: ./hotspot_pid%p.log] (%p replaced with pid)")\
2814                                                                             \
2815   product(ccstr, ErrorFile, NULL,                                           \
2816           "If an error occurs, save the error data to this file "           \
2817           "[default: ./hs_err_pid%p.log] (%p replaced with pid)")           \
2818                                                                             \
2819   product(bool, DisplayVMOutputToStderr, false,                             \
2820           "If DisplayVMOutput is true, display all VM output to stderr")    \
2821                                                                             \
2822   product(bool, DisplayVMOutputToStdout, false,                             \
2823           "If DisplayVMOutput is true, display all VM output to stdout")    \
2824                                                                             \
2825   product(bool, UseHeavyMonitors, false,                                    \
2826           "use heavyweight instead of lightweight Java monitors")           \
2827                                                                             \
2828   product(bool, PrintStringTableStatistics, false,                          \
2829           "print statistics about the StringTable and SymbolTable")         \
2830                                                                             \
2831   diagnostic(bool, VerifyStringTableAtExit, false,                          \
2832           "verify StringTable contents at exit")                            \
2833                                                                             \
2834   notproduct(bool, PrintSymbolTableSizeHistogram, false,                    \
2835           "print histogram of the symbol table")                            \
2836                                                                             \
2837   notproduct(bool, ExitVMOnVerifyError, false,                              \
2838           "standard exit from VM if bytecode verify error "                 \
2839           "(only in debug mode)")                                           \
2840                                                                             \
2841   diagnostic(ccstr, AbortVMOnException, NULL,                               \
2842           "Call fatal if this exception is thrown.  Example: "              \
2843           "java -XX:AbortVMOnException=java.lang.NullPointerException Foo") \
2844                                                                             \
2845   diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \
2846           "Call fatal if the exception pointed by AbortVMOnException "      \
2847           "has this message")                                               \
2848                                                                             \
2849   develop(bool, DebugVtables, false,                                        \
2850           "add debugging code to vtable dispatch")                          \
2851                                                                             \
2852   develop(bool, PrintVtables, false,                                        \
2853           "print vtables when printing klass")                              \
2854                                                                             \
2855   notproduct(bool, PrintVtableStats, false,                                 \
2856           "print vtables stats at end of run")                              \
2857                                                                             \
2858   develop(bool, TraceCreateZombies, false,                                  \
2859           "trace creation of zombie nmethods")                              \
2860                                                                             \
2861   notproduct(bool, IgnoreLockingAssertions, false,                          \
2862           "disable locking assertions (for speed)")                         \
2863                                                                             \
2864   product(bool, RangeCheckElimination, true,                                \
2865           "Eliminate range checks")                                         \
2866                                                                             \
2867   develop_pd(bool, UncommonNullCast,                                        \
2868           "track occurrences of null in casts; adjust compiler tactics")    \
2869                                                                             \
2870   develop(bool, TypeProfileCasts,  true,                                    \
2871           "treat casts like calls for purposes of type profiling")          \
2872                                                                             \
2873   develop(bool, DelayCompilationDuringStartup, true,                        \
2874           "Delay invoking the compiler until main application class is "    \
2875           "loaded")                                                         \
2876                                                                             \
2877   develop(bool, CompileTheWorld, false,                                     \
2878           "Compile all methods in all classes in bootstrap class path "     \
2879             "(stress test)")                                                \
2880                                                                             \
2881   develop(bool, CompileTheWorldPreloadClasses, true,                        \
2882           "Preload all classes used by a class before start loading")       \
2883                                                                             \
2884   notproduct(intx, CompileTheWorldSafepointInterval, 100,                   \
2885           "Force a safepoint every n compiles so sweeper can keep up")      \
2886                                                                             \
2887   develop(bool, FillDelaySlots, true,                                       \
2888           "Fill delay slots (on SPARC only)")                               \
2889                                                                             \
2890   develop(bool, TimeLivenessAnalysis, false,                                \
2891           "Time computation of bytecode liveness analysis")                 \
2892                                                                             \
2893   develop(bool, TraceLivenessGen, false,                                    \
2894           "Trace the generation of liveness analysis information")          \
2895                                                                             \
2896   notproduct(bool, TraceLivenessQuery, false,                               \
2897           "Trace queries of liveness analysis information")                 \
2898                                                                             \
2899   notproduct(bool, CollectIndexSetStatistics, false,                        \
2900           "Collect information about IndexSets")                            \
2901                                                                             \
2902   develop(bool, UseLoopSafepoints, true,                                    \
2903           "Generate Safepoint nodes in every loop")                         \
2904                                                                             \
2905   develop(intx, FastAllocateSizeLimit, 128*K,                               \
2906           /* Note:  This value is zero mod 1&lt;&lt;13 for a cheap sparc set. */  \
2907           "Inline allocations larger than this in doublewords must go slow")\
2908                                                                             \
2909   product(bool, AggressiveOpts, false,                                      \
2910           "Enable aggressive optimizations - see arguments.cpp")            \
2911                                                                             \
2912   product_pd(bool, CompactStrings,                                          \
2913           "Enable Strings to use single byte chars in backing store")       \
2914                                                                             \
2915   product_pd(uintx, TypeProfileLevel,                                       \
2916           "=XYZ, with Z: Type profiling of arguments at call; "             \
2917                      "Y: Type profiling of return value at call; "          \
2918                      "X: Type profiling of parameters to methods; "         \
2919           "X, Y and Z in 0=off ; 1=jsr292 only; 2=all methods")             \
2920           constraint(TypeProfileLevelConstraintFunc, AfterErgo)             \
2921                                                                             \
2922   product(intx, TypeProfileArgsLimit,     2,                                \
2923           "max number of call arguments to consider for type profiling")    \
2924           range(0, 16)                                                      \
2925                                                                             \
2926   product(intx, TypeProfileParmsLimit,    2,                                \
2927           "max number of incoming parameters to consider for type profiling"\
2928           ", -1 for all")                                                   \
2929           range(-1, 64)                                                     \
2930                                                                             \
2931   /* statistics */                                                          \
2932   develop(bool, CountCompiledCalls, false,                                  \
2933           "Count method invocations")                                       \
2934                                                                             \
2935   notproduct(bool, CountRuntimeCalls, false,                                \
2936           "Count VM runtime calls")                                         \
2937                                                                             \
2938   develop(bool, CountJNICalls, false,                                       \
2939           "Count jni method invocations")                                   \
2940                                                                             \
2941   notproduct(bool, CountJVMCalls, false,                                    \
2942           "Count jvm method invocations")                                   \
2943                                                                             \
2944   notproduct(bool, CountRemovableExceptions, false,                         \
2945           "Count exceptions that could be replaced by branches due to "     \
2946           "inlining")                                                       \
2947                                                                             \
2948   notproduct(bool, ICMissHistogram, false,                                  \
2949           "Produce histogram of IC misses")                                 \
2950                                                                             \
2951   /* interpreter */                                                         \
2952   develop(bool, ClearInterpreterLocals, false,                              \
2953           "Always clear local variables of interpreter activations upon "   \
2954           "entry")                                                          \
2955                                                                             \
2956   product_pd(bool, RewriteBytecodes,                                        \
2957           "Allow rewriting of bytecodes (bytecodes are not immutable)")     \
2958                                                                             \
2959   product_pd(bool, RewriteFrequentPairs,                                    \
2960           "Rewrite frequently used bytecode pairs into a single bytecode")  \
2961                                                                             \
2962   diagnostic(bool, PrintInterpreter, false,                                 \
2963           "Print the generated interpreter code")                           \
2964                                                                             \
2965   product(bool, UseInterpreter, true,                                       \
2966           "Use interpreter for non-compiled methods")                       \
2967                                                                             \
2968   develop(bool, UseFastSignatureHandlers, true,                             \
2969           "Use fast signature handlers for native calls")                   \
2970                                                                             \
2971   product(bool, UseLoopCounter, true,                                       \
2972           "Increment invocation counter on backward branch")                \
2973                                                                             \
2974   product_pd(bool, UseOnStackReplacement,                                   \
2975           "Use on stack replacement, calls runtime if invoc. counter "      \
2976           "overflows in loop")                                              \
2977                                                                             \
2978   notproduct(bool, TraceOnStackReplacement, false,                          \
2979           "Trace on stack replacement")                                     \
2980                                                                             \
2981   product_pd(bool, PreferInterpreterNativeStubs,                            \
2982           "Use always interpreter stubs for native methods invoked via "    \
2983           "interpreter")                                                    \
2984                                                                             \
2985   develop(bool, CountBytecodes, false,                                      \
2986           "Count number of bytecodes executed")                             \
2987                                                                             \
2988   develop(bool, PrintBytecodeHistogram, false,                              \
2989           "Print histogram of the executed bytecodes")                      \
2990                                                                             \
2991   develop(bool, PrintBytecodePairHistogram, false,                          \
2992           "Print histogram of the executed bytecode pairs")                 \
2993                                                                             \
2994   diagnostic(bool, PrintSignatureHandlers, false,                           \
2995           "Print code generated for native method signature handlers")      \
2996                                                                             \
2997   develop(bool, VerifyOops, false,                                          \
2998           "Do plausibility checks for oops")                                \
2999                                                                             \
3000   develop(bool, CheckUnhandledOops, false,                                  \
3001           "Check for unhandled oops in VM code")                            \
3002                                                                             \
3003   develop(bool, VerifyJNIFields, trueInDebug,                               \
3004           "Verify jfieldIDs for instance fields")                           \
3005                                                                             \
3006   notproduct(bool, VerifyJNIEnvThread, false,                               \
3007           "Verify JNIEnv.thread == Thread::current() when entering VM "     \
3008           "from JNI")                                                       \
3009                                                                             \
3010   develop(bool, VerifyFPU, false,                                           \
3011           "Verify FPU state (check for NaN's, etc.)")                       \
3012                                                                             \
3013   develop(bool, VerifyThread, false,                                        \
3014           "Watch the thread register for corruption (SPARC only)")          \
3015                                                                             \
3016   develop(bool, VerifyActivationFrameSize, false,                           \
3017           "Verify that activation frame didn't become smaller than its "    \
3018           "minimal size")                                                   \
3019                                                                             \
3020   develop(bool, TraceFrequencyInlining, false,                              \
3021           "Trace frequency based inlining")                                 \
3022                                                                             \
3023   develop_pd(bool, InlineIntrinsics,                                        \
3024           "Inline intrinsics that can be statically resolved")              \
3025                                                                             \
3026   product_pd(bool, ProfileInterpreter,                                      \
3027           "Profile at the bytecode level during interpretation")            \
3028                                                                             \
3029   develop(bool, TraceProfileInterpreter, false,                             \
3030           "Trace profiling at the bytecode level during interpretation. "   \
3031           "This outputs the profiling information collected to improve "    \
3032           "jit compilation.")                                               \
3033                                                                             \
3034   develop_pd(bool, ProfileTraps,                                            \
3035           "Profile deoptimization traps at the bytecode level")             \
3036                                                                             \
3037   product(intx, ProfileMaturityPercentage, 20,                              \
3038           "number of method invocations/branches (expressed as % of "       \
3039           "CompileThreshold) before using the method's profile")            \
3040           range(0, 100)                                                     \
3041                                                                             \
3042   diagnostic(bool, PrintMethodData, false,                                  \
3043           "Print the results of +ProfileInterpreter at end of run")         \
3044                                                                             \
3045   develop(bool, VerifyDataPointer, trueInDebug,                             \
3046           "Verify the method data pointer during interpreter profiling")    \
3047                                                                             \
3048   develop(bool, VerifyCompiledCode, false,                                  \
3049           "Include miscellaneous runtime verifications in nmethod code; "   \
3050           "default off because it disturbs nmethod size heuristics")        \
3051                                                                             \
3052   notproduct(bool, CrashGCForDumpingJavaThread, false,                      \
3053           "Manually make GC thread crash then dump java stack trace;  "     \
3054           "Test only")                                                      \
3055                                                                             \
3056   /* compilation */                                                         \
3057   product(bool, UseCompiler, true,                                          \
3058           "Use Just-In-Time compilation")                                   \
3059                                                                             \
3060   develop(bool, TraceCompilationPolicy, false,                              \
3061           "Trace compilation policy")                                       \
3062                                                                             \
3063   develop(bool, TimeCompilationPolicy, false,                               \
3064           "Time the compilation policy")                                    \
3065                                                                             \
3066   product(bool, UseCounterDecay, true,                                      \
3067           "Adjust recompilation counters")                                  \
3068                                                                             \
3069   develop(intx, CounterHalfLifeTime,    30,                                 \
3070           "Half-life time of invocation counters (in seconds)")             \
3071                                                                             \
3072   develop(intx, CounterDecayMinIntervalLength,   500,                       \
3073           "The minimum interval (in milliseconds) between invocation of "   \
3074           "CounterDecay")                                                   \
3075                                                                             \
3076   product(bool, AlwaysCompileLoopMethods, false,                            \
3077           "When using recompilation, never interpret methods "              \
3078           "containing loops")                                               \
3079                                                                             \
3080   product(bool, DontCompileHugeMethods, true,                               \
3081           "Do not compile methods &gt; HugeMethodLimit")                       \
3082                                                                             \
3083   /* Bytecode escape analysis estimation. */                                \
3084   product(bool, EstimateArgEscape, true,                                    \
3085           "Analyze bytecodes to estimate escape state of arguments")        \
3086                                                                             \
3087   product(intx, BCEATraceLevel, 0,                                          \
3088           "How much tracing to do of bytecode escape analysis estimates "   \
3089           "(0-3)")                                                          \
3090           range(0, 3)                                                       \
3091                                                                             \
3092   product(intx, MaxBCEAEstimateLevel, 5,                                    \
3093           "Maximum number of nested calls that are analyzed by BC EA")      \
3094           range(0, max_jint)                                                \
3095                                                                             \
3096   product(intx, MaxBCEAEstimateSize, 150,                                   \
3097           "Maximum bytecode size of a method to be analyzed by BC EA")      \
3098           range(0, max_jint)                                                \
3099                                                                             \
3100   product(intx,  AllocatePrefetchStyle, 1,                                  \
3101           "0 = no prefetch, "                                               \
3102           "1 = prefetch instructions for each allocation, "                 \
3103           "2 = use TLAB watermark to gate allocation prefetch, "            \
3104           "3 = use BIS instruction on Sparc for allocation prefetch")       \
3105           range(0, 3)                                                       \
3106                                                                             \
3107   product(intx,  AllocatePrefetchDistance, -1,                              \
3108           "Distance to prefetch ahead of allocation pointer. "              \
3109           "-1: use system-specific value (automatically determined")        \
3110           constraint(AllocatePrefetchDistanceConstraintFunc, AfterMemoryInit)\
3111                                                                             \
3112   product(intx,  AllocatePrefetchLines, 3,                                  \
3113           "Number of lines to prefetch ahead of array allocation pointer")  \
3114           range(1, max_jint / 2)                                            \
3115                                                                             \
3116   product(intx,  AllocateInstancePrefetchLines, 1,                          \
3117           "Number of lines to prefetch ahead of instance allocation "       \
3118           "pointer")                                                        \
3119           range(1, max_jint / 2)                                            \
3120                                                                             \
3121   product(intx,  AllocatePrefetchStepSize, 16,                              \
3122           "Step size in bytes of sequential prefetch instructions")         \
3123           range(1, max_jint)                                                \
3124           constraint(AllocatePrefetchStepSizeConstraintFunc,AfterMemoryInit)\
3125                                                                             \
3126   product(intx,  AllocatePrefetchInstr, 0,                                  \
3127           "Prefetch instruction to prefetch ahead of allocation pointer")   \
3128           constraint(AllocatePrefetchInstrConstraintFunc, AfterErgo)        \
3129                                                                             \
3130   /* deoptimization */                                                      \
3131   develop(bool, TraceDeoptimization, false,                                 \
3132           "Trace deoptimization")                                           \
3133                                                                             \
3134   develop(bool, PrintDeoptimizationDetails, false,                          \
3135           "Print more information about deoptimization")                    \
3136                                                                             \
3137   develop(bool, DebugDeoptimization, false,                                 \
3138           "Tracing various information while debugging deoptimization")     \
3139                                                                             \
3140   product(intx, SelfDestructTimer, 0,                                       \
3141           "Will cause VM to terminate after a given time (in minutes) "     \
3142           "(0 means off)")                                                  \
3143           range(0, max_intx)                                                \
3144                                                                             \
3145   product(intx, MaxJavaStackTraceDepth, 1024,                               \
3146           "The maximum number of lines in the stack trace for Java "        \
3147           "exceptions (0 means all)")                                       \
3148           range(0, max_jint/2)                                              \
3149                                                                             \
3150   develop(bool, TraceStackWalk, false,                                      \
3151           "Trace stack walking")                                            \
3152                                                                             \
3153   product(bool, MemberNameInStackFrame, true,                               \
3154           "Use MemberName in StackFrame")                                   \
3155                                                                             \
3156   /* notice: the max range value here is max_jint, not max_intx  */         \
3157   /* because of overflow issue                                   */         \
3158   NOT_EMBEDDED(diagnostic(intx, GuaranteedSafepointInterval, 1000,          \
3159           "Guarantee a safepoint (at least) every so many milliseconds "    \
3160           "(0 means none)"))                                                \
3161   NOT_EMBEDDED(range(0, max_jint))                                          \
3162                                                                             \
3163   EMBEDDED_ONLY(product(intx, GuaranteedSafepointInterval, 0,               \
3164           "Guarantee a safepoint (at least) every so many milliseconds "    \
3165           "(0 means none)"))                                                \
3166   EMBEDDED_ONLY(range(0, max_jint))                                         \
3167                                                                             \
3168   product(intx, SafepointTimeoutDelay, 10000,                               \
3169           "Delay in milliseconds for option SafepointTimeout")              \
3170   LP64_ONLY(range(0, max_intx/MICROUNITS))                                  \
3171   NOT_LP64(range(0, max_intx))                                              \
3172                                                                             \
3173   product(intx, NmethodSweepActivity, 10,                                   \
3174           "Removes cold nmethods from code cache if &gt; 0. Higher values "    \
3175           "result in more aggressive sweeping")                             \
3176           range(0, 2000)                                                    \
3177                                                                             \
3178   notproduct(bool, LogSweeper, false,                                       \
3179           "Keep a ring buffer of sweeper activity")                         \
3180                                                                             \
3181   notproduct(intx, SweeperLogEntries, 1024,                                 \
3182           "Number of records in the ring buffer of sweeper activity")       \
3183                                                                             \
3184   notproduct(intx, MemProfilingInterval, 500,                               \
3185           "Time between each invocation of the MemProfiler")                \
3186                                                                             \
3187   develop(intx, MallocCatchPtr, -1,                                         \
3188           "Hit breakpoint when mallocing/freeing this pointer")             \
3189                                                                             \
3190   notproduct(ccstrlist, SuppressErrorAt, "",                                \
3191           "List of assertions (file:line) to muzzle")                       \
3192                                                                             \
3193   notproduct(size_t, HandleAllocationLimit, 1024,                           \
3194           "Threshold for HandleMark allocation when +TraceHandleAllocation "\
3195           "is used")                                                        \
3196                                                                             \
3197   develop(size_t, TotalHandleAllocationLimit, 1024,                         \
3198           "Threshold for total handle allocation when "                     \
3199           "+TraceHandleAllocation is used")                                 \
3200                                                                             \
3201   develop(intx, StackPrintLimit, 100,                                       \
3202           "number of stack frames to print in VM-level stack dump")         \
3203                                                                             \
3204   notproduct(intx, MaxElementPrintSize, 256,                                \
3205           "maximum number of elements to print")                            \
3206                                                                             \
3207   notproduct(intx, MaxSubklassPrintSize, 4,                                 \
3208           "maximum number of subklasses to print when printing klass")      \
3209                                                                             \
3210   product(intx, MaxInlineLevel, 9,                                          \
3211           "maximum number of nested calls that are inlined")                \
3212           range(0, max_jint)                                                \
3213                                                                             \
3214   product(intx, MaxRecursiveInlineLevel, 1,                                 \
3215           "maximum number of nested recursive calls that are inlined")      \
3216           range(0, max_jint)                                                \
3217                                                                             \
3218   develop(intx, MaxForceInlineLevel, 100,                                   \
3219           "maximum number of nested calls that are forced for inlining "    \
3220           "(using CompileCommand or marked w/ @ForceInline)")               \
3221           range(0, max_jint)                                                \
3222                                                                             \
3223   product_pd(intx, InlineSmallCode,                                         \
3224           "Only inline already compiled methods if their code size is "     \
3225           "less than this")                                                 \
3226           range(0, max_jint)                                                \
3227                                                                             \
3228   product(intx, MaxInlineSize, 35,                                          \
3229           "The maximum bytecode size of a method to be inlined")            \
3230           range(0, max_jint)                                                \
3231                                                                             \
3232   product_pd(intx, FreqInlineSize,                                          \
3233           "The maximum bytecode size of a frequent method to be inlined")   \
3234           range(0, max_jint)                                                \
3235                                                                             \
3236   product(intx, MaxTrivialSize, 6,                                          \
3237           "The maximum bytecode size of a trivial method to be inlined")    \
3238           range(0, max_jint)                                                \
3239                                                                             \
3240   product(intx, MinInliningThreshold, 250,                                  \
3241           "The minimum invocation count a method needs to have to be "      \
3242           "inlined")                                                        \
3243           range(0, max_jint)                                                \
3244                                                                             \
3245   develop(intx, MethodHistogramCutoff, 100,                                 \
3246           "The cutoff value for method invocation histogram (+CountCalls)") \
3247                                                                             \
3248   develop(intx, ProfilerNumberOfInterpretedMethods, 25,                     \
3249           "Number of interpreted methods to show in profile")               \
3250                                                                             \
3251   develop(intx, ProfilerNumberOfCompiledMethods, 25,                        \
3252           "Number of compiled methods to show in profile")                  \
3253                                                                             \
3254   develop(intx, ProfilerNumberOfStubMethods, 25,                            \
3255           "Number of stub methods to show in profile")                      \
3256                                                                             \
3257   develop(intx, ProfilerNumberOfRuntimeStubNodes, 25,                       \
3258           "Number of runtime stub nodes to show in profile")                \
3259                                                                             \
3260   product(intx, ProfileIntervalsTicks, 100,                                 \
3261           "Number of ticks between printing of interval profile "           \
3262           "(+ProfileIntervals)")                                            \
3263           range(0, max_intx)                                                \
3264                                                                             \
3265   notproduct(intx, ScavengeALotInterval,     1,                             \
3266           "Interval between which scavenge will occur with +ScavengeALot")  \
3267                                                                             \
3268   notproduct(intx, FullGCALotInterval,     1,                               \
3269           "Interval between which full gc will occur with +FullGCALot")     \
3270                                                                             \
3271   notproduct(intx, FullGCALotStart,     0,                                  \
3272           "For which invocation to start FullGCAlot")                       \
3273                                                                             \
3274   notproduct(intx, FullGCALotDummies,  32*K,                                \
3275           "Dummy object allocated with +FullGCALot, forcing all objects "   \
3276           "to move")                                                        \
3277                                                                             \
3278   develop(intx, DontYieldALotInterval,    10,                               \
3279           "Interval between which yields will be dropped (milliseconds)")   \
3280                                                                             \
3281   develop(intx, MinSleepInterval,     1,                                    \
3282           "Minimum sleep() interval (milliseconds) when "                   \
3283           "ConvertSleepToYield is off (used for Solaris)")                  \
3284                                                                             \
3285   develop(intx, ProfilerPCTickThreshold,    15,                             \
3286           "Number of ticks in a PC buckets to be a hotspot")                \
3287                                                                             \
3288   notproduct(intx, DeoptimizeALotInterval,     5,                           \
3289           "Number of exits until DeoptimizeALot kicks in")                  \
3290                                                                             \
3291   notproduct(intx, ZombieALotInterval,     5,                               \
3292           "Number of exits until ZombieALot kicks in")                      \
3293                                                                             \
3294   diagnostic(intx, MallocVerifyInterval,     0,                             \
3295           "If non-zero, verify C heap after every N calls to "              \
3296           "malloc/realloc/free")                                            \
3297           range(0, max_intx)                                                \
3298                                                                             \
3299   diagnostic(intx, MallocVerifyStart,     0,                                \
3300           "If non-zero, start verifying C heap after Nth call to "          \
3301           "malloc/realloc/free")                                            \
3302           range(0, max_intx)                                                \
3303                                                                             \
3304   diagnostic(uintx, MallocMaxTestWords,     0,                              \
3305           "If non-zero, maximum number of words that malloc/realloc can "   \
3306           "allocate (for testing only)")                                    \
3307           range(0, max_uintx)                                               \
3308                                                                             \
3309   product(intx, TypeProfileWidth, 2,                                        \
3310           "Number of receiver types to record in call/cast profile")        \
3311           range(0, 8)                                                       \
3312                                                                             \
3313   experimental(intx, MethodProfileWidth, 0,                                 \
3314           "Number of methods to record in call profile")                    \
3315                                                                             \
3316   develop(intx, BciProfileWidth,      2,                                    \
3317           "Number of return bci's to record in ret profile")                \
3318                                                                             \
3319   product(intx, PerMethodRecompilationCutoff, 400,                          \
3320           "After recompiling N times, stay in the interpreter (-1=&gt;'Inf')") \
3321           range(-1, max_intx)                                               \
3322                                                                             \
3323   product(intx, PerBytecodeRecompilationCutoff, 200,                        \
3324           "Per-BCI limit on repeated recompilation (-1=&gt;'Inf')")            \
3325           range(-1, max_intx)                                               \
3326                                                                             \
3327   product(intx, PerMethodTrapLimit,  100,                                   \
3328           "Limit on traps (of one kind) in a method (includes inlines)")    \
3329           range(0, max_jint)                                                \
3330                                                                             \
3331   experimental(intx, PerMethodSpecTrapLimit,  5000,                         \
3332           "Limit on speculative traps (of one kind) in a method "           \
3333           "(includes inlines)")                                             \
3334           range(0, max_jint)                                                \
3335                                                                             \
3336   product(intx, PerBytecodeTrapLimit,  4,                                   \
3337           "Limit on traps (of one kind) at a particular BCI")               \
3338           range(0, max_jint)                                                \
3339                                                                             \
3340   experimental(intx, SpecTrapLimitExtraEntries,  3,                         \
3341           "Extra method data trap entries for speculation")                 \
3342                                                                             \
3343   develop(intx, InlineFrequencyRatio,    20,                                \
3344           "Ratio of call site execution to caller method invocation")       \
3345           range(0, max_jint)                                                \
3346                                                                             \
3347   develop_pd(intx, InlineFrequencyCount,                                    \
3348           "Count of call site execution necessary to trigger frequent "     \
3349           "inlining")                                                       \
3350           range(0, max_jint)                                                \
3351                                                                             \
3352   develop(intx, InlineThrowCount,    50,                                    \
3353           "Force inlining of interpreted methods that throw this often")    \
3354           range(0, max_jint)                                                \
3355                                                                             \
3356   develop(intx, InlineThrowMaxSize,   200,                                  \
3357           "Force inlining of throwing methods smaller than this")           \
3358           range(0, max_jint)                                                \
3359                                                                             \
3360   develop(intx, ProfilerNodeSize,  1024,                                    \
3361           "Size in K to allocate for the Profile Nodes of each thread")     \
3362           range(0, 1024)                                                    \
3363                                                                             \
3364   /* gc parameters */                                                       \
3365   product(size_t, InitialHeapSize, 0,                                       \
3366           "Initial heap size (in bytes); zero means use ergonomics")        \
3367           constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \
3368                                                                             \
3369   product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                      \
3370           "Maximum heap size (in bytes)")                                   \
3371           constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \
3372                                                                             \
3373   product(size_t, OldSize, ScaleForWordSize(4*M),                           \
3374           "Initial tenured generation size (in bytes)")                     \
3375           range(0, max_uintx)                                               \
3376                                                                             \
3377   product(size_t, NewSize, ScaleForWordSize(1*M),                           \
3378           "Initial new generation size (in bytes)")                         \
3379           constraint(NewSizeConstraintFunc,AfterErgo)                       \
3380                                                                             \
3381   product(size_t, MaxNewSize, max_uintx,                                    \
3382           "Maximum new generation size (in bytes), max_uintx means set "    \
3383           "ergonomically")                                                  \
3384           range(0, max_uintx)                                               \
3385                                                                             \
3386   product_pd(size_t, HeapBaseMinAddress,                                    \
3387           "OS specific low limit for heap base address")                    \
3388           constraint(HeapBaseMinAddressConstraintFunc,AfterErgo)            \
3389                                                                             \
3390   product(size_t, PretenureSizeThreshold, 0,                                \
3391           "Maximum size in bytes of objects allocated in DefNew "           \
3392           "generation; zero means no maximum")                              \
3393           range(0, max_uintx)                                               \
3394                                                                             \
3395   product(size_t, MinTLABSize, 2*K,                                         \
3396           "Minimum allowed TLAB size (in bytes)")                           \
3397           range(1, max_uintx)                                               \
3398           constraint(MinTLABSizeConstraintFunc,AfterMemoryInit)             \
3399                                                                             \
3400   product(size_t, TLABSize, 0,                                              \
3401           "Starting TLAB size (in bytes); zero means set ergonomically")    \
3402           constraint(TLABSizeConstraintFunc,AfterMemoryInit)                \
3403                                                                             \
3404   product(size_t, YoungPLABSize, 4096,                                      \
3405           "Size of young gen promotion LAB's (in HeapWords)")               \
3406           constraint(YoungPLABSizeConstraintFunc,AfterMemoryInit)           \
3407                                                                             \
3408   product(size_t, OldPLABSize, 1024,                                        \
3409           "Size of old gen promotion LAB's (in HeapWords), or Number "      \
3410           "of blocks to attempt to claim when refilling CMS LAB's")         \
3411           constraint(OldPLABSizeConstraintFunc,AfterMemoryInit)             \
3412                                                                             \
3413   product(uintx, TLABAllocationWeight, 35,                                  \
3414           "Allocation averaging weight")                                    \
3415           range(0, 100)                                                     \
3416                                                                             \
3417   /* Limit the lower bound of this flag to 1 as it is used  */              \
3418   /* in a division expression.                              */              \
3419   product(uintx, TLABWasteTargetPercent, 1,                                 \
3420           "Percentage of Eden that can be wasted")                          \
3421           range(1, 100)                                                     \
3422                                                                             \
3423   product(uintx, TLABRefillWasteFraction,    64,                            \
3424           "Maximum TLAB waste at a refill (internal fragmentation)")        \
3425           range(1, max_juint)                                               \
3426                                                                             \
3427   product(uintx, TLABWasteIncrement,    4,                                  \
3428           "Increment allowed waste at slow allocation")                     \
3429           range(0, max_jint)                                                \
3430           constraint(TLABWasteIncrementConstraintFunc,AfterMemoryInit)      \
3431                                                                             \
3432   product(uintx, SurvivorRatio, 8,                                          \
3433           "Ratio of eden/survivor space size")                              \
3434           range(1, max_uintx-2)                                             \
3435           constraint(SurvivorRatioConstraintFunc,AfterMemoryInit)           \
3436                                                                             \
3437   product(uintx, NewRatio, 2,                                               \
3438           "Ratio of old/new generation sizes")                              \
3439           range(0, max_uintx-1)                                             \
3440                                                                             \
3441   product_pd(size_t, NewSizeThreadIncrease,                                 \
3442           "Additional size added to desired new generation size per "       \
3443           "non-daemon thread (in bytes)")                                   \
3444           range(0, max_uintx)                                               \
3445                                                                             \
3446   product_pd(size_t, MetaspaceSize,                                         \
3447           "Initial size of Metaspaces (in bytes)")                          \
3448           constraint(MetaspaceSizeConstraintFunc,AfterErgo)                 \
3449                                                                             \
3450   product(size_t, MaxMetaspaceSize, max_uintx,                              \
3451           "Maximum size of Metaspaces (in bytes)")                          \
3452           constraint(MaxMetaspaceSizeConstraintFunc,AfterErgo)              \
3453                                                                             \
3454   product(size_t, CompressedClassSpaceSize, 1*G,                            \
3455           "Maximum size of class area in Metaspace when compressed "        \
3456           "class pointers are used")                                        \
3457           range(1*M, 3*G)                                                   \
3458                                                                             \
3459   manageable(uintx, MinHeapFreeRatio, 40,                                   \
3460           "The minimum percentage of heap free after GC to avoid expansion."\
3461           " For most GCs this applies to the old generation. In G1 and"     \
3462           " ParallelGC it applies to the whole heap.")                      \
3463           range(0, 100)                                                     \
3464           constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \
3465                                                                             \
3466   manageable(uintx, MaxHeapFreeRatio, 70,                                   \
3467           "The maximum percentage of heap free after GC to avoid shrinking."\
3468           " For most GCs this applies to the old generation. In G1 and"     \
3469           " ParallelGC it applies to the whole heap.")                      \
3470           range(0, 100)                                                     \
3471           constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \
3472                                                                             \
3473   product(intx, SoftRefLRUPolicyMSPerMB, 1000,                              \
3474           "Number of milliseconds per MB of free space in the heap")        \
3475           range(0, max_intx)                                                \
3476           constraint(SoftRefLRUPolicyMSPerMBConstraintFunc,AfterMemoryInit) \
3477                                                                             \
3478   product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),               \
3479           "The minimum change in heap space due to GC (in bytes)")          \
3480           range(0, max_uintx)                                               \
3481                                                                             \
3482   product(size_t, MinMetaspaceExpansion, ScaleForWordSize(256*K),           \
3483           "The minimum expansion of Metaspace (in bytes)")                  \
3484           range(0, max_uintx)                                               \
3485                                                                             \
3486   product(uintx, MaxMetaspaceFreeRatio,    70,                              \
3487           "The maximum percentage of Metaspace free after GC to avoid "     \
3488           "shrinking")                                                      \
3489           range(0, 100)                                                     \
3490           constraint(MaxMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3491                                                                             \
3492   product(uintx, MinMetaspaceFreeRatio,    40,                              \
3493           "The minimum percentage of Metaspace free after GC to avoid "     \
3494           "expansion")                                                      \
3495           range(0, 99)                                                      \
3496           constraint(MinMetaspaceFreeRatioConstraintFunc,AfterErgo)         \
3497                                                                             \
3498   product(size_t, MaxMetaspaceExpansion, ScaleForWordSize(4*M),             \
3499           "The maximum expansion of Metaspace without full GC (in bytes)")  \
3500           range(0, max_uintx)                                               \
3501                                                                             \
3502   product(uintx, QueuedAllocationWarningCount, 0,                           \
3503           "Number of times an allocation that queues behind a GC "          \
3504           "will retry before printing a warning")                           \
3505           range(0, max_uintx)                                               \
3506                                                                             \
3507   diagnostic(uintx, VerifyGCStartAt,   0,                                   \
3508           "GC invoke count where +VerifyBefore/AfterGC kicks in")           \
3509           range(0, max_uintx)                                               \
3510                                                                             \
3511   diagnostic(intx, VerifyGCLevel,     0,                                    \
3512           "Generation level at which to start +VerifyBefore/AfterGC")       \
3513           range(0, 1)                                                       \
3514                                                                             \
3515   product(uintx, MaxTenuringThreshold,    15,                               \
3516           "Maximum value for tenuring threshold")                           \
3517           range(0, markOopDesc::max_age + 1)                                \
3518           constraint(MaxTenuringThresholdConstraintFunc,AfterErgo)          \
3519                                                                             \
3520   product(uintx, InitialTenuringThreshold,    7,                            \
3521           "Initial value for tenuring threshold")                           \
3522           range(0, markOopDesc::max_age + 1)                                \
3523           constraint(InitialTenuringThresholdConstraintFunc,AfterErgo)      \
3524                                                                             \
3525   product(uintx, TargetSurvivorRatio,    50,                                \
3526           "Desired percentage of survivor space used after scavenge")       \
3527           range(0, 100)                                                     \
3528                                                                             \
3529   product(uintx, MarkSweepDeadRatio,     5,                                 \
3530           "Percentage (0-100) of the old gen allowed as dead wood. "        \
3531           "Serial mark sweep treats this as both the minimum and maximum "  \
3532           "value. "                                                         \
3533           "CMS uses this value only if it falls back to mark sweep. "       \
3534           "Par compact uses a variable scale based on the density of the "  \
3535           "generation and treats this as the maximum value when the heap "  \
3536           "is either completely full or completely empty.  Par compact "    \
3537           "also has a smaller default value; see arguments.cpp.")           \
3538           range(0, 100)                                                     \
3539                                                                             \
3540   product(uintx, MarkSweepAlwaysCompactCount,     4,                        \
3541           "How often should we fully compact the heap (ignoring the dead "  \
3542           "space parameters)")                                              \
3543           range(1, max_uintx)                                               \
3544                                                                             \
3545   product(intx, PrintCMSStatistics, 0,                                      \
3546           "Statistics for CMS")                                             \
3547           range(0, 2)                                                       \
3548                                                                             \
3549   product(bool, PrintCMSInitiationStatistics, false,                        \
3550           "Statistics for initiating a CMS collection")                     \
3551                                                                             \
3552   product(intx, PrintFLSStatistics, 0,                                      \
3553           "Statistics for CMS' FreeListSpace")                              \
3554           range(0, 2)                                                       \
3555                                                                             \
3556   product(intx, PrintFLSCensus, 0,                                          \
3557           "Census for CMS' FreeListSpace")                                  \
3558           range(0, 1)                                                       \
3559                                                                             \
3560   develop(uintx, GCExpandToAllocateDelayMillis, 0,                          \
3561           "Delay between expansion and allocation (in milliseconds)")       \
3562                                                                             \
3563   develop(uintx, GCWorkerDelayMillis, 0,                                    \
3564           "Delay in scheduling GC workers (in milliseconds)")               \
3565                                                                             \
3566   product(intx, DeferThrSuspendLoopCount,     4000,                         \
3567           "(Unstable) Number of times to iterate in safepoint loop "        \
3568           "before blocking VM threads ")                                    \
3569           range(-1, max_jint-1)                                             \
3570                                                                             \
3571   product(intx, DeferPollingPageLoopCount,     -1,                          \
3572           "(Unsafe,Unstable) Number of iterations in safepoint loop "       \
3573           "before changing safepoint polling page to RO ")                  \
3574           range(-1, max_jint-1)                                             \
3575                                                                             \
3576   product(intx, SafepointSpinBeforeYield, 2000, "(Unstable)")               \
3577           range(0, max_intx)                                                \
3578                                                                             \
3579   product(bool, PSChunkLargeArrays, true,                                   \
3580           "Process large arrays in chunks")                                 \
3581                                                                             \
3582   product(uintx, GCDrainStackTargetSize, 64,                                \
3583           "Number of entries we will try to leave on the stack "            \
3584           "during parallel gc")                                             \
3585           range(0, max_juint)                                               \
3586                                                                             \
3587   /* stack parameters */                                                    \
3588   product_pd(intx, StackYellowPages,                                        \
3589           "Number of yellow zone (recoverable overflows) pages")            \
3590           range(MIN_STACK_YELLOW_PAGES, (DEFAULT_STACK_YELLOW_PAGES+5))     \
3591                                                                             \
3592   product_pd(intx, StackRedPages,                                           \
3593           "Number of red zone (unrecoverable overflows) pages")             \
3594           range(MIN_STACK_RED_PAGES, (DEFAULT_STACK_RED_PAGES+2))           \
3595                                                                             \
3596   /* greater stack shadow pages can't generate instruction to bang stack */ \
3597   product_pd(intx, StackShadowPages,                                        \
3598           "Number of shadow zone (for overflow checking) pages "            \
3599           "this should exceed the depth of the VM and native call stack")   \
3600           range(MIN_STACK_SHADOW_PAGES, (DEFAULT_STACK_SHADOW_PAGES+30))    \
3601                                                                             \
3602   product_pd(intx, ThreadStackSize,                                         \
3603           "Thread Stack Size (in Kbytes)")                                  \
3604           range(0, max_intx-os::vm_page_size())                             \
3605                                                                             \
3606   product_pd(intx, VMThreadStackSize,                                       \
3607           "Non-Java Thread Stack Size (in Kbytes)")                         \
3608           range(0, max_intx/(1 * K))                                        \
3609                                                                             \
3610   product_pd(intx, CompilerThreadStackSize,                                 \
3611           "Compiler Thread Stack Size (in Kbytes)")                         \
3612           range(0, max_intx /(1 * K))                                       \
3613                                                                             \
3614   develop_pd(size_t, JVMInvokeMethodSlack,                                  \
3615           "Stack space (bytes) required for JVM_InvokeMethod to complete")  \
3616                                                                             \
3617   /* code cache parameters                                    */            \
3618   /* ppc64/tiered compilation has large code-entry alignment. */            \
3619   develop(uintx, CodeCacheSegmentSize,                                      \
3620           64 PPC64_ONLY(+64) NOT_PPC64(TIERED_ONLY(+64)),                   \
3621           "Code cache segment size (in bytes) - smallest unit of "          \
3622           "allocation")                                                     \
3623           range(1, 1024)                                                    \
3624           constraint(CodeCacheSegmentSizeConstraintFunc, AfterErgo)         \
3625                                                                             \
3626   develop_pd(intx, CodeEntryAlignment,                                      \
3627           "Code entry alignment for generated code (in bytes)")             \
3628           constraint(CodeEntryAlignmentConstraintFunc, AfterErgo)           \
3629                                                                             \
3630   product_pd(intx, OptoLoopAlignment,                                       \
3631           "Align inner loops to zero relative to this modulus")             \
3632           range(1, 16)                                                      \
3633           constraint(OptoLoopAlignmentConstraintFunc, AfterErgo)            \
3634                                                                             \
3635   product_pd(uintx, InitialCodeCacheSize,                                   \
3636           "Initial code cache size (in bytes)")                             \
3637           range(0, max_uintx)                                               \
3638                                                                             \
3639   develop_pd(uintx, CodeCacheMinimumUseSpace,                               \
3640           "Minimum code cache size (in bytes) required to start VM.")       \
3641           range(0, max_uintx)                                               \
3642                                                                             \
3643   product(bool, SegmentedCodeCache, false,                                  \
3644           "Use a segmented code cache")                                     \
3645                                                                             \
3646   product_pd(uintx, ReservedCodeCacheSize,                                  \
3647           "Reserved code cache size (in bytes) - maximum code cache size")  \
3648           range(0, max_uintx)                                               \
3649                                                                             \
3650   product_pd(uintx, NonProfiledCodeHeapSize,                                \
3651           "Size of code heap with non-profiled methods (in bytes)")         \
3652           range(0, max_uintx)                                               \
3653                                                                             \
3654   product_pd(uintx, ProfiledCodeHeapSize,                                   \
3655           "Size of code heap with profiled methods (in bytes)")             \
3656           range(0, max_uintx)                                               \
3657                                                                             \
3658   product_pd(uintx, NonNMethodCodeHeapSize,                                 \
3659           "Size of code heap with non-nmethods (in bytes)")                 \
3660           range(0, max_uintx)                                               \
3661                                                                             \
3662   product_pd(uintx, CodeCacheExpansionSize,                                 \
3663           "Code cache expansion size (in bytes)")                           \
3664           range(0, max_uintx)                                               \
3665                                                                             \
3666   develop_pd(uintx, CodeCacheMinBlockLength,                                \
3667           "Minimum number of segments in a code cache block")               \
3668           range(1, 100)                                                     \
3669                                                                             \
3670   notproduct(bool, ExitOnFullCodeCache, false,                              \
3671           "Exit the VM if we fill the code cache")                          \
3672                                                                             \
3673   product(bool, UseCodeCacheFlushing, true,                                 \
3674           "Remove cold/old nmethods from the code cache")                   \
3675                                                                             \
3676   product(uintx, StartAggressiveSweepingAt, 10,                             \
3677           "Start aggressive sweeping if X[%] of the code cache is free."    \
3678           "Segmented code cache: X[%] of the non-profiled heap."            \
3679           "Non-segmented code cache: X[%] of the total code cache")         \
3680           range(0, 100)                                                     \
3681                                                                             \
3682   /* interpreter debugging */                                               \
3683   develop(intx, BinarySwitchThreshold, 5,                                   \
3684           "Minimal number of lookupswitch entries for rewriting to binary " \
3685           "switch")                                                         \
3686                                                                             \
3687   develop(intx, StopInterpreterAt, 0,                                       \
3688           "Stop interpreter execution at specified bytecode number")        \
3689                                                                             \
3690   develop(intx, TraceBytecodesAt, 0,                                        \
3691           "Trace bytecodes starting with specified bytecode number")        \
3692                                                                             \
3693   /* compiler interface */                                                  \
3694   develop(intx, CIStart, 0,                                                 \
3695           "The id of the first compilation to permit")                      \
3696                                                                             \
3697   develop(intx, CIStop, max_jint,                                           \
3698           "The id of the last compilation to permit")                       \
3699                                                                             \
3700   develop(intx, CIStartOSR, 0,                                              \
3701           "The id of the first osr compilation to permit "                  \
3702           "(CICountOSR must be on)")                                        \
3703                                                                             \
3704   develop(intx, CIStopOSR, max_jint,                                        \
3705           "The id of the last osr compilation to permit "                   \
3706           "(CICountOSR must be on)")                                        \
3707                                                                             \
3708   develop(intx, CIBreakAtOSR, -1,                                           \
3709           "The id of osr compilation to break at")                          \
3710                                                                             \
3711   develop(intx, CIBreakAt, -1,                                              \
3712           "The id of compilation to break at")                              \
3713                                                                             \
3714   product(ccstrlist, CompileOnly, "",                                       \
3715           "List of methods (pkg/class.name) to restrict compilation to")    \
3716                                                                             \
3717   product(ccstr, CompileCommandFile, NULL,                                  \
3718           "Read compiler commands from this file [.hotspot_compiler]")      \
3719                                                                             \
3720   diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \
3721           "Read compiler directives from this file")                        \
3722                                                                             \
3723   product(ccstrlist, CompileCommand, "",                                    \
3724           "Prepend to .hotspot_compiler; e.g. log,java/lang/String.&lt;init&gt;") \
3725                                                                             \
3726   develop(bool, ReplayCompiles, false,                                      \
3727           "Enable replay of compilations from ReplayDataFile")              \
3728                                                                             \
3729   product(ccstr, ReplayDataFile, NULL,                                      \
3730           "File containing compilation replay information"                  \
3731           "[default: ./replay_pid%p.log] (%p replaced with pid)")           \
3732                                                                             \
3733    product(ccstr, InlineDataFile, NULL,                                     \
3734           "File containing inlining replay information"                     \
3735           "[default: ./inline_pid%p.log] (%p replaced with pid)")           \
3736                                                                             \
3737   develop(intx, ReplaySuppressInitializers, 2,                              \
3738           "Control handling of class initialization during replay: "        \
3739           "0 - don't do anything special; "                                 \
3740           "1 - treat all class initializers as empty; "                     \
3741           "2 - treat class initializers for application classes as empty; " \
3742           "3 - allow all class initializers to run during bootstrap but "   \
3743           "    pretend they are empty after starting replay")               \
3744           range(0, 3)                                                       \
3745                                                                             \
3746   develop(bool, ReplayIgnoreInitErrors, false,                              \
3747           "Ignore exceptions thrown during initialization for replay")      \
3748                                                                             \
3749   product(bool, DumpReplayDataOnError, true,                                \
3750           "Record replay data for crashing compiler threads")               \
3751                                                                             \
3752   product(bool, CICompilerCountPerCPU, false,                               \
3753           "1 compiler thread for log(N CPUs)")                              \
3754                                                                             \
3755   develop(intx, CIFireOOMAt,    -1,                                         \
3756           "Fire OutOfMemoryErrors throughout CI for testing the compiler "  \
3757           "(non-negative value throws OOM after this many CI accesses "     \
3758           "in each compile)")                                               \
3759   notproduct(intx, CICrashAt, -1,                                           \
3760           "id of compilation to trigger assert in compiler thread for "     \
3761           "the purpose of testing, e.g. generation of replay data")         \
3762   notproduct(bool, CIObjectFactoryVerify, false,                            \
3763           "enable potentially expensive verification in ciObjectFactory")   \
3764                                                                             \
3765   /* Priorities */                                                          \
3766   product_pd(bool, UseThreadPriorities,  "Use native thread priorities")    \
3767                                                                             \
3768   product(intx, ThreadPriorityPolicy, 0,                                    \
3769           "0 : Normal.                                                     "\
3770           "    VM chooses priorities that are appropriate for normal       "\
3771           "    applications. On Solaris NORM_PRIORITY and above are mapped "\
3772           "    to normal native priority. Java priorities below "           \
3773           "    NORM_PRIORITY map to lower native priority values. On       "\
3774           "    Windows applications are allowed to use higher native       "\
3775           "    priorities. However, with ThreadPriorityPolicy=0, VM will   "\
3776           "    not use the highest possible native priority,               "\
3777           "    THREAD_PRIORITY_TIME_CRITICAL, as it may interfere with     "\
3778           "    system threads. On Linux thread priorities are ignored      "\
3779           "    because the OS does not support static priority in          "\
3780           "    SCHED_OTHER scheduling class which is the only choice for   "\
3781           "    non-root, non-realtime applications.                        "\
3782           "1 : Aggressive.                                                 "\
3783           "    Java thread priorities map over to the entire range of      "\
3784           "    native thread priorities. Higher Java thread priorities map "\
3785           "    to higher native thread priorities. This policy should be   "\
3786           "    used with care, as sometimes it can cause performance       "\
3787           "    degradation in the application and/or the entire system. On "\
3788           "    Linux this policy requires root privilege.")                 \
3789           range(0, 1)                                                       \
3790                                                                             \
3791   product(bool, ThreadPriorityVerbose, false,                               \
3792           "Print priority changes")                                         \
3793                                                                             \
3794   product(intx, CompilerThreadPriority, -1,                                 \
3795           "The native priority at which compiler threads should run "       \
3796           "(-1 means no change)")                                           \
3797           range(min_jint, max_jint)                                         \
3798           constraint(CompilerThreadPriorityConstraintFunc, AfterErgo)       \
3799                                                                             \
3800   product(intx, VMThreadPriority, -1,                                       \
3801           "The native priority at which the VM thread should run "          \
3802           "(-1 means no change)")                                           \
3803           range(-1, 127)                                                    \
3804                                                                             \
3805   product(bool, CompilerThreadHintNoPreempt, true,                          \
3806           "(Solaris only) Give compiler threads an extra quanta")           \
3807                                                                             \
3808   product(bool, VMThreadHintNoPreempt, false,                               \
3809           "(Solaris only) Give VM thread an extra quanta")                  \
3810                                                                             \
3811   product(intx, JavaPriority1_To_OSPriority, -1,                            \
3812           "Map Java priorities to OS priorities")                           \
3813           range(-1, 127)                                                    \
3814                                                                             \
3815   product(intx, JavaPriority2_To_OSPriority, -1,                            \
3816           "Map Java priorities to OS priorities")                           \
3817           range(-1, 127)                                                    \
3818                                                                             \
3819   product(intx, JavaPriority3_To_OSPriority, -1,                            \
3820           "Map Java priorities to OS priorities")                           \
3821           range(-1, 127)                                                    \
3822                                                                             \
3823   product(intx, JavaPriority4_To_OSPriority, -1,                            \
3824           "Map Java priorities to OS priorities")                           \
3825           range(-1, 127)                                                    \
3826                                                                             \
3827   product(intx, JavaPriority5_To_OSPriority, -1,                            \
3828           "Map Java priorities to OS priorities")                           \
3829           range(-1, 127)                                                    \
3830                                                                             \
3831   product(intx, JavaPriority6_To_OSPriority, -1,                            \
3832           "Map Java priorities to OS priorities")                           \
3833           range(-1, 127)                                                    \
3834                                                                             \
3835   product(intx, JavaPriority7_To_OSPriority, -1,                            \
3836           "Map Java priorities to OS priorities")                           \
3837           range(-1, 127)                                                    \
3838                                                                             \
3839   product(intx, JavaPriority8_To_OSPriority, -1,                            \
3840           "Map Java priorities to OS priorities")                           \
3841           range(-1, 127)                                                    \
3842                                                                             \
3843   product(intx, JavaPriority9_To_OSPriority, -1,                            \
3844           "Map Java priorities to OS priorities")                           \
3845           range(-1, 127)                                                    \
3846                                                                             \
3847   product(intx, JavaPriority10_To_OSPriority,-1,                            \
3848           "Map Java priorities to OS priorities")                           \
3849           range(-1, 127)                                                    \
3850                                                                             \
3851   experimental(bool, UseCriticalJavaThreadPriority, false,                  \
3852           "Java thread priority 10 maps to critical scheduling priority")   \
3853                                                                             \
3854   experimental(bool, UseCriticalCompilerThreadPriority, false,              \
3855           "Compiler thread(s) run at critical scheduling priority")         \
3856                                                                             \
3857   experimental(bool, UseCriticalCMSThreadPriority, false,                   \
3858           "ConcurrentMarkSweep thread runs at critical scheduling priority")\
3859                                                                             \
3860   /* compiler debugging */                                                  \
3861   notproduct(intx, CompileTheWorldStartAt,     1,                           \
3862           "First class to consider when using +CompileTheWorld")            \
3863                                                                             \
3864   notproduct(intx, CompileTheWorldStopAt, max_jint,                         \
3865           "Last class to consider when using +CompileTheWorld")             \
3866                                                                             \
3867   develop(intx, NewCodeParameter,      0,                                   \
3868           "Testing Only: Create a dedicated integer parameter before "      \
3869           "putback")                                                        \
3870                                                                             \
3871   /* new oopmap storage allocation */                                       \
3872   develop(intx, MinOopMapAllocation,     8,                                 \
3873           "Minimum number of OopMap entries in an OopMapSet")               \
3874                                                                             \
3875   /* Background Compilation */                                              \
3876   develop(intx, LongCompileThreshold,     50,                               \
3877           "Used with +TraceLongCompiles")                                   \
3878                                                                             \
3879   /* recompilation */                                                       \
3880   product_pd(intx, CompileThreshold,                                        \
3881           "number of interpreted method invocations before (re-)compiling") \
3882           constraint(CompileThresholdConstraintFunc, AfterErgo)             \
3883                                                                             \
3884   product(double, CompileThresholdScaling, 1.0,                             \
3885           "Factor to control when first compilation happens "               \
3886           "(both with and without tiered compilation): "                    \
3887           "values greater than 1.0 delay counter overflow, "                \
3888           "values between 0 and 1.0 rush counter overflow, "                \
3889           "value of 1.0 leaves compilation thresholds unchanged "           \
3890           "value of 0.0 is equivalent to -Xint. "                           \
3891           ""                                                                \
3892           "Flag can be set as per-method option. "                          \
3893           "If a value is specified for a method, compilation thresholds "   \
3894           "for that method are scaled by both the value of the global flag "\
3895           "and the value of the per-method flag.")                          \
3896           range(0.0, DBL_MAX)                                               \
3897                                                                             \
3898   product(intx, Tier0InvokeNotifyFreqLog, 7,                                \
3899           "Interpreter (tier 0) invocation notification frequency")         \
3900           range(0, 30)                                                      \
3901                                                                             \
3902   product(intx, Tier2InvokeNotifyFreqLog, 11,                               \
3903           "C1 without MDO (tier 2) invocation notification frequency")      \
3904           range(0, 30)                                                      \
3905                                                                             \
3906   product(intx, Tier3InvokeNotifyFreqLog, 10,                               \
3907           "C1 with MDO profiling (tier 3) invocation notification "         \
3908           "frequency")                                                      \
3909           range(0, 30)                                                      \
3910                                                                             \
3911   product(intx, Tier23InlineeNotifyFreqLog, 20,                             \
3912           "Inlinee invocation (tiers 2 and 3) notification frequency")      \
3913           range(0, 30)                                                      \
3914                                                                             \
3915   product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \
3916           "Interpreter (tier 0) invocation notification frequency")         \
3917           range(0, 30)                                                      \
3918                                                                             \
3919   product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \
3920           "C1 without MDO (tier 2) invocation notification frequency")      \
3921           range(0, 30)                                                      \
3922                                                                             \
3923   product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \
3924           "C1 with MDO profiling (tier 3) invocation notification "         \
3925           "frequency")                                                      \
3926           range(0, 30)                                                      \
3927                                                                             \
3928   product(intx, Tier2CompileThreshold, 0,                                   \
3929           "threshold at which tier 2 compilation is invoked")               \
3930           range(0, max_jint)                                                \
3931                                                                             \
3932   product(intx, Tier2BackEdgeThreshold, 0,                                  \
3933           "Back edge threshold at which tier 2 compilation is invoked")     \
3934           range(0, max_jint)                                                \
3935                                                                             \
3936   product(intx, Tier3InvocationThreshold, 200,                              \
3937           "Compile if number of method invocations crosses this "           \
3938           "threshold")                                                      \
3939           range(0, max_jint)                                                \
3940                                                                             \
3941   product(intx, Tier3MinInvocationThreshold, 100,                           \
3942           "Minimum invocation to compile at tier 3")                        \
3943           range(0, max_jint)                                                \
3944                                                                             \
3945   product(intx, Tier3CompileThreshold, 2000,                                \
3946           "Threshold at which tier 3 compilation is invoked (invocation "   \
3947           "minimum must be satisfied)")                                     \
3948           range(0, max_jint)                                                \
3949                                                                             \
3950   product(intx, Tier3BackEdgeThreshold,  60000,                             \
3951           "Back edge threshold at which tier 3 OSR compilation is invoked") \
3952           range(0, max_jint)                                                \
3953                                                                             \
3954   product(intx, Tier4InvocationThreshold, 5000,                             \
3955           "Compile if number of method invocations crosses this "           \
3956           "threshold")                                                      \
3957           range(0, max_jint)                                                \
3958                                                                             \
3959   product(intx, Tier4MinInvocationThreshold, 600,                           \
3960           "Minimum invocation to compile at tier 4")                        \
3961           range(0, max_jint)                                                \
3962                                                                             \
3963   product(intx, Tier4CompileThreshold, 15000,                               \
3964           "Threshold at which tier 4 compilation is invoked (invocation "   \
3965           "minimum must be satisfied")                                      \
3966           range(0, max_jint)                                                \
3967                                                                             \
3968   product(intx, Tier4BackEdgeThreshold, 40000,                              \
3969           "Back edge threshold at which tier 4 OSR compilation is invoked") \
3970           range(0, max_jint)                                                \
3971                                                                             \
3972   product(intx, Tier3DelayOn, 5,                                            \
3973           "If C2 queue size grows over this amount per compiler thread "    \
3974           "stop compiling at tier 3 and start compiling at tier 2")         \
3975           range(0, max_jint)                                                \
3976                                                                             \
3977   product(intx, Tier3DelayOff, 2,                                           \
3978           "If C2 queue size is less than this amount per compiler thread "  \
3979           "allow methods compiled at tier 2 transition to tier 3")          \
3980           range(0, max_jint)                                                \
3981                                                                             \
3982   product(intx, Tier3LoadFeedback, 5,                                       \
3983           "Tier 3 thresholds will increase twofold when C1 queue size "     \
3984           "reaches this amount per compiler thread")                        \
3985           range(0, max_jint)                                                \
3986                                                                             \
3987   product(intx, Tier4LoadFeedback, 3,                                       \
3988           "Tier 4 thresholds will increase twofold when C2 queue size "     \
3989           "reaches this amount per compiler thread")                        \
3990           range(0, max_jint)                                                \
3991                                                                             \
3992   product(intx, TieredCompileTaskTimeout, 50,                               \
3993           "Kill compile task if method was not used within "                \
3994           "given timeout in milliseconds")                                  \
3995           range(0, max_intx)                                                \
3996                                                                             \
3997   product(intx, TieredStopAtLevel, 4,                                       \
3998           "Stop at given compilation level")                                \
3999           range(0, 4)                                                       \
4000                                                                             \
4001   product(intx, Tier0ProfilingStartPercentage, 200,                         \
4002           "Start profiling in interpreter if the counters exceed tier 3 "   \
4003           "thresholds by the specified percentage")                         \
4004           range(0, max_jint)                                                \
4005                                                                             \
4006   product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \
4007           "Increase the compile threshold for C1 compilation if the code "  \
4008           "cache is filled by the specified percentage")                    \
4009           range(0, 99)                                                      \
4010                                                                             \
4011   product(intx, TieredRateUpdateMinTime, 1,                                 \
4012           "Minimum rate sampling interval (in milliseconds)")               \
4013           range(0, max_intx)                                                \
4014                                                                             \
4015   product(intx, TieredRateUpdateMaxTime, 25,                                \
4016           "Maximum rate sampling interval (in milliseconds)")               \
4017           range(0, max_intx)                                                \
4018                                                                             \
4019   product_pd(bool, TieredCompilation,                                       \
4020           "Enable tiered compilation")                                      \
4021                                                                             \
4022   product(bool, PrintTieredEvents, false,                                   \
4023           "Print tiered events notifications")                              \
4024                                                                             \
4025   product_pd(intx, OnStackReplacePercentage,                                \
4026           "NON_TIERED number of method invocations/branches (expressed as " \
4027           "% of CompileThreshold) before (re-)compiling OSR code")          \
4028           constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \
4029                                                                             \
4030   product(intx, InterpreterProfilePercentage, 33,                           \
4031           "NON_TIERED number of method invocations/branches (expressed as " \
4032           "% of CompileThreshold) before profiling in the interpreter")     \
4033           range(0, 100)                                                     \
4034                                                                             \
4035   develop(intx, MaxRecompilationSearchLength,    10,                        \
4036           "The maximum number of frames to inspect when searching for "     \
4037           "recompilee")                                                     \
4038                                                                             \
4039   develop(intx, MaxInterpretedSearchLength,     3,                          \
4040           "The maximum number of interpreted frames to skip when searching "\
4041           "for recompilee")                                                 \
4042                                                                             \
4043   develop(intx, DesiredMethodLimit,  8000,                                  \
4044           "The desired maximum method size (in bytecodes) after inlining")  \
4045                                                                             \
4046   develop(intx, HugeMethodLimit,  8000,                                     \
4047           "Don't compile methods larger than this if "                      \
4048           "+DontCompileHugeMethods")                                        \
4049                                                                             \
4050   /* New JDK 1.4 reflection implementation */                               \
4051                                                                             \
4052   develop(intx, FastSuperclassLimit, 8,                                     \
4053           "Depth of hardwired instanceof accelerator array")                \
4054                                                                             \
4055   /* Properties for Java libraries  */                                      \
4056                                                                             \
4057   product(size_t, MaxDirectMemorySize, 0,                                   \
4058           "Maximum total size of NIO direct-buffer allocations")            \
4059           range(0, (size_t)SIZE_MAX)                                        \
4060                                                                             \
4061   /* Flags used for temporary code during development  */                   \
4062                                                                             \
4063   diagnostic(bool, UseNewCode, false,                                       \
4064           "Testing Only: Use the new version while testing")                \
4065                                                                             \
4066   diagnostic(bool, UseNewCode2, false,                                      \
4067           "Testing Only: Use the new version while testing")                \
4068                                                                             \
4069   diagnostic(bool, UseNewCode3, false,                                      \
4070           "Testing Only: Use the new version while testing")                \
4071                                                                             \
4072   /* flags for performance data collection */                               \
4073                                                                             \
4074   product(bool, UsePerfData, falseInEmbedded,                               \
4075           "Flag to disable jvmstat instrumentation for performance testing "\
4076           "and problem isolation purposes")                                 \
4077                                                                             \
4078   product(bool, PerfDataSaveToFile, false,                                  \
4079           "Save PerfData memory to hsperfdata_&lt;pid&gt; file on exit")          \
4080                                                                             \
4081   product(ccstr, PerfDataSaveFile, NULL,                                    \
4082           "Save PerfData memory to the specified absolute pathname. "       \
4083           "The string %p in the file name (if present) "                    \
4084           "will be replaced by pid")                                        \
4085                                                                             \
4086   product(intx, PerfDataSamplingInterval, 50,                               \
4087           "Data sampling interval (in milliseconds)")                       \
4088           range(PeriodicTask::min_interval, max_jint)                       \
4089           constraint(PerfDataSamplingIntervalFunc, AfterErgo)               \
4090                                                                             \
4091   develop(bool, PerfTraceDataCreation, false,                               \
4092           "Trace creation of Performance Data Entries")                     \
4093                                                                             \
4094   develop(bool, PerfTraceMemOps, false,                                     \
4095           "Trace PerfMemory create/attach/detach calls")                    \
4096                                                                             \
4097   product(bool, PerfDisableSharedMem, false,                                \
4098           "Store performance data in standard memory")                      \
4099                                                                             \
4100   product(intx, PerfDataMemorySize, 64*K,                                   \
4101           "Size of performance data memory region. Will be rounded "        \
4102           "up to a multiple of the native os page size.")                   \
4103           range(128, 32*64*K)                                               \
4104                                                                             \
4105   product(intx, PerfMaxStringConstLength, 1024,                             \
4106           "Maximum PerfStringConstant string length before truncation")     \
4107           range(32, 32*K)                                                   \
4108                                                                             \
4109   product(bool, PerfAllowAtExitRegistration, false,                         \
4110           "Allow registration of atexit() methods")                         \
4111                                                                             \
4112   product(bool, PerfBypassFileSystemCheck, false,                           \
4113           "Bypass Win32 file system criteria checks (Windows Only)")        \
4114                                                                             \
4115   product(intx, UnguardOnExecutionViolation, 0,                             \
4116           "Unguard page and retry on no-execute fault (Win32 only) "        \
4117           "0=off, 1=conservative, 2=aggressive")                            \
4118           range(0, 2)                                                       \
4119                                                                             \
4120   /* Serviceability Support */                                              \
4121                                                                             \
4122   product(bool, ManagementServer, false,                                    \
4123           "Create JMX Management Server")                                   \
4124                                                                             \
4125   product(bool, DisableAttachMechanism, false,                              \
4126           "Disable mechanism that allows tools to attach to this VM")       \
4127                                                                             \
4128   product(bool, StartAttachListener, false,                                 \
4129           "Always start Attach Listener at VM startup")                     \
4130                                                                             \
4131   manageable(bool, PrintConcurrentLocks, false,                             \
4132           "Print java.util.concurrent locks in thread dump")                \
4133                                                                             \
4134   product(bool, TransmitErrorReport, false,                                 \
4135           "Enable error report transmission on erroneous termination")      \
4136                                                                             \
4137   product(ccstr, ErrorReportServer, NULL,                                   \
4138           "Override built-in error report server address")                  \
4139                                                                             \
4140   /* Shared spaces */                                                       \
4141                                                                             \
4142   product(bool, UseSharedSpaces, true,                                      \
4143           "Use shared spaces for metadata")                                 \
4144                                                                             \
4145   product(bool, VerifySharedSpaces, false,                                  \
4146           "Verify shared spaces (false for default archive, true for "      \
4147           "archive specified by -XX:SharedArchiveFile)")                    \
4148                                                                             \
4149   product(bool, RequireSharedSpaces, false,                                 \
4150           "Require shared spaces for metadata")                             \
4151                                                                             \
4152   product(bool, DumpSharedSpaces, false,                                    \
4153           "Special mode: JVM reads a class list, loads classes, builds "    \
4154           "shared spaces, and dumps the shared spaces to a file to be "     \
4155           "used in future JVM runs")                                        \
4156                                                                             \
4157   product(bool, PrintSharedSpaces, false,                                   \
4158           "Print usage of shared spaces")                                   \
4159                                                                             \
4160   product(bool, PrintSharedArchiveAndExit, false,                           \
4161           "Print shared archive file contents")                             \
4162                                                                             \
4163   product(bool, PrintSharedDictionary, false,                               \
4164           "If PrintSharedArchiveAndExit is true, also print the shared "    \
4165           "dictionary")                                                     \
4166                                                                             \
4167   product(size_t, SharedReadWriteSize, DEFAULT_SHARED_READ_WRITE_SIZE,      \
4168           "Size of read-write space for metadata (in bytes)")               \
4169           range(MIN_SHARED_READ_WRITE_SIZE, MAX_SHARED_READ_WRITE_SIZE)     \
4170                                                                             \
4171   product(size_t, SharedReadOnlySize, DEFAULT_SHARED_READ_ONLY_SIZE,        \
4172           "Size of read-only space for metadata (in bytes)")                \
4173           range(MIN_SHARED_READ_ONLY_SIZE, MAX_SHARED_READ_ONLY_SIZE)       \
4174                                                                             \
4175   product(size_t, SharedMiscDataSize, DEFAULT_SHARED_MISC_DATA_SIZE,        \
4176           "Size of the shared miscellaneous data area (in bytes)")          \
4177           range(MIN_SHARED_MISC_DATA_SIZE, MAX_SHARED_MISC_DATA_SIZE)       \
4178                                                                             \
4179   product(size_t, SharedMiscCodeSize, DEFAULT_SHARED_MISC_CODE_SIZE,        \
4180           "Size of the shared miscellaneous code area (in bytes)")          \
4181           range(MIN_SHARED_MISC_CODE_SIZE, MAX_SHARED_MISC_CODE_SIZE)       \
4182                                                                             \
4183   product(size_t, SharedBaseAddress, LP64_ONLY(32*G)                        \
4184           NOT_LP64(LINUX_ONLY(2*G) NOT_LINUX(0)),                           \
4185           "Address to allocate shared memory region for class data")        \
4186           range(0, SIZE_MAX)                                                \
4187                                                                             \
4188   product(uintx, SharedSymbolTableBucketSize, 4,                            \
4189           "Average number of symbols per bucket in shared table")           \
4190           range(2, 246)                                                     \
4191                                                                             \
4192   diagnostic(bool, IgnoreUnverifiableClassesDuringDump, false,              \
4193           "Do not quit -Xshare:dump even if we encounter unverifiable "     \
4194           "classes. Just exclude them from the shared dictionary.")         \
4195                                                                             \
4196   diagnostic(bool, PrintMethodHandleStubs, false,                           \
4197           "Print generated stub code for method handles")                   \
4198                                                                             \
4199   develop(bool, TraceMethodHandles, false,                                  \
4200           "trace internal method handle operations")                        \
4201                                                                             \
4202   diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \
4203           "perform extra checks when constructing method handles")          \
4204                                                                             \
4205   diagnostic(bool, ShowHiddenFrames, false,                                 \
4206           "show method handle implementation frames (usually hidden)")      \
4207                                                                             \
4208   experimental(bool, TrustFinalNonStaticFields, false,                      \
4209           "trust final non-static declarations for constant folding")       \
4210                                                                             \
4211   diagnostic(bool, FoldStableValues, true,                                  \
4212           "Optimize loads from stable fields (marked w/ @Stable)")          \
4213                                                                             \
4214   develop(bool, TraceInvokeDynamic, false,                                  \
4215           "trace internal invoke dynamic operations")                       \
4216                                                                             \
4217   diagnostic(bool, PauseAtStartup,      false,                              \
4218           "Causes the VM to pause at startup time and wait for the pause "  \
4219           "file to be removed (default: ./vm.paused.&lt;pid&gt;)")                \
4220                                                                             \
4221   diagnostic(ccstr, PauseAtStartupFile, NULL,                               \
4222           "The file to create and for whose removal to await when pausing " \
4223           "at startup. (default: ./vm.paused.&lt;pid&gt;)")                       \
4224                                                                             \
4225   diagnostic(bool, PauseAtExit, false,                                      \
4226           "Pause and wait for keypress on exit if a debugger is attached")  \
4227                                                                             \
4228   product(bool, ExtendedDTraceProbes,    false,                             \
4229           "Enable performance-impacting dtrace probes")                     \
4230                                                                             \
4231   product(bool, DTraceMethodProbes, false,                                  \
4232           "Enable dtrace probes for method-entry and method-exit")          \
4233                                                                             \
4234   product(bool, DTraceAllocProbes, false,                                   \
4235           "Enable dtrace probes for object allocation")                     \
4236                                                                             \
4237   product(bool, DTraceMonitorProbes, false,                                 \
4238           "Enable dtrace probes for monitor events")                        \
4239                                                                             \
4240   product(bool, RelaxAccessControlCheck, false,                             \
4241           "Relax the access control checks in the verifier")                \
4242                                                                             \
4243   product(uintx, StringTableSize, defaultStringTableSize,                   \
4244           "Number of buckets in the interned String table")                 \
4245           range(minimumStringTableSize, 111*defaultStringTableSize)         \
4246                                                                             \
4247   experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \
4248           "Number of buckets in the JVM internal Symbol table")             \
4249           range(minimumSymbolTableSize, 111*defaultSymbolTableSize)         \
4250                                                                             \
4251   product(bool, UseStringDeduplication, false,                              \
4252           "Use string deduplication")                                       \
4253                                                                             \
4254   product(bool, PrintStringDeduplicationStatistics, false,                  \
4255           "Print string deduplication statistics")                          \
4256                                                                             \
4257   product(uintx, StringDeduplicationAgeThreshold, 3,                        \
4258           "A string must reach this age (or be promoted to an old region) " \
4259           "to be considered for deduplication")                             \
4260           range(1, markOopDesc::max_age)                                    \
4261                                                                             \
4262   diagnostic(bool, StringDeduplicationResizeALot, false,                    \
4263           "Force table resize every time the table is scanned")             \
4264                                                                             \
4265   diagnostic(bool, StringDeduplicationRehashALot, false,                    \
4266           "Force table rehash every time the table is scanned")             \
4267                                                                             \
4268   diagnostic(bool, WhiteBoxAPI, false,                                      \
4269           "Enable internal testing APIs")                                   \
4270                                                                             \
4271   product(bool, PrintGCCause, true,                                         \
4272           "Include GC cause in GC logging")                                 \
4273                                                                             \
4274   experimental(intx, SurvivorAlignmentInBytes, 0,                           \
4275            "Default survivor space alignment in bytes")                     \
4276            constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \
4277                                                                             \
4278   product(bool , AllowNonVirtualCalls, false,                               \
4279           "Obey the ACC_SUPER flag and allow invokenonvirtual calls")       \
4280                                                                             \
4281   product(ccstr, DumpLoadedClassList, NULL,                                 \
4282           "Dump the names all loaded classes, that could be stored into "   \
4283           "the CDS archive, in the specified file")                         \
4284                                                                             \
4285   product(ccstr, SharedClassListFile, NULL,                                 \
4286           "Override the default CDS class list")                            \
4287                                                                             \
4288   diagnostic(ccstr, SharedArchiveFile, NULL,                                \
4289           "Override the default location of the CDS archive file")          \
4290                                                                             \
4291   product(ccstr, ExtraSharedClassListFile, NULL,                            \
4292           "Extra classlist for building the CDS archive file")              \
4293                                                                             \
4294   experimental(size_t, ArrayAllocatorMallocLimit,                           \
4295           SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \
4296           "Allocation less than this value will be allocated "              \
4297           "using malloc. Larger allocations will use mmap.")                \
4298                                                                             \
4299   experimental(bool, AlwaysAtomicAccesses, false,                           \
4300           "Accesses to all variables should always be atomic")              \
4301                                                                             \
4302   product(bool, EnableTracing, false,                                       \
4303           "Enable event-based tracing")                                     \
4304                                                                             \
4305   product(bool, UseLockedTracing, false,                                    \
4306           "Use locked-tracing when doing event-based tracing")              \
4307                                                                             \
4308   diagnostic(bool, UseUnalignedAccesses, false,                             \
4309           "Use unaligned memory accesses in Unsafe")                        \
4310                                                                             \
4311   product_pd(bool, PreserveFramePointer,                                    \
4312              "Use the FP register for holding the frame pointer "           \
4313              "and not as a general purpose register.")                      \
4314                                                                             \
4315   diagnostic(bool, CheckIntrinsics, true,                                   \
4316              "When a class C is loaded, check that "                        \
4317              "(1) all intrinsics defined by the VM for class C are present "\
4318              "in the loaded class file and are marked with the "            \
4319              "@HotSpotIntrinsicCandidate annotation, that "                 \
4320              "(2) there is an intrinsic registered for all loaded methods " \
4321              "that are annotated with the @HotSpotIntrinsicCandidate "      \
4322              "annotation, and that "                                        \
4323              "(3) no orphan methods exist for class C (i.e., methods for "  \
4324              "which the VM declares an intrinsic but that are not declared "\
4325              "in the loaded class C. "                                      \
4326              "Check (3) is available only in debug builds.")                \
4327                                                                             \
4328   diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \
4329              "Disable backwards compatibility for compile commands.")       \
4330                                                                             \
4331   diagnostic(bool, PrintCompilerDirectives, false,                          \
4332              "Print compiler directives on installation.")
4333 
4334 /*
4335  *  Macros for factoring of globals
4336  */
4337 
4338 // Interface macros
4339 #define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern "C" type name;
4340 #define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern "C" type name;
4341 #define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern "C" type name;
4342 #define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern "C" type name;
4343 #define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern "C" type name;
4344 #define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern "C" type name;
4345 #ifdef PRODUCT
4346 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;
4347 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;
4348 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;
4349 #else
4350 #define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern "C" type name;
4351 #define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern "C" type name;
4352 #define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern "C" type name;
4353 #endif // PRODUCT
4354 // Special LP64 flags, product only needed for now.
4355 #ifdef _LP64
4356 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern "C" type name;
4357 #else
4358 #define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;
4359 #endif // _LP64
4360 
4361 // Implementation macros
4362 #define MATERIALIZE_PRODUCT_FLAG(type, name, value, doc)      type name = value;
4363 #define MATERIALIZE_PD_PRODUCT_FLAG(type, name, doc)          type name = pd_##name;
4364 #define MATERIALIZE_DIAGNOSTIC_FLAG(type, name, value, doc)   type name = value;
4365 #define MATERIALIZE_EXPERIMENTAL_FLAG(type, name, value, doc) type name = value;
4366 #define MATERIALIZE_MANAGEABLE_FLAG(type, name, value, doc)   type name = value;
4367 #define MATERIALIZE_PRODUCT_RW_FLAG(type, name, value, doc)   type name = value;
4368 #ifdef PRODUCT
4369 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)
4370 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)
4371 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)
4372 #else
4373 #define MATERIALIZE_DEVELOPER_FLAG(type, name, value, doc)    type name = value;
4374 #define MATERIALIZE_PD_DEVELOPER_FLAG(type, name, doc)        type name = pd_##name;
4375 #define MATERIALIZE_NOTPRODUCT_FLAG(type, name, value, doc)   type name = value;
4376 #endif // PRODUCT
4377 #ifdef _LP64
4378 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) type name = value;
4379 #else
4380 #define MATERIALIZE_LP64_PRODUCT_FLAG(type, name, value, doc) /* flag is constant */
4381 #endif // _LP64
4382 
4383 // Only materialize src code for range checking when required, ignore otherwise
4384 #define IGNORE_RANGE(a, b)
4385 // Only materialize src code for contraint checking when required, ignore otherwise
4386 #define IGNORE_CONSTRAINT(func,type)
4387 
4388 RUNTIME_FLAGS(DECLARE_DEVELOPER_FLAG, \
4389               DECLARE_PD_DEVELOPER_FLAG, \
4390               DECLARE_PRODUCT_FLAG, \
4391               DECLARE_PD_PRODUCT_FLAG, \
4392               DECLARE_DIAGNOSTIC_FLAG, \
4393               DECLARE_EXPERIMENTAL_FLAG, \
4394               DECLARE_NOTPRODUCT_FLAG, \
4395               DECLARE_MANAGEABLE_FLAG, \
4396               DECLARE_PRODUCT_RW_FLAG, \
4397               DECLARE_LP64_PRODUCT_FLAG, \
4398               IGNORE_RANGE, \
4399               IGNORE_CONSTRAINT)
4400 
4401 RUNTIME_OS_FLAGS(DECLARE_DEVELOPER_FLAG, \
4402                  DECLARE_PD_DEVELOPER_FLAG, \
4403                  DECLARE_PRODUCT_FLAG, \
4404                  DECLARE_PD_PRODUCT_FLAG, \
4405                  DECLARE_DIAGNOSTIC_FLAG, \
4406                  DECLARE_NOTPRODUCT_FLAG, \
4407                  IGNORE_RANGE, \
4408                  IGNORE_CONSTRAINT)
4409 
4410 ARCH_FLAGS(DECLARE_DEVELOPER_FLAG, \
4411            DECLARE_PRODUCT_FLAG, \
4412            DECLARE_DIAGNOSTIC_FLAG, \
4413            DECLARE_EXPERIMENTAL_FLAG, \
4414            DECLARE_NOTPRODUCT_FLAG, \
4415            IGNORE_RANGE, \
4416            IGNORE_CONSTRAINT)
4417 
4418 // Extensions
4419 
4420 #include "runtime/globals_ext.hpp"
4421 
4422 #endif // SHARE_VM_RUNTIME_GLOBALS_HPP
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="2" type="hidden" /></form></body></html>
